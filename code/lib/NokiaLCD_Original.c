//********************************************************************
//
//				EPSON Controller Library
//
//********************************************************************

#include "NokiaLCD.h"
#include "LPC214x.h"
#include "stdlib.h"
#include "rootdir.h"
#include "fat16.h"
#include "MP3Dev.h"
#include "rprintf.h"
#include "serial.h"

static char x_offset = 0;
static char y_offset = 0;
char white = 255;//white teXt
char other = 192;
char black = 0;//black background

static char text_array[475] = {0x00,0x00,0x00,0x00,0x00,/*space*/
                              0x00,0xF6,0xF6,0x00,0x00,/*!*/
                              0x00,0xE0,0x00,0xE0,0x00,/*"*/
                              0x28,0xFE,0x28,0xFE,0x28,/*#*/
                              0x00,0x64,0xD6,0x54,0x08,/*$*/
                              0xC2,0xCC,0x10,0x26,0xC6,/*%*/
                              0x4C,0xB2,0x92,0x6C,0x0A,/*&*/
                              0x00,0x00,0xE0,0x00,0x00,/*'*/
                              0x00,0x38,0x44,0x82,0x00,/*(*/
                              0x00,0x82,0x44,0x38,0x00,/*)*/
                              0x88,0x50,0xF8,0x50,0x88,/***/
                              0x08,0x08,0x3E,0x08,0x08,/*+*/
                              0x00,0x00,0x05,0x06,0x00,/*,*/
                              0x08,0x08,0x08,0x08,0x08,/*-*/
                              0x00,0x00,0x06,0x06,0x00,/*.*/
                              0x02,0x0C,0x10,0x60,0x80,/*/*/
                              0x7C,0x8A,0x92,0xA2,0x7C,/*0*/
                              0x00,0x42,0xFE,0x02,0x00,/*1*/
                              0x42,0x86,0x8A,0x92,0x62,/*2*/
                              0x44,0x82,0x92,0x92,0x6C,/*3*/
                              0x10,0x30,0x50,0xFE,0x10,/*4*/
                              0xE4,0xA2,0xA2,0xA2,0x9C,/*5*/
                              0x3C,0x52,0x92,0x92,0x0C,/*6*/
                              0x80,0x86,0x98,0xE0,0x80,/*7*/
                              0x6C,0x92,0x92,0x92,0x6C,/*8*/
                              0x60,0x92,0x92,0x94,0x78,/*9*/
                              0x00,0x00,0x36,0x36,0x00,/*:*/
                              0x00,0x00,0x35,0x36,0x00,/*;*/
                              0x10,0x28,0x44,0x82,0x00,/*<*/
                              0x28,0x28,0x28,0x28,0x28,/*=*/
                              0x00,0x82,0x44,0x28,0x10,/*>*/
                              0x40,0x80,0x8A,0x90,0x60,/*?*/
                              0x7C,0x82,0xBA,0xBA,0x62,/*@*/
                              0x3E,0x48,0x88,0x48,0x3E,/*A*/
                              0xFE,0x92,0x92,0x92,0x6C,/*B*/
                              0x7C,0x82,0x82,0x82,0x44,/*C*/
                              0xFE,0x82,0x82,0x82,0x7C,/*D*/
                              0xFE,0x92,0x92,0x92,0x82,/*E*/
                              0xFE,0x90,0x90,0x90,0x80,/*F*/
                              0x7C,0x82,0x82,0x8A,0x4E,/*G*/
                              0xFE,0x10,0x10,0x10,0xFE,/*H*/
                              0x82,0x82,0xFE,0x82,0x82,/*I*/
                              0x84,0x82,0xFC,0x80,0x80,/*J*/
                              0xFE,0x10,0x28,0x44,0x82,/*K*/
                              0xFE,0x02,0x02,0x02,0x02,/*L*/
                              0xFE,0x40,0x20,0x40,0xFE,/*M*/
                              0xFE,0x60,0x10,0x0C,0xFE,/*N*/
                              0x7C,0x82,0x82,0x82,0x7C,/*O*/
                              0xFE,0x90,0x90,0x90,0x60,/*P*/
                              0x7C,0x82,0x82,0x86,0x7E,/*Q*/
                              0xFE,0x90,0x98,0x94,0x62,/*R*/
                              0x64,0x92,0x92,0x92,0x4C,/*S*/
                              0x80,0x80,0xFE,0x80,0x80,/*T*/
                              0xFC,0x02,0x02,0x02,0xFC,/*U*/
                              0xF8,0x04,0x02,0x04,0xF8,/*V*/
                              0xFC,0x02,0x0C,0x02,0xFC,/*W*/
                              0xC6,0x28,0x10,0x28,0xC6,/*X*/
                              0xC0,0x20,0x1E,0x20,0xC0,/*Y*/
                              0x86,0x8A,0x92,0xA2,0xC2,/*Z*/
                              0x00,0x00,0xFE,0x82,0x00,/*[*/
                              0x00,0x00,0x00,0x00,0x00,/*this should be / */
                              0x80,0x60,0x10,0x0C,0x02,/*]*/
                              0x20,0x40,0x80,0x40,0x20,/*^*/
                              0x01,0x01,0x01,0x01,0x01,/*_*/
                              0x80,0x40,0x20,0x00,0x00,/*`*/
                              0x04,0x2A,0x2A,0x2A,0x1E,/*a*/
                              0xFE,0x12,0x22,0x22,0x1C,/*b*/
                              0x1C,0x22,0x22,0x22,0x14,/*c*/
                              0x1C,0x22,0x22,0x12,0xFE,/*d*/
                              0x1C,0x2A,0x2A,0x2A,0x18,/*e*/
                              0x10,0x7E,0x90,0x80,0x40,/*f*/
                              0x18,0x25,0x25,0x25,0x1E,/*g*/
                              0xFE,0x10,0x10,0x10,0x0E,/*h*/
                              0x00,0x12,0x5E,0x02,0x00,/*i*/
                              0x02,0x01,0x01,0x11,0x5E,/*j*/
                              0xFE,0x08,0x08,0x14,0x22,/*k*/
                              0x00,0x82,0xFE,0x02,0x00,/*l*/
                              0x3E,0x20,0x1C,0x20,0x1E,/*m*/
                              0x3E,0x20,0x20,0x20,0x1E,/*n*/
                              0x1C,0x22,0x22,0x22,0x1C,/*o*/
                              0x3F,0x24,0x24,0x24,0x18,/*p*/
                              0x18,0x24,0x24,0x3F,0x01,/*q*/
                              0x3E,0x10,0x20,0x20,0x10,/*r*/
                              0x12,0x2A,0x2A,0x2A,0x04,/*s*/
                              0x00,0x10,0x3C,0x12,0x04,/*t*/
                              0x3C,0x02,0x02,0x02,0x3E,/*u*/
                              0x30,0x0C,0x02,0x0C,0x30,/*v*/
                              0x38,0x06,0x18,0x06,0x38,/*w*/
                              0x22,0x14,0x08,0x14,0x22,/*x*/
                              0x38,0x05,0x05,0x05,0x3E,/*y*/
                              0x22,0x26,0x2A,0x32,0x22,/*z*/
                              0x00,0x10,0x6C,0x82,0x82,/*{*/
                              //0x00,0x00,0xFF,0x00,0x00,/*|*/
                              0x04,0x02,0xFF,0x02,0x04,/*|, arrow*/
                              0x82,0x82,0x6C,0x10,0x00,/*}*/
                              0x08,0x10,0x18,0x08,0x10};/*~*/

static char logo_spark[1120] =	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfb,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x3f,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x3f,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x7f,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0x20,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x0f,0xe0,0x9f,0x01,0xfc,0x09,0x9e,0x1e,0x7f,0x70,0x73,0x9f,0x00,0x00,0x00,0x00,
0x3f,0xf1,0xff,0x87,0xfe,0x3f,0xde,0x3d,0xff,0x78,0xf3,0xff,0x80,0x00,0x00,0x00,
0x3c,0xf9,0xff,0xc7,0xdf,0x3f,0xde,0x79,0xff,0x78,0xf3,0xff,0xc0,0x00,0x00,0x00,
0x78,0x79,0xc3,0xcf,0x0f,0x3f,0x1c,0xf0,0x3c,0x78,0xf3,0xe3,0xc0,0x00,0x00,0x00,
0x7c,0x01,0xc1,0xe0,0x0f,0x3e,0x1f,0xe0,0x3c,0x78,0xf3,0xc3,0xc0,0x00,0x00,0x00,
0x3f,0xc1,0x81,0xe0,0x3f,0x3c,0x1f,0xe0,0x3c,0x78,0xf3,0xc1,0xc0,0x00,0x00,0x00,
0x1f,0xf1,0x81,0xe3,0xff,0x3c,0x1f,0xe0,0x3c,0x78,0xf3,0xc1,0xc0,0x00,0x00,0x00,
0x07,0xf9,0x81,0xe7,0xef,0x3c,0x1f,0xf0,0x3c,0x78,0xf3,0xc1,0xc0,0x00,0x00,0x00,
0x00,0xf9,0x81,0xef,0x07,0x3c,0x1e,0xf8,0x3c,0x78,0xf3,0xc1,0xc0,0x00,0x00,0x00,
0x78,0x79,0xc1,0xef,0x0f,0x3c,0x1e,0x78,0x3c,0x78,0xf3,0xc1,0xc0,0x00,0x00,0x00,
0x78,0x79,0xe3,0xcf,0x0f,0x3c,0x1e,0x3c,0x3c,0x7c,0xf3,0xc1,0xc0,0x00,0x00,0x00,
0x3f,0xf9,0xff,0xcf,0xff,0x3c,0x1e,0x3e,0x3c,0x7f,0xf3,0xc1,0xcf,0x00,0x00,0x00,
0x1f,0xf1,0xff,0x87,0xff,0x3c,0x1e,0x1e,0x3c,0x3f,0xf3,0xc1,0xc7,0x00,0x00,0x00,
0x07,0xc1,0x9e,0x03,0xe0,0x00,0x00,0x02,0x00,0x0e,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x03,0x80,0x00,0x00,0x00,0xc0,0x00,0x00,0x18,0x00,0x00,0x08,0x08,0x00,0x00,
0x00,0x01,0x87,0xc3,0x03,0xe0,0xe1,0xf0,0xf8,0x3e,0x33,0x08,0x3e,0x1e,0x00,0x00,
0x00,0x01,0x86,0x03,0x03,0x01,0xb0,0xe0,0xdc,0x66,0x3b,0x08,0x66,0x32,0x00,0x00,
0x00,0x00,0x87,0xc3,0x03,0xe1,0x80,0x40,0xd8,0x63,0x3b,0x08,0x60,0x3c,0x00,0x00,
0x00,0x00,0x87,0x83,0x03,0xc1,0x80,0x40,0xf8,0x63,0x3f,0x08,0x60,0x0e,0x00,0x00,
0x00,0x00,0x06,0x03,0x03,0x01,0xb0,0x40,0xd8,0x66,0x37,0x08,0x66,0x32,0x00,0x00,
0x00,0x00,0x07,0xc3,0xe3,0xe0,0xe0,0x40,0xc8,0x3e,0x33,0x08,0x3e,0x3e,0x00,0x00,
0x00,0x00,0x07,0xc3,0xe3,0xe0,0xe0,0x40,0x88,0x3c,0x33,0x08,0x3c,0x1e,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};

//unsigned char msg_array[352];
//uint8_t stringBuf[512];
//unsigned int msg;

void clear_screen(char color)
{
    int i;
    
    disp_cmd(PASET);
    disp_data(0);
    disp_data(131);

    disp_cmd(CASET);
    disp_data(0);
    disp_data(131);

    disp_cmd(RAMWR);
	
    for (i = 1; i < 17424; i++)//
    {
      disp_data(color);         
    }

    x_offset = 0;
    y_offset = 0;
}

void disp_cmd(unsigned char data)
{
    int j;
	uint32_t tempRegister=0;
	
	tempRegister=PINSEL0;		//Store Port 0 Pin Functions for later retrieval
	//This assignment of PINSEL0 is incorrect because there are two bits to set for each pin function!
	//PINSEL0 &= (~SCLK_PINSEL & ~MOSI_PINSEL);				//Make sure that pins are in GPIO mode
	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
	
	IOCLR0 = LCD_CS;      // enable chip, p0.20 goes low
    IOCLR0 = LCD_DIO;     // output low on data out (9th bit low = command), p0.19

    IOCLR0 = LCD_SCK;      // send clock pulse
    IOSET0 = LCD_SCK;

    for (j = 0; j < 8; j++)
    {
        if ((data & 0x80) == 0x80) IOSET0 = LCD_DIO;
        else IOCLR0 = LCD_DIO;

        IOCLR0 = LCD_SCK;   // send clock pulse
        IOSET0 = LCD_SCK;

        data <<= 1;
    }

    IOSET0 = LCD_CS;    		// disable
	//PINSEL0=tempRegister;		//Restore Port 0 Pin Functions

}

void disp_data(unsigned char data)
{
    char delay =1;
	
	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
	
    IOCLR0 = LCD_CS;      // enable chip, p0.20 goes low
    IOSET0 = LCD_DIO;    // output high on data out (9th bit high = data), p0.19

    IOCLR0 = LCD_SCK;    // send clock pulse
    IOSET0 = LCD_SCK;

    for (char j = 0; j < 8; j++)
    {
        if ((data & 0x80) == 0x80) IOSET0 = LCD_DIO;
        else IOCLR0 = LCD_DIO;

        IOCLR0 = LCD_SCK;   // send clock pulse
        IOSET0 = LCD_SCK;

        data <<= 1;
    }

    IOSET0 = LCD_CS;     		// disable

}

void disp_init(void)
{
    int j;
	
    // reset display
	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
		
    IOCLR0 = (LCD_SCK | LCD_DIO);							//output_low (SPI_CLK);//output_low (SPI_DO);
    IOSET0 = LCD_CS;				//output_high (LCD_CS);
    for (j = 0; j < 16; j++);
    IOCLR0 = LCD_RES;				//output_low (LCD_RESET);
    for (j = 0; j < 300000; j++);
    IOSET0 = LCD_RES;				//output_high (LCD_RESET);
    IOSET0 = (LCD_SCK | LCD_DIO);
    for (j = 0; j < 300000; j++);	//delay_ms(100);
	
    disp_cmd(DISCTL);  	// display control(EPSON)
    disp_data(0x0C);   	// 12 = 1100 - CL dividing ratio [don't divide] switching period 8H (default)
    disp_data(0x20);
    disp_data(0x02);
	
    disp_cmd(COMSCN);  	// common scanning direction(EPSON)
    disp_data(0x01);
    
    disp_cmd(OSCON);  	// internal oscialltor ON(EPSON)
    
    disp_cmd(SLPOUT);  	// sleep out(EPSON)
	disp_cmd(SLEEPOUT);	//sleep out(PHILLIPS)
    
    disp_cmd(VOLCTR);  	// electronic volume, this is the contrast/brightness(EPSON)
    disp_data(0x18);   	// volume (contrast) setting - fine tuning, original
    disp_data(0x03);   	// internal resistor ratio - coarse adjustment
	disp_cmd(SETCON);	//Set Contrast(PHILLIPS)
	disp_data(0x30);	
	
    
    disp_cmd(PWRCTR); 	// power ctrl(EPSON)
    disp_data(0x0F);    //everything on, no external reference resistors
    disp_cmd(BSTRON);	//Booset On(PHILLIPS)
	
    disp_cmd(DISINV);  	// invert display mode(EPSON)
	disp_cmd(INVON);	// invert display mode(PHILLIPS)
    
    disp_cmd(DATCTL);  	// data control(EPSON)
    disp_data(0x03);	//correct for normal sin7
    disp_data(0x00);   	// normal RGB arrangement
    disp_data(0x01);   	// 8-bit grayscale
	disp_cmd(MADCTL);	//Memory Access Control(PHILLIPS)
	disp_data(0xC8);
	
	disp_cmd(COLMOD);	//Set Color Mode(PHILLIPS)
	disp_data(0x02);	
	
    
    disp_cmd(RGBSET8);   // setup 8-bit color lookup table  [RRRGGGBB](EPSON)
    //RED
    disp_data(0);
    disp_data(2);
    disp_data(4);
    disp_data(6);
    disp_data(8);
    disp_data(10);
    disp_data(12);
    disp_data(15);
    // GREEN
    disp_data(0);
    disp_data(2);
    disp_data(4);
    disp_data(6);
    disp_data(8);
    disp_data(10);
    disp_data(12);
    disp_data(15);
    //BLUE
    disp_data(0);
    disp_data(4);
    disp_data(9);
    disp_data(15);
    
    disp_cmd(NOP);  	// nop(EPSON)
	disp_cmd(NOPP);		// nop(PHILLIPS)

    disp_cmd(DISON);   	// display on(EPSON)
	disp_cmd(DISPON);	// display on(PHILLIPS)
}

unsigned char print_char(char txt, char text_color, char *x_pos, char *y_pos, char inverted)
{
    short text_array_offset = (txt - 32)*5, j;
    char k, temp;
	
    
    if (txt == 10)
    {
        y_pos += 8;
        return(0);
    }

    else if (txt == 13)
    {
        x_pos = 0;
        return(0);
    }

    for (j = text_array_offset; j < text_array_offset+5; j++)
    {
        temp = text_array[j];
        
        for (k = 0; k < 8; k++)
        {
			if(inverted==0){
				if ((temp & 0x80) == 0x80) pset(text_color, *y_pos + k, *x_pos + j + 2 - text_array_offset);
				temp <<= 1;
			}
			else if(inverted==1){
				if ((temp & 0x01) == 0x01) pset(text_color, *y_pos + j + 2 - text_array_offset, *x_pos + k);
				temp >>= 1;	
			}
        }

    }

	if(inverted==0){
		if ((*x_pos + 12) > 132) *x_pos = 0, *y_pos += 8;
		else *x_pos += 6;
	}
	else if(inverted==1){
		if ((*y_pos + 12) > 132) *y_pos = 0, *x_pos += 8;
		else *y_pos += 6;	
	}

    if ((*y_pos + 8) > 132)
    {
        //clear_screen();
        return 1;
    }
    else return 0;

}

void print_logo(void)
{
    int x = 4, y = 25, logo_ix = 0, z;
    char logo;
    
    for (logo_ix = 0; logo_ix < 1120; logo_ix++)
    {
        //logo = logo_array[logo_ix];
        logo = logo_spark[logo_ix];
		for (z = 0; z < 8; z++)
        {
            if ((logo & 0x80) == 0x80) pset(other, y, x);
            x++;
            if (x == 132)
            {
                x = 4;
                y++;
            }
            
            logo <<= 1;
        }
    }

}
/*
void fit_msg(void)
{
    int j, k = 0, l = 0, msg_mark = 0, temp_msg_mark = 0;
    unsigned char temp_msg[352];
    unsigned char x = 0;

    for (j = 0; j < 352; j++)
    {
        temp_msg[j] = 0xFF;
    }

    for (msg_mark = 0; msg_array[msg_mark] != 0xFF; msg_mark++)
    {
        temp_msg[temp_msg_mark] = msg_array[msg_mark];
        temp_msg_mark++;

        //if ((temp_msg_mark % 21) == 0)
        if ((temp_msg_mark % 22) == 0)
        {
            k++;
            
            x = 0;
            //pad end of line with spaces
            if ((temp_msg[temp_msg_mark-1] != 32) & (msg_array[msg_mark+1] != 32))
            {
                while (temp_msg[temp_msg_mark-1] != 32)
                {
                    temp_msg[temp_msg_mark-1] = 32;
                    temp_msg_mark--;
                    msg_mark--;
                    x++;
                }
            }
              
            //center the line horizontally
            if(x > 0)
            {
                x = (x/2)+1;
                //for (j = ((k*21)-1); j >= (((k*21)-21)+x); j--)
                for (j = ((k*22)-1); j >= (((k*22)-22)+x); j--)
                {
                    temp_msg[j] = temp_msg[j-x];
                }
                //temp_msg[(k-1)*21] = 32;
                //for (j = (k*21)-21; j < ((k*21)-21+x); j++)
                for (j = (k*22)-22; j < ((k*22)-22+x); j++)
                {
                    temp_msg[j] = 32;
                }
            }

            //temp_msg_mark = k*21;
            temp_msg_mark = k*22;
        }
    }
    
    y_offset = ((14-k)/2)*8;//center vertically
    //l = k*21;//marker for beginning of last line
    l = k*22;//marker for beginning of last line
    //k = (21 - ((temp_msg_mark-1) % 21));//number of spaces in last line
    k = (22 - ((temp_msg_mark-1) % 22));//number of spaces in last line
    //l = (temp_msg_mark-1) - k;//marker for beginning of last line
    k = (k / 2)+1; //number of spaces to pad beginning of line
    
    //for (j = l + 21; (j-k) >= l; j--)//shift characters right
    for (j = l + 22; (j-k) >= l; j--)//shift characters right
    {
        temp_msg[j] = temp_msg[j-k];
    }
    
    //k = (k / 2)+1; //number of spaces to pad beginning of line
    for (j = l; j < (l+k); j++)//put spaces in beginning of line
    {
        temp_msg[j] = 32;
    }

    for (j = 0; j < 352; j++)//dump it all back into the main array
    {
        msg_array[j] = temp_msg[j];
    }
}
*/
//Prints a string including variables
void print_string(const char *txt, int variable, char text_color, char row, char column, char inverted)
{
	if(inverted==0){
		x_offset=column*6;
		y_offset=row*8;
	}
	else if(inverted==1){
		x_offset=(15-row)*8+3;
		y_offset=(column*6);
	}
    int	  temp;
    short i, k, l, m;
    short temp2;
    
    short decimal_output[9];
    
    for(i = 0 ; i < 22; i++)		//Only print the length of the screen
    {
        //delay_ms(3);
        
        k = txt[i];

        if (k == '\0') break;
        
        else if (k == '%') //Print var
        {
            i++;
            k = txt[i];

            if (k == '\0') break;
        	
            else if (k == '\\') //Print special characters
            {
                i++;
                k = txt[i];
                
                print_char(k, white, &x_offset, &y_offset, inverted);
                

            } //End Special Characters
            else if (k == 'b') //Print Binary
            {
                for( m = 0 ; m < 32 ; m++ )
                {
                    if ((variable & 0x80000000) == 0x80000000) print_char('1', white,&x_offset, &y_offset, inverted);
                    if ((variable & 0x80000000) == 0) print_char('0', white,&x_offset, &y_offset, inverted);
                    if (((m+1) % 4) == 0) print_char(' ', white,&x_offset, &y_offset, inverted);
                    
                    variable = variable << 1;
                }
            } //End Binary               
            else if (k == 'd') //Print Decimal
            {
                //Print negative sign and take 2's compliment
                
                if(variable < 0)
                {
                    print_char('-', text_color,&x_offset, &y_offset, inverted);
                    variable *= -1;
                }
                
                
                if (variable == 0)
                    print_char('0', text_color,&x_offset, &y_offset, inverted);
                else
                {
                    //Divide number by a series of 10s
                    for(m = 9 ; variable > 0 ; m--)
                    {
                        temp = variable % 10;
                        decimal_output[m] = temp+48;
                        variable = variable / 10;               
                    }
                
                    for(m++ ; m < 10 ; m++)
                    {
                        print_char(decimal_output[m], text_color,&x_offset, &y_offset, inverted);
                    }
                }
    
            } //End Decimal
            else if (k == 'h') //Print Hex
            {
                //New trick 3-15-04
                print_char('0', white,&x_offset, &y_offset, inverted);
                print_char('x', white,&x_offset, &y_offset, inverted);
                
                for (m = 0; m < 8; m++)
                {
                	temp = variable & 0xF0000000;
                	temp2 = temp >>= 28;
                	//print_char(bin2Hex(temp2));
                	variable <<= 4;
                }
            } //End Hex
            else if (k == 'f') //Print Float
            {
                print_char('!', white,&x_offset, &y_offset, inverted);
            } //End Float
            else if (k == 'u') //Print Direct Character
            {
                //All ascii characters below 20 are special and screwy characters
                //if(my_byte > 20) 
                    print_char(variable, text_color,&x_offset, &y_offset, inverted);
            } //End Direct
                        
        } //End Special Chars           
        
        else if (k == '/')
        {
            l = txt[i+1];
            if (l == 'r') print_char(13, white,&x_offset, &y_offset, inverted);
            else if (l == 'n') print_char(10, white,&x_offset, &y_offset, inverted);
            i += 1;
        }

        else print_char(k, text_color,&x_offset, &y_offset, inverted);
    }    
}

//  sets the starting page(row) and column (x & y) coordinates in ram,
//  then writes the colour to display memory.  The ending x & y are left
//  maxed out so one can continue sending colour data bytes to the 'open'
//  RAMWR command to fill further memory.  issuing any other command
//  finishes RAMWR.
void pset(unsigned char color, unsigned char x, unsigned char y)
{
    //x += 2;                  // for some reason starts at 2
    //y += 2; 
	VICIntEnClr=0x20;
    disp_cmd(PASET);   // page start/end ram
    disp_data(x);
    disp_data(ENDPAGE);
  
    disp_cmd(CASET);   // column start/end ram
    disp_data(y);
    disp_data(ENDCOL);
  
    disp_cmd(RAMWR);    // write
    disp_data(color);
	VICIntEnable=0x20;
}

void setRowColor(unsigned char row, unsigned char column, char color, char inverted){
	if(inverted==ORIENTUP){
		row *= 8;
		column *=6;
	}
	else if(inverted==ORIENTLEFT){
		row=(15-row)*8+3;
		column = (column*6);
	}
	for (int j = column; j < ROW_LENGTH; j++)
	{
		for (int k = 0; k < 8; k++)
		{
			if(inverted==ORIENTUP){
				pset(color, row + k, j);
			}
			else if(inverted==ORIENTLEFT){
				pset(color, j, row+k);
			}
		}
	}
}

void lcdContrast(char setting){
	//Set the contrast to setting
	disp_cmd(VOLCTR);  // electronic volume, this is the contrast/brightness
    disp_data(0x18);   // volume (contrast) setting - fine tuning, original
    disp_data(setting);   // internal resistor ratio - coarse adjustment
}

