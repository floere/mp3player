   1              		.file	"sd_raw.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	sd_raw_available
  13              	sd_raw_available:
  14              	.LFB3:
  15              		.file 1 "../lib/sd_raw.c"
   1:../lib/sd_raw.c **** 
   2:../lib/sd_raw.c **** /* This program is free software; you can redistribute it and/or modify
   3:../lib/sd_raw.c ****  * it under the terms of the GNU General Public License version 2 as
   4:../lib/sd_raw.c ****  * published by the Free Software Foundation.
   5:../lib/sd_raw.c ****  */
   6:../lib/sd_raw.c **** 
   7:../lib/sd_raw.c **** #include <string.h>
   8:../lib/sd_raw.c **** #include "sd_raw.h"
   9:../lib/sd_raw.c **** #include "LPC214x.h"
  10:../lib/sd_raw.c **** #include <stdio.h>
  11:../lib/sd_raw.c **** //#include "printmacros.h"
  12:../lib/sd_raw.c **** #include "rprintf.h"
  13:../lib/sd_raw.c **** 
  14:../lib/sd_raw.c **** /**
  15:../lib/sd_raw.c ****  * \addtogroup sd_raw MMC/SD card raw access
  16:../lib/sd_raw.c ****  *
  17:../lib/sd_raw.c ****  * This module implements read and write access to MMC and
  18:../lib/sd_raw.c ****  * SD cards. It serves as a low-level driver for the higher
  19:../lib/sd_raw.c ****  * level modules such as partition and file system access.
  20:../lib/sd_raw.c ****  *
  21:../lib/sd_raw.c ****  * @{
  22:../lib/sd_raw.c ****  */
  23:../lib/sd_raw.c **** /**
  24:../lib/sd_raw.c ****  * \file
  25:../lib/sd_raw.c ****  * MMC/SD raw access implementation.
  26:../lib/sd_raw.c ****  *
  27:../lib/sd_raw.c ****  * \author Roland Riegel
  28:../lib/sd_raw.c ****  */
  29:../lib/sd_raw.c **** 
  30:../lib/sd_raw.c **** /**
  31:../lib/sd_raw.c ****  * \addtogroup sd_raw_config MMC/SD configuration
  32:../lib/sd_raw.c ****  * Preprocessor defines to configure the MMC/SD support.
  33:../lib/sd_raw.c ****  */
  34:../lib/sd_raw.c **** 
  35:../lib/sd_raw.c **** /**
  36:../lib/sd_raw.c ****  * @}
  37:../lib/sd_raw.c ****  */
  38:../lib/sd_raw.c **** 
  39:../lib/sd_raw.c **** /* commands available in SPI mode */
  40:../lib/sd_raw.c **** 
  41:../lib/sd_raw.c **** /* CMD0: response R1 */
  42:../lib/sd_raw.c **** #define CMD_GO_IDLE_STATE 0x00
  43:../lib/sd_raw.c **** /* CMD1: response R1 */
  44:../lib/sd_raw.c **** #define CMD_SEND_OP_COND 0x01
  45:../lib/sd_raw.c **** /* CMD9: response R1 */
  46:../lib/sd_raw.c **** #define CMD_SEND_CSD 0x09
  47:../lib/sd_raw.c **** /* CMD10: response R1 */
  48:../lib/sd_raw.c **** #define CMD_SEND_CID 0x0a
  49:../lib/sd_raw.c **** /* CMD12: response R1 */
  50:../lib/sd_raw.c **** #define CMD_STOP_TRANSMISSION 0x0c
  51:../lib/sd_raw.c **** /* CMD13: response R2 */
  52:../lib/sd_raw.c **** #define CMD_SEND_STATUS 0x0d
  53:../lib/sd_raw.c **** /* CMD16: arg0[31:0]: block length, response R1 */
  54:../lib/sd_raw.c **** #define CMD_SET_BLOCKLEN 0x10
  55:../lib/sd_raw.c **** /* CMD17: arg0[31:0]: data address, response R1 */
  56:../lib/sd_raw.c **** #define CMD_READ_SINGLE_BLOCK 0x11
  57:../lib/sd_raw.c **** /* CMD18: arg0[31:0]: data address, response R1 */
  58:../lib/sd_raw.c **** #define CMD_READ_MULTIPLE_BLOCK 0x12
  59:../lib/sd_raw.c **** /* CMD24: arg0[31:0]: data address, response R1 */
  60:../lib/sd_raw.c **** #define CMD_WRITE_SINGLE_BLOCK 0x18
  61:../lib/sd_raw.c **** /* CMD25: arg0[31:0]: data address, response R1 */
  62:../lib/sd_raw.c **** #define CMD_WRITE_MULTIPLE_BLOCK 0x19
  63:../lib/sd_raw.c **** /* CMD27: response R1 */
  64:../lib/sd_raw.c **** #define CMD_PROGRAM_CSD 0x1b
  65:../lib/sd_raw.c **** /* CMD28: arg0[31:0]: data address, response R1b */
  66:../lib/sd_raw.c **** #define CMD_SET_WRITE_PROT 0x1c
  67:../lib/sd_raw.c **** /* CMD29: arg0[31:0]: data address, response R1b */
  68:../lib/sd_raw.c **** #define CMD_CLR_WRITE_PROT 0x1d
  69:../lib/sd_raw.c **** /* CMD30: arg0[31:0]: write protect data address, response R1 */
  70:../lib/sd_raw.c **** #define CMD_SEND_WRITE_PROT 0x1e
  71:../lib/sd_raw.c **** /* CMD32: arg0[31:0]: data address, response R1 */
  72:../lib/sd_raw.c **** #define CMD_TAG_SECTOR_START 0x20
  73:../lib/sd_raw.c **** /* CMD33: arg0[31:0]: data address, response R1 */
  74:../lib/sd_raw.c **** #define CMD_TAG_SECTOR_END 0x21
  75:../lib/sd_raw.c **** /* CMD34: arg0[31:0]: data address, response R1 */
  76:../lib/sd_raw.c **** #define CMD_UNTAG_SECTOR 0x22
  77:../lib/sd_raw.c **** /* CMD35: arg0[31:0]: data address, response R1 */
  78:../lib/sd_raw.c **** #define CMD_TAG_ERASE_GROUP_START 0x23
  79:../lib/sd_raw.c **** /* CMD36: arg0[31:0]: data address, response R1 */
  80:../lib/sd_raw.c **** #define CMD_TAG_ERASE_GROUP_END 0x24
  81:../lib/sd_raw.c **** /* CMD37: arg0[31:0]: data address, response R1 */
  82:../lib/sd_raw.c **** #define CMD_UNTAG_ERASE_GROUP 0x25
  83:../lib/sd_raw.c **** /* CMD38: arg0[31:0]: stuff bits, response R1b */
  84:../lib/sd_raw.c **** #define CMD_ERASE 0x26
  85:../lib/sd_raw.c **** /* CMD42: arg0[31:0]: stuff bits, response R1b */
  86:../lib/sd_raw.c **** #define CMD_LOCK_UNLOCK 0x2a
  87:../lib/sd_raw.c **** /* CMD58: response R3 */
  88:../lib/sd_raw.c **** #define CMD_READ_OCR 0x3a
  89:../lib/sd_raw.c **** /* CMD59: arg0[31:1]: stuff bits, arg0[0:0]: crc option, response R1 */
  90:../lib/sd_raw.c **** #define CMD_CRC_ON_OFF 0x3b
  91:../lib/sd_raw.c **** 
  92:../lib/sd_raw.c **** /* command responses */
  93:../lib/sd_raw.c **** /* R1: size 1 byte */
  94:../lib/sd_raw.c **** #define R1_IDLE_STATE 0
  95:../lib/sd_raw.c **** #define R1_ERASE_RESET 1
  96:../lib/sd_raw.c **** #define R1_ILL_COMMAND 2
  97:../lib/sd_raw.c **** #define R1_COM_CRC_ERR 3
  98:../lib/sd_raw.c **** #define R1_ERASE_SEQ_ERR 4
  99:../lib/sd_raw.c **** #define R1_ADDR_ERR 5
 100:../lib/sd_raw.c **** #define R1_PARAM_ERR 6
 101:../lib/sd_raw.c **** /* R1b: equals R1, additional busy bytes */
 102:../lib/sd_raw.c **** /* R2: size 2 bytes */
 103:../lib/sd_raw.c **** #define R2_CARD_LOCKED 0
 104:../lib/sd_raw.c **** #define R2_WP_ERASE_SKIP 1
 105:../lib/sd_raw.c **** #define R2_ERR 2
 106:../lib/sd_raw.c **** #define R2_CARD_ERR 3
 107:../lib/sd_raw.c **** #define R2_CARD_ECC_FAIL 4
 108:../lib/sd_raw.c **** #define R2_WP_VIOLATION 5
 109:../lib/sd_raw.c **** #define R2_INVAL_ERASE 6
 110:../lib/sd_raw.c **** #define R2_OUT_OF_RANGE 7
 111:../lib/sd_raw.c **** #define R2_CSD_OVERWRITE 7
 112:../lib/sd_raw.c **** #define R2_IDLE_STATE (R1_IDLE_STATE + 8)
 113:../lib/sd_raw.c **** #define R2_ERASE_RESET (R1_ERASE_RESET + 8)
 114:../lib/sd_raw.c **** #define R2_ILL_COMMAND (R1_ILL_COMMAND + 8)
 115:../lib/sd_raw.c **** #define R2_COM_CRC_ERR (R1_COM_CRC_ERR + 8)
 116:../lib/sd_raw.c **** #define R2_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 8)
 117:../lib/sd_raw.c **** #define R2_ADDR_ERR (R1_ADDR_ERR + 8)
 118:../lib/sd_raw.c **** #define R2_PARAM_ERR (R1_PARAM_ERR + 8)
 119:../lib/sd_raw.c **** /* R3: size 5 bytes */
 120:../lib/sd_raw.c **** #define R3_OCR_MASK (0xffffffffUL)
 121:../lib/sd_raw.c **** #define R3_IDLE_STATE (R1_IDLE_STATE + 32)
 122:../lib/sd_raw.c **** #define R3_ERASE_RESET (R1_ERASE_RESET + 32)
 123:../lib/sd_raw.c **** #define R3_ILL_COMMAND (R1_ILL_COMMAND + 32)
 124:../lib/sd_raw.c **** #define R3_COM_CRC_ERR (R1_COM_CRC_ERR + 32)
 125:../lib/sd_raw.c **** #define R3_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 32)
 126:../lib/sd_raw.c **** #define R3_ADDR_ERR (R1_ADDR_ERR + 32)
 127:../lib/sd_raw.c **** #define R3_PARAM_ERR (R1_PARAM_ERR + 32)
 128:../lib/sd_raw.c **** /* Data Response: size 1 byte */
 129:../lib/sd_raw.c **** #define DR_STATUS_MASK 0x0e
 130:../lib/sd_raw.c **** #define DR_STATUS_ACCEPTED 0x05
 131:../lib/sd_raw.c **** #define DR_STATUS_CRC_ERR 0x0a
 132:../lib/sd_raw.c **** #define DR_STATUS_WRITE_ERR 0x0c
 133:../lib/sd_raw.c **** 
 134:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 135:../lib/sd_raw.c ****     
 136:../lib/sd_raw.c ****     /* static data buffer for acceleration */
 137:../lib/sd_raw.c ****     static unsigned char raw_block[512];
 138:../lib/sd_raw.c ****     /* offset where the data within raw_block lies on the card */
 139:../lib/sd_raw.c ****     static unsigned int raw_block_address;
 140:../lib/sd_raw.c ****     #if SD_RAW_WRITE_BUFFERING
 141:../lib/sd_raw.c ****     /* flag to remember if raw_block was written to the card */
 142:../lib/sd_raw.c ****     static unsigned char raw_block_written;
 143:../lib/sd_raw.c **** #endif
 144:../lib/sd_raw.c **** 
 145:../lib/sd_raw.c **** #endif
 146:../lib/sd_raw.c **** 
 147:../lib/sd_raw.c **** /* private helper functions */
 148:../lib/sd_raw.c **** static void sd_raw_send_byte(unsigned char b);
 149:../lib/sd_raw.c **** static unsigned char sd_raw_rec_byte(void);
 150:../lib/sd_raw.c **** static unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg);
 151:../lib/sd_raw.c **** //static unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg);
 152:../lib/sd_raw.c **** 
 153:../lib/sd_raw.c **** /**
 154:../lib/sd_raw.c ****  * \ingroup sd_raw
 155:../lib/sd_raw.c ****  * Initializes memory card communication.
 156:../lib/sd_raw.c ****  *
 157:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 158:../lib/sd_raw.c ****  */
 159:../lib/sd_raw.c **** unsigned char sd_raw_init()
 160:../lib/sd_raw.c **** {
 161:../lib/sd_raw.c ****     /* enable inputs for reading card status */
 162:../lib/sd_raw.c ****     /*    configure_pin_available();*/
 163:../lib/sd_raw.c ****     /*    configure_pin_locked();*/
 164:../lib/sd_raw.c **** 
 165:../lib/sd_raw.c ****     /* enable outputs for MOSI, SCK, SS, input for MISO */
 166:../lib/sd_raw.c ****     configure_pin_ss();
 167:../lib/sd_raw.c ****     configure_pin_mosi();
 168:../lib/sd_raw.c ****     configure_pin_miso();
 169:../lib/sd_raw.c ****     configure_pin_sck();
 170:../lib/sd_raw.c **** 
 171:../lib/sd_raw.c ****     unselect_card();
 172:../lib/sd_raw.c **** 
 173:../lib/sd_raw.c ****     /* initialize SPI with lowest frequency; max. 400kHz during identification mode of card */
 174:../lib/sd_raw.c ****     S0SPCCR = 150;  /* Set frequency to 400kHz */
 175:../lib/sd_raw.c ****     S0SPCR = 0x38;
 176:../lib/sd_raw.c **** 
 177:../lib/sd_raw.c **** 
 178:../lib/sd_raw.c ****     /* initialization procedure */
 179:../lib/sd_raw.c **** 
 180:../lib/sd_raw.c ****     if(!sd_raw_available())
 181:../lib/sd_raw.c ****     {
 182:../lib/sd_raw.c ****         rprintf("SD RAW NOT AVAILABLE\n\r");
 183:../lib/sd_raw.c ****         return 0;
 184:../lib/sd_raw.c ****     }
 185:../lib/sd_raw.c ****     configure_pin_ss();
 186:../lib/sd_raw.c ****     unselect_card();
 187:../lib/sd_raw.c **** 
 188:../lib/sd_raw.c ****     unsigned short i;
 189:../lib/sd_raw.c ****     /* card needs 74 cycles minimum to start up */
 190:../lib/sd_raw.c ****     for(i = 0; i < 10; ++i)
 191:../lib/sd_raw.c ****     {
 192:../lib/sd_raw.c ****         /* wait 8 clock cycles */
 193:../lib/sd_raw.c ****         sd_raw_rec_byte();
 194:../lib/sd_raw.c ****     }
 195:../lib/sd_raw.c **** 
 196:../lib/sd_raw.c ****     /* address card */
 197:../lib/sd_raw.c ****     select_card();
 198:../lib/sd_raw.c **** 
 199:../lib/sd_raw.c ****     /* reset card */
 200:../lib/sd_raw.c ****     unsigned char response;
 201:../lib/sd_raw.c ****     for(i = 0; ; ++i)
 202:../lib/sd_raw.c ****     {
 203:../lib/sd_raw.c ****         response = sd_raw_send_command_r1(CMD_GO_IDLE_STATE, 0);
 204:../lib/sd_raw.c **** 		rprintf("i=%d, response=%d\n\r", i, response);
 205:../lib/sd_raw.c ****         if(response == (1 << R1_IDLE_STATE))
 206:../lib/sd_raw.c ****             break;
 207:../lib/sd_raw.c ****         if(i == 0x1ff)
 208:../lib/sd_raw.c ****         {
 209:../lib/sd_raw.c ****             rprintf("\n\rresponse: %d\n\r",response);
 210:../lib/sd_raw.c ****             unselect_card();
 211:../lib/sd_raw.c ****             return 0;
 212:../lib/sd_raw.c ****         }
 213:../lib/sd_raw.c ****     }
 214:../lib/sd_raw.c **** 
 215:../lib/sd_raw.c ****     /* wait for card to get ready */
 216:../lib/sd_raw.c ****     for(i = 0; ; ++i)
 217:../lib/sd_raw.c ****     {
 218:../lib/sd_raw.c ****         response = sd_raw_send_command_r1(CMD_SEND_OP_COND, 0);
 219:../lib/sd_raw.c ****         if(!(response & (1 << R1_IDLE_STATE)))
 220:../lib/sd_raw.c ****             break;
 221:../lib/sd_raw.c **** 
 222:../lib/sd_raw.c ****         if(i == 0x7fff)
 223:../lib/sd_raw.c ****         {
 224:../lib/sd_raw.c ****             unselect_card();
 225:../lib/sd_raw.c ****             rprintf("i = 0x7fff\n\r");
 226:../lib/sd_raw.c ****             return 0;
 227:../lib/sd_raw.c ****         }
 228:../lib/sd_raw.c ****     }
 229:../lib/sd_raw.c **** 
 230:../lib/sd_raw.c ****     /* set block size to 512 bytes */
 231:../lib/sd_raw.c ****     if(sd_raw_send_command_r1(CMD_SET_BLOCKLEN, 512))
 232:../lib/sd_raw.c ****     {
 233:../lib/sd_raw.c ****         unselect_card();
 234:../lib/sd_raw.c ****         rprintf("BLOCK SIZE SET ERR \n\r");
 235:../lib/sd_raw.c ****         return 0;
 236:../lib/sd_raw.c ****     }
 237:../lib/sd_raw.c **** 
 238:../lib/sd_raw.c ****     /* deaddress card */
 239:../lib/sd_raw.c ****     unselect_card();
 240:../lib/sd_raw.c **** 
 241:../lib/sd_raw.c ****     /* switch to highest SPI frequency possible */
 242:../lib/sd_raw.c ****     S0SPCCR = 60; /* ~1MHz-- potentially can be faster */
 243:../lib/sd_raw.c **** 
 244:../lib/sd_raw.c ****     #if !SD_RAW_SAVE_RAM
 245:../lib/sd_raw.c ****         /* the first block is likely to be accessed first, so precache it here */
 246:../lib/sd_raw.c ****         raw_block_address = 0xffffffff;
 247:../lib/sd_raw.c ****         #if SD_RAW_WRITE_BUFFERING
 248:../lib/sd_raw.c ****         raw_block_written = 1;
 249:../lib/sd_raw.c ****     #endif
 250:../lib/sd_raw.c ****     if(!sd_raw_read(0, raw_block, sizeof(raw_block)))
 251:../lib/sd_raw.c ****     {
 252:../lib/sd_raw.c ****         rprintf("sd_raw_read borks\n\r");
 253:../lib/sd_raw.c ****         return 0;
 254:../lib/sd_raw.c ****     }
 255:../lib/sd_raw.c ****     #endif
 256:../lib/sd_raw.c **** 
 257:../lib/sd_raw.c ****     return 1;
 258:../lib/sd_raw.c **** }
 259:../lib/sd_raw.c **** 
 260:../lib/sd_raw.c **** /**
 261:../lib/sd_raw.c ****  * \ingroup sd_raw
 262:../lib/sd_raw.c ****  * Checks wether a memory card is located in the slot.
 263:../lib/sd_raw.c ****  *
 264:../lib/sd_raw.c ****  * \returns 1 if the card is available, 0 if it is not.
 265:../lib/sd_raw.c ****  */
 266:../lib/sd_raw.c **** unsigned char sd_raw_available()
 267:../lib/sd_raw.c **** {
  16              	@ Function supports interworking.
  17              		@ args = 0, pretend = 0, frame = 0
  18              		@ frame_needed = 0, uses_anonymous_args = 0
  19              		@ link register save eliminated.
  20              		.loc 1 269 0
 268:../lib/sd_raw.c ****    return i == 0x00;
 269:../lib/sd_raw.c **** }
  21              	r2, .L3
  22 0000 28209FE5 		ldr	r3, [r2, #8]
  23 0004 083092E5 		bic	r3, r3, #128
  24 0008 8030C3E3 		str	r3, [r2, #8]
  25 000c 083082E5 		.loc 1 271 0
 270:../lib/sd_raw.c **** **
 271:../lib/sd_raw.c ****  * \ingroup sd_raw
  26              	r1, [r2, #0]
  27 0010 001092E5 		.loc 1 272 0
 272:../lib/sd_raw.c ****  Checks wether the memory card is locked for write access.
  28              	dr	r3, [r2, #8]
  29 0014 083092E5 		tst	r1, #128
  30 0018 800011E3 		orr	r3, r3, #128
  31 001c 803083E3 		.loc 1 274 0
 273:../lib/sd_raw.c **** *
 274:../lib/sd_raw.c ****  * \returns 1 if the card is locked, 0 if it is not.
  32              	eq	r0, #0
  33 0020 0000A003 		movne	r0, #1
  34 0024 0100A013 		.loc 1 267 0
  35              		@ lr needed for prologue
  36              		.loc 1 272 0
  37              		str	r3, [r2, #8]
  38 0028 083082E5 		.loc 1 274 0
  39              		bx	lr
  40 002c 1EFF2FE1 	.L4:
  41              		.align	2
  42              	.L3:
  43              		.word	-536707072
  44 0030 008002E0 	.LFE3:
  46              		.align	2
  47              		.global	sd_raw_locked
  49              	sd_raw_locked:
  50              	.LFB4:
  51              		.loc 1 283 0
 275:../lib/sd_raw.c **** /
 276:../lib/sd_raw.c **** unsigned char sd_raw_locked()
 277:../lib/sd_raw.c **** {
 278:../lib/sd_raw.c ****     return get_pin_locked() == 0x00;
 279:../lib/sd_raw.c **** }
 280:../lib/sd_raw.c **** 
 281:../lib/sd_raw.c **** /**
 282:../lib/sd_raw.c ****  * \ingroup sd_raw
 283:../lib/sd_raw.c ****  * Sends a raw byte to the memory card.
  52              	 interworking.
  53              		@ args = 0, pretend = 0, frame = 0
  54              		@ frame_needed = 0, uses_anonymous_args = 0
  55              		@ link register save eliminated.
  56              		.loc 1 285 0
 284:../lib/sd_raw.c **** ram[in] b The byte to sent.
 285:../lib/sd_raw.c ****  * \see sd_raw_rec_byte
  57              	r0, #1
  58 0034 0100A0E3 		.loc 1 283 0
  59              		@ lr needed for prologue
  60              		.loc 1 285 0
  61              		bx	lr
  62 0038 1EFF2FE1 	.LFE4:
  64              		.align	2
  66              	sd_raw_rec_byte:
  67              	.LFB6:
  68              		.loc 1 309 0
 286:../lib/sd_raw.c **** /
 287:../lib/sd_raw.c **** void sd_raw_send_byte(unsigned char b)
 288:../lib/sd_raw.c **** {
 289:../lib/sd_raw.c ****     S0SPDR = b;
 290:../lib/sd_raw.c ****     /* wait for byte to be shifted out */
 291:../lib/sd_raw.c ****     while(!(S0SPSR & 0x80));
 292:../lib/sd_raw.c **** }
 293:../lib/sd_raw.c **** 
 294:../lib/sd_raw.c **** /**
 295:../lib/sd_raw.c ****  * \ingroup sd_raw
 296:../lib/sd_raw.c ****  * Receives a raw byte from the memory card.
 297:../lib/sd_raw.c ****  *
 298:../lib/sd_raw.c ****  * \returns The byte which should be read.
 299:../lib/sd_raw.c ****  * \see sd_raw_send_byte
 300:../lib/sd_raw.c ****  */
 301:../lib/sd_raw.c **** unsigned char sd_raw_rec_byte(void)
 302:../lib/sd_raw.c **** {
 303:../lib/sd_raw.c ****     /* send dummy data for receiving some */
 304:../lib/sd_raw.c ****     S0SPDR = 0xff;
 305:../lib/sd_raw.c ****     while(!(S0SPSR & 0x80));
 306:../lib/sd_raw.c **** 
 307:../lib/sd_raw.c ****     return S0SPDR;
 308:../lib/sd_raw.c **** }
 309:../lib/sd_raw.c **** 
  69              	supports interworking.
  70              		@ args = 0, pretend = 0, frame = 0
  71              		@ frame_needed = 0, uses_anonymous_args = 0
  72              		@ link register save eliminated.
  73              		.loc 1 311 0
 310:../lib/sd_raw.c **** * Send a command to the memory card which responses with a R1 response.
 311:../lib/sd_raw.c ****  *
  74              	r3, .L13
  75 003c 20309FE5 		mov	r2, #255
  76 0040 FF20A0E3 		str	r2, [r3, #8]
  77 0044 082083E5 		.loc 1 309 0
  78              		@ lr needed for prologue
  79              	.L8:
  80              		.loc 1 312 0
 312:../lib/sd_raw.c ****  \param[in] command The command to send.
  81              	, .L13
  82 0048 14209FE5 		ldr	r3, [r2, #4]
  83 004c 043092E5 		tst	r3, #128
  84 0050 800013E3 		beq	.L8
  85 0054 FBFFFF0A 		.loc 1 314 0
 313:../lib/sd_raw.c **** * \param[in] arg The argument for command.
 314:../lib/sd_raw.c ****  * \returns The command answer.
  86              	r0, [r2, #8]
  87 0058 080092E5 		and	r0, r0, #255
  88 005c FF0000E2 		.loc 1 315 0
 315:../lib/sd_raw.c **** /
  89              		lr
  90 0060 1EFF2FE1 	.L14:
  91              		.align	2
  92              	.L13:
  93              		.word	-536739840
  94 0064 000002E0 	.LFE6:
  96              		.align	2
  98              	sd_raw_send_command_r1:
  99              	.LFB7:
 100              		.loc 1 326 0
 316:../lib/sd_raw.c **** nsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
 317:../lib/sd_raw.c **** {
 318:../lib/sd_raw.c ****     unsigned char response;
 319:../lib/sd_raw.c ****     unsigned char i;
 320:../lib/sd_raw.c **** 
 321:../lib/sd_raw.c ****     /* wait some clock cycles */
 322:../lib/sd_raw.c ****     sd_raw_rec_byte();
 323:../lib/sd_raw.c **** 
 324:../lib/sd_raw.c ****     /* send command via SPI */
 325:../lib/sd_raw.c ****     sd_raw_send_byte(0x40 | command);
 326:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 24) & 0xff);
 101              	supports interworking.
 102              		@ args = 0, pretend = 0, frame = 0
 103              		@ frame_needed = 0, uses_anonymous_args = 0
 104              	.LVL0:
 105              		stmfd	sp!, {r4, r5, lr}
 106 0068 30402DE9 	.LCFI0:
 107              		.loc 1 326 0
 108              		and	r5, r0, #255
 109 006c FF5000E2 		mov	r4, r1
 110 0070 0140A0E1 		.loc 1 331 0
 327:../lib/sd_raw.c **** send_byte((arg >> 16) & 0xff);
 328:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 8) & 0xff);
 329:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 0) & 0xff);
 330:../lib/sd_raw.c ****     sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);
 331:../lib/sd_raw.c **** 
 111              	_rec_byte
 112 0074 F0FFFFEB 	.LVL1:
 113              	.LBB23:
 114              	.LBB24:
 115              		.loc 1 296 0
 116              		ldr	r3, .L48
 117 0078 C4309FE5 		orr	r2, r5, #64
 118 007c 402085E3 		str	r2, [r3, #8]
 119 0080 082083E5 	.L16:
 120              		.loc 1 298 0
 121              		ldr	r2, .L48
 122 0084 B8209FE5 		ldr	r3, [r2, #4]
 123 0088 043092E5 		tst	r3, #128
 124 008c 800013E3 		beq	.L16
 125 0090 FBFFFF0A 	.LBE24:
 126              	.LBE23:
 127              	.LBB25:
 128              	.LBB26:
 129              		.loc 1 296 0
 130              		mov	r3, r4, lsr #24
 131 0094 243CA0E1 		str	r3, [r2, #8]
 132 0098 083082E5 	.L18:
 133              		.loc 1 298 0
 134              		ldr	r2, .L48
 135 009c A0209FE5 		ldr	r3, [r2, #4]
 136 00a0 043092E5 		tst	r3, #128
 137 00a4 800013E3 		beq	.L18
 138 00a8 FBFFFF0A 	.LBE26:
 139              	.LBE25:
 140              	.LBB27:
 141              	.LBB28:
 142              		.loc 1 296 0
 143              		mov	r3, r4, lsr #16
 144 00ac 2438A0E1 		and	r3, r3, #255
 145 00b0 FF3003E2 		str	r3, [r2, #8]
 146 00b4 083082E5 	.L20:
 147              		.loc 1 298 0
 148              		ldr	r2, .L48
 149 00b8 84209FE5 		ldr	r3, [r2, #4]
 150 00bc 043092E5 		tst	r3, #128
 151 00c0 800013E3 		beq	.L20
 152 00c4 FBFFFF0A 	.LBE28:
 153              	.LBE27:
 154              	.LBB29:
 155              	.LBB30:
 156              		.loc 1 296 0
 157              		mov	r3, r4, lsr #8
 158 00c8 2434A0E1 		and	r3, r3, #255
 159 00cc FF3003E2 		str	r3, [r2, #8]
 160 00d0 083082E5 	.L22:
 161              		.loc 1 298 0
 162              		ldr	r2, .L48
 163 00d4 68209FE5 		ldr	r3, [r2, #4]
 164 00d8 043092E5 		tst	r3, #128
 165 00dc 800013E3 		beq	.L22
 166 00e0 FBFFFF0A 	.LBE30:
 167              	.LBE29:
 168              	.LBB31:
 169              	.LBB32:
 170              		.loc 1 296 0
 171              		and	r3, r4, #255
 172 00e4 FF3004E2 		str	r3, [r2, #8]
 173 00e8 083082E5 	.L24:
 174              		.loc 1 298 0
 175              		ldr	r2, .L48
 176 00ec 50209FE5 		ldr	r3, [r2, #4]
 177 00f0 043092E5 		tst	r3, #128
 178 00f4 800013E3 		beq	.L24
 179 00f8 FBFFFF0A 	.LBE32:
 180              	.LBE31:
 181              	.LBB33:
 182              	.LBB34:
 183              		.loc 1 296 0
 184              		cmp	r5, #0
 185 00fc 000055E3 		movne	r3, #255
 186 0100 FF30A013 		moveq	r3, #149
 187 0104 9530A003 		str	r3, [r2, #8]
 188 0108 083082E5 	.L29:
 189              		.loc 1 298 0
 190              		ldr	r3, .L48
 191 010c 30309FE5 		ldr	r3, [r3, #4]
 192 0110 043093E5 		tst	r3, #128
 193 0114 800013E3 		beq	.L29
 194 0118 FBFFFF0A 		mov	r4, #0
 195 011c 0040A0E3 	.LVL2:
 196              	.L31:
 197              	.LBE34:
 198              	.LBE33:
 199              		.loc 1 344 0
 332:../lib/sd_raw.c **** * receive response */
 333:../lib/sd_raw.c ****     for(i = 0; i < 10; ++i)
 334:../lib/sd_raw.c ****     {
 335:../lib/sd_raw.c ****         response = sd_raw_rec_byte();
 336:../lib/sd_raw.c ****         if(response != 0xff)
 337:../lib/sd_raw.c ****             break;
 338:../lib/sd_raw.c ****     }
 339:../lib/sd_raw.c **** 
 340:../lib/sd_raw.c ****     return response;
 341:../lib/sd_raw.c **** }
 342:../lib/sd_raw.c **** 
 343:../lib/sd_raw.c **** /**
 344:../lib/sd_raw.c ****  * \ingroup sd_raw
 200              	 0
 201 0120 C5FFFFEB 		and	r4, r3, #255
 202              		.loc 1 345 0
 203 0124 013084E2 		bne	.L32
 345:../lib/sd_raw.c **** mand to the memory card which responses with a R2 response.
 204              	c 1 342 0
 205 0128 FF0050E3 		cmp	r4, #10
 206              		bne	.L31
 207 012c FF4003E2 	.L32:
 208              		.loc 1 350 0
 209 0130 0100001A 		ldmfd	sp!, {r4, r5, lr}
 210              		bx	lr
 211 0134 0A0054E3 	.L49:
 212 0138 F8FFFF1A 		.align	2
 213              	.L48:
 346:../lib/sd_raw.c **** *
 347:../lib/sd_raw.c ****  * \param[in] command The command to send.
 348:../lib/sd_raw.c ****  * \param[in] arg The argument for command.
 349:../lib/sd_raw.c ****  * \returns The command answer.
 350:../lib/sd_raw.c ****  */
 214              	6739840
 215 013c 3040BDE8 	.LFE7:
 217              		.align	2
 218              		.global	SDoff
 220 0144 000002E0 	SDoff:
 221              	.LFB13:
 222              		.loc 1 874 0
 223              		@ Function supports interworking.
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              		@ link register save eliminated.
 227              		.loc 1 875 0
 351:../lib/sd_raw.c **** signed short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
 352:../lib/sd_raw.c **** {
 353:../lib/sd_raw.c ****     unsigned short response;
 354:../lib/sd_raw.c ****     unsigned char i;
 355:../lib/sd_raw.c **** 
 356:../lib/sd_raw.c ****     // wait some clock cycles
 357:../lib/sd_raw.c ****     sd_raw_rec_byte();
 358:../lib/sd_raw.c **** 
 359:../lib/sd_raw.c ****     // send command via SPI
 360:../lib/sd_raw.c ****     sd_raw_send_byte(0x40 | command);
 361:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 24) & 0xff);
 362:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 16) & 0xff);
 363:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 8) & 0xff);
 364:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 0) & 0xff);
 365:../lib/sd_raw.c ****     sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);
 366:../lib/sd_raw.c **** 
 367:../lib/sd_raw.c ****     // receive response
 368:../lib/sd_raw.c ****     for(i = 0; i < 10; ++i)
 369:../lib/sd_raw.c ****     {
 370:../lib/sd_raw.c ****         response = sd_raw_rec_byte();
 371:../lib/sd_raw.c ****         if(response != 0xff)
 372:../lib/sd_raw.c ****             break;
 373:../lib/sd_raw.c ****     }
 374:../lib/sd_raw.c ****     response <<= 8;
 375:../lib/sd_raw.c ****     response |= sd_raw_rec_byte();
 376:../lib/sd_raw.c **** 
 377:../lib/sd_raw.c ****     return response;
 378:../lib/sd_raw.c **** }
 379:../lib/sd_raw.c **** */
 380:../lib/sd_raw.c **** 
 381:../lib/sd_raw.c **** /**
 382:../lib/sd_raw.c ****  * \ingroup sd_raw
 383:../lib/sd_raw.c ****  * Reads raw data from the card.
 384:../lib/sd_raw.c ****  *
 385:../lib/sd_raw.c ****  * \param[in] offset The offset from which to read.
 386:../lib/sd_raw.c ****  * \param[out] buffer The buffer into which to write the data.
 387:../lib/sd_raw.c ****  * \param[in] length The number of bytes to read.
 388:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 389:../lib/sd_raw.c ****  * \see sd_raw_read_interval, sd_raw_write
 390:../lib/sd_raw.c ****  */
 391:../lib/sd_raw.c **** unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
 392:../lib/sd_raw.c **** {
 393:../lib/sd_raw.c ****     unsigned int block_address;
 394:../lib/sd_raw.c ****     unsigned short block_offset;
 395:../lib/sd_raw.c ****     unsigned short read_length;
 396:../lib/sd_raw.c ****     while(length > 0)
 397:../lib/sd_raw.c ****     {
 398:../lib/sd_raw.c ****         /* determine byte count to read at once */
 399:../lib/sd_raw.c ****         block_address = offset & 0xfffffe00;
 400:../lib/sd_raw.c ****         block_offset = offset & 0x01ff;
 401:../lib/sd_raw.c ****         read_length = 512 - block_offset; /* read up to block border */
 402:../lib/sd_raw.c ****         if(read_length > length)
 403:../lib/sd_raw.c ****             read_length = length;
 404:../lib/sd_raw.c **** 
 405:../lib/sd_raw.c ****         #if !SD_RAW_SAVE_RAM
 406:../lib/sd_raw.c ****             /* check if the requested data is cached */
 407:../lib/sd_raw.c ****             if(block_address != raw_block_address)
 408:../lib/sd_raw.c ****             #endif
 409:../lib/sd_raw.c ****         {
 410:../lib/sd_raw.c ****             #if SD_RAW_WRITE_BUFFERING
 411:../lib/sd_raw.c ****                 if(!raw_block_written)
 412:../lib/sd_raw.c ****                 {
 413:../lib/sd_raw.c ****                     if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 414:../lib/sd_raw.c ****                         return 0;
 415:../lib/sd_raw.c ****                 }
 416:../lib/sd_raw.c ****             #endif
 417:../lib/sd_raw.c **** 
 418:../lib/sd_raw.c ****             /* address card */
 419:../lib/sd_raw.c ****             select_card();
 420:../lib/sd_raw.c **** 
 421:../lib/sd_raw.c ****             /* send single block request */
 422:../lib/sd_raw.c ****             if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
 423:../lib/sd_raw.c ****             {
 424:../lib/sd_raw.c ****                 unselect_card();
 425:../lib/sd_raw.c ****                 return 0;
 426:../lib/sd_raw.c ****             }
 427:../lib/sd_raw.c **** 
 428:../lib/sd_raw.c ****             /* wait for data block (start byte 0xfe) */
 429:../lib/sd_raw.c ****             while(sd_raw_rec_byte() != 0xfe);
 430:../lib/sd_raw.c **** 
 431:../lib/sd_raw.c ****             #if SD_RAW_SAVE_RAM
 432:../lib/sd_raw.c ****                 /* read byte block */
 433:../lib/sd_raw.c ****                 unsigned short read_to = block_offset + read_length;
 434:../lib/sd_raw.c ****                 for(unsigned short i = 0; i < 512; ++i)
 435:../lib/sd_raw.c ****                 {
 436:../lib/sd_raw.c ****                     unsigned char b = sd_raw_rec_byte();
 437:../lib/sd_raw.c ****                     if(i >= block_offset && i < read_to)
 438:../lib/sd_raw.c ****                         *buffer++ = b;
 439:../lib/sd_raw.c ****                 }
 440:../lib/sd_raw.c ****             #else
 441:../lib/sd_raw.c ****                 /* read byte block */
 442:../lib/sd_raw.c ****                 unsigned char* cache = raw_block;
 443:../lib/sd_raw.c ****                 unsigned short i;
 444:../lib/sd_raw.c ****                 for(i = 0; i < 512; ++i)
 445:../lib/sd_raw.c ****                     *cache++ = sd_raw_rec_byte();
 446:../lib/sd_raw.c ****                 raw_block_address = block_address;
 447:../lib/sd_raw.c ****     
 448:../lib/sd_raw.c ****                 memcpy(buffer, raw_block + block_offset, read_length);
 449:../lib/sd_raw.c ****                 buffer += read_length;
 450:../lib/sd_raw.c ****             #endif
 451:../lib/sd_raw.c **** 
 452:../lib/sd_raw.c ****             /* read crc16 */
 453:../lib/sd_raw.c ****             sd_raw_rec_byte();
 454:../lib/sd_raw.c ****             sd_raw_rec_byte();
 455:../lib/sd_raw.c **** 
 456:../lib/sd_raw.c ****             /* deaddress card */
 457:../lib/sd_raw.c ****             unselect_card();
 458:../lib/sd_raw.c **** 
 459:../lib/sd_raw.c ****             /* let card some time to finish */
 460:../lib/sd_raw.c ****             sd_raw_rec_byte();
 461:../lib/sd_raw.c ****         }
 462:../lib/sd_raw.c ****         #if !SD_RAW_SAVE_RAM
 463:../lib/sd_raw.c ****             else
 464:../lib/sd_raw.c ****             {
 465:../lib/sd_raw.c ****                 /* use cached data */
 466:../lib/sd_raw.c ****                 memcpy(buffer, raw_block + block_offset, read_length);
 467:../lib/sd_raw.c ****             }
 468:../lib/sd_raw.c ****         #endif
 469:../lib/sd_raw.c **** 
 470:../lib/sd_raw.c ****         length -= read_length;
 471:../lib/sd_raw.c ****         offset += read_length;
 472:../lib/sd_raw.c ****     }
 473:../lib/sd_raw.c **** 
 474:../lib/sd_raw.c ****     return 1;
 475:../lib/sd_raw.c **** }
 476:../lib/sd_raw.c **** 
 477:../lib/sd_raw.c **** /**
 478:../lib/sd_raw.c ****  * \ingroup sd_raw
 479:../lib/sd_raw.c ****  * Continuously reads units of \c interval bytes and calls a callback function.
 480:../lib/sd_raw.c ****  *
 481:../lib/sd_raw.c ****  * This function starts reading at the specified offset. Every \c interval bytes,
 482:../lib/sd_raw.c ****  * it calls the callback function with the associated data buffer.
 483:../lib/sd_raw.c ****  *
 484:../lib/sd_raw.c ****  * By returning zero, the callback may stop reading.
 485:../lib/sd_raw.c ****  *
 486:../lib/sd_raw.c ****  * \note Within the callback function, you can not start another read or
 487:../lib/sd_raw.c ****  *       write operation.
 488:../lib/sd_raw.c ****  * \note This function only works if the following conditions are met:
 489:../lib/sd_raw.c ****  *       - (offset - (offset % 512)) % interval == 0
 490:../lib/sd_raw.c ****  *       - length % interval == 0
 491:../lib/sd_raw.c ****  *
 492:../lib/sd_raw.c ****  * \param[in] offset Offset from which to start reading.
 493:../lib/sd_raw.c ****  * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 494:../lib/sd_raw.c ****  * \param[in] interval Number of bytes to read before calling the callback function.
 495:../lib/sd_raw.c ****  * \param[in] length Number of bytes to read altogether.
 496:../lib/sd_raw.c ****  * \param[in] callback The function to call every interval bytes.
 497:../lib/sd_raw.c ****  * \param[in] p An opaque pointer directly passed to the callback function.
 498:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success
 499:../lib/sd_raw.c ****  * \see sd_raw_read, sd_raw_write
 500:../lib/sd_raw.c ****  */
 501:../lib/sd_raw.c **** unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short inter
 502:../lib/sd_raw.c **** {
 503:../lib/sd_raw.c ****     if(!buffer || interval == 0 || length < interval || !callback)
 504:../lib/sd_raw.c ****         return 0;
 505:../lib/sd_raw.c **** 
 506:../lib/sd_raw.c ****     #if !SD_RAW_SAVE_RAM
 507:../lib/sd_raw.c ****         while(length >= interval)
 508:../lib/sd_raw.c ****         {
 509:../lib/sd_raw.c ****             /* as reading is now buffered, we directly
 510:../lib/sd_raw.c ****                      * hand over the request to sd_raw_read()
 511:../lib/sd_raw.c ****                      */
 512:../lib/sd_raw.c ****             if(!sd_raw_read(offset, buffer, interval))
 513:../lib/sd_raw.c ****                 return 0;
 514:../lib/sd_raw.c ****             if(!callback(buffer, offset, p))
 515:../lib/sd_raw.c ****                 break;
 516:../lib/sd_raw.c ****             offset += interval;
 517:../lib/sd_raw.c ****             length -= interval;
 518:../lib/sd_raw.c ****         }
 519:../lib/sd_raw.c ****     
 520:../lib/sd_raw.c ****         return 1;
 521:../lib/sd_raw.c ****     #else
 522:../lib/sd_raw.c ****         /* address card */
 523:../lib/sd_raw.c ****         select_card();
 524:../lib/sd_raw.c ****     
 525:../lib/sd_raw.c ****         unsigned short block_offset;
 526:../lib/sd_raw.c ****         unsigned short read_length;
 527:../lib/sd_raw.c ****         unsigned char* buffer_cur;
 528:../lib/sd_raw.c ****         unsigned char finished = 0;
 529:../lib/sd_raw.c ****         do
 530:../lib/sd_raw.c ****         {
 531:../lib/sd_raw.c ****             /* determine byte count to read at once */
 532:../lib/sd_raw.c ****             block_offset = offset & 0x01ff;
 533:../lib/sd_raw.c ****             read_length = 512 - block_offset;
 534:../lib/sd_raw.c ****     
 535:../lib/sd_raw.c ****             /* send single block request */
 536:../lib/sd_raw.c ****             if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
 537:../lib/sd_raw.c ****             {
 538:../lib/sd_raw.c ****                 unselect_card();
 539:../lib/sd_raw.c ****                 return 0;
 540:../lib/sd_raw.c ****             }
 541:../lib/sd_raw.c ****     
 542:../lib/sd_raw.c ****             /* wait for data block (start byte 0xfe) */
 543:../lib/sd_raw.c ****             while(sd_raw_rec_byte() != 0xfe);
 544:../lib/sd_raw.c ****             unsigned short i;
 545:../lib/sd_raw.c ****             /* read up to the data of interest */
 546:../lib/sd_raw.c ****             for(i = 0; i < block_offset; ++i)
 547:../lib/sd_raw.c ****                 sd_raw_rec_byte();
 548:../lib/sd_raw.c ****     
 549:../lib/sd_raw.c ****             /* read interval bytes of data and execute the callback */
 550:../lib/sd_raw.c ****             do
 551:../lib/sd_raw.c ****             {
 552:../lib/sd_raw.c ****                 if(read_length < interval || length < interval)
 553:../lib/sd_raw.c ****                     break;
 554:../lib/sd_raw.c ****     
 555:../lib/sd_raw.c ****                 buffer_cur = buffer;
 556:../lib/sd_raw.c ****                 for(i = 0; i < interval; ++i)
 557:../lib/sd_raw.c ****                     *buffer_cur++ = sd_raw_rec_byte();
 558:../lib/sd_raw.c ****     
 559:../lib/sd_raw.c ****                 if(!callback(buffer, offset + (512 - read_length), p))
 560:../lib/sd_raw.c ****                 {
 561:../lib/sd_raw.c ****                     finished = 1;
 562:../lib/sd_raw.c ****                     break;
 563:../lib/sd_raw.c ****                 }
 564:../lib/sd_raw.c ****     
 565:../lib/sd_raw.c ****                 read_length -= interval;
 566:../lib/sd_raw.c ****                 length -= interval;
 567:../lib/sd_raw.c ****     
 568:../lib/sd_raw.c ****             }
 569:../lib/sd_raw.c ****             while(read_length > 0 && length > 0);
 570:../lib/sd_raw.c ****     
 571:../lib/sd_raw.c ****             /* read rest of data block */
 572:../lib/sd_raw.c ****             while(read_length-- > 0)
 573:../lib/sd_raw.c ****                 sd_raw_rec_byte();
 574:../lib/sd_raw.c ****     
 575:../lib/sd_raw.c ****             /* read crc16 */
 576:../lib/sd_raw.c ****             sd_raw_rec_byte();
 577:../lib/sd_raw.c ****             sd_raw_rec_byte();
 578:../lib/sd_raw.c ****     
 579:../lib/sd_raw.c ****             if(length < interval)
 580:../lib/sd_raw.c ****                 break;
 581:../lib/sd_raw.c ****     
 582:../lib/sd_raw.c ****             offset = (offset & 0xfffffe00) + 512;
 583:../lib/sd_raw.c ****     
 584:../lib/sd_raw.c ****         }
 585:../lib/sd_raw.c ****         while(!finished);
 586:../lib/sd_raw.c ****     
 587:../lib/sd_raw.c ****         /* deaddress card */
 588:../lib/sd_raw.c ****         unselect_card();
 589:../lib/sd_raw.c ****     
 590:../lib/sd_raw.c ****         /* let card some time to finish */
 591:../lib/sd_raw.c ****         sd_raw_rec_byte();
 592:../lib/sd_raw.c ****     
 593:../lib/sd_raw.c ****         return 1;
 594:../lib/sd_raw.c ****     #endif
 595:../lib/sd_raw.c **** }
 596:../lib/sd_raw.c **** 
 597:../lib/sd_raw.c **** /**
 598:../lib/sd_raw.c ****  * \ingroup sd_raw
 599:../lib/sd_raw.c ****  * Writes raw data to the card.
 600:../lib/sd_raw.c ****  *
 601:../lib/sd_raw.c ****  * \note If write buffering is enabled, you might have to
 602:../lib/sd_raw.c ****  *       call sd_raw_sync() before disconnecting the card
 603:../lib/sd_raw.c ****  *       to ensure all remaining data has been written.
 604:../lib/sd_raw.c ****  *
 605:../lib/sd_raw.c ****  * \param[in] offset The offset where to start writing.
 606:../lib/sd_raw.c ****  * \param[in] buffer The buffer containing the data to be written.
 607:../lib/sd_raw.c ****  * \param[in] length The number of bytes to write.
 608:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 609:../lib/sd_raw.c ****  * \see sd_raw_read
 610:../lib/sd_raw.c ****  */
 611:../lib/sd_raw.c **** unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
 612:../lib/sd_raw.c **** {
 613:../lib/sd_raw.c ****     #if SD_RAW_WRITE_SUPPORT
 614:../lib/sd_raw.c ****     
 615:../lib/sd_raw.c ****         if(get_pin_locked())
 616:../lib/sd_raw.c ****             return 0;
 617:../lib/sd_raw.c ****     
 618:../lib/sd_raw.c ****         unsigned int block_address;
 619:../lib/sd_raw.c ****         unsigned short block_offset;
 620:../lib/sd_raw.c ****         unsigned short write_length;
 621:../lib/sd_raw.c ****         while(length > 0)
 622:../lib/sd_raw.c ****         {
 623:../lib/sd_raw.c ****             /* determine byte count to write at once */
 624:../lib/sd_raw.c ****             block_address = offset & 0xfffffe00;
 625:../lib/sd_raw.c ****             block_offset = offset & 0x01ff;
 626:../lib/sd_raw.c ****             write_length = 512 - block_offset; /* write up to block border */
 627:../lib/sd_raw.c ****             if(write_length > length)
 628:../lib/sd_raw.c ****                 write_length = length;
 629:../lib/sd_raw.c ****     
 630:../lib/sd_raw.c ****             /* Merge the data to write with the content of the block.
 631:../lib/sd_raw.c ****                      * Use the cached block if available.
 632:../lib/sd_raw.c ****                      */
 633:../lib/sd_raw.c ****             if(block_address != raw_block_address)
 634:../lib/sd_raw.c ****             {
 635:../lib/sd_raw.c ****                 #if SD_RAW_WRITE_BUFFERING
 636:../lib/sd_raw.c ****                 if(!raw_block_written)
 637:../lib/sd_raw.c ****                 {
 638:../lib/sd_raw.c ****                     if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 639:../lib/sd_raw.c ****                         return 0;
 640:../lib/sd_raw.c ****                 }
 641:../lib/sd_raw.c ****             #endif
 642:../lib/sd_raw.c **** 
 643:../lib/sd_raw.c ****             if(block_offset || write_length < 512)
 644:../lib/sd_raw.c ****             {
 645:../lib/sd_raw.c ****                 if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
 646:../lib/sd_raw.c ****                     return 0;
 647:../lib/sd_raw.c ****             }
 648:../lib/sd_raw.c ****             raw_block_address = block_address;
 649:../lib/sd_raw.c ****         }
 650:../lib/sd_raw.c **** 
 651:../lib/sd_raw.c ****         if(buffer != raw_block)
 652:../lib/sd_raw.c ****         {
 653:../lib/sd_raw.c ****             memcpy(raw_block + block_offset, buffer, write_length);
 654:../lib/sd_raw.c **** 
 655:../lib/sd_raw.c ****             #if SD_RAW_WRITE_BUFFERING
 656:../lib/sd_raw.c ****                 raw_block_written = 0;
 657:../lib/sd_raw.c ****     
 658:../lib/sd_raw.c ****                 if(length == write_length)
 659:../lib/sd_raw.c ****                     return 1;
 660:../lib/sd_raw.c ****             #endif
 661:../lib/sd_raw.c ****         }
 662:../lib/sd_raw.c **** 
 663:../lib/sd_raw.c ****         buffer += write_length;
 664:../lib/sd_raw.c **** 
 665:../lib/sd_raw.c ****         /* address card */
 666:../lib/sd_raw.c ****         select_card();
 667:../lib/sd_raw.c **** 
 668:../lib/sd_raw.c ****         /* send single block request */
 669:../lib/sd_raw.c ****         if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
 670:../lib/sd_raw.c ****         {
 671:../lib/sd_raw.c ****             unselect_card();
 672:../lib/sd_raw.c ****             return 0;
 673:../lib/sd_raw.c ****         }
 674:../lib/sd_raw.c **** 
 675:../lib/sd_raw.c ****         /* send start byte */
 676:../lib/sd_raw.c ****         sd_raw_send_byte(0xfe);
 677:../lib/sd_raw.c **** 
 678:../lib/sd_raw.c ****         /* write byte block */
 679:../lib/sd_raw.c ****         unsigned char* cache = raw_block;
 680:../lib/sd_raw.c ****         unsigned short i;
 681:../lib/sd_raw.c ****         for(i = 0; i < 512; ++i)
 682:../lib/sd_raw.c ****             sd_raw_send_byte(*cache++);
 683:../lib/sd_raw.c **** 
 684:../lib/sd_raw.c ****         /* write dummy crc16 */
 685:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 686:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 687:../lib/sd_raw.c **** 
 688:../lib/sd_raw.c ****         /* wait while card is busy */
 689:../lib/sd_raw.c ****         while(sd_raw_rec_byte() != 0xff);
 690:../lib/sd_raw.c ****         sd_raw_rec_byte();
 691:../lib/sd_raw.c **** 
 692:../lib/sd_raw.c ****         /* deaddress card */
 693:../lib/sd_raw.c ****         unselect_card();
 694:../lib/sd_raw.c **** 
 695:../lib/sd_raw.c ****         length -= write_length;
 696:../lib/sd_raw.c ****         offset += write_length;
 697:../lib/sd_raw.c **** 
 698:../lib/sd_raw.c ****         #if SD_RAW_WRITE_BUFFERING
 699:../lib/sd_raw.c ****             raw_block_written = 1;
 700:../lib/sd_raw.c ****         #endif
 701:../lib/sd_raw.c ****     }
 702:../lib/sd_raw.c **** 
 703:../lib/sd_raw.c ****     return 1;
 704:../lib/sd_raw.c ****     #else
 705:../lib/sd_raw.c ****         return 0;
 706:../lib/sd_raw.c ****     #endif
 707:../lib/sd_raw.c **** }
 708:../lib/sd_raw.c **** 
 709:../lib/sd_raw.c **** /**
 710:../lib/sd_raw.c ****  * \ingroup sd_raw
 711:../lib/sd_raw.c ****  * Writes the write buffer's content to the card.
 712:../lib/sd_raw.c ****  *
 713:../lib/sd_raw.c ****  * \note When write buffering is enabled, you should
 714:../lib/sd_raw.c ****  *       call this function before disconnecting the
 715:../lib/sd_raw.c ****  *       card to ensure all remaining data has been
 716:../lib/sd_raw.c ****  *       written.
 717:../lib/sd_raw.c ****  *
 718:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 719:../lib/sd_raw.c ****  * \see sd_raw_write
 720:../lib/sd_raw.c ****  */
 721:../lib/sd_raw.c **** unsigned char sd_raw_sync()
 722:../lib/sd_raw.c **** {
 723:../lib/sd_raw.c ****     #if SD_RAW_WRITE_SUPPORT
 724:../lib/sd_raw.c ****         #if SD_RAW_WRITE_BUFFERING
 725:../lib/sd_raw.c ****         if(raw_block_written)
 726:../lib/sd_raw.c ****             return 1;
 727:../lib/sd_raw.c ****         if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 728:../lib/sd_raw.c ****             return 0;
 729:../lib/sd_raw.c ****     #endif
 730:../lib/sd_raw.c ****     return 1;
 731:../lib/sd_raw.c ****     #else
 732:../lib/sd_raw.c ****     return 0;
 733:../lib/sd_raw.c ****     #endif
 734:../lib/sd_raw.c **** }
 735:../lib/sd_raw.c **** 
 736:../lib/sd_raw.c **** /**
 737:../lib/sd_raw.c ****  * \ingroup sd_raw
 738:../lib/sd_raw.c ****  * Reads informational data from the card.
 739:../lib/sd_raw.c ****  *
 740:../lib/sd_raw.c ****  * This function reads and returns the card's registers
 741:../lib/sd_raw.c ****  * containing manufacturing and status information.
 742:../lib/sd_raw.c ****  *
 743:../lib/sd_raw.c ****  * \note: The information retrieved by this function is
 744:../lib/sd_raw.c ****  *        not required in any way to operate on the card,
 745:../lib/sd_raw.c ****  *        but it might be nice to display some of the data
 746:../lib/sd_raw.c ****  *        to the user.
 747:../lib/sd_raw.c ****  *
 748:../lib/sd_raw.c ****  * \param[in] info A pointer to the structure into which to save the information.
 749:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 750:../lib/sd_raw.c ****  */
 751:../lib/sd_raw.c **** unsigned char sd_raw_get_info(struct sd_raw_info* info)
 752:../lib/sd_raw.c **** {
 753:../lib/sd_raw.c ****     if(!info || !sd_raw_available())
 754:../lib/sd_raw.c ****         return 0;
 755:../lib/sd_raw.c **** 
 756:../lib/sd_raw.c ****     memset(info, 0, sizeof(*info));
 757:../lib/sd_raw.c **** 
 758:../lib/sd_raw.c ****     select_card();
 759:../lib/sd_raw.c **** 
 760:../lib/sd_raw.c ****     /* read cid register */
 761:../lib/sd_raw.c ****     if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
 762:../lib/sd_raw.c ****     {
 763:../lib/sd_raw.c ****         unselect_card();
 764:../lib/sd_raw.c ****         return 0;
 765:../lib/sd_raw.c ****     }
 766:../lib/sd_raw.c ****     while(sd_raw_rec_byte() != 0xfe);
 767:../lib/sd_raw.c ****     unsigned char i;
 768:../lib/sd_raw.c ****     for(i = 0; i < 18; ++i)
 769:../lib/sd_raw.c ****     {
 770:../lib/sd_raw.c ****         unsigned char b = sd_raw_rec_byte();
 771:../lib/sd_raw.c **** 
 772:../lib/sd_raw.c ****         switch(i)
 773:../lib/sd_raw.c ****         {
 774:../lib/sd_raw.c ****             case 0:
 775:../lib/sd_raw.c ****                 info->manufacturer = b;
 776:../lib/sd_raw.c ****                 break;
 777:../lib/sd_raw.c ****             case 1:
 778:../lib/sd_raw.c ****             case 2:
 779:../lib/sd_raw.c ****                 info->oem[i - 1] = b;
 780:../lib/sd_raw.c ****                 break;
 781:../lib/sd_raw.c ****             case 3:
 782:../lib/sd_raw.c ****             case 4:
 783:../lib/sd_raw.c ****             case 5:
 784:../lib/sd_raw.c ****             case 6:
 785:../lib/sd_raw.c ****             case 7:
 786:../lib/sd_raw.c ****                 info->product[i - 3] = b;
 787:../lib/sd_raw.c ****                 break;
 788:../lib/sd_raw.c ****             case 8:
 789:../lib/sd_raw.c ****                 info->revision = b;
 790:../lib/sd_raw.c ****                 break;
 791:../lib/sd_raw.c ****             case 9:
 792:../lib/sd_raw.c ****             case 10:
 793:../lib/sd_raw.c ****             case 11:
 794:../lib/sd_raw.c ****             case 12:
 795:../lib/sd_raw.c ****                 info->serial |= (unsigned int) b << ((12 - i) * 8);
 796:../lib/sd_raw.c ****                 break;
 797:../lib/sd_raw.c ****             case 13:
 798:../lib/sd_raw.c ****                 info->manufacturing_year = b << 4;
 799:../lib/sd_raw.c ****                 break;
 800:../lib/sd_raw.c ****             case 14:
 801:../lib/sd_raw.c ****                 info->manufacturing_year |= b >> 4;
 802:../lib/sd_raw.c ****                 info->manufacturing_month = b & 0x0f;
 803:../lib/sd_raw.c ****                 break;
 804:../lib/sd_raw.c ****         }
 805:../lib/sd_raw.c ****     }
 806:../lib/sd_raw.c **** 
 807:../lib/sd_raw.c ****     /* read csd register */
 808:../lib/sd_raw.c ****     unsigned char csd_read_bl_len = 0;
 809:../lib/sd_raw.c ****     unsigned char csd_c_size_mult = 0;
 810:../lib/sd_raw.c ****     unsigned short csd_c_size = 0;
 811:../lib/sd_raw.c ****     if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
 812:../lib/sd_raw.c ****     {
 813:../lib/sd_raw.c ****         unselect_card();
 814:../lib/sd_raw.c ****         return 0;
 815:../lib/sd_raw.c ****     }
 816:../lib/sd_raw.c ****     while(sd_raw_rec_byte() != 0xfe);
 817:../lib/sd_raw.c ****     for(i = 0; i < 18; ++i)
 818:../lib/sd_raw.c ****     {
 819:../lib/sd_raw.c ****         unsigned char b = sd_raw_rec_byte();
 820:../lib/sd_raw.c **** 
 821:../lib/sd_raw.c ****         switch(i)
 822:../lib/sd_raw.c ****         {
 823:../lib/sd_raw.c ****             case 5:
 824:../lib/sd_raw.c ****                 csd_read_bl_len = b & 0x0f;
 825:../lib/sd_raw.c ****                 break;
 826:../lib/sd_raw.c ****             case 6:
 827:../lib/sd_raw.c ****                 csd_c_size = (unsigned short) (b & 0x03) << 8;
 828:../lib/sd_raw.c ****                 break;
 829:../lib/sd_raw.c ****             case 7:
 830:../lib/sd_raw.c ****                 csd_c_size |= b;
 831:../lib/sd_raw.c ****                 csd_c_size <<= 2;
 832:../lib/sd_raw.c ****                 break;
 833:../lib/sd_raw.c ****             case 8:
 834:../lib/sd_raw.c ****                 csd_c_size |= b >> 6;
 835:../lib/sd_raw.c ****                 ++csd_c_size;
 836:../lib/sd_raw.c ****                 break;
 837:../lib/sd_raw.c ****             case 9:
 838:../lib/sd_raw.c ****                 csd_c_size_mult = (b & 0x03) << 1;
 839:../lib/sd_raw.c ****                 break;
 840:../lib/sd_raw.c ****             case 10:
 841:../lib/sd_raw.c ****                 csd_c_size_mult |= b >> 7;
 842:../lib/sd_raw.c **** 
 843:../lib/sd_raw.c ****                 info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 
 844:../lib/sd_raw.c **** 
 845:../lib/sd_raw.c ****                 break;
 846:../lib/sd_raw.c ****             case 14:
 847:../lib/sd_raw.c ****                 if(b & 0x40)
 848:../lib/sd_raw.c ****                     info->flag_copy = 1;
 849:../lib/sd_raw.c ****                 if(b & 0x20)
 850:../lib/sd_raw.c ****                     info->flag_write_protect = 1;
 851:../lib/sd_raw.c ****                 if(b & 0x10)
 852:../lib/sd_raw.c ****                     info->flag_write_protect_temp = 1;
 853:../lib/sd_raw.c ****                 info->format = (b & 0x0c) >> 2;
 854:../lib/sd_raw.c ****                 break;
 855:../lib/sd_raw.c ****         }
 856:../lib/sd_raw.c ****     }
 857:../lib/sd_raw.c **** 
 858:../lib/sd_raw.c ****     unselect_card();
 859:../lib/sd_raw.c **** 
 860:../lib/sd_raw.c ****     return 1;
 861:../lib/sd_raw.c **** }
 862:../lib/sd_raw.c **** 
 863:../lib/sd_raw.c **** void SDoff(void)
 864:../lib/sd_raw.c **** {
 865:../lib/sd_raw.c ****     IODIR1 &= ~(CS);
 866:../lib/sd_raw.c ****     PINSEL0 &= ~(0x1500);
 867:../lib/sd_raw.c **** }
 868:../lib/sd_raw.c **** 
 869:../lib/sd_raw.c **** //NES : 10-28-7 
 870:../lib/sd_raw.c **** //Low-level formats a 512MB card
 871:../lib/sd_raw.c **** //Assumes *many* things
 872:../lib/sd_raw.c **** //You must pass this fuction 0xAA to get it to work (safety check)
 873:../lib/sd_raw.c **** char format_card(char make_sure)
 874:../lib/sd_raw.c **** {
 228              		ldr	r3, [r2, #24]
 229              		bic	r3, r3, #128
 230              		str	r3, [r2, #24]
 231              		.loc 1 876 0
 232              		add	r2, r2, #16384
 875:../lib/sd_raw.c **** ATION + (0x200 * 512))
 233              	r3, [r2, #0]
 234 0148 1C209FE5 		bic	r3, r3, #5376
 235 014c 183092E5 		.loc 1 874 0
 236 0150 8030C3E3 		@ lr needed for prologue
 237 0154 183082E5 		.loc 1 876 0
 876:../lib/sd_raw.c **** BR_LOCATION		(MBR_LOCATION+0x80000)
 238              	r3, [r2, #0]
 239 0158 012982E2 		.loc 1 877 0
 240 015c 003092E5 		bx	lr
 241 0160 153CC3E3 	.L53:
 242              		.align	2
 243              	.L52:
 244              		.word	-536707072
 245 0164 003082E5 	.LFE13:
 877:../lib/sd_raw.c **** r make_sure)
 246              	Doff, .-SDoff
 247 0168 1EFF2FE1 		.align	2
 248              		.global	sd_raw_get_info
 250              	sd_raw_get_info:
 251 016c 008002E0 	.LFB12:
 252              		.loc 1 762 0
 253              		@ Function supports interworking.
 254              		@ args = 0, pretend = 0, frame = 0
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256              	.LVL3:
 257              		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 258              	.LCFI1:
 259              		.loc 1 763 0
 260              		subs	r4, r0, #0
 261              		beq	.L55
 262              	.LVL4:
 263              		bl	sd_raw_available
 264 0170 F0412DE9 		cmp	r0, #0
 265              		beq	.L55
 266              		.loc 1 768 0
 267 0174 004050E2 		ldr	r5, .L121
 268 0178 9700000A 		.loc 1 766 0
 269              		mov	r1, #0
 270 017c FEFFFFEB 		mov	r2, #28
 271 0180 000050E3 		mov	r0, r4
 272 0184 9400000A 		bl	memset
 273              		.loc 1 768 0
 274 0188 70529FE5 		ldr	r3, [r5, #12]
 275              		orr	r3, r3, #128
 276 018c 0010A0E3 		.loc 1 771 0
 277 0190 1C20A0E3 		mov	r0, #10
 278 0194 0400A0E1 		mov	r1, #0
 279 0198 FEFFFFEB 		.loc 1 768 0
 280              		str	r3, [r5, #12]
 281 019c 0C3095E5 		.loc 1 771 0
 282 01a0 803083E3 		bl	sd_raw_send_command_r1
 283              		cmp	r0, #0
 284 01a4 0A00A0E3 		.loc 1 773 0
 285 01a8 0010A0E3 		ldrne	r3, [r5, #4]
 286              		movne	r0, #0
 287 01ac 0C3085E5 		orrne	r3, r3, #128
 288              		strne	r3, [r5, #4]
 289 01b0 ACFFFFEB 		bne	.L60
 290 01b4 000050E3 	.L102:
 291              		.loc 1 776 0
 292 01b8 04309515 		bl	sd_raw_rec_byte
 293 01bc 0000A013 		cmp	r0, #254
 294 01c0 80308313 		bne	.L102
 295 01c4 04308515 	.LBB35:
 296 01c8 8A00001A 		.loc 1 780 0
 297              		bl	sd_raw_rec_byte
 298              		mov	r5, #0
 299 01cc 9AFFFFEB 	.LVL5:
 300 01d0 FE0050E3 		b	.L62
 301 01d4 FCFFFF1A 	.LVL6:
 302              	.L63:
 303              		bl	sd_raw_rec_byte
 304 01d8 97FFFFEB 	.LVL7:
 305 01dc 0050A0E3 		.loc 1 782 0
 306              		cmp	r5, #14
 307 01e0 120000EA 		ldrls	pc, [pc, r5, asl #2]
 308              		b	.L64
 309              		.p2align 2
 310 01e4 94FFFFEB 	.L71:
 311              		.word	.L62
 312              		.word	.L65
 313 01e8 0E0055E3 		.word	.L65
 314 01ec 05F19F97 		.word	.L66
 315 01f0 260000EA 		.word	.L66
 316              		.word	.L66
 317              		.word	.L66
 318 01f4 30020000 		.word	.L66
 319 01f8 38020000 		.word	.L67
 320 01fc 38020000 		.word	.L68
 321 0200 40020000 		.word	.L68
 322 0204 40020000 		.word	.L68
 323 0208 40020000 		.word	.L68
 324 020c 40020000 		.word	.L69
 325 0210 40020000 		.word	.L70
 326 0214 4C020000 	.L62:
 327 0218 54020000 	.LVL8:
 328 021c 54020000 		.loc 1 785 0
 329 0220 54020000 		strb	r0, [r4, #0]
 330 0224 54020000 		b	.L120
 331 0228 6C020000 	.LVL9:
 332 022c 78020000 	.L65:
 333              	.LVL10:
 334              		.loc 1 789 0
 335              		strb	r0, [r5, r4]
 336 0230 0000C4E5 		b	.L64
 337 0234 6A0000EA 	.LVL11:
 338              	.L66:
 339              		.loc 1 796 0
 340              		add	r3, r5, r4
 341              	.LVL12:
 342 0238 0400C5E7 		strb	r0, [r3, #1]
 343 023c 130000EA 		b	.L64
 344              	.LVL13:
 345              	.L67:
 346              	.LVL14:
 347 0240 043085E0 		.loc 1 799 0
 348              		strb	r0, [r4, #10]
 349 0244 0100C3E5 		b	.L120
 350 0248 100000EA 	.LVL15:
 351              	.L68:
 352              		.loc 1 805 0
 353              		ldr	r2, [r4, #12]
 354              		rsb	r3, r5, #12
 355 024c 0A00C4E5 		mov	r3, r3, asl #3
 356 0250 630000EA 	.LVL16:
 357              		orr	r2, r2, r0, asl r3
 358              		str	r2, [r4, #12]
 359              		b	.L64
 360 0254 0C2094E5 	.LVL17:
 361 0258 0C3065E2 	.L69:
 362 025c 8331A0E1 	.LVL18:
 363              		.loc 1 808 0
 364 0260 102382E1 		mov	r3, r0, asl #4
 365 0264 0C2084E5 		strb	r3, [r4, #16]
 366 0268 080000EA 		b	.L120
 367              	.LVL19:
 368              	.L70:
 369              		.loc 1 811 0
 370              		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 371 026c 0032A0E1 	.LVL20:
 372 0270 1030C4E5 		.loc 1 812 0
 373 0274 5A0000EA 		and	r2, r0, #15
 374              		.loc 1 811 0
 375              		orr	r3, r3, r0, lsr #4
 376              		strb	r3, [r4, #16]
 377 0278 1030D4E5 		.loc 1 812 0
 378              		strb	r2, [r4, #17]
 379              		b	.L120
 380 027c 0F2000E2 	.L64:
 381              	.LBE35:
 382 0280 203283E1 		.loc 1 778 0
 383 0284 1030C4E5 		add	r3, r5, #1
 384              		and	r5, r3, #255
 385 0288 1120C4E5 		cmp	r5, #17
 386 028c 540000EA 		bls	.L63
 387              		.loc 1 821 0
 388              		mov	r0, #9
 389              	.LVL21:
 390 0290 013085E2 		mov	r1, #0
 391 0294 FF5003E2 		bl	sd_raw_send_command_r1
 392 0298 110055E3 		cmp	r0, #0
 393 029c D0FFFF9A 		.loc 1 823 0
 394              		ldrne	r2, .L121
 395 02a0 0900A0E3 		ldrne	r3, [r2, #4]
 396              		movne	r0, #0
 397 02a4 0010A0E3 		orrne	r3, r3, #128
 398 02a8 6EFFFFEB 		bne	.L118
 399 02ac 000050E3 	.L103:
 400              		.loc 1 826 0
 401 02b0 48219F15 		bl	sd_raw_rec_byte
 402 02b4 04309215 		cmp	r0, #254
 403 02b8 0000A013 		bne	.L103
 404 02bc 80308313 	.LBB36:
 405 02c0 4300001A 		.loc 1 829 0
 406              		bl	sd_raw_rec_byte
 407              	.LBE36:
 408 02c4 5CFFFFEB 		.loc 1 827 0
 409 02c8 FE0050E3 		mov	r7, #0
 410 02cc FCFFFF1A 	.LVL22:
 411              		mov	r5, #1
 412              	.LVL23:
 413 02d0 59FFFFEB 		mov	r8, r7
 414              	.LVL24:
 415              		mov	r6, r7
 416 02d4 0070A0E3 	.LVL25:
 417              	.LVL26:
 418 02d8 0150A0E3 	.L119:
 419              	.LBB37:
 420 02dc 0780A0E1 		.loc 1 829 0
 421              		bl	sd_raw_rec_byte
 422 02e0 0760A0E1 	.LVL27:
 423              		.loc 1 831 0
 424              		sub	r3, r5, #5
 425              		add	r2, r5, #1
 426              		cmp	r3, #9
 427              		ldrls	pc, [pc, r3, asl #2]
 428 02e4 54FFFFEB 		b	.L78
 429              		.p2align 2
 430              	.L86:
 431 02e8 053045E2 		.word	.L79
 432 02ec 012085E2 		.word	.L80
 433 02f0 090053E3 		.word	.L81
 434 02f4 03F19F97 		.word	.L82
 435 02f8 2E0000EA 		.word	.L83
 436              		.word	.L84
 437              		.word	.L78
 438 02fc 24030000 		.word	.L78
 439 0300 2C030000 		.word	.L78
 440 0304 38030000 		.word	.L85
 441 0308 44030000 	.L79:
 442 030c 5C030000 	.LVL28:
 443 0310 68030000 		.loc 1 834 0
 444 0314 B8030000 		and	r8, r0, #15
 445 0318 B8030000 		b	.L87
 446 031c B8030000 	.LVL29:
 447 0320 84030000 	.L80:
 448              	.LVL30:
 449              		.loc 1 837 0
 450              		and	r3, r0, #3
 451 0324 0F8000E2 		mov	r6, r3, asl #8
 452 0328 300000EA 		b	.L87
 453              	.LVL31:
 454              	.L81:
 455              	.LVL32:
 456              		.loc 1 840 0
 457 032c 033000E2 		orr	r3, r6, r0
 458 0330 0364A0E1 		.loc 1 841 0
 459 0334 2D0000EA 		mov	r3, r3, asl #18
 460              		b	.L117
 461              	.LVL33:
 462              	.L82:
 463              	.LVL34:
 464 0338 003086E1 		.loc 1 844 0
 465              		mov	r3, r0, asl #18
 466 033c 0339A0E1 		orr	r3, r6, r3, lsr #24
 467 0340 030000EA 	.LVL35:
 468              		.loc 1 845 0
 469              		add	r3, r3, #1
 470              	.LVL36:
 471              		mov	r3, r3, asl #16
 472 0344 0039A0E1 	.L117:
 473 0348 233C86E1 		mov	r6, r3, lsr #16
 474              		b	.L87
 475              	.LVL37:
 476 034c 013083E2 	.L83:
 477              	.LVL38:
 478 0350 0338A0E1 		.loc 1 848 0
 479              		and	r3, r0, #3
 480 0354 2368A0E1 		mov	r7, r3, asl #1
 481 0358 240000EA 		b	.L87
 482              	.LVL39:
 483              	.L84:
 484              	.LVL40:
 485              		.loc 1 851 0
 486 035c 033000E2 		orr	r3, r7, r0, lsr #7
 487 0360 8370A0E1 		and	r7, r3, #255
 488 0364 210000EA 		.loc 1 853 0
 489              		add	r3, r8, #2
 490              		add	r3, r7, r3
 491              		mov	r3, r6, asl r3
 492              		str	r3, [r4, #20]
 493 0368 A03387E1 		b	.L87
 494 036c FF7003E2 	.LVL41:
 495              	.L85:
 496 0370 023088E2 	.LVL42:
 497 0374 033087E0 		.loc 1 857 0
 498 0378 1633A0E1 		tst	r0, #64
 499 037c 143084E5 		.loc 1 858 0
 500 0380 1A0000EA 		movne	r3, #1
 501              		strneb	r3, [r4, #24]
 502              		.loc 1 859 0
 503              		tst	r0, #32
 504              		.loc 1 860 0
 505 0384 400010E3 		movne	r3, #1
 506              		strneb	r3, [r4, #25]
 507 0388 0130A013 		.loc 1 861 0
 508 038c 1830C415 		tst	r0, #16
 509              		.loc 1 862 0
 510 0390 200010E3 		movne	r3, #1
 511              		strneb	r3, [r4, #26]
 512 0394 0130A013 		.loc 1 863 0
 513 0398 1930C415 		and	r3, r0, #12
 514              		mov	r3, r3, asr #2
 515 039c 100010E3 		strb	r3, [r4, #27]
 516              		b	.L87
 517 03a0 0130A013 	.LVL43:
 518 03a4 1A30C415 	.L78:
 519              	.LBE37:
 520 03a8 0C3000E2 		.loc 1 827 0
 521 03ac 4331A0E1 		and	r5, r2, #255
 522 03b0 1B30C4E5 		cmp	r5, #17
 523 03b4 0D0000EA 		bls	.L119
 524              		.loc 1 868 0
 525              		ldr	r2, .L121
 526              		ldr	r3, [r2, #4]
 527              		mov	r0, #1
 528 03b8 FF5002E2 		orr	r3, r3, #128
 529 03bc 110055E3 	.LVL44:
 530 03c0 C7FFFF9A 	.L118:
 531              		str	r3, [r2, #4]
 532 03c4 34209FE5 		b	.L60
 533 03c8 043092E5 	.LVL45:
 534 03cc 0100A0E3 	.L55:
 535 03d0 803083E3 		.loc 1 870 0
 536              		mov	r0, #0
 537              		b	.L60
 538 03d4 043082E5 	.LVL46:
 539 03d8 060000EA 	.L120:
 540              		.loc 1 778 0
 541              		add	r3, r5, #1
 542              		and	r5, r3, #255
 543 03dc 0000A0E3 		b	.L63
 544 03e0 040000EA 	.LVL47:
 545              	.L87:
 546              		.loc 1 827 0
 547              		and	r5, r2, #255
 548 03e4 013085E2 		b	.L119
 549 03e8 FF5003E2 	.LVL48:
 550 03ec 7CFFFFEA 	.L60:
 551              		.loc 1 871 0
 552              		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 553              		bx	lr
 554 03f0 FF5002E2 	.L122:
 555 03f4 BAFFFFEA 		.align	2
 556              	.L121:
 557              		.word	-536707072
 558              	.LFE12:
 560 03fc 1EFF2FE1 		.align	2
 561              		.global	sd_raw_read
 563              	sd_raw_read:
 564 0400 008002E0 	.LFB8:
 565              		.loc 1 402 0
 566              		@ Function supports interworking.
 567              		@ args = 0, pretend = 0, frame = 0
 568              		@ frame_needed = 0, uses_anonymous_args = 0
 569              	.LVL49:
 570              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 571              	.LCFI2:
 572              		.loc 1 402 0
 573              		mov	r2, r2, asl #16
 574              	.LVL50:
 575              		mov	r9, r0
 576              		mov	sl, r1
 577 0404 F0472DE9 		mov	r8, r2, lsr #16
 578              	.LVL51:
 579              		b	.L124
 580 0408 0228A0E1 	.LVL52:
 581              	.L125:
 582 040c 0090A0E1 		.loc 1 410 0
 583 0410 01A0A0E1 		mov	r6, r9, asl #23
 584 0414 2288A0E1 		mov	r6, r6, lsr #23
 585              		.loc 1 417 0
 586 0418 460000EA 		ldr	r3, .L145
 587              		.loc 1 411 0
 588              		rsb	r2, r6, #512
 589              		mov	r2, r2, asl #16
 590 041c 896BA0E1 		.loc 1 417 0
 591 0420 A66BA0E1 		ldr	r0, [r3, #0]
 592              		.loc 1 409 0
 593 0424 20319FE5 		bic	r5, r9, #508
 594              		bic	r5, r5, #3
 595 0428 022C66E2 		.loc 1 411 0
 596 042c 0228A0E1 		mov	r2, r2, lsr #16
 597              	.LVL53:
 598 0430 000093E5 		cmp	r8, r2
 599              		movcc	r7, r8
 600 0434 7F5FC9E3 		movcs	r7, r2
 601 0438 0350C5E3 		.loc 1 417 0
 602              		cmp	r5, r0
 603 043c 2228A0E1 		beq	.L126
 604              	.LBB38:
 605 0440 020058E1 		.loc 1 421 0
 606 0444 0870A031 		ldr	r3, .L145+4
 607 0448 0270A021 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 608              		cmp	r3, #0
 609 044c 000055E1 		bne	.L128
 610 0450 2F00000A 		.loc 1 423 0
 611              		ldr	r1, .L145+8
 612              		mov	r2, #512
 613 0454 F4309FE5 	.LVL54:
 614 0458 0030D3E5 		bl	sd_raw_write
 615 045c 000053E3 		cmp	r0, #0
 616 0460 0400001A 		beq	.L131
 617              	.LVL55:
 618 0464 E8109FE5 	.L128:
 619 0468 022CA0E3 		.loc 1 429 0
 620              		ldr	r4, .L145+12
 621 046c FEFFFFEB 		ldr	r3, [r4, #12]
 622 0470 000050E3 		orr	r3, r3, #128
 623 0474 3200000A 		.loc 1 432 0
 624              		mov	r0, #17
 625              		mov	r1, r5
 626              		.loc 1 429 0
 627 0478 D8409FE5 		str	r3, [r4, #12]
 628 047c 0C3094E5 		.loc 1 432 0
 629 0480 803083E3 		bl	sd_raw_send_command_r1
 630              	.LVL56:
 631 0484 1100A0E3 		cmp	r0, #0
 632 0488 0510A0E1 		.loc 1 434 0
 633              		ldrne	r3, [r4, #4]
 634 048c 0C3084E5 		movne	r0, #0
 635              		orrne	r3, r3, #128
 636 0490 F4FEFFEB 		strne	r3, [r4, #4]
 637              		bne	.L131
 638 0494 000050E3 	.L140:
 639              		.loc 1 439 0
 640 0498 04309415 		bl	sd_raw_rec_byte
 641 049c 0000A013 		cmp	r0, #254
 642 04a0 80308313 		bne	.L140
 643 04a4 04308415 		ldr	r4, .L145+16
 644 04a8 2500001A 	.L135:
 645              		.loc 1 455 0
 646              		bl	sd_raw_rec_byte
 647 04ac E2FEFFEB 		.loc 1 454 0
 648 04b0 FE0050E3 		ldr	r3, .L145+20
 649 04b4 FCFFFF1A 		.loc 1 455 0
 650 04b8 9C409FE5 		strb	r0, [r4, #-1]
 651              		add	r4, r4, #1
 652              		.loc 1 454 0
 653 04bc DEFEFFEB 		cmp	r4, r3
 654              		bne	.L135
 655 04c0 98309FE5 		.loc 1 456 0
 656              		ldr	r3, .L145
 657 04c4 010044E5 		.loc 1 458 0
 658 04c8 014084E2 		ldr	r1, .L145+8
 659              		mov	r2, r7
 660 04cc 030054E1 		.loc 1 456 0
 661 04d0 F9FFFF1A 		str	r5, [r3, #0]
 662              		.loc 1 458 0
 663 04d4 70309FE5 		add	r1, r6, r1
 664              		mov	r0, sl
 665 04d8 74109FE5 		bl	memcpy
 666 04dc 0720A0E1 		.loc 1 463 0
 667              		bl	sd_raw_rec_byte
 668 04e0 005083E5 		.loc 1 464 0
 669              		bl	sd_raw_rec_byte
 670 04e4 011086E0 		.loc 1 467 0
 671 04e8 0A00A0E1 		ldr	r2, .L145+12
 672 04ec FEFFFFEB 		ldr	r3, [r2, #4]
 673              		orr	r3, r3, #128
 674 04f0 D1FEFFEB 		str	r3, [r2, #4]
 675              		.loc 1 459 0
 676 04f4 D0FEFFEB 		add	sl, sl, r7
 677              		.loc 1 470 0
 678 04f8 58209FE5 		bl	sd_raw_rec_byte
 679 04fc 043092E5 		b	.L137
 680 0500 803083E3 	.LVL57:
 681 0504 043082E5 	.L126:
 682              	.LBE38:
 683 0508 07A08AE0 		.loc 1 476 0
 684              		ldr	r1, .L145+8
 685 050c CAFEFFEB 		mov	r0, sl
 686 0510 040000EA 		add	r1, r6, r1
 687              		mov	r2, r7
 688              	.LVL58:
 689              		bl	memcpy
 690              	.L137:
 691 0514 38109FE5 		.loc 1 480 0
 692 0518 0A00A0E1 		rsb	r3, r7, r8
 693 051c 011086E0 		mov	r3, r3, asl #16
 694 0520 0720A0E1 		.loc 1 481 0
 695              		add	r9, r9, r7
 696 0524 FEFFFFEB 		.loc 1 480 0
 697              		mov	r8, r3, lsr #16
 698              	.LVL59:
 699 0528 083067E0 	.L124:
 700 052c 0338A0E1 		.loc 1 406 0
 701              		cmp	r8, #0
 702 0530 079089E0 		bne	.L125
 703              		mov	r0, #1
 704 0534 2388A0E1 	.L131:
 705              		.loc 1 485 0
 706              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 707              		bx	lr
 708 0538 000058E3 	.L146:
 709 053c B6FFFF1A 		.align	2
 710 0540 0100A0E3 	.L145:
 711              		.word	raw_block_address
 712              		.word	raw_block_written
 713 0544 F047BDE8 		.word	raw_block
 714 0548 1EFF2FE1 		.word	-536707072
 715              		.word	raw_block+1
 716              		.word	raw_block+513
 717              	.LFE8:
 719 0550 04020000 		.align	2
 720 0554 00000000 		.global	sd_raw_write
 722 055c 01000000 	sd_raw_write:
 723 0560 01020000 	.LFB10:
 724              		.loc 1 622 0
 725              		@ Function supports interworking.
 726              		@ args = 0, pretend = 0, frame = 0
 727              		@ frame_needed = 0, uses_anonymous_args = 0
 728              	.LVL60:
 729              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 730              	.LCFI3:
 731              		.loc 1 622 0
 732              		mov	r2, r2, asl #16
 733              	.LVL61:
 734              		mov	sl, r0
 735              		mov	r8, r1
 736 0564 F0472DE9 		mov	r7, r2, lsr #16
 737              	.LVL62:
 738              		b	.L148
 739 0568 0228A0E1 	.LVL63:
 740              	.L149:
 741 056c 00A0A0E1 	.LBB39:
 742 0570 0180A0E1 		.loc 1 635 0
 743 0574 2278A0E1 		mov	r4, sl, asl #23
 744              	.LVL64:
 745 0578 690000EA 		mov	r4, r4, lsr #23
 746              		.loc 1 643 0
 747              		ldr	r9, .L188
 748              		.loc 1 636 0
 749              		rsb	r3, r4, #512
 750 057c 8A4BA0E1 		mov	r3, r3, asl #16
 751              		.loc 1 634 0
 752 0580 A44BA0E1 		bic	r5, sl, #508
 753              		.loc 1 643 0
 754 0584 CC919FE5 		ldr	r0, [r9, #0]
 755              		.loc 1 634 0
 756 0588 023C64E2 		bic	r5, r5, #3
 757 058c 0338A0E1 		.loc 1 636 0
 758              		mov	r3, r3, lsr #16
 759 0590 7F5FCAE3 	.LVL65:
 760              		cmp	r7, r3
 761 0594 000099E5 		movcc	r6, r7
 762              		movcs	r6, r3
 763 0598 0350C5E3 		.loc 1 643 0
 764              		cmp	r5, r0
 765 059c 2338A0E1 		beq	.L150
 766              		.loc 1 646 0
 767 05a0 030057E1 		ldr	r3, .L188+4
 768 05a4 0760A031 	.LVL66:
 769 05a8 0360A021 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 770              		cmp	r3, #0
 771 05ac 000055E1 		bne	.L152
 772 05b0 1700000A 		.loc 1 648 0
 773              		ldr	r1, .L188+8
 774 05b4 A0319FE5 		mov	r2, #512
 775              		bl	sd_raw_write
 776 05b8 0030D3E5 		cmp	r0, #0
 777 05bc 000053E3 		beq	.L154
 778 05c0 0400001A 	.LVL67:
 779              	.L152:
 780 05c4 94119FE5 		.loc 1 653 0
 781 05c8 022CA0E3 		ldr	r3, .L188+12
 782 05cc FEFFFFEB 		cmp	r6, r3
 783 05d0 000050E3 		movhi	r3, #0
 784 05d4 5500000A 		movls	r3, #1
 785              		cmp	r4, #0
 786              		orrne	r3, r3, #1
 787              		cmp	r3, #0
 788 05d8 84319FE5 		beq	.L155
 789 05dc 030056E1 		.loc 1 655 0
 790 05e0 0030A083 		mov	r0, r5
 791 05e4 0130A093 		ldr	r1, .L188+8
 792 05e8 000054E3 		mov	r2, #512
 793 05ec 01308313 		bl	sd_raw_read
 794 05f0 000053E3 		cmp	r0, #0
 795 05f4 0500000A 		beq	.L154
 796              	.LVL68:
 797 05f8 0500A0E1 	.L155:
 798 05fc 5C119FE5 		.loc 1 658 0
 799 0600 022CA0E3 		str	r5, [r9, #0]
 800 0604 FEFFFFEB 	.LVL69:
 801 0608 000050E3 	.L150:
 802 060c 4700000A 		.loc 1 661 0
 803              		ldr	r3, .L188+8
 804              	.LVL70:
 805              		cmp	r8, r3
 806 0610 005089E5 		beq	.L157
 807              		.loc 1 663 0
 808              		add	r0, r4, r3
 809              		mov	r2, r6
 810 0614 44319FE5 		mov	r1, r8
 811              		bl	memcpy
 812 0618 030058E1 		.loc 1 666 0
 813 061c 0800000A 		ldr	r3, .L188+4
 814              		mov	r2, #0
 815 0620 030084E0 		.loc 1 668 0
 816 0624 0620A0E1 		cmp	r7, r6
 817 0628 0810A0E1 		.loc 1 666 0
 818 062c FEFFFFEB 		strb	r2, [r3, #0]
 819              		.loc 1 668 0
 820 0630 24319FE5 		beq	.L159
 821 0634 0020A0E3 	.LVL71:
 822              	.L157:
 823 0638 060057E1 		.loc 1 676 0
 824              		ldr	r4, .L188+16
 825 063c 0020C3E5 	.LVL72:
 826              		ldr	r3, [r4, #12]
 827 0640 4100000A 		orr	r3, r3, #128
 828              		.loc 1 679 0
 829              		mov	r1, r5
 830              		mov	r0, #24
 831 0644 1C419FE5 		.loc 1 676 0
 832              		str	r3, [r4, #12]
 833 0648 0C3094E5 		.loc 1 679 0
 834 064c 803083E3 		bl	sd_raw_send_command_r1
 835              		cmp	r0, #0
 836 0650 0510A0E1 		bne	.L175
 837 0654 1800A0E3 	.LBB40:
 838              	.LBB41:
 839 0658 0C3084E5 		.loc 1 296 0
 840              		ldr	r3, .L188+20
 841 065c 81FEFFEB 		mov	r2, #254
 842 0660 000050E3 		str	r2, [r3, #8]
 843 0664 3300001A 	.L163:
 844              		.loc 1 298 0
 845              		ldr	r3, .L188+20
 846              		ldr	r3, [r3, #4]
 847 0668 FC309FE5 		tst	r3, #128
 848 066c FE20A0E3 		beq	.L163
 849 0670 082083E5 		ldr	r1, .L188+24
 850              	.L165:
 851              	.LBE41:
 852 0674 F0309FE5 	.LBE40:
 853 0678 043093E5 	.LBB42:
 854 067c 800013E3 	.LBB43:
 855 0680 FBFFFF0A 		.loc 1 296 0
 856 0684 E4109FE5 		ldrb	r2, [r1, #-1]	@ zero_extendqisi2
 857              		ldr	r3, .L188+20
 858              		str	r2, [r3, #8]
 859              	.L166:
 860              		.loc 1 298 0
 861              		ldr	r2, .L188+20
 862              		ldr	r3, [r2, #4]
 863 0688 012051E5 		tst	r3, #128
 864 068c D8309FE5 		beq	.L166
 865 0690 082083E5 	.LBE43:
 866              	.LBE42:
 867              		.loc 1 691 0
 868 0694 D0209FE5 		ldr	r3, .L188+28
 869 0698 043092E5 	.LBB44:
 870 069c 800013E3 	.LBB45:
 871 06a0 FBFFFF0A 		.loc 1 298 0
 872              		add	r1, r1, #1
 873              	.LBE45:
 874              	.LBE44:
 875 06a4 C8309FE5 		.loc 1 691 0
 876              		cmp	r1, r3
 877              		bne	.L165
 878              	.LBB46:
 879 06a8 011081E2 	.LBB47:
 880              		.loc 1 296 0
 881              		mov	r3, #255
 882              		str	r3, [r2, #8]
 883 06ac 030051E1 	.L169:
 884 06b0 F4FFFF1A 		.loc 1 298 0
 885              		ldr	r2, .L188+20
 886              		ldr	r3, [r2, #4]
 887              		tst	r3, #128
 888 06b4 FF30A0E3 		beq	.L169
 889 06b8 083082E5 	.LBE47:
 890              	.LBE46:
 891              	.LBB48:
 892 06bc A8209FE5 	.LBB49:
 893 06c0 043092E5 		.loc 1 296 0
 894 06c4 800013E3 		mov	r3, #255
 895 06c8 FBFFFF0A 		str	r3, [r2, #8]
 896              	.L171:
 897              		.loc 1 298 0
 898              		ldr	r3, .L188+20
 899              		ldr	r3, [r3, #4]
 900              		tst	r3, #128
 901 06cc FF30A0E3 		beq	.L171
 902 06d0 083082E5 	.L176:
 903              	.LBE49:
 904              	.LBE48:
 905 06d4 90309FE5 		.loc 1 699 0
 906 06d8 043093E5 		bl	sd_raw_rec_byte
 907 06dc 800013E3 		cmp	r0, #255
 908 06e0 FBFFFF0A 		bne	.L176
 909              		.loc 1 700 0
 910              		bl	sd_raw_rec_byte
 911              		.loc 1 703 0
 912              		ldr	r2, .L188+16
 913 06e4 54FEFFEB 		ldr	r3, [r2, #4]
 914 06e8 FF0050E3 		orr	r3, r3, #128
 915 06ec FCFFFF1A 		str	r3, [r2, #4]
 916              		.loc 1 709 0
 917 06f0 51FEFFEB 		ldr	r3, .L188+4
 918              		.loc 1 705 0
 919 06f4 6C209FE5 		rsb	r1, r6, r7
 920 06f8 043092E5 		.loc 1 709 0
 921 06fc 803083E3 		mov	r2, #1
 922 0700 043082E5 		.loc 1 705 0
 923              		mov	r1, r1, asl #16
 924 0704 50309FE5 		.loc 1 709 0
 925              		strb	r2, [r3, #0]
 926 0708 071066E0 		.loc 1 706 0
 927              		add	sl, sl, r6
 928 070c 0120A0E3 		.loc 1 673 0
 929              		add	r8, r8, r6
 930 0710 0118A0E1 		.loc 1 705 0
 931              		mov	r7, r1, lsr #16
 932 0714 0020C3E5 	.LVL73:
 933              	.L148:
 934 0718 06A08AE0 	.LBE39:
 935              		.loc 1 631 0
 936 071c 068088E0 		cmp	r7, #0
 937              		bne	.L149
 938 0720 2178A0E1 		b	.L159
 939              	.LVL74:
 940              	.L154:
 941              		mov	r0, #0
 942              		b	.L162
 943 0724 000057E3 	.LVL75:
 944 0728 93FFFF1A 	.L175:
 945 072c 060000EA 	.LBB50:
 946              		.loc 1 681 0
 947              		ldr	r3, [r4, #4]
 948 0730 0000A0E3 		mov	r0, #0
 949 0734 050000EA 		orr	r3, r3, #128
 950              		str	r3, [r4, #4]
 951              		b	.L162
 952              	.LVL76:
 953              	.L159:
 954 0738 043094E5 	.LBE50:
 955 073c 0000A0E3 		.loc 1 631 0
 956 0740 803083E3 		mov	r0, #1
 957 0744 043084E5 	.L162:
 958 0748 000000EA 		.loc 1 717 0
 959              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 960              		bx	lr
 961              	.L189:
 962              		.align	2
 963 074c 0100A0E3 	.L188:
 964              		.word	raw_block_address
 965              		.word	raw_block_written
 966 0750 F047BDE8 		.word	raw_block
 967 0754 1EFF2FE1 		.word	511
 968              		.word	-536707072
 969              		.word	-536739840
 970              		.word	raw_block+1
 971 0758 00020000 		.word	raw_block+513
 972 075c 04020000 	.LFE10:
 974 0764 FF010000 		.align	2
 975 0768 008002E0 		.global	sd_raw_sync
 977 0770 01000000 	sd_raw_sync:
 978 0774 01020000 	.LFB11:
 979              		.loc 1 732 0
 980              		@ Function supports interworking.
 981              		@ args = 0, pretend = 0, frame = 0
 982              		@ frame_needed = 0, uses_anonymous_args = 0
 983              		str	lr, [sp, #-4]!
 984              	.LCFI4:
 985              		.loc 1 735 0
 986              		ldr	r3, .L195
 987              		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 988              		cmp	r3, #0
 989              		.loc 1 737 0
 990 0778 04E02DE5 		ldr	r1, .L195+4
 991              		mov	r2, #512
 992              		.loc 1 735 0
 993 077c 30309FE5 		mov	r0, #1
 994 0780 0030D3E5 		bne	.L193
 995 0784 000053E3 		.loc 1 737 0
 996              		ldr	r3, .L195+8
 997 0788 28109FE5 		ldr	r0, [r3, #0]
 998 078c 022CA0E3 		bl	sd_raw_write
 999              		subs	r0, r0, #0
 1000 0790 0100A0E3 		movne	r0, #1
 1001 0794 0400001A 	.L193:
 1002              		.loc 1 744 0
 1003 0798 1C309FE5 		ldr	lr, [sp], #4
 1004 079c 000093E5 		bx	lr
 1005 07a0 FEFFFFEB 	.L196:
 1006 07a4 000050E2 		.align	2
 1007 07a8 0100A013 	.L195:
 1008              		.word	raw_block_written
 1009              		.word	raw_block
 1010 07ac 04E09DE4 		.word	raw_block_address
 1011 07b0 1EFF2FE1 	.LFE11:
 1013              		.align	2
 1014              		.global	sd_raw_read_interval
 1016 07b8 00000000 	sd_raw_read_interval:
 1017 07bc 00020000 	.LFB9:
 1018              		.loc 1 512 0
 1019              		@ Function supports interworking.
 1020              		@ args = 8, pretend = 0, frame = 0
 1021              		@ frame_needed = 0, uses_anonymous_args = 0
 1022              	.LVL77:
 1023              		mov	r2, r2, asl #16
 1024              	.LVL78:
 1025              		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1026              	.LCFI5:
 1027              		.loc 1 512 0
 1028              		mov	r3, r3, asl #16
 1029              	.LVL79:
 1030 07c0 0228A0E1 		.loc 1 513 0
 1031              		cmp	r2, #0
 1032 07c4 F0452DE9 		cmpne	r1, #0
 1033              		mov	r7, r1
 1034              		.loc 1 512 0
 1035 07c8 0338A0E1 		mov	r6, r0
 1036              		mov	r5, r3, lsr #16
 1037              	.LVL80:
 1038 07cc 000052E3 		add	r8, sp, #28
 1039 07d0 00005113 		ldmia	r8, {r8, sl}	@ phole ldm
 1040 07d4 0170A0E1 		.loc 1 513 0
 1041              		mov	r4, r2, lsr #16
 1042 07d8 0060A0E1 	.LVL81:
 1043 07dc 2358A0E1 		beq	.L198
 1044              	.LVL82:
 1045 07e0 1C808DE2 		rsbs	r3, r8, #1
 1046 07e4 000598E8 		movcc	r3, #0
 1047              		cmp	r5, r4
 1048 07e8 2248A0E1 		orrcc	r3, r3, #1
 1049              		cmp	r3, #0
 1050 07ec 1A00000A 		beq	.L207
 1051              		b	.L198
 1052 07f0 013078E2 	.LVL83:
 1053 07f4 0030A033 	.L201:
 1054 07f8 040055E1 		.loc 1 522 0
 1055 07fc 01308333 		bl	sd_raw_read
 1056 0800 000053E3 	.LVL84:
 1057 0804 0E00000A 		cmp	r0, #0
 1058 0808 130000EA 		.loc 1 524 0
 1059              		mov	r1, r6
 1060              		mov	r2, sl
 1061              		mov	r0, r7
 1062 080c FEFFFFEB 		.loc 1 525 0
 1063              		add	r6, r6, r4
 1064 0810 000050E3 		.loc 1 522 0
 1065              		beq	.L198
 1066 0814 0610A0E1 	.LVL85:
 1067 0818 0A20A0E1 		.loc 1 524 0
 1068 081c 0700A0E1 		mov	lr, pc
 1069              		bx	r8
 1070 0820 046086E0 	.LVL86:
 1071              		cmp	r0, #0
 1072 0824 0C00000A 		beq	.L203
 1073              		.loc 1 527 0
 1074              		rsb	r3, r4, r5
 1075 0828 0FE0A0E1 		mov	r3, r3, asl #16
 1076 082c 18FF2FE1 		mov	r5, r3, lsr #16
 1077              	.LVL87:
 1078 0830 000050E3 	.L207:
 1079 0834 0A00000A 		.loc 1 517 0
 1080              		cmp	r5, r4
 1081 0838 053064E0 		.loc 1 522 0
 1082 083c 0338A0E1 		mov	r0, r6
 1083 0840 2358A0E1 		mov	r1, r7
 1084              		mov	r2, r4
 1085              		.loc 1 517 0
 1086              		bcs	.L201
 1087 0844 040055E1 	.LVL88:
 1088              		b	.L203
 1089 0848 0600A0E1 	.LVL89:
 1090 084c 0710A0E1 	.L198:
 1091 0850 0420A0E1 		mov	r0, #0
 1092              		b	.L205
 1093 0854 ECFFFF2A 	.LVL90:
 1094              	.L203:
 1095 0858 010000EA 		mov	r0, #1
 1096              	.LVL91:
 1097              	.L205:
 1098 085c 0000A0E3 		.loc 1 605 0
 1099 0860 000000EA 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1100              		bx	lr
 1101              	.LFE9:
 1103              		.section	.rodata.str1.4,"aMS",%progbits,1
 1104              		.align	2
 1105              	.LC0:
 1106 0868 F045BDE8 		.ascii	"SD RAW NOT AVAILABLE\012\015\000"
 1107 086c 1EFF2FE1 		.align	2
 1108              	.LC1:
 1109              		.ascii	"i=%d, response=%d\012\015\000"
 1110              		.align	2
 1111              	.LC2:
 1112              		.ascii	"\012\015response: %d\012\015\000"
 1113 0000 53442052 		.align	2
 1113      4157204E 
 1113      4F542041 
 1113      5641494C 
 1113      41424C45 
 1114 0017 00       	.LC3:
 1115              		.ascii	"i = 0x7fff\012\015\000"
 1116 0018 693D2564 		.align	2
 1116      2C207265 
 1116      73706F6E 
 1116      73653D25 
 1116      640A0D00 
 1117              	.LC4:
 1118              		.ascii	"BLOCK SIZE SET ERR \012\015\000"
 1119 002c 0A0D7265 		.align	2
 1119      73706F6E 
 1119      73653A20 
 1119      25640A0D 
 1119      00
 1120 003d 000000   	.LC5:
 1121              		.ascii	"sd_raw_read borks\012\015\000"
 1122 0040 69203D20 		.text
 1122      30783766 
 1122      66660A0D 
 1122      00
 1123 004d 000000   		.align	2
 1124              		.global	sd_raw_init
 1126 0066 0000     	sd_raw_init:
 1127              	.LFB2:
 1128 0068 73645F72 		.loc 1 160 0
 1128      61775F72 
 1128      65616420 
 1128      626F726B 
 1128      730A0D00 
 1129              		@ Function supports interworking.
 1130              		@ args = 0, pretend = 0, frame = 0
 1131              		@ frame_needed = 0, uses_anonymous_args = 0
 1132              		stmfd	sp!, {r4, r5, lr}
 1133              	.LCFI6:
 1134              		.loc 1 166 0
 1135              		ldr	r4, .L235
 1136              		ldr	r3, [r4, #8]
 1137              		orr	r3, r3, #128
 1138              		str	r3, [r4, #8]
 1139 0870 30402DE9 		.loc 1 167 0
 1140              		ldr	r2, .L235+4
 1141              		ldr	r3, [r2, #0]
 1142 0874 E4419FE5 		orr	r3, r3, #4096
 1143 0878 083094E5 		str	r3, [r2, #0]
 1144 087c 803083E3 		.loc 1 168 0
 1145 0880 083084E5 		ldr	r3, [r2, #0]
 1146              		orr	r3, r3, #1024
 1147 0884 D8219FE5 		str	r3, [r2, #0]
 1148 0888 003092E5 		.loc 1 169 0
 1149 088c 013A83E3 		ldr	r3, [r2, #0]
 1150 0890 003082E5 		orr	r3, r3, #256
 1151              		str	r3, [r2, #0]
 1152 0894 003092E5 		.loc 1 171 0
 1153 0898 013B83E3 		ldr	r3, [r4, #4]
 1154 089c 003082E5 		orr	r3, r3, #128
 1155              		str	r3, [r4, #4]
 1156 08a0 003092E5 		.loc 1 174 0
 1157 08a4 013C83E3 		sub	r2, r2, #49152
 1158 08a8 003082E5 		mov	r3, #150
 1159              		str	r3, [r2, #12]
 1160 08ac 043094E5 		.loc 1 175 0
 1161 08b0 803083E3 		mov	r3, #56
 1162 08b4 043084E5 		str	r3, [r2, #0]
 1163              		.loc 1 180 0
 1164 08b8 032942E2 		bl	sd_raw_available
 1165 08bc 9630A0E3 		subs	r5, r0, #0
 1166 08c0 0C3082E5 		bne	.L209
 1167              		.loc 1 182 0
 1168 08c4 3830A0E3 		ldr	r0, .L235+8
 1169 08c8 003082E5 		bl	rprintf
 1170              		b	.L233
 1171 08cc FEFFFFEB 	.L209:
 1172 08d0 005050E2 		.loc 1 185 0
 1173 08d4 0200001A 		ldr	r3, [r4, #8]
 1174              		orr	r3, r3, #128
 1175 08d8 88019FE5 		str	r3, [r4, #8]
 1176 08dc FEFFFFEB 		.loc 1 186 0
 1177 08e0 4F0000EA 		ldr	r3, [r4, #4]
 1178              		orr	r3, r3, #128
 1179              		str	r3, [r4, #4]
 1180 08e4 083094E5 		mov	r4, #0
 1181 08e8 803083E3 	.LVL92:
 1182 08ec 083084E5 	.L212:
 1183              		.loc 1 193 0
 1184 08f0 043094E5 		bl	sd_raw_rec_byte
 1185 08f4 803083E3 		.loc 1 190 0
 1186 08f8 043084E5 		add	r3, r4, #1
 1187 08fc 0040A0E3 		mov	r3, r3, asl #16
 1188              		mov	r4, r3, lsr #16
 1189              		cmp	r4, #10
 1190              		bne	.L212
 1191 0900 CDFDFFEB 		.loc 1 197 0
 1192              		ldr	r2, .L235
 1193 0904 013084E2 		ldr	r3, [r2, #12]
 1194 0908 0338A0E1 		orr	r3, r3, #128
 1195 090c 2348A0E1 		str	r3, [r2, #12]
 1196 0910 0A0054E3 		mov	r5, #0
 1197 0914 F9FFFF1A 	.L214:
 1198              		.loc 1 203 0
 1199 0918 40219FE5 		mov	r0, #0
 1200 091c 0C3092E5 		mov	r1, r0
 1201 0920 803083E3 		bl	sd_raw_send_command_r1
 1202 0924 0C3082E5 		mov	r4, r0
 1203 0928 0050A0E3 	.LVL93:
 1204              		.loc 1 204 0
 1205              		mov	r1, r5
 1206 092c 0000A0E3 		ldr	r0, .L235+12
 1207 0930 0010A0E1 		mov	r2, r4
 1208 0934 CBFDFFEB 		bl	rprintf
 1209 0938 0040A0E1 		.loc 1 205 0
 1210              		cmp	r4, #1
 1211              		.loc 1 206 0
 1212 093c 0510A0E1 		add	r5, r5, #1
 1213 0940 24019FE5 		.loc 1 205 0
 1214 0944 0420A0E1 		beq	.L215
 1215 0948 FEFFFFEB 		.loc 1 207 0
 1216              		cmp	r5, #512
 1217 094c 010054E3 		bne	.L214
 1218              		.loc 1 209 0
 1219 0950 015085E2 		ldr	r0, .L235+16
 1220              		mov	r1, r4
 1221 0954 0A00000A 		bl	rprintf
 1222              		.loc 1 210 0
 1223 0958 020C55E3 		ldr	r2, .L235
 1224 095c F2FFFF1A 		ldr	r3, [r2, #4]
 1225              		mov	r0, #0
 1226 0960 08019FE5 		orr	r3, r3, #128
 1227 0964 0410A0E1 		str	r3, [r2, #4]
 1228 0968 FEFFFFEB 		b	.L211
 1229              	.L215:
 1230 096c EC209FE5 		.loc 1 211 0
 1231 0970 043092E5 		mov	r4, #0
 1232 0974 0000A0E3 	.LVL94:
 1233 0978 803083E3 	.L218:
 1234 097c 043082E5 		.loc 1 218 0
 1235 0980 340000EA 		mov	r1, #0
 1236              		mov	r0, #1
 1237              		bl	sd_raw_send_command_r1
 1238 0984 0040A0E3 		.loc 1 216 0
 1239              		add	r3, r4, #1
 1240              		.loc 1 219 0
 1241              		tst	r0, #1
 1242 0988 0010A0E3 		.loc 1 216 0
 1243 098c 0100A0E3 		mov	r2, r3, asl #16
 1244 0990 B4FDFFEB 		.loc 1 219 0
 1245              		beq	.L219
 1246 0994 013084E2 		.loc 1 222 0
 1247              		ldr	r3, .L235+20
 1248 0998 010010E3 		cmp	r4, r3
 1249              		.loc 1 216 0
 1250 099c 0328A0E1 		mov	r4, r2, lsr #16
 1251              		.loc 1 222 0
 1252 09a0 0400000A 		beq	.L228
 1253              		b	.L218
 1254 09a4 C8309FE5 	.L219:
 1255 09a8 030054E1 		.loc 1 231 0
 1256              		mov	r0, #16
 1257 09ac 2248A0E1 		mov	r1, #512
 1258              		bl	sd_raw_send_command_r1
 1259 09b0 1D00000A 		cmp	r0, #0
 1260 09b4 F3FFFFEA 		.loc 1 233 0
 1261              		ldrne	r2, .L235
 1262              		ldrne	r3, [r2, #4]
 1263 09b8 1000A0E3 		.loc 1 234 0
 1264 09bc 021CA0E3 		ldrne	r0, .L235+24
 1265 09c0 A8FDFFEB 		.loc 1 233 0
 1266 09c4 000050E3 		orrne	r3, r3, #128
 1267              		bne	.L234
 1268 09c8 90209F15 	.L223:
 1269 09cc 04309215 		.loc 1 239 0
 1270              		ldr	ip, .L235
 1271 09d0 A0009F15 		ldr	r3, [ip, #4]
 1272              		orr	r3, r3, #128
 1273 09d4 80308313 		str	r3, [ip, #4]
 1274 09d8 1700001A 		.loc 1 246 0
 1275              		ldr	r3, .L235+28
 1276              		mvn	ip, #0
 1277 09dc 7CC09FE5 		str	ip, [r3, #0]
 1278 09e0 04309CE5 		.loc 1 242 0
 1279 09e4 803083E3 		ldr	r3, .L235+32
 1280 09e8 04308CE5 		add	ip, ip, #61
 1281              		str	ip, [r3, #12]
 1282 09ec 88309FE5 		.loc 1 248 0
 1283 09f0 00C0E0E3 		ldr	r3, .L235+36
 1284 09f4 00C083E5 		mov	r5, #1
 1285              		.loc 1 250 0
 1286 09f8 80309FE5 		ldr	r1, .L235+40
 1287 09fc 3DC08CE2 		mov	r2, #512
 1288 0a00 0CC083E5 		.loc 1 248 0
 1289              		strb	r5, [r3, #0]
 1290 0a04 78309FE5 		.loc 1 250 0
 1291 0a08 0150A0E3 		bl	sd_raw_read
 1292              		subs	r4, r0, #0
 1293 0a0c 74109FE5 	.LVL95:
 1294 0a10 022CA0E3 		beq	.L225
 1295              	.L233:
 1296 0a14 0050C3E5 		mov	r0, r5
 1297              		b	.L211
 1298 0a18 FEFFFFEB 	.LVL96:
 1299 0a1c 004050E2 	.L228:
 1300              		.loc 1 224 0
 1301 0a20 0900000A 		ldr	r2, .L235
 1302              		ldr	r3, [r2, #4]
 1303 0a24 0500A0E1 		.loc 1 225 0
 1304 0a28 0A0000EA 		ldr	r0, .L235+44
 1305              		.loc 1 224 0
 1306              		orr	r3, r3, #128
 1307              	.L234:
 1308 0a2c 2C209FE5 		str	r3, [r2, #4]
 1309 0a30 043092E5 		.loc 1 225 0
 1310              		bl	rprintf
 1311 0a34 50009FE5 		mov	r0, #0
 1312              		b	.L211
 1313 0a38 803083E3 	.LVL97:
 1314              	.L225:
 1315 0a3c 043082E5 		.loc 1 252 0
 1316              		ldr	r0, .L235+48
 1317 0a40 FEFFFFEB 		bl	rprintf
 1318 0a44 0000A0E3 		mov	r0, r4
 1319 0a48 020000EA 	.LVL98:
 1320              	.L211:
 1321              		.loc 1 258 0
 1322              		ldmfd	sp!, {r4, r5, lr}
 1323 0a4c 3C009FE5 		bx	lr
 1324 0a50 FEFFFFEB 	.L236:
 1325 0a54 0400A0E1 		.align	2
 1326              	.L235:
 1327              		.word	-536707072
 1328              		.word	-536690688
 1329 0a58 3040BDE8 		.word	.LC0
 1330 0a5c 1EFF2FE1 		.word	.LC1
 1331              		.word	.LC2
 1332              		.word	32767
 1333              		.word	.LC4
 1334 0a60 008002E0 		.word	raw_block_address
 1335 0a64 00C002E0 		.word	-536739840
 1336 0a68 00000000 		.word	raw_block_written
 1337 0a6c 18000000 		.word	raw_block
 1338 0a70 2C000000 		.word	.LC3
 1339 0a74 FF7F0000 		.word	.LC5
 1340 0a78 50000000 	.LFE2:
 1342 0a80 000002E0 		.align	2
 1343 0a84 04020000 		.global	format_card
 1345 0a8c 40000000 	format_card:
 1346 0a90 68000000 	.LFB14:
 1347              		.loc 1 884 0
 1348              		@ Function supports interworking.
 1349              		@ args = 0, pretend = 0, frame = 512
 1350              		@ frame_needed = 0, uses_anonymous_args = 0
 1351              	.LVL99:
 1352              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1353              	.LCFI7:
 878:../lib/sd_raw.c ****  pass this fuction 0xAA to get it to work (safety check)
 879:../lib/sd_raw.c **** char format_card(char make_sure)
 880:../lib/sd_raw.c **** {
 881:../lib/sd_raw.c **** 	#define MBR_LOCATION	0x00
 882:../lib/sd_raw.c **** 	#define BR_LOCATION		(MBR_LOCATION+0x80000)
 883:../lib/sd_raw.c **** 	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
 884:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 1354              		.loc 1 898 0
 1355              		bl	sd_raw_init
 1356              		.loc 1 901 0
 1357              		bl	sd_raw_sync
 1358              		.loc 1 902 0
 1359 0a94 F0472DE9 		mov	r2, r4
 1360              		mov	r1, sp
 1361 0a98 FF0000E2 		mov	r0, r6
 885:../lib/sd_raw.c **** 0x200 * 512))
 886:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 887:../lib/sd_raw.c **** 
 888:../lib/sd_raw.c **** 	//Safety check
 889:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 890:../lib/sd_raw.c **** 	
 891:../lib/sd_raw.c **** 	int i;
 1362              	aw_write
 1363 0a9c AA0050E3 		.loc 1 905 0
 1364              		bl	sd_raw_sync
 1365 0aa0 02DC4DE2 		.loc 1 906 0
 1366              		mov	r2, r4
 1367              		mov	r1, sp
 1368 0aa4 0000A013 		mov	r0, #524288
 1369              		bl	sd_raw_write
 1370 0aa8 6D00001A 		mov	r4, #786432
 1371 0aac 0040A0E3 	.LVL102:
 1372              	.L243:
 1373              		.loc 1 911 0
 892:../lib/sd_raw.c **** 0x00F5 * 2 * 512))
 893:../lib/sd_raw.c **** 
 894:../lib/sd_raw.c **** 	//Safety check
 895:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 1374              	ync
 1375 0ab0 0060A0E3 		.loc 1 912 0
 1376 0ab4 0D60C4E7 		mov	r0, r4
 1377 0ab8 014084E2 		mov	r1, sp
 1378 0abc 020C54E3 		mov	r2, #512
 1379 0ac0 FAFFFF1A 		bl	sd_raw_write
 896:../lib/sd_raw.c **** 0 * 512) + (0x00F5 * 2 * 512))
 897:../lib/sd_raw.c **** 
 898:../lib/sd_raw.c **** 	//Safety check
 1380              	1 909 0
 1381 0ac4 FEFFFFEB 		ldr	r3, .L250
 899:../lib/sd_raw.c **** ine ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 900:../lib/sd_raw.c **** 
 901:../lib/sd_raw.c **** 	//Safety check
 1382              	loc 1 912 0
 1383 0ac8 FEFFFFEB 		add	r4, r4, #512
 902:../lib/sd_raw.c **** ine ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 1384              	loc 1 909 0
 1385 0acc 0420A0E1 		cmp	r4, r3
 1386 0ad0 0D10A0E1 		.loc 1 912 0
 1387 0ad4 0600A0E1 		mov	r9, sp
 1388 0ad8 FEFFFFEB 		.loc 1 909 0
 903:../lib/sd_raw.c **** 0x200 * 512))
 904:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 905:../lib/sd_raw.c **** 
 1389              	.L243
 1390 0adc FEFFFFEB 		.loc 1 921 0
 906:../lib/sd_raw.c **** 200 * 512))
 1391              	ov	r3, #6
 1392 0ae0 0420A0E1 		strb	r3, [sp, #450]
 1393 0ae4 0D10A0E1 		.loc 1 922 0
 1394 0ae8 0207A0E3 		add	r3, r3, #25
 1395 0aec FEFFFFEB 		strb	r3, [sp, #451]
 1396 0af0 0347A0E3 		.loc 1 923 0
 1397              		mvn	r3, #31
 1398              		.loc 1 917 0
 907:../lib/sd_raw.c **** BR_LOCATION		(MBR_LOCATION+0x80000)
 908:../lib/sd_raw.c **** 	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
 909:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 910:../lib/sd_raw.c **** 
 911:../lib/sd_raw.c **** 	//Safety check
 1399              	 #0
 1400 0af4 FEFFFFEB 		.loc 1 919 0
 912:../lib/sd_raw.c **** ine ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 1401              	ov	r2, #1
 1402 0af8 0400A0E1 		.loc 1 932 0
 1403 0afc 0D10A0E1 		mov	r5, #85
 1404 0b00 022CA0E3 		.loc 1 926 0
 1405 0b04 FEFFFFEB 		mov	r6, #4
 1406              		.loc 1 930 0
 1407 0b08 60319FE5 		mov	r7, #76
 1408              		.loc 1 931 0
 1409 0b0c 024C84E2 		mov	r8, #15
 1410              		.loc 1 933 0
 1411 0b10 030054E1 		mvn	sl, #85
 1412              		.loc 1 923 0
 1413 0b14 0D90A0E1 		strb	r3, [sp, #452]
 1414              		.loc 1 924 0
 1415 0b18 F5FFFF1A 		mvn	r3, #44
 913:../lib/sd_raw.c **** 0x200 * 512))
 914:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 915:../lib/sd_raw.c **** 
 916:../lib/sd_raw.c **** 	//Safety check
 917:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 918:../lib/sd_raw.c **** 	
 919:../lib/sd_raw.c **** 	int i;
 920:../lib/sd_raw.c **** 	unsigned char my_buff[512];
 921:../lib/sd_raw.c **** 	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
 1416              	#453]
 1417 0b1c 0630A0E3 		.loc 1 920 0
 1418 0b20 C231CDE5 		strb	r2, [sp, #449]
 922:../lib/sd_raw.c **** ;
 1419              	oc 1 919 0
 1420 0b24 193083E2 		strb	r2, [sp, #448]
 1421 0b28 C331CDE5 		.loc 1 917 0
 923:../lib/sd_raw.c **** 0x00F5 * 2 * 512))
 1422              	rb	r4, [sp, #446]
 1423 0b2c 1F30E0E3 		.loc 1 918 0
 1424              		strb	r4, [sp, #447]
 1425 0b30 0040A0E3 		.loc 1 925 0
 1426              		strb	r4, [sp, #454]
 1427 0b34 0120A0E3 		.loc 1 926 0
 924:../lib/sd_raw.c **** 0x200 * 512))
 925:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 926:../lib/sd_raw.c **** 
 927:../lib/sd_raw.c **** 	//Safety check
 928:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 929:../lib/sd_raw.c **** 	
 930:../lib/sd_raw.c **** 	int i;
 931:../lib/sd_raw.c **** 	unsigned char my_buff[512];
 932:../lib/sd_raw.c **** 	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
 1428              	r6, [sp, #455]
 1429 0b38 5550A0E3 		.loc 1 927 0
 1430              		strb	r4, [sp, #456]
 1431 0b3c 0460A0E3 		.loc 1 928 0
 1432              		strb	r4, [sp, #457]
 1433 0b40 4C70A0E3 		.loc 1 929 0
 1434              		strb	r4, [sp, #458]
 1435 0b44 0F80A0E3 		.loc 1 930 0
 933:../lib/sd_raw.c **** ;
 1436              	, [sp, #459]
 1437 0b48 55A0E0E3 		.loc 1 931 0
 1438              		strb	r8, [sp, #460]
 1439 0b4c C431CDE5 		.loc 1 932 0
 1440              		strb	r5, [sp, #510]
 1441 0b50 2C30E0E3 		.loc 1 933 0
 1442 0b54 C531CDE5 		strb	sl, [sp, #511]
 1443              		.loc 1 935 0
 1444 0b58 C121CDE5 		bl	sd_raw_sync
 1445              		.loc 1 936 0
 1446 0b5c C021CDE5 		mov	r1, sp
 1447              		mov	r2, #512
 1448 0b60 BE41CDE5 		mov	r0, r4
 1449              		bl	sd_raw_write
 1450 0b64 BF41CDE5 		.loc 1 937 0
 1451              		bl	sd_raw_sync
 1452 0b68 C641CDE5 		.loc 1 941 0
 1453              		mvn	r3, #20
 1454 0b6c C761CDE5 		strb	r3, [sp, #0]
 1455              		.loc 1 942 0
 1456 0b70 C841CDE5 		add	r3, r3, #19
 1457              		strb	r3, [sp, #1]
 1458 0b74 C941CDE5 		.loc 1 943 0
 1459              		mvn	r3, #111
 1460 0b78 CA41CDE5 		strb	r3, [sp, #2]
 1461              		.loc 1 945 0
 1462 0b7c CB71CDE5 		add	r3, r3, #128
 1463              		strb	r3, [sp, #13]
 1464 0b80 CC81CDE5 		.loc 1 946 0
 1465              		add	r3, r3, #6
 1466 0b84 FE51CDE5 		strb	r3, [sp, #14]
 1467              		.loc 1 949 0
 1468 0b88 FFA1CDE5 		mvn	r3, #7
 934:../lib/sd_raw.c **** 0x00F5 * 2 * 512))
 935:../lib/sd_raw.c **** 
 1469              	
 1470 0b8c FEFFFFEB 		mvn	r3, #10
 936:../lib/sd_raw.c **** 200 * 512))
 1471              	strb	r3, [sp, #22]
 1472 0b90 0D10A0E1 		.loc 1 956 0
 1473 0b94 022CA0E3 		add	r3, r3, #52
 1474 0b98 0400A0E1 		strb	r3, [sp, #38]
 1475 0b9c FEFFFFEB 		.loc 1 957 0
 937:../lib/sd_raw.c **** BR_LOCATION		(MBR_LOCATION+0x80000)
 1476              	r3, r3, #29
 1477 0ba0 FEFFFFEB 		strb	r3, [sp, #54]
 938:../lib/sd_raw.c **** r make_sure)
 939:../lib/sd_raw.c **** {
 940:../lib/sd_raw.c **** 	#define MBR_LOCATION	0x00
 941:../lib/sd_raw.c **** 	#define BR_LOCATION		(MBR_LOCATION+0x80000)
 1478              	loc 1 958 0
 1479 0ba4 1430E0E3 		mov	r3, #65
 1480 0ba8 0030CDE5 		strb	r3, [sp, #55]
 942:../lib/sd_raw.c **** r make_sure)
 1481              	oc 1 959 0
 1482 0bac 133083E2 		add	r3, r3, #19
 1483 0bb0 0130CDE5 		strb	r3, [sp, #56]
 943:../lib/sd_raw.c ****  pass this fuction 0xAA to get it to work (safety check)
 1484              	oc 1 960 0
 1485 0bb4 6F30E0E3 		mov	r3, #49
 1486 0bb8 0230CDE5 		.loc 1 951 0
 944:../lib/sd_raw.c **** //Assumes *many* things
 945:../lib/sd_raw.c **** //You must pass this fuction 0xAA to get it to work (safety check)
 1487              	v	r2, #32
 1488 0bbc 803083E2 		.loc 1 944 0
 1489 0bc0 0D30CDE5 		mov	r1, #2
 946:../lib/sd_raw.c **** //Assumes *many* things
 1490              	oc 1 960 0
 1491 0bc4 063083E2 		strb	r3, [sp, #57]
 1492 0bc8 0E30CDE5 		.loc 1 961 0
 947:../lib/sd_raw.c ****  &= ~(0x1500);
 948:../lib/sd_raw.c **** }
 949:../lib/sd_raw.c **** 
 1493              	d	r3, r3, #5
 1494 0bcc 0730E0E3 		strb	r3, [sp, #58]
 1495 0bd0 1530CDE5 		.loc 1 948 0
 950:../lib/sd_raw.c **** card();
 1496              	rb	r1, [sp, #18]
 1497 0bd4 0A30E0E3 		.loc 1 964 0
 1498 0bd8 1630CDE5 		strb	r2, [sp, #61]
 951:../lib/sd_raw.c ****             info->format = (b & 0x0c) >> 2;
 952:../lib/sd_raw.c ****                 break;
 953:../lib/sd_raw.c ****         }
 954:../lib/sd_raw.c ****     }
 955:../lib/sd_raw.c **** 
 956:../lib/sd_raw.c ****     unselect_card();
 1499              	oc 1 944 0
 1500 0bdc 343083E2 		strb	r1, [sp, #12]
 1501 0be0 2630CDE5 		.loc 1 947 0
 957:../lib/sd_raw.c ****             info->format = (b & 0x0c) >> 2;
 1502              	rb	r1, [sp, #16]
 1503 0be4 1D3083E2 		.loc 1 951 0
 1504 0be8 3630CDE5 		strb	r2, [sp, #24]
 958:../lib/sd_raw.c ****  0x10)
 1505              	oc 1 952 0
 1506 0bec 4130A0E3 		strb	r2, [sp, #26]
 1507 0bf0 3730CDE5 		.loc 1 962 0
 959:../lib/sd_raw.c ****  1;
 1508              	rb	r2, [sp, #59]
 1509 0bf4 133083E2 		.loc 1 963 0
 1510 0bf8 3830CDE5 		strb	r2, [sp, #60]
 960:../lib/sd_raw.c **** 
 1511              	oc 1 953 0
 1512 0bfc 3130A0E3 		strb	r6, [sp, #29]
 1513              		.loc 1 954 0
 1514 0c00 2020A0E3 		strb	r7, [sp, #33]
 1515              		.loc 1 955 0
 1516 0c04 0210A0E3 		strb	r8, [sp, #34]
 1517              		.loc 1 966 0
 1518 0c08 3930CDE5 		strb	sl, [sp, #511]
 961:../lib/sd_raw.c **** lt |= b >> 7;
 1519              	965 0
 1520 0c0c 053083E2 		strb	r5, [sp, #510]
 1521 0c10 3A30CDE5 		.loc 1 968 0
 1522              		bl	sd_raw_sync
 1523 0c14 1210CDE5 		.loc 1 969 0
 962:../lib/sd_raw.c **** csd_c_size_mult = (b & 0x03) << 1;
 963:../lib/sd_raw.c ****                 break;
 964:../lib/sd_raw.c ****             case 10:
 1524              	r1, sp
 1525 0c18 3D20CDE5 		mov	r2, #512
 1526              		mov	r0, #524288
 1527 0c1c 0C10CDE5 		bl	sd_raw_write
 1528              		.loc 1 970 0
 1529 0c20 1010CDE5 		bl	sd_raw_sync
 1530              		mov	r0, r5
 1531 0c24 1820CDE5 	.L240:
 1532              		.loc 1 973 0
 1533 0c28 1A20CDE5 		add	sp, sp, #512
 1534              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1535 0c2c 3B20CDE5 		bx	lr
 1536              	.L251:
 1537 0c30 3C20CDE5 		.align	2
 1538              	.L250:
 1539 0c34 1D60CDE5 		.word	911872
 1540              	.LFE14:
 1542              		.bss
 1543 0c3c 2280CDE5 	raw_block:
 965:../lib/sd_raw.c ****  break;
 966:../lib/sd_raw.c ****             case 9:
 1544              	2
 1545 0c40 FFA1CDE5 	raw_block_address:
 1546              		.space	4
 1547 0c44 FE51CDE5 	raw_block_written:
 967:../lib/sd_raw.c ****        case 8:
 968:../lib/sd_raw.c ****                 csd_c_size |= b >> 6;
 1548              	ace	1
 1549 0c48 FEFFFFEB 		.section	.debug_frame,"",%progbits
 969:../lib/sd_raw.c **** _c_size |= b;
 1550              	frame0:
 1551 0c4c 0D10A0E1 		.4byte	.LECIE0-.LSCIE0
 1552 0c50 022CA0E3 	.LSCIE0:
 1553 0c54 0207A0E3 		.4byte	0xffffffff
 1554 0c58 FEFFFFEB 		.byte	0x1
 970:../lib/sd_raw.c ****           csd_c_size = (unsigned short) (b & 0x03) << 8;
 1555              	ii	"\000"
 1556 0c5c FEFFFFEB 		.uleb128 0x1
 1557 0c60 0500A0E1 		.sleb128 -4
 1558              		.byte	0xe
 971:../lib/sd_raw.c ****   csd_read_bl_len = b & 0x0f;
 972:../lib/sd_raw.c ****                 break;
 973:../lib/sd_raw.c ****             case 6:
 1559              	te	0xc
 1560 0c64 02DC8DE2 		.uleb128 0xd
 1561 0c68 F047BDE8 		.uleb128 0x0
 1562 0c6c 1EFF2FE1 		.align	2
 1563              	.LECIE0:
 1564              	.LSFDE0:
 1565              		.4byte	.LEFDE0-.LASFDE0
 1566 0c70 00EA0D00 	.LASFDE0:
 1567              		.4byte	.Lframe0
 1568              		.4byte	.LFB3
 1569              		.4byte	.LFE3-.LFB3
 1570              		.align	2
 1571 0000 00000000 	.LEFDE0:
 1571      00000000 
 1571      00000000 
 1571      00000000 
 1571      00000000 
 1572              	.LSFDE2:
 1573              		.4byte	.LEFDE2-.LASFDE2
 1574 0200 00000000 	.LASFDE2:
 1575              		.4byte	.Lframe0
 1576 0204 00       		.4byte	.LFB4
 1814              		.4byte	.LVL1-.Ltext0
DEFINED SYMBOLS
                            *ABS*:00000000 sd_raw.c
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:13     .text:00000000 sd_raw_available
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:22     .text:00000000 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:44     .text:00000030 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:50     .text:00000034 sd_raw_locked
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:58     .text:00000034 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:67     .text:0000003c sd_raw_rec_byte
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:94     .text:00000064 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:99     .text:00000068 sd_raw_send_command_r1
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:106    .text:00000068 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:220    .text:00000144 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:226    .text:00000148 SDoff
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:234    .text:00000148 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:251    .text:0000016c $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:257    .text:00000170 sd_raw_get_info
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:264    .text:00000170 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:318    .text:000001f4 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:336    .text:00000230 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:438    .text:000002fc $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:451    .text:00000324 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:564    .text:00000400 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:570    .text:00000404 sd_raw_read
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:577    .text:00000404 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:729    .text:00000564 sd_raw_write
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:718    .text:0000054c $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1573   .bss:00000200 raw_block_address
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1575   .bss:00000204 raw_block_written
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1570   .bss:00000000 raw_block
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:736    .text:00000564 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:971    .text:00000758 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:984    .text:00000778 sd_raw_sync
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:990    .text:00000778 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1015   .text:000007b4 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1023   .text:000007c0 sd_raw_read_interval
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1030   .text:000007c0 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1133   .text:00000870 sd_raw_init
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1334   .text:00000a60 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1352   .text:00000a94 format_card
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1359   .text:00000a94 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/cckNaaaa.s:1566   .text:00000c70 $d

UNDEFINED SYMBOLS
memset
memcpy
rprintf
