   1              		.file	"fat16.c"
   9              	.Ltext0:
  10              		.align	2
  12              	fat16_dir_entry_seek_callback:
  13              	.LFB7:
  14              		.file 1 "../lib/fat16.c"
   1:../lib/fat16.c **** /* This program is free software; you can redistribute it and/or modify
   2:../lib/fat16.c ****  * it under the terms of the GNU General Public License version 2 as
   3:../lib/fat16.c ****  * published by the Free Software Foundation.
   4:../lib/fat16.c ****  */
   5:../lib/fat16.c **** 
   6:../lib/fat16.c **** #include <stdio.h>
   7:../lib/fat16.c **** 
   8:../lib/fat16.c **** //Debug
   9:../lib/fat16.c **** #include "rprintf.h"
  10:../lib/fat16.c **** 
  11:../lib/fat16.c **** #include "partition.h"
  12:../lib/fat16.c **** #include "fat16.h"
  13:../lib/fat16.c **** #include "fat16_config.h"
  14:../lib/fat16.c **** #include "sd_raw.h"
  15:../lib/fat16.c **** #include <stdlib.h>
  16:../lib/fat16.c **** #include <string.h>
  17:../lib/fat16.c **** 
  18:../lib/fat16.c **** //System level settings and defines
  19:../lib/fat16.c **** //#include "system_settings.h"
  20:../lib/fat16.c **** 
  21:../lib/fat16.c **** /**
  22:../lib/fat16.c ****  * \addtogroup fat16 FAT16 support
  23:../lib/fat16.c ****  *
  24:../lib/fat16.c ****  * This module implements FAT16 read and write access.
  25:../lib/fat16.c ****  *
  26:../lib/fat16.c ****  * The following features are supported:
  27:../lib/fat16.c ****  * - File names up to 31 characters long.
  28:../lib/fat16.c ****  * - Unlimited depth of subdirectories.
  29:../lib/fat16.c ****  * - Short 8.3 and long filenames.
  30:../lib/fat16.c ****  * - Creating and deleting files.
  31:../lib/fat16.c ****  * - Reading and writing from and to files.
  32:../lib/fat16.c ****  * - File resizing.
  33:../lib/fat16.c ****  * - File sizes of up to 4 gigabytes.
  34:../lib/fat16.c ****  *
  35:../lib/fat16.c ****  * @{
  36:../lib/fat16.c ****  */
  37:../lib/fat16.c **** /**
  38:../lib/fat16.c ****  * \file
  39:../lib/fat16.c ****  * FAT16 implementation.
  40:../lib/fat16.c ****  *
  41:../lib/fat16.c ****  * \author Roland Riegel
  42:../lib/fat16.c ****  */
  43:../lib/fat16.c **** 
  44:../lib/fat16.c **** /**
  45:../lib/fat16.c ****  * \addtogroup fat16_config FAT16 configuration
  46:../lib/fat16.c ****  * Preprocessor defines to configure the FAT16 implementation.
  47:../lib/fat16.c ****  */
  48:../lib/fat16.c **** 
  49:../lib/fat16.c **** /**
  50:../lib/fat16.c ****  * \addtogroup fat16_fs FAT16 access
  51:../lib/fat16.c ****  * Basic functions for handling a FAT16 filesystem.
  52:../lib/fat16.c ****  */
  53:../lib/fat16.c **** 
  54:../lib/fat16.c **** /**
  55:../lib/fat16.c ****  * \addtogroup fat16_file FAT16 file functions
  56:../lib/fat16.c ****  * Functions for managing files.
  57:../lib/fat16.c ****  */
  58:../lib/fat16.c **** 
  59:../lib/fat16.c **** /**
  60:../lib/fat16.c ****  * \addtogroup fat16_dir FAT16 directory functions
  61:../lib/fat16.c ****  * Functions for managing directories.
  62:../lib/fat16.c ****  */
  63:../lib/fat16.c **** 
  64:../lib/fat16.c **** /**
  65:../lib/fat16.c ****  * @}
  66:../lib/fat16.c ****  */
  67:../lib/fat16.c **** 
  68:../lib/fat16.c **** #define FAT16_CLUSTER_FREE 0x0000
  69:../lib/fat16.c **** #define FAT16_CLUSTER_RESERVED_MIN (uint16_t)0xfff0
  70:../lib/fat16.c **** #define FAT16_CLUSTER_RESERVED_MAX (uint16_t)0xfff6
  71:../lib/fat16.c **** #define FAT16_CLUSTER_BAD (uint16_t)0xfff7
  72:../lib/fat16.c **** #define FAT16_CLUSTER_LAST_MIN (uint16_t)0xfff8
  73:../lib/fat16.c **** #define FAT16_CLUSTER_LAST_MAX (uint16_t)0xffff
  74:../lib/fat16.c **** 
  75:../lib/fat16.c **** #define FAT16_DIRENTRY_DELETED 0xe5
  76:../lib/fat16.c **** #define FAT16_DIRENTRY_LFNLAST (1 << 6)
  77:../lib/fat16.c **** #define FAT16_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
  78:../lib/fat16.c **** 
  79:../lib/fat16.c **** /* Each entry within the directory table has a size of 32 bytes
  80:../lib/fat16.c ****  * and either contains a 8.3 DOS-style file name or a part of a
  81:../lib/fat16.c ****  * long file name, which may consist of several directory table
  82:../lib/fat16.c ****  * entries at once.
  83:../lib/fat16.c ****  *
  84:../lib/fat16.c ****  * multi-byte integer values are stored little-endian!
  85:../lib/fat16.c ****  *
  86:../lib/fat16.c ****  * 8.3 file name entry:
  87:../lib/fat16.c ****  * ====================
  88:../lib/fat16.c ****  * offset  length  description
  89:../lib/fat16.c ****  *      0       8  name (space padded)
  90:../lib/fat16.c ****  *      8       3  extension (space padded)
  91:../lib/fat16.c ****  *     11       1  attributes (FAT16_ATTRIB_*)
  92:../lib/fat16.c ****  
  93:../lib/fat16.c ****  *     0x0E     2  Creation Time
  94:../lib/fat16.c ****  *     0x10     2  Creation Date
  95:../lib/fat16.c ****  
  96:../lib/fat16.c ****  *
  97:../lib/fat16.c ****  * long file name (lfn) entry ordering for a single file name:
  98:../lib/fat16.c ****  * ===========================================================
  99:../lib/fat16.c ****  * LFN entry n
 100:../lib/fat16.c ****  *     ...
 101:../lib/fat16.c ****  * LFN entry 2
 102:../lib/fat16.c ****  * LFN entry 1
 103:../lib/fat16.c ****  * 8.3 entry (see above)
 104:../lib/fat16.c ****  *
 105:../lib/fat16.c ****  * lfn entry:
 106:../lib/fat16.c ****  * ==========
 107:../lib/fat16.c ****  * offset  length  description
 108:../lib/fat16.c ****  *      0       1  ordinal field
 109:../lib/fat16.c ****  *      1       2  unicode character 1
 110:../lib/fat16.c ****  *      3       3  unicode character 2
 111:../lib/fat16.c ****  *      5       3  unicode character 3
 112:../lib/fat16.c ****  *      7       3  unicode character 4
 113:../lib/fat16.c ****  *      9       3  unicode character 5
 114:../lib/fat16.c ****  *     11       1  attribute (always 0x0f)
 115:../lib/fat16.c ****  *     12       1  type (reserved, always 0)
 116:../lib/fat16.c ****  *     13       1  checksum
 117:../lib/fat16.c ****  *     14       2  unicode character 6
 118:../lib/fat16.c ****  *     16       2  unicode character 7
 119:../lib/fat16.c ****  *     18       2  unicode character 8
 120:../lib/fat16.c ****  *     20       2  unicode character 9
 121:../lib/fat16.c ****  *     22       2  unicode character 10
 122:../lib/fat16.c ****  *     24       2  unicode character 11
 123:../lib/fat16.c ****  *     26       2  cluster (unused, always 0)
 124:../lib/fat16.c ****  *     28       2  unicode character 12
 125:../lib/fat16.c ****  *     30       2  unicode character 13
 126:../lib/fat16.c ****  *
 127:../lib/fat16.c ****  * The ordinal field contains a descending number, from n to 1.
 128:../lib/fat16.c ****  * For the n'th lfn entry the ordinal field is or'ed with 0x40.
 129:../lib/fat16.c ****  * For deleted lfn entries, the ordinal field is set to 0xe5.
 130:../lib/fat16.c ****  */
 131:../lib/fat16.c **** 
 132:../lib/fat16.c **** struct fat16_header_struct
 133:../lib/fat16.c **** {
 134:../lib/fat16.c ****     uint32_t size;
 135:../lib/fat16.c **** 
 136:../lib/fat16.c ****     uint32_t fat_offset;
 137:../lib/fat16.c ****     uint32_t fat_size;
 138:../lib/fat16.c **** 
 139:../lib/fat16.c ****     uint16_t sector_size;
 140:../lib/fat16.c ****     uint16_t cluster_size;
 141:../lib/fat16.c **** 
 142:../lib/fat16.c ****     uint32_t root_dir_offset;
 143:../lib/fat16.c **** 
 144:../lib/fat16.c ****     uint32_t cluster_zero_offset;
 145:../lib/fat16.c **** };
 146:../lib/fat16.c **** 
 147:../lib/fat16.c **** struct fat16_fs_struct
 148:../lib/fat16.c **** {
 149:../lib/fat16.c ****     struct partition_struct* partition;
 150:../lib/fat16.c ****     struct fat16_header_struct header;
 151:../lib/fat16.c **** };
 152:../lib/fat16.c **** 
 153:../lib/fat16.c **** struct fat16_file_struct
 154:../lib/fat16.c **** {
 155:../lib/fat16.c ****     struct fat16_fs_struct* fs;
 156:../lib/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 157:../lib/fat16.c ****     uint32_t pos;
 158:../lib/fat16.c ****     uint16_t pos_cluster;
 159:../lib/fat16.c **** };
 160:../lib/fat16.c **** 
 161:../lib/fat16.c **** struct fat16_dir_struct
 162:../lib/fat16.c **** {
 163:../lib/fat16.c ****     struct fat16_fs_struct* fs;
 164:../lib/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 165:../lib/fat16.c ****     uint16_t entry_next;
 166:../lib/fat16.c **** };
 167:../lib/fat16.c **** 
 168:../lib/fat16.c **** struct fat16_read_callback_arg
 169:../lib/fat16.c **** {
 170:../lib/fat16.c ****     uint16_t entry_cur;
 171:../lib/fat16.c ****     uint16_t entry_num;
 172:../lib/fat16.c ****     uint32_t entry_offset;
 173:../lib/fat16.c ****     uint8_t byte_count;
 174:../lib/fat16.c **** };
 175:../lib/fat16.c **** 
 176:../lib/fat16.c **** struct fat16_usage_count_callback_arg
 177:../lib/fat16.c **** {
 178:../lib/fat16.c ****     uint16_t cluster_count;
 179:../lib/fat16.c ****     uint8_t buffer_size;
 180:../lib/fat16.c **** };
 181:../lib/fat16.c **** 
 182:../lib/fat16.c **** static uint8_t fat16_read_header(struct fat16_fs_struct* fs);
 183:../lib/fat16.c **** static uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, stru
 184:../lib/fat16.c **** static uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const
 185:../lib/fat16.c **** static uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p);
 186:../lib/fat16.c **** static uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p);
 187:../lib/fat16.c **** static uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* r
 188:../lib/fat16.c **** static uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 189:../lib/fat16.c **** static uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint1
 190:../lib/fat16.c **** static uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 191:../lib/fat16.c **** static uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 192:../lib/fat16.c **** static uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry
 193:../lib/fat16.c **** 
 194:../lib/fat16.c **** static uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p);
 195:../lib/fat16.c **** 
 196:../lib/fat16.c **** /**
 197:../lib/fat16.c ****  * \ingroup fat16_fs
 198:../lib/fat16.c ****  * Opens a FAT16 filesystem.
 199:../lib/fat16.c ****  *
 200:../lib/fat16.c ****  * \param[in] partition Discriptor of partition on which the filesystem resides.
 201:../lib/fat16.c ****  * \returns 0 on error, a FAT16 filesystem descriptor on success.
 202:../lib/fat16.c ****  * \see fat16_open
 203:../lib/fat16.c ****  */
 204:../lib/fat16.c **** struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
 205:../lib/fat16.c **** {
 206:../lib/fat16.c ****     if(!partition ||
 207:../lib/fat16.c ****         #if FAT16_WRITE_SUPPORT
 208:../lib/fat16.c ****         !partition->device_write
 209:../lib/fat16.c ****        #else
 210:../lib/fat16.c ****         0
 211:../lib/fat16.c ****        #endif
 212:../lib/fat16.c ****        )
 213:../lib/fat16.c ****     return 0;
 214:../lib/fat16.c **** 
 215:../lib/fat16.c ****     struct fat16_fs_struct* fs = malloc(sizeof(*fs));
 216:../lib/fat16.c ****     if(!fs)
 217:../lib/fat16.c ****     {
 218:../lib/fat16.c ****         rprintf("MALLOC FAILS\n\r");
 219:../lib/fat16.c ****         return 0;
 220:../lib/fat16.c ****     }
 221:../lib/fat16.c ****     memset(fs, 0, sizeof(*fs));
 222:../lib/fat16.c **** 
 223:../lib/fat16.c ****     fs->partition = partition;
 224:../lib/fat16.c ****     if(!fat16_read_header(fs))
 225:../lib/fat16.c ****     {
 226:../lib/fat16.c ****         rprintf("Failed Reading Header\n\r");
 227:../lib/fat16.c ****         free(fs);
 228:../lib/fat16.c ****         return 0;
 229:../lib/fat16.c ****     }
 230:../lib/fat16.c **** 
 231:../lib/fat16.c ****     return fs;
 232:../lib/fat16.c **** }
 233:../lib/fat16.c **** 
 234:../lib/fat16.c **** /**
 235:../lib/fat16.c ****  * \ingroup fat16_fs
 236:../lib/fat16.c ****  * Closes a FAT16 filesystem.
 237:../lib/fat16.c ****  *
 238:../lib/fat16.c ****  * When this function returns, the given filesystem descriptor
 239:../lib/fat16.c ****  * will be invalid.
 240:../lib/fat16.c ****  *
 241:../lib/fat16.c ****  * \param[in] fs The filesystem to close.
 242:../lib/fat16.c ****  * \see fat16_open
 243:../lib/fat16.c ****  */
 244:../lib/fat16.c **** void fat16_close(struct fat16_fs_struct* fs)
 245:../lib/fat16.c **** {
 246:../lib/fat16.c ****     if(!fs)
 247:../lib/fat16.c ****         return;
 248:../lib/fat16.c **** 
 249:../lib/fat16.c ****     free(fs);
 250:../lib/fat16.c **** }
 251:../lib/fat16.c **** 
 252:../lib/fat16.c **** /**
 253:../lib/fat16.c ****  * \ingroup fat16_fs
 254:../lib/fat16.c ****  * Reads and parses the header of a FAT16 filesystem.
 255:../lib/fat16.c ****  *
 256:../lib/fat16.c ****  * \param[inout] fs The filesystem for which to parse the header.
 257:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 258:../lib/fat16.c ****  */
 259:../lib/fat16.c **** uint8_t fat16_read_header(struct fat16_fs_struct* fs)
 260:../lib/fat16.c **** {
 261:../lib/fat16.c ****     if(!fs)
 262:../lib/fat16.c ****         return 0;
 263:../lib/fat16.c **** 
 264:../lib/fat16.c ****     struct partition_struct* partition = fs->partition;
 265:../lib/fat16.c ****     if(!partition)
 266:../lib/fat16.c ****     {
 267:../lib/fat16.c ****         rprintf("Partition = 0\n\r");
 268:../lib/fat16.c ****         return 0;
 269:../lib/fat16.c ****     }
 270:../lib/fat16.c **** 
 271:../lib/fat16.c ****     /* read fat parameters */
 272:../lib/fat16.c ****     uint8_t buffer[25];
 273:../lib/fat16.c ****     uint32_t partition_offset = partition->offset * 512;
 274:../lib/fat16.c **** 
 275:../lib/fat16.c ****     if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
 276:../lib/fat16.c ****         return 0;
 277:../lib/fat16.c **** 
 278:../lib/fat16.c ****     uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
 279:../lib/fat16.c ****     ((uint16_t) buffer[0x01] << 8);
 280:../lib/fat16.c ****     uint8_t sectors_per_cluster = buffer[0x02];
 281:../lib/fat16.c ****     uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
 282:../lib/fat16.c ****     ((uint16_t) buffer[0x04] << 8);
 283:../lib/fat16.c ****     uint8_t fat_copies = buffer[0x05];
 284:../lib/fat16.c ****     uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
 285:../lib/fat16.c ****     ((uint16_t) buffer[0x07] << 8);
 286:../lib/fat16.c ****     uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
 287:../lib/fat16.c ****     ((uint16_t) buffer[0x09] << 8);
 288:../lib/fat16.c ****     uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
 289:../lib/fat16.c ****     ((uint16_t) buffer[0x0c] << 8);
 290:../lib/fat16.c ****     uint32_t sector_count = ((uint32_t) buffer[0x15]) |
 291:../lib/fat16.c ****     ((uint32_t) buffer[0x16] << 8) |
 292:../lib/fat16.c ****     ((uint32_t) buffer[0x17] << 16) |
 293:../lib/fat16.c ****     ((uint32_t) buffer[0x18] << 24);
 294:../lib/fat16.c **** 
 295:../lib/fat16.c ****     if(sectors_per_fat == 0)
 296:../lib/fat16.c ****     /* this is not a FAT16 */
 297:../lib/fat16.c ****         return 0;
 298:../lib/fat16.c **** 
 299:../lib/fat16.c ****     if(sector_count == 0)
 300:../lib/fat16.c ****     {
 301:../lib/fat16.c ****         if(sector_count_16 == 0)
 302:../lib/fat16.c ****     /* illegal volume size */
 303:../lib/fat16.c ****             return 0;
 304:../lib/fat16.c ****         else
 305:../lib/fat16.c ****             sector_count = sector_count_16;
 306:../lib/fat16.c ****     }
 307:../lib/fat16.c **** 
 308:../lib/fat16.c ****     /* ensure we really have a FAT16 fs here */
 309:../lib/fat16.c ****     uint32_t data_sector_count = sector_count
 310:../lib/fat16.c ****     - reserved_sectors
 311:../lib/fat16.c ****     - (uint32_t) sectors_per_fat * fat_copies
 312:../lib/fat16.c ****     - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
 313:../lib/fat16.c ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 314:../lib/fat16.c ****     if(data_cluster_count < 4085 || data_cluster_count >= 65525)
 315:../lib/fat16.c ****     /* this is not a FAT16 */
 316:../lib/fat16.c ****         return 0;
 317:../lib/fat16.c **** 
 318:../lib/fat16.c ****     partition->type = PARTITION_TYPE_FAT16;
 319:../lib/fat16.c **** 
 320:../lib/fat16.c ****     /* fill header information */
 321:../lib/fat16.c ****     struct fat16_header_struct* header = &fs->header;
 322:../lib/fat16.c ****     memset(header, 0, sizeof(*header));
 323:../lib/fat16.c **** 
 324:../lib/fat16.c ****     header->size = sector_count * bytes_per_sector;
 325:../lib/fat16.c **** 
 326:../lib/fat16.c ****     header->fat_offset = /* jump to partition */
 327:../lib/fat16.c ****     partition_offset +
 328:../lib/fat16.c ****     /* jump to fat */
 329:../lib/fat16.c ****     (uint32_t) reserved_sectors * bytes_per_sector;
 330:../lib/fat16.c ****     header->fat_size = (data_cluster_count + 2) * 2;
 331:../lib/fat16.c **** 
 332:../lib/fat16.c ****     header->sector_size = bytes_per_sector;
 333:../lib/fat16.c ****     header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
 334:../lib/fat16.c **** 
 335:../lib/fat16.c ****     header->root_dir_offset = /* jump to fats */
 336:../lib/fat16.c ****     header->fat_offset +
 337:../lib/fat16.c ****     /* jump to root directory entries */
 338:../lib/fat16.c ****     (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;
 339:../lib/fat16.c **** 
 340:../lib/fat16.c ****     header->cluster_zero_offset = /* jump to root directory entries */
 341:../lib/fat16.c ****     header->root_dir_offset +
 342:../lib/fat16.c ****     /* skip root directory entries */
 343:../lib/fat16.c ****     (uint32_t) max_root_entries * 32;
 344:../lib/fat16.c **** 
 345:../lib/fat16.c ****     return 1;
 346:../lib/fat16.c **** }
 347:../lib/fat16.c **** 
 348:../lib/fat16.c **** /**
 349:../lib/fat16.c ****  * \ingroup fat16_fs
 350:../lib/fat16.c ****  * Reads a directory entry of the root directory.
 351:../lib/fat16.c ****  *
 352:../lib/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 353:../lib/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 354:../lib/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 355:../lib/fat16.c ****  * \returns 0 on failure, 1 on success
 356:../lib/fat16.c ****  * \see fat16_read_sub_dir_entry, fat16_read_dir_entry_by_path
 357:../lib/fat16.c ****  */
 358:../lib/fat16.c **** uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, struct fat1
 359:../lib/fat16.c **** {
 360:../lib/fat16.c ****     if(!fs || !dir_entry)
 361:../lib/fat16.c ****         return 0;
 362:../lib/fat16.c **** 
 363:../lib/fat16.c ****     /* we read from the root directory entry */
 364:../lib/fat16.c ****     const struct fat16_header_struct* header = &fs->header;
 365:../lib/fat16.c ****     device_read_interval_t device_read_interval = fs->partition->device_read_interval;
 366:../lib/fat16.c ****     uint8_t buffer[32];
 367:../lib/fat16.c **** 
 368:../lib/fat16.c ****     /* seek to the n-th entry */
 369:../lib/fat16.c ****     struct fat16_read_callback_arg arg;
 370:../lib/fat16.c ****     memset(&arg, 0, sizeof(arg));
 371:../lib/fat16.c ****     arg.entry_num = entry_num;
 372:../lib/fat16.c ****     if(!device_read_interval(header->root_dir_offset,
 373:../lib/fat16.c ****         buffer,
 374:../lib/fat16.c ****        sizeof(buffer),
 375:../lib/fat16.c ****        header->cluster_zero_offset - header->root_dir_offset,
 376:../lib/fat16.c ****        fat16_dir_entry_seek_callback,
 377:../lib/fat16.c ****        &arg) ||
 378:../lib/fat16.c ****        arg.entry_offset == 0
 379:../lib/fat16.c ****        )
 380:../lib/fat16.c ****     return 0;
 381:../lib/fat16.c **** 
 382:../lib/fat16.c ****     /* read entry */
 383:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 384:../lib/fat16.c ****     if(!device_read_interval(arg.entry_offset,
 385:../lib/fat16.c ****         buffer,
 386:../lib/fat16.c ****        sizeof(buffer),
 387:../lib/fat16.c ****        arg.byte_count,
 388:../lib/fat16.c ****        fat16_dir_entry_read_callback,
 389:../lib/fat16.c ****        dir_entry))
 390:../lib/fat16.c ****     return 0;
 391:../lib/fat16.c **** 
 392:../lib/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 393:../lib/fat16.c **** }
 394:../lib/fat16.c **** 
 395:../lib/fat16.c **** /**
 396:../lib/fat16.c ****  * \ingroup fat16_fs
 397:../lib/fat16.c ****  * Reads a directory entry of a given parent directory.
 398:../lib/fat16.c ****  *
 399:../lib/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 400:../lib/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 401:../lib/fat16.c ****  * \param[in] parent Directory entry descriptor in which to read directory entry.
 402:../lib/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 403:../lib/fat16.c ****  * \returns 0 on failure, 1 on success
 404:../lib/fat16.c ****  * \see fat16_read_root_dir_entry, fat16_read_dir_entry_by_path
 405:../lib/fat16.c ****  */
 406:../lib/fat16.c **** uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const struct
 407:../lib/fat16.c **** {
 408:../lib/fat16.c ****     if(!fs || !parent || !dir_entry)
 409:../lib/fat16.c ****         return 0;
 410:../lib/fat16.c **** 
 411:../lib/fat16.c ****     /* we are in a parent directory and want to search within its directory entry table */
 412:../lib/fat16.c ****     if(!(parent->attributes & FAT16_ATTRIB_DIR))
 413:../lib/fat16.c ****         return 0;
 414:../lib/fat16.c **** 
 415:../lib/fat16.c ****     /* loop through all clusters of the directory */
 416:../lib/fat16.c ****     uint8_t buffer[32];
 417:../lib/fat16.c ****     uint32_t cluster_offset;
 418:../lib/fat16.c ****     uint16_t cluster_size = fs->header.cluster_size;
 419:../lib/fat16.c ****     uint16_t cluster_num = parent->cluster;
 420:../lib/fat16.c ****     struct fat16_read_callback_arg arg;
 421:../lib/fat16.c **** 
 422:../lib/fat16.c ****     while(1)
 423:../lib/fat16.c ****     {
 424:../lib/fat16.c ****         /* calculate new cluster offset */
 425:../lib/fat16.c ****         cluster_offset = fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * cluster_si
 426:../lib/fat16.c **** 
 427:../lib/fat16.c ****         /* seek to the n-th entry */
 428:../lib/fat16.c ****         memset(&arg, 0, sizeof(arg));
 429:../lib/fat16.c ****         arg.entry_num = entry_num;
 430:../lib/fat16.c ****         if(!fs->partition->device_read_interval(cluster_offset,
 431:../lib/fat16.c ****             buffer,
 432:../lib/fat16.c ****            sizeof(buffer),
 433:../lib/fat16.c ****            cluster_size,
 434:../lib/fat16.c ****            fat16_dir_entry_seek_callback,
 435:../lib/fat16.c ****            &arg)
 436:../lib/fat16.c ****            )
 437:../lib/fat16.c ****         return 0;
 438:../lib/fat16.c **** 
 439:../lib/fat16.c ****         /* check if we found the entry */
 440:../lib/fat16.c ****         if(arg.entry_offset)
 441:../lib/fat16.c ****             break;
 442:../lib/fat16.c **** 
 443:../lib/fat16.c ****         /* get number of next cluster */
 444:../lib/fat16.c ****         if(!(cluster_num = fat16_get_next_cluster(fs, cluster_num)))
 445:../lib/fat16.c ****             return 0; /* directory entry not found */
 446:../lib/fat16.c ****     }
 447:../lib/fat16.c **** 
 448:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 449:../lib/fat16.c **** 
 450:../lib/fat16.c ****     /* read entry */
 451:../lib/fat16.c ****     if(!fs->partition->device_read_interval(arg.entry_offset,
 452:../lib/fat16.c ****         buffer,
 453:../lib/fat16.c ****        sizeof(buffer),
 454:../lib/fat16.c ****        arg.byte_count,
 455:../lib/fat16.c ****        fat16_dir_entry_read_callback,
 456:../lib/fat16.c ****        dir_entry))
 457:../lib/fat16.c ****     return 0;
 458:../lib/fat16.c **** 
 459:../lib/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 460:../lib/fat16.c **** }
 461:../lib/fat16.c **** 
 462:../lib/fat16.c **** /**
 463:../lib/fat16.c ****  * \ingroup fat16_fs
 464:../lib/fat16.c ****  * Callback function for seeking through subdirectory entries.
 465:../lib/fat16.c ****  */
 466:../lib/fat16.c **** uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p)
 467:../lib/fat16.c **** {
  15              		@ Function supports interworking.
  16              		@ args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 471 0
 468:../lib/fat16.c **** 
 469:../lib/fat16.c **** 
 470:../lib/fat16.c ****     /* skip deleted or empty entries */
 471:../lib/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
  21              	r3, [r0, #0]	@ zero_extendqisi2
  22 0000 0030D0E5 		cmp	r3, #0
  23 0004 000053E3 		cmpne	r3, #229
  24 0008 E5005313 		.loc 1 467 0
  25              		@ lr needed for prologue
  26              		.loc 1 471 0
  27              		beq	.L2
  28 000c 1500000A 		.loc 1 474 0
 472:../lib/fat16.c ****      return 1;
 473:../lib/fat16.c **** 
 474:../lib/fat16.c ****     if(arg->entry_cur == arg->entry_num)
  29              	, [r2, #0]
  30 0010 B0C0D2E1 		ldrh	r3, [r2, #2]
  31 0014 B230D2E1 		cmp	r3, ip
  32 0018 0C0053E1 		bne	.L4
  33 001c 0B00001A 		.loc 1 476 0
 475:../lib/fat16.c ****  {
 476:../lib/fat16.c ****         arg->entry_offset = offset;
  34              	r1, [r2, #4]
  35 0020 041082E5 		.loc 1 477 0
 477:../lib/fat16.c ****       arg->byte_count = buffer[11] == 0x0f ?
  36              	drb	r3, [r0, #11]	@ zero_extendqisi2
  37 0024 0B30D0E5 		cmp	r3, #15
  38 0028 0F0053E3 		ldreqb	r3, [r0, #0]	@ zero_extendqisi2
  39 002c 0030D005 		andeq	r3, r3, #63
  40 0030 3F300302 		moveq	r3, r3, asl #5
  41 0034 8332A001 		addeq	r3, r3, #32
  42 0038 20308302 		mov	r1, #32
  43 003c 2010A0E3 	.LVL1:
  44              		mov	r0, #0
  45 0040 0000A0E3 	.LVL2:
  46              		andeq	r1, r3, #255
  47 0044 FF100302 		strb	r1, [r2, #8]
  48 0048 0810C2E5 		bx	lr
  49 004c 1EFF2FE1 	.LVL3:
  50              	.L4:
  51              		.loc 1 484 0
 478:../lib/fat16.c ****        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
 479:../lib/fat16.c ****         32;
 480:../lib/fat16.c ****         return 0;
 481:../lib/fat16.c ****     }
 482:../lib/fat16.c **** 
 483:../lib/fat16.c ****     /* if we read a 8.3 entry, we reached a new directory entry */
 484:../lib/fat16.c ****     if(buffer[11] != 0x0f)
  52              	11]	@ zero_extendqisi2
  53 0050 0B30D0E5 		.loc 1 485 0
 485:../lib/fat16.c ****  ++arg->entry_cur;
  54              	dd	r1, ip, #1
  55 0054 01108CE2 	.LVL4:
  56              		.loc 1 484 0
  57              		cmp	r3, #15
  58 0058 0F0053E3 		.loc 1 485 0
  59              		mov	r0, #1
  60 005c 0100A0E3 	.LVL5:
  61              		strneh	r1, [r2, #0]	@ movhi
  62 0060 B010C211 		.loc 1 484 0
  63              		bxne	lr
  64 0064 1EFF2F11 	.LVL6:
  65              	.L2:
  66              		.loc 1 485 0
  67              		mov	r0, #1
  68 0068 0100A0E3 	.LVL7:
  69              		.loc 1 488 0
 486:../lib/fat16.c ****     return 1;
 487:../lib/fat16.c **** }
 488:../lib/fat16.c **** 
  70              	size	fat16_dir_entry_seek_callback, .-fat16_dir_entry_seek_callback
  71 006c 1EFF2FE1 		.align	2
  73              	fat16_dir_entry_read_callback:
  74              	.LFB8:
  75              		.loc 1 495 0
  76              		@ Function supports interworking.
  77              		@ args = 0, pretend = 0, frame = 0
 489:../lib/fat16.c **** 
 490:../lib/fat16.c ****  * \ingroup fat16_fs
 491:../lib/fat16.c ****  * Callback function for reading a directory entry.
 492:../lib/fat16.c ****  */
 493:../lib/fat16.c **** uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
 494:../lib/fat16.c **** {
 495:../lib/fat16.c ****     struct fat16_dir_entry_struct* dir_entry = p;
  78              	_needed = 0, uses_anonymous_args = 0
  79              	.LVL8:
  80              		stmfd	sp!, {r4, r5, lr}
  81              	.LCFI0:
  82              		.loc 1 499 0
  83 0070 30402DE9 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  84              		cmp	r3, #0
 496:../lib/fat16.c **** * there should not be any deleted or empty entries */
 497:../lib/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
 498:../lib/fat16.c ****         return 0;
 499:../lib/fat16.c **** 
  85              	r3, #229
  86 0074 0030D0E5 		.loc 1 495 0
  87 0078 000053E3 		mov	ip, r2
  88 007c E5005313 		.loc 1 499 0
  89              		beq	.L13
  90 0080 02C0A0E1 	.LVL9:
  91              		.loc 1 502 0
  92 0084 6200000A 		ldr	r3, [r2, #40]
  93              		cmp	r3, #0
 500:../lib/fat16.c **** if(!dir_entry->entry_offset)
 501:../lib/fat16.c ****         dir_entry->entry_offset = offset;
 502:../lib/fat16.c **** 
  94              	03 0
  95 0088 283092E5 		streq	r1, [r2, #40]
  96 008c 000053E3 	.LBB9:
 503:../lib/fat16.c ****  switch(fat16_interpret_dir_entry(dir_entry, buffer))
  97              	B10:
  98 0090 28108205 		.loc 1 536 0
  99              		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 100              		cmp	r2, #0
 504:../lib/fat16.c ****    {
 505:../lib/fat16.c ****         case 0: /* failure */
 506:../lib/fat16.c ****             return 0;
 507:../lib/fat16.c ****             case 1: /* buffer successfully parsed, continue */
 508:../lib/fat16.c ****             return 1;
 509:../lib/fat16.c ****             case 2: /* directory entry complete, finish */
 510:../lib/fat16.c ****             return 0;
 511:../lib/fat16.c ****         }
 512:../lib/fat16.c **** 
 513:../lib/fat16.c ****     return 0;
 514:../lib/fat16.c **** }
 515:../lib/fat16.c **** 
 516:../lib/fat16.c **** /**
 517:../lib/fat16.c ****  * \ingroup fat16_fs
 518:../lib/fat16.c ****  * Interprets a raw directory entry and puts the contained
 519:../lib/fat16.c ****  * information into the directory entry.
 520:../lib/fat16.c ****  *
 521:../lib/fat16.c ****  * For a single file there may exist multiple directory
 522:../lib/fat16.c ****  * entries. All except the last one are lfn entries, which
 523:../lib/fat16.c ****  * contain parts of the long filename. The last directory
 524:../lib/fat16.c ****  * entry is a traditional 8.3 style one. It contains all
 525:../lib/fat16.c ****  * other information like size, cluster, date and time.
 526:../lib/fat16.c ****  *
 527:../lib/fat16.c ****  * \param[in,out] dir_entry The directory entry to fill.
 528:../lib/fat16.c ****  * \param[in] raw_entry A pointer to 32 bytes of raw data.
 529:../lib/fat16.c ****  * \returns 0 on failure, 1 on success and 2 if the
 530:../lib/fat16.c ****  *          directory entry is complete.
 531:../lib/fat16.c ****  */
 532:../lib/fat16.c **** uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entr
 533:../lib/fat16.c **** {
 534:../lib/fat16.c ****     if(!dir_entry || !raw_entry || !raw_entry[0])
 535:../lib/fat16.c ****         return 0;
 536:../lib/fat16.c **** 
 101              		.L13
 102 0094 0020D0E5 		.loc 1 540 0
 103 0098 000052E3 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 104 009c 5C00000A 		cmp	r3, #15
 537:../lib/fat16.c **** long_name;
 538:../lib/fat16.c ****     if(raw_entry[11] == 0x0f)
 539:../lib/fat16.c ****     {
 540:../lib/fat16.c ****         uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
 105              		r5, r0, #11
 106 00a0 0B30D0E5 		bne	.L18
 107 00a4 0F0053E3 	.LBB11:
 108 00a8 0B5080E2 		.loc 1 542 0
 109 00ac 2600001A 		and	r2, r2, #63
 110              		mov	r3, #13
 541:../lib/fat16.c ****      if(char_offset + 12 < sizeof(dir_entry->long_name))
 542:../lib/fat16.c ****         {
 111              	3, r2, r3
 112 00b0 3F2002E2 		sub	r3, r3, #13
 113 00b4 0D30A0E3 		mov	r3, r3, asl #16
 114 00b8 920303E0 		mov	r2, r3, lsr #16
 115 00bc 0D3043E2 	.LVL10:
 116 00c0 0338A0E1 		.loc 1 544 0
 117 00c4 2328A0E1 		add	r3, r2, #12
 118              		cmp	r3, #31
 543:../lib/fat16.c ****           /* Lfn supports unicode, but we do not, for now.
 544:../lib/fat16.c ****                                                  * So we assume pure ascii and read only every
 119              	0, #1
 120 00c8 0C3082E2 	.LVL11:
 121 00cc 1F0053E3 		bhi	.L22
 122 00d0 0100A083 	.LVL12:
 123              		.loc 1 550 0
 124 00d4 4F00008A 		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 125              		strb	r3, [ip, r2]
 545:../lib/fat16.c ****                                                * second byte.
 546:../lib/fat16.c ****                                                  */
 547:../lib/fat16.c ****             long_name[char_offset + 0] = raw_entry[1];
 548:../lib/fat16.c ****             long_name[char_offset + 1] = raw_entry[3];
 549:../lib/fat16.c ****             long_name[char_offset + 2] = raw_entry[5];
 550:../lib/fat16.c ****             long_name[char_offset + 3] = raw_entry[7];
 126              	 551 0
 127 00d8 0130D0E5 		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 128 00dc 0230CCE7 		add	r2, ip, r2
 551:../lib/fat16.c ****       long_name[char_offset + 4] = raw_entry[9];
 129              	L13:
 130 00e0 0330D0E5 		strb	r3, [r2, #1]
 131 00e4 02208CE0 		.loc 1 552 0
 132              		ldrb	r3, [r0, #5]	@ zero_extendqisi2
 133 00e8 0130C2E5 		strb	r3, [r2, #2]
 552:../lib/fat16.c ****            long_name[char_offset + 5] = raw_entry[14];
 134              	 1 553 0
 135 00ec 0530D0E5 		ldrb	r3, [r0, #7]	@ zero_extendqisi2
 136 00f0 0230C2E5 		strb	r3, [r2, #3]
 553:../lib/fat16.c ****            long_name[char_offset + 6] = raw_entry[16];
 137              	oc 1 554 0
 138 00f4 0730D0E5 		ldrb	r3, [r0, #9]	@ zero_extendqisi2
 139 00f8 0330C2E5 		strb	r3, [r2, #4]
 554:../lib/fat16.c ****            long_name[char_offset + 7] = raw_entry[18];
 140              	oc 1 555 0
 141 00fc 0930D0E5 		ldrb	r3, [r0, #14]	@ zero_extendqisi2
 142 0100 0430C2E5 		strb	r3, [r2, #5]
 555:../lib/fat16.c ****            long_name[char_offset + 8] = raw_entry[20];
 143              	oc 1 556 0
 144 0104 0E30D0E5 		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 145 0108 0530C2E5 		strb	r3, [r2, #6]
 556:../lib/fat16.c ****            long_name[char_offset + 9] = raw_entry[22];
 146              	oc 1 557 0
 147 010c 1030D0E5 		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 148 0110 0630C2E5 		strb	r3, [r2, #7]
 557:../lib/fat16.c ****            long_name[char_offset + 10] = raw_entry[24];
 149              	oc 1 558 0
 150 0114 1230D0E5 		ldrb	r3, [r0, #20]	@ zero_extendqisi2
 151 0118 0730C2E5 		strb	r3, [r2, #8]
 558:../lib/fat16.c ****            long_name[char_offset + 11] = raw_entry[28];
 152              	oc 1 559 0
 153 011c 1430D0E5 		ldrb	r3, [r0, #22]	@ zero_extendqisi2
 154 0120 0830C2E5 		strb	r3, [r2, #9]
 559:../lib/fat16.c ****            long_name[char_offset + 12] = raw_entry[30];
 155              	oc 1 560 0
 156 0124 1630D0E5 		ldrb	r3, [r0, #24]	@ zero_extendqisi2
 157 0128 0930C2E5 		strb	r3, [r2, #10]
 560:../lib/fat16.c ****        }
 158              	oc 1 561 0
 159 012c 1830D0E5 		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 160 0130 0A30C2E5 		strb	r3, [r2, #11]
 561:../lib/fat16.c ****         return 1;
 161              	oc 1 562 0
 162 0134 1C30D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 163 0138 0B30C2E5 		mov	r0, #1
 562:../lib/fat16.c ****    }
 164              	L14:
 165 013c 1E30D0E5 		strb	r3, [r2, #12]
 166 0140 0100A0E3 		b	.L22
 167              	.LVL15:
 168 0144 0C30C2E5 	.L18:
 169 0148 320000EA 	.LBE11:
 170              		.loc 1 570 0
 171              		ldrb	r2, [ip, #0]	@ zero_extendqisi2
 172              		cmp	r2, #0
 563:../lib/fat16.c ****    else
 564:../lib/fat16.c ****     {
 565:../lib/fat16.c ****         /* if we do not have a long name, take the short one */
 566:../lib/fat16.c ****         if(long_name[0] == '\0')
 567:../lib/fat16.c ****         {
 568:../lib/fat16.c ****             uint8_t i;
 569:../lib/fat16.c ****             for(i = 0; i < 8; ++i)
 570:../lib/fat16.c ****             {
 173              	
 174 014c 0020DCE5 		mov	r1, r2
 175 0150 000052E3 	.LVL16:
 176 0154 1D00001A 	.L25:
 177 0158 0210A0E1 	.LBB12:
 178              		.loc 1 575 0
 179              		ldrb	r3, [r2, r0]	@ zero_extendqisi2
 180              		cmp	r3, #32
 571:../lib/fat16.c ****         if(raw_entry[i] == ' ')
 572:../lib/fat16.c ****                     break;
 573:../lib/fat16.c ****                 long_name[i] = raw_entry[i];
 574:../lib/fat16.c ****             }
 575:../lib/fat16.c ****             if(raw_entry[8] != ' ')
 181              	 573 0
 182 015c 0030D2E7 		add	lr, r1, #1
 183 0160 200053E3 		.loc 1 575 0
 184              		beq	.L26
 185 0164 01E081E2 		.loc 1 573 0
 186              		and	r1, lr, #255
 187 0168 0400000A 		cmp	r1, #8
 188              		.loc 1 577 0
 189 016c FF100EE2 		strb	r3, [r2, ip]
 190 0170 080051E3 		.loc 1 573 0
 576:../lib/fat16.c ****        {
 577:../lib/fat16.c ****                 long_name[i++] = '.';
 191              	2, #1
 192 0174 0C30C2E7 		bne	.L25
 193              	.L26:
 194 0178 012082E2 		.loc 1 579 0
 195 017c F6FFFF1A 		ldrb	r3, [r0, #8]	@ zero_extendqisi2
 196              		cmp	r3, #32
 578:../lib/fat16.c ****                uint8_t j = 8;
 579:../lib/fat16.c ****                 for(; j < 11; ++j)
 197              	L28
 198 0180 0830D0E5 	.LBB13:
 199 0184 200053E3 		.loc 1 581 0
 200 0188 0E00000A 		mov	r3, #46
 201              		add	r2, r1, #1
 580:../lib/fat16.c ****               {
 581:../lib/fat16.c ****                     if(raw_entry[j] != ' ')
 202              		r3, [ip, r1]
 203 018c 2E30A0E3 		and	r1, r2, #255
 204 0190 012081E2 		mov	r3, r0
 205 0194 0130CCE7 	.L30:
 206 0198 FF1002E2 		.loc 1 586 0
 207 019c 0030A0E1 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 208              		cmp	r2, #32
 582:../lib/fat16.c ****                   {
 583:../lib/fat16.c ****                         long_name[i++] = raw_entry[j];
 584:../lib/fat16.c ****                     }
 585:../lib/fat16.c ****                     else
 586:../lib/fat16.c ****                     {
 209              	 584 0
 210 01a0 0820D3E5 		add	lr, r0, #3
 211 01a4 200052E3 		.loc 1 588 0
 212              		add	r4, r1, #1
 213 01a8 03E080E2 		add	r3, r3, #1
 587:../lib/fat16.c ****                    break;
 588:../lib/fat16.c ****                     }
 214              	 1 586 0
 215 01ac 014081E2 		beq	.L28
 216 01b0 013083E2 		.loc 1 584 0
 217              		cmp	r3, lr
 218 01b4 0300000A 		.loc 1 588 0
 219              		strb	r2, [ip, r1]
 220 01b8 0E0053E1 		and	r1, r4, #255
 221              		.loc 1 584 0
 222 01bc 0120CCE7 		bne	.L30
 223 01c0 FF1004E2 	.L28:
 224              	.LBE13:
 225 01c4 F5FFFF1A 		.loc 1 597 0
 226              		mov	r3, #0
 227              		strb	r3, [ip, r1]
 589:../lib/fat16.c ****               }
 590:../lib/fat16.c ****             }
 591:../lib/fat16.c **** 
 592:../lib/fat16.c ****             long_name[i] = '\0';
 593:../lib/fat16.c ****         }
 594:../lib/fat16.c **** 
 595:../lib/fat16.c ****         /* extract properties of file and store them within the structure */
 596:../lib/fat16.c ****         dir_entry->attributes = raw_entry[11];
 597:../lib/fat16.c ****         dir_entry->cluster = ((uint16_t) raw_entry[26]) |
 228              	.LBE12:
 229 01c8 0030A0E3 		.loc 1 601 0
 230 01cc 0130CCE7 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 231              		strb	r3, [ip, #32]
 232              		.loc 1 602 0
 233              		ldrb	r2, [r0, #27]	@ zero_extendqisi2
 598:../lib/fat16.c **** (uint16_t) raw_entry[27] << 8);
 599:../lib/fat16.c ****         dir_entry->file_size = ((uint32_t) raw_entry[28]) |
 600:../lib/fat16.c ****         ((uint32_t) raw_entry[29] << 8) |
 601:../lib/fat16.c ****         ((uint32_t) raw_entry[30] << 16) |
 234              	r3, [r0, #26]	@ zero_extendqisi2
 235 01d0 0030D5E5 		orr	r3, r3, r2, asl #8
 236 01d4 2030CCE5 		strh	r3, [ip, #34]	@ movhi
 602:../lib/fat16.c ****     ((uint32_t) raw_entry[31] << 24);
 237              	oc 1 604 0
 238 01d8 1B20D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 239 01dc 1A30D0E5 		ldrb	r2, [r0, #28]	@ zero_extendqisi2
 240 01e0 023483E1 		ldrb	r1, [r0, #29]	@ zero_extendqisi2
 241 01e4 B232CCE1 	.LVL18:
 603:../lib/fat16.c ****         return 2;
 604:../lib/fat16.c ****     }
 242              		r0, [r0, #31]	@ zero_extendqisi2
 243 01e8 1E30D0E5 	.LVL19:
 244 01ec 1C20D0E5 		mov	r3, r3, asl #16
 245 01f0 1D10D0E5 		orr	r3, r3, r0, asl #24
 246              		orr	r2, r2, r1, asl #8
 247 01f4 1F00D0E5 		orr	r2, r2, r3
 248              		mov	r0, #0
 249 01f8 0338A0E1 		str	r2, [ip, #36]
 250 01fc 003C83E1 		b	.L22
 251 0200 012482E1 	.LVL20:
 252 0204 032082E1 	.L13:
 253 0208 0000A0E3 		mov	r0, #0
 254 020c 24208CE5 	.LVL21:
 255 0210 000000EA 	.L22:
 256              	.LBE10:
 257              	.LBE9:
 258 0214 0000A0E3 		.loc 1 516 0
 259              		ldmfd	sp!, {r4, r5, lr}
 260              		bx	lr
 261              	.LFE8:
 263              		.align	2
 265 021c 1EFF2FE1 	fat16_get_next_cluster:
 266              	.LFB11:
 267              		.loc 1 697 0
 268              		@ Function supports interworking.
 269              		@ args = 0, pretend = 0, frame = 4
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              	.LVL22:
 605:../lib/fat16.c **** 
 606:../lib/fat16.c **** /**
 607:../lib/fat16.c ****  * \ingroup fat16_file
 608:../lib/fat16.c ****  * Retrieves the directory entry of a path.
 609:../lib/fat16.c ****  *
 610:../lib/fat16.c ****  * The given path may both describe a file or a directory.
 611:../lib/fat16.c ****  *
 612:../lib/fat16.c ****  * \param[in] fs The FAT16 filesystem on which to search.
 613:../lib/fat16.c ****  * \param[in] path The path of which to read the directory entry.
 614:../lib/fat16.c ****  * \param[out] dir_entry The directory entry to fill.
 615:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 616:../lib/fat16.c ****  * \see fat16_read_dir
 617:../lib/fat16.c ****  */
 618:../lib/fat16.c **** uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_
 619:../lib/fat16.c **** {
 620:../lib/fat16.c ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 621:../lib/fat16.c ****         return 0;
 622:../lib/fat16.c **** 
 623:../lib/fat16.c ****     if(path[0] == '/')
 624:../lib/fat16.c ****         ++path;
 625:../lib/fat16.c **** 
 626:../lib/fat16.c ****     /* begin with the root directory */
 627:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 628:../lib/fat16.c ****     dir_entry->attributes = FAT16_ATTRIB_DIR;
 629:../lib/fat16.c **** 
 630:../lib/fat16.c ****     if(path[0] == '\0')
 631:../lib/fat16.c ****         return 1;
 632:../lib/fat16.c **** 
 633:../lib/fat16.c ****     while(1)
 634:../lib/fat16.c ****     {
 635:../lib/fat16.c ****         struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
 636:../lib/fat16.c ****         if(!dd)
 637:../lib/fat16.c ****             break;
 638:../lib/fat16.c **** 
 639:../lib/fat16.c ****         /* extract the next hierarchy we will search for */
 640:../lib/fat16.c ****         const char* sep_pos = strchr(path, '/');
 641:../lib/fat16.c ****         if(!sep_pos)
 642:../lib/fat16.c ****             sep_pos = path + strlen(path);
 643:../lib/fat16.c ****         uint8_t length_to_sep = sep_pos - path;
 644:../lib/fat16.c **** 
 645:../lib/fat16.c ****         /* read directory entries */
 646:../lib/fat16.c ****         while(fat16_read_dir(dd, dir_entry))
 647:../lib/fat16.c ****         {
 648:../lib/fat16.c ****             /* check if we have found the next hierarchy */
 649:../lib/fat16.c ****             if((strlen(dir_entry->long_name) != length_to_sep ||
 650:../lib/fat16.c ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 651:../lib/fat16.c ****             continue;
 652:../lib/fat16.c **** 
 653:../lib/fat16.c ****             fat16_close_dir(dd);
 654:../lib/fat16.c ****             dd = 0;
 655:../lib/fat16.c **** 
 656:../lib/fat16.c ****             if(path[length_to_sep] == '\0')
 657:../lib/fat16.c ****     /* we iterated through the whole path and have found the file */
 658:../lib/fat16.c ****                 return 1;
 659:../lib/fat16.c **** 
 660:../lib/fat16.c ****             if(dir_entry->attributes & FAT16_ATTRIB_DIR)
 661:../lib/fat16.c ****             {
 662:../lib/fat16.c ****                 /* we found a parent directory of the file we are searching for */
 663:../lib/fat16.c ****                 path = sep_pos + 1;
 664:../lib/fat16.c ****                 break;
 665:../lib/fat16.c ****             }
 666:../lib/fat16.c **** 
 667:../lib/fat16.c ****             /* a parent of the file exists, but not the file itself */
 668:../lib/fat16.c ****             return 0;
 669:../lib/fat16.c ****         }
 670:../lib/fat16.c **** 
 671:../lib/fat16.c ****         fat16_close_dir(dd);
 672:../lib/fat16.c ****     }
 673:../lib/fat16.c **** 
 674:../lib/fat16.c ****     return 0;
 675:../lib/fat16.c **** }
 676:../lib/fat16.c **** 
 677:../lib/fat16.c **** /**
 678:../lib/fat16.c ****  * \ingroup fat16_fs
 679:../lib/fat16.c ****  * Retrieves the next following cluster of a given cluster.
 680:../lib/fat16.c ****  *
 681:../lib/fat16.c ****  * Using the filesystem file allocation table, this function returns
 682:../lib/fat16.c ****  * the number of the cluster containing the data directly following
 683:../lib/fat16.c ****  * the data within the cluster with the given number.
 684:../lib/fat16.c ****  *
 685:../lib/fat16.c ****  * \param[in] fs The filesystem for which to determine the next cluster.
 686:../lib/fat16.c ****  * \param[in] cluster_num The number of the cluster for which to determine its successor.
 687:../lib/fat16.c ****  * \returns The wanted cluster number, or 0 on error.
 688:../lib/fat16.c ****  */
 689:../lib/fat16.c **** uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 690:../lib/fat16.c **** {
 691:../lib/fat16.c ****     if(!fs || cluster_num < 2)
 692:../lib/fat16.c ****         return 0;
 693:../lib/fat16.c **** 
 694:../lib/fat16.c ****     /* read appropriate fat entry */
 695:../lib/fat16.c ****     uint8_t fat_entry[2];
 696:../lib/fat16.c ****     if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
 697:../lib/fat16.c ****         return 0;
 272              	ov	r3, r1, asl #16
 273              		mov	r3, r3, lsr #16
 274              		sub	sp, sp, #4
 275              	.LCFI2:
 276              		.loc 1 703 0
 277 0220 04E02DE5 		mov	r2, #2
 278              		.loc 1 698 0
 279 0224 0138A0E1 		cmp	r0, #0
 280 0228 2338A0E1 		cmpne	r3, #1
 281 022c 04D04DE2 		.loc 1 703 0
 282              		add	r1, sp, r2
 698:../lib/fat16.c ****  ((uint16_t) fat_entry[1] << 8);
 699:../lib/fat16.c **** 	///*
 700:../lib/fat16.c ****     if(cluster_num == FAT16_CLUSTER_FREE ||
 701:../lib/fat16.c ****         cluster_num == FAT16_CLUSTER_BAD ||
 702:../lib/fat16.c ****        (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
 703:../lib/fat16.c **** 	   //********************************************************************************
 283              	oc 1 698 0
 284 0230 0220A0E3 		mov	ip, r0
 285              		bls	.L36
 286 0234 000050E3 	.LVL24:
 287 0238 01005313 		.loc 1 703 0
 288              		ldr	r0, [r0, #8]
 289 023c 02108DE0 		mla	r0, r3, r2, r0
 290              		ldr	r3, [ip, #0]
 291              	.LVL25:
 292 0240 00C0A0E1 		ldr	ip, [r3, #0]
 293 0244 1A00009A 		mov	lr, pc
 294              		bx	ip
 295              	.LVL26:
 296 0248 080090E5 		cmp	r0, #0
 297 024c 930220E0 		.loc 1 710 0
 298 0250 00309CE5 		ldr	r1, .L43
 299              		.loc 1 703 0
 300 0254 00C093E5 		beq	.L36
 301 0258 0FE0A0E1 		.loc 1 707 0
 302 025c 1CFF2FE1 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 303              		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 304 0260 000050E3 		.loc 1 710 0
 704:../lib/fat16.c ****  //(cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 705:../lib/fat16.c **** 	   (cluster_num >= FAT16_CLUSTER_LAST_MIN))
 706:../lib/fat16.c **** 	   //********************************************************************************
 707:../lib/fat16.c ****     //*/
 708:../lib/fat16.c **** 	return 0;
 709:../lib/fat16.c **** 
 710:../lib/fat16.c ****     return cluster_num;
 305              	#8
 306 0264 58109FE5 	.LVL27:
 307              		movne	r3, #0
 308 0268 1100000A 		moveq	r3, #1
 309              		cmp	r0, r1
 310 026c 0220DDE5 		orreq	r3, r3, #1
 311 0270 0330DDE5 		add	r2, r0, #16
 312              		cmp	r3, #0
 313 0274 030492E1 		mov	r2, r2, asl #16
 314              		bne	.L36
 315 0278 0030A013 		cmp	r0, r1
 316 027c 0130A003 		movls	r3, #0
 317 0280 010050E1 		movhi	r3, #1
 318 0284 01308303 		cmp	r2, #393216
 319 0288 102080E2 		orrls	r3, r3, #1
 320 028c 000053E3 		cmp	r3, #0
 321 0290 0228A0E1 		beq	.L41
 322 0294 0600001A 	.LVL28:
 323 0298 010050E1 	.L36:
 324 029c 0030A093 		.loc 1 720 0
 325 02a0 0130A083 		mov	r0, #0
 326 02a4 060852E3 	.LVL29:
 327 02a8 01308393 	.L41:
 328 02ac 000053E3 	.LVL30:
 329 02b0 0000000A 		.loc 1 721 0
 330              		add	sp, sp, #4
 331              		ldr	lr, [sp], #4
 711:../lib/fat16.c ****  * \ingroup fat16_fs
 712:../lib/fat16.c ****  * Appends a new cluster chain to an existing one.
 713:../lib/fat16.c ****  *
 714:../lib/fat16.c ****  * Set cluster_num to zero to create a completely new one.
 715:../lib/fat16.c ****  *
 716:../lib/fat16.c ****  * \param[in] fs The file system on which to operate.
 717:../lib/fat16.c ****  * \param[in] cluster_num The cluster to which to append the new chain.
 718:../lib/fat16.c ****  * \param[in] count The number of clusters to allocate.
 719:../lib/fat16.c ****  * \returns 0 on failure, the number of the first new cluster on success.
 720:../lib/fat16.c ****  */
 332              	:
 333 02b4 0000A0E3 		.word	65527
 334              	.LFE11:
 336              		.align	2
 721:../lib/fat16.c **** at16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
 337              	e	fat16_free_clusters, %function
 338 02b8 04D08DE2 	fat16_free_clusters:
 339 02bc 04E09DE4 	.LFB13:
 340 02c0 1EFF2FE1 		.loc 1 828 0
 341              		@ Function supports interworking.
 342              		@ args = 0, pretend = 0, frame = 4
 343              		@ frame_needed = 0, uses_anonymous_args = 0
 344 02c4 F7FF0000 	.LVL31:
 345              		stmfd	sp!, {r4, r5, r6, r7, lr}
 346              	.LCFI3:
 347              		mov	r1, r1, asl #16
 348              	.LVL32:
 349              		mov	r3, r1, lsr #16
 350              	.LVL33:
 722:../lib/fat16.c **** 
 723:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 724:../lib/fat16.c ****         if(!fs)
 725:../lib/fat16.c ****             return 0;
 726:../lib/fat16.c ****     
 727:../lib/fat16.c ****         device_read_t device_read = fs->partition->device_read;
 728:../lib/fat16.c ****         device_write_t device_write = fs->partition->device_write;
 729:../lib/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 730:../lib/fat16.c ****         uint16_t cluster_max = fs->header.fat_size / 2;
 731:../lib/fat16.c ****         uint16_t cluster_next = 0;
 732:../lib/fat16.c ****         uint16_t count_left = count;
 733:../lib/fat16.c ****         uint8_t buffer[2];
 734:../lib/fat16.c ****         uint16_t cluster_new;
 735:../lib/fat16.c ****         for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
 736:../lib/fat16.c ****         {
 737:../lib/fat16.c ****             if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 738:../lib/fat16.c ****                 return 0;
 739:../lib/fat16.c ****     
 740:../lib/fat16.c ****             /* check if this is a free cluster */
 741:../lib/fat16.c ****             if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
 742:../lib/fat16.c ****                 buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
 743:../lib/fat16.c ****             {
 744:../lib/fat16.c ****                 /* allocate cluster */
 745:../lib/fat16.c ****                 if(count_left == count)
 746:../lib/fat16.c ****                 {
 747:../lib/fat16.c ****                     buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 748:../lib/fat16.c ****                     buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 749:../lib/fat16.c ****                 }
 750:../lib/fat16.c ****                 else
 751:../lib/fat16.c ****                 {
 752:../lib/fat16.c ****                     buffer[0] = cluster_next & 0xff;
 753:../lib/fat16.c ****                     buffer[1] = (cluster_next >> 8) & 0xff;
 754:../lib/fat16.c ****                 }
 755:../lib/fat16.c ****     
 756:../lib/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 757:../lib/fat16.c ****                     break;
 758:../lib/fat16.c ****     
 759:../lib/fat16.c ****                 cluster_next = cluster_new;
 760:../lib/fat16.c ****                 if(--count_left == 0)
 761:../lib/fat16.c ****                     break;
 762:../lib/fat16.c ****             }
 763:../lib/fat16.c ****         }
 764:../lib/fat16.c ****     
 765:../lib/fat16.c ****         do
 766:../lib/fat16.c ****         {
 767:../lib/fat16.c ****             if(count_left > 0)
 768:../lib/fat16.c ****                 break;
 769:../lib/fat16.c ****     
 770:../lib/fat16.c ****             /* We allocated a new cluster chain. Now join
 771:../lib/fat16.c ****                                              * it with the existing one.
 772:../lib/fat16.c ****                                              */
 773:../lib/fat16.c ****             if(cluster_num >= 2)
 774:../lib/fat16.c ****             {
 775:../lib/fat16.c ****                 buffer[0] = cluster_next & 0xff;
 776:../lib/fat16.c ****                 buffer[1] = (cluster_next >> 8) & 0xff;
 777:../lib/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
 778:../lib/fat16.c ****                     break;
 779:../lib/fat16.c ****             }
 780:../lib/fat16.c ****     
 781:../lib/fat16.c ****             return cluster_next;
 782:../lib/fat16.c ****     
 783:../lib/fat16.c ****         }
 784:../lib/fat16.c ****         while(0);
 785:../lib/fat16.c ****     
 786:../lib/fat16.c ****         /* No space left on device or writing error.
 787:../lib/fat16.c ****                              * Free up all clusters already allocated.
 788:../lib/fat16.c ****                              */
 789:../lib/fat16.c ****         fat16_free_clusters(fs, cluster_next);
 790:../lib/fat16.c ****     
 791:../lib/fat16.c ****         return 0;
 792:../lib/fat16.c ****     #else
 793:../lib/fat16.c ****         return 0;
 794:../lib/fat16.c ****     #endif
 795:../lib/fat16.c **** }
 796:../lib/fat16.c **** 
 797:../lib/fat16.c **** /**
 798:../lib/fat16.c ****  * \ingroup fat16_fs
 799:../lib/fat16.c ****  * Frees a cluster chain, or a part thereof.
 800:../lib/fat16.c ****  *
 801:../lib/fat16.c ****  * Marks the specified cluster and all clusters which are sequentially
 802:../lib/fat16.c ****  * referenced by it as free. They may then be used again for future
 803:../lib/fat16.c ****  * file allocations.
 804:../lib/fat16.c ****  *
 805:../lib/fat16.c ****  * \note If this function is used for freeing just a part of a cluster
 806:../lib/fat16.c ****  *       chain, the new end of the chain is not correctly terminated
 807:../lib/fat16.c ****  *       within the FAT. Use fat16_terminate_clusters() instead.
 808:../lib/fat16.c ****  *
 809:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 810:../lib/fat16.c ****  * \param[in] cluster_num The starting cluster of the chain which to free.
 811:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 812:../lib/fat16.c ****  * \see fat16_terminate_clusters
 813:../lib/fat16.c ****  */
 814:../lib/fat16.c **** uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 815:../lib/fat16.c **** {
 816:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 817:../lib/fat16.c ****         if(!fs || cluster_num < 2)
 818:../lib/fat16.c ****             return 0;
 819:../lib/fat16.c ****     
 820:../lib/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 821:../lib/fat16.c ****         uint8_t buffer[2];
 822:../lib/fat16.c ****         while(cluster_num)
 823:../lib/fat16.c ****         {
 824:../lib/fat16.c ****             if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
 825:../lib/fat16.c ****                 return 0;
 826:../lib/fat16.c ****     
 827:../lib/fat16.c ****             /* get next cluster of current cluster before freeing current cluster */
 828:../lib/fat16.c ****             uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
 351              		cmp	r0, #0
 352              		cmpne	r3, #1
 353              		.loc 1 828 0
 354              		sub	sp, sp, #4
 355              	.LCFI4:
 356 02c8 F0402DE9 		.loc 1 830 0
 357              		mov	r5, r0
 358 02cc 0118A0E1 		.loc 1 833 0
 359              		ldrhi	r7, [r0, #8]
 360 02d0 2138A0E1 	.LVL34:
 361              		.loc 1 830 0
 829:../lib/fat16.c ****            return 1;
 830:../lib/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_BAD ||
 362              	b	.L46
 363 02d4 000050E3 	.LVL35:
 364 02d8 01005313 	.L49:
 365              	.LBB14:
 366 02dc 04D04DE2 		.loc 1 837 0
 367              		ldr	r3, [r5, #0]
 368              	.LVL36:
 369 02e0 0050A0E1 		ldr	ip, [r3, #0]
 831:../lib/fat16.c ****               (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 832:../lib/fat16.c ****                cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
 833:../lib/fat16.c ****                )
 370              	 pc
 371 02e4 08709085 		bx	ip
 372              		.loc 1 863 0
 373              		mov	lr, #0
 374 02e8 1D00008A 		.loc 1 837 0
 375 02ec 240000EA 		cmp	r0, lr
 376              		.loc 1 865 0
 377              		mov	r1, r6
 378              		mov	r2, #2
 834:../lib/fat16.c ****             )
 835:../lib/fat16.c ****             return 0;
 836:../lib/fat16.c **** 			///*
 837:../lib/fat16.c **** 			//**********************************************************
 379              	r4
 380 02f0 003095E5 		.loc 1 837 0
 381              		beq	.L46
 382 02f4 00C093E5 		.loc 1 842 0
 383 02f8 0FE0A0E1 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 384 02fc 1CFF2FE1 		ldrb	ip, [sp, #3]	@ zero_extendqisi2
 838:../lib/fat16.c ****         //if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
 839:../lib/fat16.c ****             //    (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
 840:../lib/fat16.c ****             //   )
 841:../lib/fat16.c **** 			if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN)
 842:../lib/fat16.c **** 			//***********************************************************
 843:../lib/fat16.c **** 			//*/
 844:../lib/fat16.c ****             cluster_num_next = 0;
 845:../lib/fat16.c ****     
 846:../lib/fat16.c ****             /* free cluster */
 847:../lib/fat16.c ****             buffer[0] = FAT16_CLUSTER_FREE & 0xff;
 848:../lib/fat16.c ****             buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
 849:../lib/fat16.c ****             fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
 850:../lib/fat16.c ****     
 851:../lib/fat16.c ****             /* We continue in any case here, even if freeing the cluster failed.
 852:../lib/fat16.c ****                                              * The cluster is lost, but maybe we can still free up 
 853:../lib/fat16.c ****                                              */
 854:../lib/fat16.c ****     
 855:../lib/fat16.c ****             cluster_num = cluster_num_next;
 856:../lib/fat16.c ****         }
 857:../lib/fat16.c ****     
 858:../lib/fat16.c ****         return 1;
 859:../lib/fat16.c ****     #else
 860:../lib/fat16.c ****         return 0;
 861:../lib/fat16.c ****     #endif
 862:../lib/fat16.c **** }
 863:../lib/fat16.c **** 
 385              	1 844 0
 386 0300 00E0A0E3 		orrs	r3, r3, ip, asl #8
 387              		.loc 1 842 0
 388 0304 0E0050E1 		mov	r4, r3
 864:../lib/fat16.c **** * Frees a part of a cluster chain and correctly terminates the rest.
 865:../lib/fat16.c ****  *
 389              	37:
 390 0308 0610A0E1 		.loc 1 846 0
 391 030c 0220A0E3 		add	r3, r3, #16
 392 0310 0400A0E1 		mov	r3, r3, asl #16
 393              		.loc 1 844 0
 394 0314 1A00000A 		beq	.L51
 395              		.loc 1 846 0
 396 0318 0230DDE5 		cmp	r3, #458752
 397 031c 03C0DDE5 		bls	.L46
 398              		.loc 1 857 0
 399 0320 0C3493E1 		ldr	r3, .L58
 400              		.loc 1 864 0
 401 0324 0340A0E1 		strb	lr, [sp, #3]
 402              		.loc 1 863 0
 403              		strb	lr, [sp, #2]
 404 0328 103083E2 		.loc 1 857 0
 405 032c 0338A0E1 		cmp	r4, r3
 406              		movhi	r4, lr
 407 0330 1500000A 		.loc 1 865 0
 408              		ldr	r3, [r5, #0]
 409 0334 070853E3 		ldr	ip, [r3, #8]
 410 0338 1100009A 		mov	lr, pc
 411              		bx	ip
 412 033c 58309FE5 		mov	r3, r4
 413              	.LVL38:
 414 0340 03E0CDE5 	.L48:
 415              		.loc 1 837 0
 416 0344 02E0CDE5 		add	r4, r7, r3, asl #1
 417              	.LVL39:
 418 0348 030054E1 		add	r6, sp, #2
 419 034c 0E40A081 	.LBE14:
 420              		.loc 1 835 0
 421 0350 003095E5 		cmp	r3, #0
 422 0354 08C093E5 	.LBB15:
 423 0358 0FE0A0E1 		.loc 1 837 0
 424 035c 1CFF2FE1 		mov	r1, r6
 425 0360 0430A0E1 		mov	r2, #2
 426              		mov	r0, r4
 427              	.LBE15:
 428              		.loc 1 835 0
 429 0364 834087E0 		bne	.L49
 430              		b	.L51
 431 0368 02608DE2 	.LVL40:
 432              	.L46:
 433              		mov	r0, #0
 434 036c 000053E3 		b	.L56
 435              	.L51:
 436              		mov	r0, #1
 437 0370 0610A0E1 	.L56:
 438 0374 0220A0E3 		.loc 1 878 0
 439 0378 0400A0E1 		add	sp, sp, #4
 440              		ldmfd	sp!, {r4, r5, r6, r7, lr}
 441              		bx	lr
 442 037c DBFFFF1A 	.L59:
 443 0380 010000EA 		.align	2
 444              	.L58:
 445              		.word	65527
 446 0384 0000A0E3 	.LFE13:
 448              		.align	2
 450              	fat16_append_clusters:
 866:../lib/fat16.c ****  Marks the specified cluster as the new end of a cluster chain and
 867:../lib/fat16.c ****  * frees all following clusters.
 868:../lib/fat16.c ****  *
 869:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 870:../lib/fat16.c ****  * \param[in] cluster_num The new end of the cluster chain.
 871:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 872:../lib/fat16.c ****  * \see fat16_free_clusters
 873:../lib/fat16.c ****  */
 874:../lib/fat16.c **** uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 875:../lib/fat16.c **** {
 876:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 877:../lib/fat16.c ****         if(!fs || cluster_num < 2)
 878:../lib/fat16.c ****             return 0;
 451              	gs = 0, pretend = 0, frame = 20
 452 0390 04D08DE2 		@ frame_needed = 0, uses_anonymous_args = 0
 453 0394 F040BDE8 	.LVL41:
 454 0398 1EFF2FE1 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 455              	.LCFI5:
 456              		mov	r1, r1, asl #16
 457              	.LVL42:
 458 039c F7FF0000 		sub	sp, sp, #20
 459              	.LCFI6:
 460              		.loc 1 735 0
 461              		mov	r2, r2, asl #16
 462              	.LVL43:
 463              		mov	r1, r1, lsr #16
 464              		.loc 1 737 0
 465              		subs	r7, r0, #0
 466              		.loc 1 735 0
 467              		str	r1, [sp, #0]
 468              	.LVL44:
 469              		mov	r9, r2, lsr #16
 470 03a0 F04F2DE9 	.LVL45:
 471              		.loc 1 737 0
 472 03a4 0118A0E1 		beq	.L61
 473              	.LVL46:
 474 03a8 14D04DE2 		.loc 1 740 0
 475              		ldr	r2, [r7, #0]
 476              		.loc 1 743 0
 477 03ac 0228A0E1 		ldr	r3, [r7, #12]
 478              		.loc 1 741 0
 479 03b0 2118A0E1 		ldr	r1, [r2, #8]
 480              		.loc 1 743 0
 481 03b4 007050E2 		mov	r3, r3, asl #15
 482              		mov	r4, #0
 483 03b8 00108DE5 	.LVL47:
 484              		.loc 1 740 0
 485 03bc 2298A0E1 		ldr	r2, [r2, #0]
 486              		.loc 1 742 0
 487              		ldr	fp, [r7, #8]
 488 03c0 4E00000A 	.LVL48:
 489              		.loc 1 743 0
 490              		mov	r3, r3, lsr #16
 491 03c4 002097E5 		mov	r5, r9
 492              	.LVL49:
 493 03c8 0C3097E5 		mov	sl, r4
 494              		.loc 1 741 0
 495 03cc 081092E5 		str	r1, [sp, #8]
 496              	.LVL50:
 497 03d0 8337A0E1 		.loc 1 740 0
 498 03d4 0040A0E3 		str	r2, [sp, #4]
 499              	.LVL51:
 500              		.loc 1 743 0
 501 03d8 002092E5 		str	r3, [sp, #12]
 502              	.LVL52:
 503 03dc 08B097E5 		b	.L63
 504              	.LVL53:
 505              	.L64:
 506 03e0 2338A0E1 		.loc 1 750 0
 507 03e4 0950A0E1 		add	r8, fp, r6, asl #1
 508              		mov	r0, r8
 509 03e8 04A0A0E1 		add	r1, sp, #18
 510              		mov	r2, #2
 511 03ec 08108DE5 		ldr	r3, [sp, #4]
 512              		mov	lr, pc
 513              		bx	r3
 514 03f0 04208DE5 		cmp	r0, #0
 515              		beq	.L61
 516              		.loc 1 754 0
 517 03f4 0C308DE5 		ldrb	r3, [sp, #18]	@ zero_extendqisi2
 518              		cmp	r3, #0
 519 03f8 230000EA 		bne	.L66
 520              		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 521              		cmp	r3, #0
 522              		bne	.L66
 523 03fc 86808BE0 		.loc 1 758 0
 524 0400 0800A0E1 		cmp	r5, r9
 525 0404 12108DE2 		.loc 1 760 0
 526 0408 0220A0E3 		mvneq	r3, #0
 527 040c 04309DE5 		.loc 1 766 0
 528 0410 0FE0A0E1 		movne	r3, r4, lsr #8
 529 0414 13FF2FE1 		.loc 1 761 0
 530 0418 000050E3 		streqb	r3, [sp, #19]
 531 041c 3700000A 		.loc 1 760 0
 532              		streqb	r3, [sp, #18]
 533 0420 1230DDE5 		.loc 1 766 0
 534 0424 000053E3 		strneb	r3, [sp, #19]
 535 0428 1600001A 		.loc 1 765 0
 536 042c 1330DDE5 		strneb	r4, [sp, #18]
 537 0430 000053E3 		.loc 1 769 0
 538 0434 1300001A 		mov	r0, r8
 539              		add	r1, sp, #18
 540 0438 090055E1 		mov	r2, #2
 541              		ldr	r3, [sp, #8]
 542 043c 0030E003 		mov	lr, pc
 543              		bx	r3
 544 0440 2434A011 		cmp	r0, #0
 545              		beq	.L72
 546 0444 1330CD05 		.loc 1 773 0
 547              		sub	r3, r5, #1
 548 0448 1230CD05 		mov	r3, r3, asl #16
 549              		movs	r5, r3, lsr #16
 550 044c 1330CD15 		beq	.L82
 551              		mov	r4, r6
 552 0450 1240CD15 	.L66:
 553              		add	sl, sl, #1
 554 0454 0800A0E1 	.LVL54:
 555 0458 12108DE2 	.L63:
 556 045c 0220A0E3 		.loc 1 748 0
 557 0460 08309DE5 		ldr	r1, [sp, #12]
 558 0464 0FE0A0E1 		.loc 1 773 0
 559 0468 13FF2FE1 		mov	r3, sl, asl #16
 560 046c 000050E3 		.loc 1 748 0
 561 0470 0A00000A 		cmp	sl, r1
 562              		.loc 1 773 0
 563 0474 013045E2 		mov	r6, r3, lsr #16
 564 0478 0338A0E1 		.loc 1 748 0
 565 047c 2358B0E1 		bne	.L64
 566 0480 1900000A 	.L72:
 567 0484 0640A0E1 		.loc 1 780 0
 568              		cmp	r5, #0
 569 0488 01A08AE2 		bne	.L77
 570              	.L76:
 571              		.loc 1 786 0
 572              		ldr	r3, [sp, #0]
 573 048c 0C109DE5 		cmp	r3, #1
 574              		bls	.L78
 575 0490 0A38A0E1 		.loc 1 790 0
 576              		ldr	r1, [sp, #0]
 577 0494 01005AE1 		.loc 1 789 0
 578              		mov	r3, r4, lsr #8
 579 0498 2368A0E1 		strb	r3, [sp, #19]
 580              		.loc 1 790 0
 581 049c D6FFFF1A 		add	r0, fp, r1, asl #1
 582              		.loc 1 788 0
 583              		strb	r4, [sp, #18]
 584 04a0 000055E3 		.loc 1 790 0
 585 04a4 1200001A 		add	r1, sp, #18
 586              		mov	r2, #2
 587              		ldr	r3, [sp, #8]
 588 04a8 00309DE5 		mov	lr, pc
 589 04ac 010053E3 		bx	r3
 590 04b0 0B00009A 		cmp	r0, #0
 591              		beq	.L77
 592 04b4 00109DE5 	.LVL55:
 593              	.L78:
 594 04b8 2434A0E1 		.loc 1 794 0
 595 04bc 1330CDE5 		mov	r0, r4
 596              		b	.L80
 597 04c0 81008BE0 	.L82:
 598              		.loc 1 773 0
 599 04c4 1240CDE5 		mov	r4, r6
 600              		b	.L76
 601 04c8 12108DE2 	.LVL56:
 602 04cc 0220A0E3 	.L77:
 603 04d0 08309DE5 		.loc 1 802 0
 604 04d4 0FE0A0E1 		mov	r0, r7
 605 04d8 13FF2FE1 		mov	r1, r4
 606 04dc 000050E3 		bl	fat16_free_clusters
 607 04e0 0300000A 	.LVL57:
 608              	.L61:
 609              		.loc 1 804 0
 610              		mov	r0, #0
 611 04e4 0400A0E1 	.L80:
 612 04e8 050000EA 		.loc 1 808 0
 613              		add	sp, sp, #20
 614              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 615 04ec 0640A0E1 		bx	lr
 616 04f0 ECFFFFEA 	.LFE12:
 618              		.global	__umodsi3
 619              		.align	2
 620 04f4 0700A0E1 		.global	fat16_read_file
 622 04fc 71FFFFEB 	fat16_read_file:
 623              	.LFB17:
 624              		.loc 1 970 0
 625              		@ Function supports interworking.
 626 0500 0000A0E3 		@ args = 0, pretend = 0, frame = 0
 627              		@ frame_needed = 0, uses_anonymous_args = 0
 628              	.LVL58:
 629 0504 14D08DE2 		mov	r2, r2, asl #16
 630 0508 F04FBDE8 	.LVL59:
 631 050c 1EFF2FE1 		.loc 1 972 0
 632              		cmp	r1, #0
 633              		cmpne	r0, #0
 634              		.loc 1 970 0
 635              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 636              	.LCFI7:
 637              		.loc 1 972 0
 638              		mov	r6, r0
 639              		mov	fp, r1
 879:../lib/fat16.c **** /* fetch next cluster before overwriting the cluster entry */
 880:../lib/fat16.c ****         uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
 881:../lib/fat16.c ****     
 882:../lib/fat16.c ****         /* mark cluster as the last one */
 883:../lib/fat16.c ****         uint8_t buffer[2];
 884:../lib/fat16.c ****         buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 885:../lib/fat16.c ****         buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 886:../lib/fat16.c ****         if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
 887:../lib/fat16.c ****             return 0;
 888:../lib/fat16.c ****     
 889:../lib/fat16.c ****         /* free remaining clusters */
 890:../lib/fat16.c ****         if(cluster_num_next)
 891:../lib/fat16.c ****             return fat16_free_clusters(fs, cluster_num_next);
 892:../lib/fat16.c ****         else
 893:../lib/fat16.c ****             return 1;
 894:../lib/fat16.c ****     #else
 895:../lib/fat16.c ****         return 0;
 896:../lib/fat16.c ****     #endif
 897:../lib/fat16.c **** }
 898:../lib/fat16.c **** 
 899:../lib/fat16.c **** /**
 900:../lib/fat16.c ****  * \ingroup fat16_file
 901:../lib/fat16.c ****  * Opens a file on a FAT16 filesystem.
 902:../lib/fat16.c ****  *
 903:../lib/fat16.c ****  * \param[in] fs The filesystem on which the file to open lies.
 904:../lib/fat16.c ****  * \param[in] dir_entry The directory entry of the file to open.
 905:../lib/fat16.c ****  * \returns The file handle, or 0 on failure.
 906:../lib/fat16.c ****  * \see fat16_close_file
 907:../lib/fat16.c ****  */
 908:../lib/fat16.c **** struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_
 909:../lib/fat16.c **** {
 910:../lib/fat16.c ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
 911:../lib/fat16.c ****         return 0;
 912:../lib/fat16.c **** 
 913:../lib/fat16.c ****     struct fat16_file_struct* fd = malloc(sizeof(*fd));
 914:../lib/fat16.c ****     if(!fd)
 915:../lib/fat16.c ****         return 0;
 916:../lib/fat16.c **** 
 917:../lib/fat16.c ****     memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
 918:../lib/fat16.c ****     fd->fs = fs;
 919:../lib/fat16.c ****     fd->pos = 0;
 920:../lib/fat16.c ****     fd->pos_cluster = dir_entry->cluster;
 921:../lib/fat16.c **** 
 922:../lib/fat16.c ****     return fd;
 923:../lib/fat16.c **** }
 924:../lib/fat16.c **** 
 925:../lib/fat16.c **** /**
 926:../lib/fat16.c ****  * \ingroup fat16_file
 927:../lib/fat16.c ****  * Closes a file.
 928:../lib/fat16.c ****  *
 929:../lib/fat16.c ****  * \param[in] fd The file handle of the file to close.
 930:../lib/fat16.c ****  * \see fat16_open_file
 931:../lib/fat16.c ****  */
 932:../lib/fat16.c **** void fat16_close_file(struct fat16_file_struct* fd)
 933:../lib/fat16.c **** {
 934:../lib/fat16.c ****     if(fd)
 935:../lib/fat16.c ****         free(fd);
 936:../lib/fat16.c **** }
 937:../lib/fat16.c **** 
 938:../lib/fat16.c **** /**
 939:../lib/fat16.c ****  * \ingroup fat16_file
 940:../lib/fat16.c ****  * Reads data from a file.
 941:../lib/fat16.c ****  *
 942:../lib/fat16.c ****  * The data requested is read from the current file location.
 943:../lib/fat16.c ****  *
 944:../lib/fat16.c ****  * \param[in] fd The file handle of the file from which to read.
 945:../lib/fat16.c ****  * \param[out] buffer The buffer into which to write.
 946:../lib/fat16.c ****  * \param[in] buffer_len The amount of data to read.
 947:../lib/fat16.c ****  * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 948:../lib/fat16.c ****  * \see fat16_write_file
 949:../lib/fat16.c ****  */
 950:../lib/fat16.c **** int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
 951:../lib/fat16.c **** {
 952:../lib/fat16.c ****     /* check arguments */
 953:../lib/fat16.c ****     if(!fd || !buffer || buffer_len < 1)
 954:../lib/fat16.c ****         return -1;
 955:../lib/fat16.c **** 
 956:../lib/fat16.c ****     /* determine number of bytes to read */
 957:../lib/fat16.c ****     if(fd->pos + buffer_len > fd->dir_entry.file_size)
 958:../lib/fat16.c ****         buffer_len = fd->dir_entry.file_size - fd->pos;
 959:../lib/fat16.c ****     if(buffer_len == 0)
 960:../lib/fat16.c ****         return 0;
 961:../lib/fat16.c **** 
 962:../lib/fat16.c ****     uint16_t cluster_size = fd->fs->header.cluster_size;
 963:../lib/fat16.c ****     uint16_t cluster_num = fd->pos_cluster;
 964:../lib/fat16.c ****     uint16_t buffer_left = buffer_len;
 965:../lib/fat16.c ****     uint16_t first_cluster_offset = fd->pos % cluster_size;
 966:../lib/fat16.c **** 
 967:../lib/fat16.c ****     /* find cluster in which to start reading */
 968:../lib/fat16.c ****     if(!cluster_num)
 969:../lib/fat16.c ****     {
 970:../lib/fat16.c ****         cluster_num = fd->dir_entry.cluster;
 640              		.L87
 641              	.LVL63:
 642              		.loc 1 977 0
 643              		rsb	r3, r7, r2
 644              		mov	r3, r3, asl #16
 645 0510 0228A0E1 		.loc 1 978 0
 646              		movs	r8, r3, lsr #16
 971:../lib/fat16.c ****        else
 972:../lib/fat16.c ****                 return -1;
 647              	89
 648 0514 000051E3 	.L87:
 649 0518 00005013 		.loc 1 982 0
 650              		ldrh	r5, [r6, #52]
 651 051c F04F2DE9 	.LVL64:
 652              		.loc 1 981 0
 653              		ldr	r3, [r6, #0]
 654 0520 0060A0E1 		.loc 1 987 0
 655 0524 01B0A0E1 		cmp	r5, #0
 656              		.loc 1 981 0
 657 0528 2288A0E1 		ldrh	r9, [r3, #18]
 658              	.LVL65:
 659              		.loc 1 987 0
 660 052c 5000000A 		bne	.L90
 661              	.LVL66:
 662 0530 000058E3 		.loc 1 989 0
 663 0534 4E00000A 		ldrh	r5, [r6, #38]
 973:../lib/fat16.c ****       }
 974:../lib/fat16.c **** 
 975:../lib/fat16.c ****         if(fd->pos)
 976:../lib/fat16.c ****         {
 664              	p	r5, #0
 665 0538 307090E5 		bne	.L92
 666              		.loc 1 993 0
 667 053c 282090E5 		cmp	r7, #0
 668 0540 083087E0 		beq	.L89
 669 0544 020053E1 		b	.L84
 670 0548 0300009A 	.L92:
 671              		.loc 1 999 0
 977:../lib/fat16.c ****         uint32_t pos = fd->pos;
 672              	 #0
 673 054c 023067E0 		movne	r4, r7
 674 0550 0338A0E1 	.LVL67:
 978:../lib/fat16.c ****            while(pos >= cluster_size)
 675              	e	.L95
 676 0554 2388B0E1 		b	.L90
 677 0558 5000000A 	.LVL68:
 678              	.L96:
 979:../lib/fat16.c ****            {
 980:../lib/fat16.c ****                 pos -= cluster_size;
 981:../lib/fat16.c ****                 cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
 982:../lib/fat16.c ****                 if(!cluster_num)
 679              	16:
 680 055c B453D6E1 		.loc 1 1005 0
 681              		ldr	r0, [r6, #0]
 682              		bl	fat16_get_next_cluster
 683 0560 003096E5 	.LVL69:
 983:../lib/fat16.c ****                 return -1;
 984:../lib/fat16.c ****             }
 985:../lib/fat16.c ****         }
 986:../lib/fat16.c ****     }
 987:../lib/fat16.c **** 
 684              	 1 1006 0
 685 0564 000055E3 		subs	r5, r0, #0
 686              		beq	.L84
 687 0568 B291D3E1 	.LVL70:
 688              	.L95:
 689              		.loc 1 1002 0
 690 056c 1100001A 		cmp	r4, r9
 691              		.loc 1 1005 0
 988:../lib/fat16.c **** * read data */
 989:../lib/fat16.c ****     do
 692              	 r5
 693 0570 B652D6E1 		.loc 1 1006 0
 990:../lib/fat16.c ****   {
 991:../lib/fat16.c ****         /* calculate data size to copy from cluster */
 694              	sb	r4, r9, r4
 695 0574 000055E3 		.loc 1 1002 0
 696 0578 0200001A 		bcs	.L96
 992:../lib/fat16.c ****       uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
 993:../lib/fat16.c ****         (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
 697              	L71:
 698 057c 000057E3 	.L90:
 699 0580 4600000A 	.LBE16:
 700 0584 3A0000EA 		.loc 1 984 0
 701              		mov	r0, r7
 994:../lib/fat16.c ****       uint16_t copy_length = cluster_size - first_cluster_offset;
 995:../lib/fat16.c ****         if(copy_length > buffer_left)
 996:../lib/fat16.c ****             copy_length = buffer_left;
 997:../lib/fat16.c **** 
 998:../lib/fat16.c ****         /* read data */
 999:../lib/fat16.c ****         if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
 702              	r1, r9
 703 0588 000057E3 		bl	__umodsi3
 704 058c 0740A011 		mov	r0, r0, asl #16
 705              		mov	sl, r0, lsr #16
 706 0590 0400001A 	.LVL72:
 707 0594 070000EA 		mov	r7, r8
 708              	.LVL73:
 709              	.LVL74:
 710              	.L98:
1000:../lib/fat16.c ****       return buffer_len - buffer_left;
1001:../lib/fat16.c **** 
1002:../lib/fat16.c ****         /* calculate new file position */
1003:../lib/fat16.c ****         buffer += copy_length;
1004:../lib/fat16.c ****         buffer_left -= copy_length;
1005:../lib/fat16.c ****         fd->pos += copy_length;
 711              	.loc 1 1018 0
 712 0598 000096E5 		rsb	r3, sl, r9
 713 059c 1FFFFFEB 		.loc 1 1017 0
 714              		ldr	ip, [r6, #0]
1006:../lib/fat16.c ****    if(first_cluster_offset + copy_length >= cluster_size)
 715              	c 1 1018 0
 716 05a0 005050E2 		mov	r3, r3, asl #16
 717 05a4 3200000A 		mov	r3, r3, lsr #16
 718              	.LVL75:
 719              		cmp	r7, r3
 720              		movcc	r3, r7
 721 05a8 090054E1 	.LVL76:
 722              		.loc 1 1023 0
 723 05ac 0510A0E1 		ldr	r2, [ip, #24]
 724              		.loc 1 1018 0
 725 05b0 044069E0 		mov	r3, r3, asl #16
 726              		mov	r4, r3, lsr #16
 727 05b4 F7FFFF2A 	.LVL77:
 728              		.loc 1 1023 0
 729              		add	r2, sl, r2
 730              		sub	r3, r5, #2
 731              		mla	r0, r9, r3, r2
 732 05b8 0700A0E1 		mov	r1, fp
 733 05bc 0910A0E1 		mov	r2, r4
 734 05c0 FEFFFFEB 		ldr	r3, [ip, #0]
 735 05c4 0008A0E1 		ldr	ip, [r3, #0]
 736 05c8 20A8A0E1 		mov	lr, pc
 737              		bx	ip
 738 05cc 0870A0E1 		.loc 1 1028 0
 739              		rsb	r3, r4, r7
 740              		.loc 1 1023 0
 741              		cmp	r0, #0
 742              		.loc 1 1034 0
1007:../lib/fat16.c ****        {
1008:../lib/fat16.c ****             /* we are on a cluster boundary, so get the next cluster */
1009:../lib/fat16.c ****             if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
1010:../lib/fat16.c ****             {
1011:../lib/fat16.c ****                 first_cluster_offset = 0;
1012:../lib/fat16.c ****             }
1013:../lib/fat16.c ****             else
1014:../lib/fat16.c ****             {
1015:../lib/fat16.c ****                 fd->pos_cluster = 0;
1016:../lib/fat16.c ****                 return buffer_len - buffer_left;
1017:../lib/fat16.c ****             }
1018:../lib/fat16.c ****         }
 743              	add	fp, fp, r4
 744 05d0 09306AE0 		.loc 1 1031 0
 745              		add	r2, sl, r4
 746 05d4 00C096E5 		.loc 1 1028 0
 747              		mov	r0, r3, asl #16
 748 05d8 0338A0E1 		.loc 1 1023 0
 749 05dc 2338A0E1 		beq	.L109
 750              		.loc 1 1029 0
 751 05e0 030057E1 		ldr	r3, [r6, #48]
 752 05e4 0730A031 		.loc 1 1031 0
 753              		cmp	r2, r9
1019:../lib/fat16.c **** >pos_cluster = cluster_num;
1020:../lib/fat16.c **** 
1021:../lib/fat16.c ****     }
1022:../lib/fat16.c ****     while(buffer_left > 0); /* check if we are done */
1023:../lib/fat16.c **** 
 754              	9 0
 755 05e8 18209CE5 		add	r3, r3, r4
 756              		str	r3, [r6, #48]
 757 05ec 0338A0E1 		.loc 1 1028 0
 758 05f0 2348A0E1 		mov	r7, r0, lsr #16
 759              		.loc 1 1031 0
 760              		blt	.L102
 761 05f4 02208AE0 		.loc 1 1034 0
 762 05f8 023045E2 		ldr	r0, [r6, #0]
 763 05fc 992320E0 		bl	fat16_get_next_cluster
 764 0600 0B10A0E1 		subs	r5, r0, #0
 765 0604 0420A0E1 		.loc 1 1041 0
 766 0608 00309CE5 		mov	sl, #0
 767 060c 00C093E5 		.loc 1 1034 0
 768 0610 0FE0A0E1 		beq	.L110
 769 0614 1CFF2FE1 	.L102:
1024:../lib/fat16.c **** eturn buffer_len;
1025:../lib/fat16.c **** }
1026:../lib/fat16.c **** 
1027:../lib/fat16.c **** /**
1028:../lib/fat16.c ****  * \ingroup fat16_file
 770              	1048 0
 771 0618 073064E0 		cmp	r7, #0
 772              	.LBB18:
 773 061c 000050E3 		.loc 1 1045 0
1029:../lib/fat16.c **** ites data to a file.
1030:../lib/fat16.c ****  *
1031:../lib/fat16.c ****  * The data is written to the current file location.
1032:../lib/fat16.c ****  *
1033:../lib/fat16.c ****  * \param[in] fd The file handle of the file to which to write.
1034:../lib/fat16.c ****  * \param[in] buffer The buffer from which to read the data to be written.
 774              	h	r5, [r6, #52]	@ movhi
 775 0620 0510A0E1 	.LBE18:
 776              		.loc 1 1048 0
 777 0624 04B08BE0 		bne	.L98
 778              		.loc 1 1050 0
 779 0628 04208AE0 		mov	r3, r8, asl #16
 780              		b	.L111
 781 062c 0308A0E1 	.LVL78:
 782              	.L84:
 783 0630 1100000A 		mvn	r0, #0
 784              		b	.L101
 785 0634 303096E5 	.LVL79:
 786              	.L109:
 787 0638 090052E1 	.LBB19:
 788              		.loc 1 1024 0
 789 063c 043083E0 		rsb	r3, r7, r8
 790 0640 303086E5 		mov	r3, r3, asl #16
 791              	.L111:
 792 0644 2078A0E1 		mov	r0, r3, asr #16
 793              		b	.L101
 794 0648 040000BA 	.L110:
 795              		.loc 1 1041 0
 796 064c 000096E5 		rsb	r3, r7, r8
 797 0650 F2FEFFEB 		mov	r3, r3, asl #16
 798 0654 005050E2 		mov	r0, r3, asr #16
1035:../lib/fat16.c **** ram[in] buffer_len The amount of data to write.
1036:../lib/fat16.c ****  * \returns The number of bytes written, 0 on disk full, or -1 on failure.
1037:../lib/fat16.c ****  * \see fat16_read_file
1038:../lib/fat16.c ****  */
1039:../lib/fat16.c **** int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
1040:../lib/fat16.c **** {
1041:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 799              	[r6, #52]	@ movhi
 800 0658 00A0A0E3 		b	.L101
 801              	.LVL80:
 802 065c 0A00000A 	.L89:
 803              	.LBE19:
 804              		.loc 1 1050 0
1042:../lib/fat16.c ****  /* check arguments */
1043:../lib/fat16.c ****         if(!fd || !buffer || buffer_len < 1)
1044:../lib/fat16.c ****             return -1;
1045:../lib/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1046:../lib/fat16.c ****             return -1;
1047:../lib/fat16.c ****     
1048:../lib/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
 805              	0, #0
 806 0660 000057E3 	.LVL81:
 807              	.L101:
 808              		.loc 1 1051 0
 809 0664 B453C6E1 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810              		bx	lr
 811              	.LFE17:
1049:../lib/fat16.c ****  uint16_t cluster_num = fd->pos_cluster;
1050:../lib/fat16.c ****         uint16_t buffer_left = buffer_len;
 813              	2
 814 066c 0838A0E1 		.global	fat16_reset_dir
 816              	fat16_reset_dir:
 817              	.LFB24:
 818 0674 0000E0E3 		.loc 1 1439 0
 819 0678 090000EA 		@ Function supports interworking.
 820              		@ args = 0, pretend = 0, frame = 0
 821              		@ frame_needed = 0, uses_anonymous_args = 0
 822              		@ link register save eliminated.
 823              	.LVL82:
 824 067c 083067E0 		.loc 1 1440 0
 825 0680 0338A0E1 		cmp	r0, #0
 826              		mov	r3, r0
 827 0684 4308A0E1 		.loc 1 1443 0
 828 0688 050000EA 		movne	r3, #0	@ movhi
 829              		strneh	r3, [r0, #48]	@ movhi
 830              		movne	r3, #1
 831 068c 083067E0 		.loc 1 1445 0
 832 0690 0338A0E1 		mov	r0, r3
 833 0694 4308A0E1 	.LVL83:
 834              		.loc 1 1439 0
 835 0698 B453C6E1 		@ lr needed for prologue
 836 069c 000000EA 		.loc 1 1445 0
 837              		bx	lr
 838              	.LFE24:
 840              		.align	2
 841 06a0 0000A0E3 		.global	fat16_delete_file
 843              	fat16_delete_file:
1051:../lib/fat16.c ****       uint16_t first_cluster_offset = fd->pos % cluster_size;
 844              	ion supports interworking.
 845 06a4 F04FBDE8 		@ args = 0, pretend = 0, frame = 12
 846 06a8 1EFF2FE1 		@ frame_needed = 0, uses_anonymous_args = 0
 847              	.LVL84:
 848              		stmfd	sp!, {r4, r5, r6, r7, lr}
 849              	.LCFI8:
 850              		.loc 1 1804 0
 851              		cmp	r1, #0
 852              		cmpne	r0, #0
 853              		.loc 1 1802 0
1052:../lib/fat16.c ****    
1053:../lib/fat16.c ****         /* find cluster in which to start writing */
1054:../lib/fat16.c ****         if(!cluster_num)
1055:../lib/fat16.c ****         {
1056:../lib/fat16.c ****             cluster_num = fd->dir_entry.cluster;
1057:../lib/fat16.c ****     
1058:../lib/fat16.c ****             if(!cluster_num)
1059:../lib/fat16.c ****             {
1060:../lib/fat16.c ****                 if(!fd->pos)
1061:../lib/fat16.c ****                 {
1062:../lib/fat16.c ****                     /* empty file */
1063:../lib/fat16.c ****                     fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
1064:../lib/fat16.c ****                     if(!cluster_num)
1065:../lib/fat16.c ****                         return -1;
1066:../lib/fat16.c ****                 }
1067:../lib/fat16.c ****                 else
1068:../lib/fat16.c ****                 {
1069:../lib/fat16.c ****                     return -1;
1070:../lib/fat16.c ****                 }
1071:../lib/fat16.c ****             }
1072:../lib/fat16.c ****     
1073:../lib/fat16.c ****             if(fd->pos)
1074:../lib/fat16.c ****             {
1075:../lib/fat16.c ****                 uint32_t pos = fd->pos;
1076:../lib/fat16.c ****                 uint16_t cluster_num_next;
1077:../lib/fat16.c ****                 while(pos >= cluster_size)
1078:../lib/fat16.c ****                 {
1079:../lib/fat16.c ****                     pos -= cluster_size;
1080:../lib/fat16.c ****                     cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1081:../lib/fat16.c ****                     if(!cluster_num_next && pos == 0)
1082:../lib/fat16.c ****         /* the file exactly ends on a cluster boundary, and we append to it */
1083:../lib/fat16.c ****                         cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1084:../lib/fat16.c ****                     if(!cluster_num_next)
1085:../lib/fat16.c ****                         return -1;
1086:../lib/fat16.c ****     
1087:../lib/fat16.c ****                     cluster_num = cluster_num_next;
1088:../lib/fat16.c ****                 }
1089:../lib/fat16.c ****             }
1090:../lib/fat16.c ****         }
1091:../lib/fat16.c ****     
1092:../lib/fat16.c ****         /* write data */
1093:../lib/fat16.c ****         do
1094:../lib/fat16.c ****         {
1095:../lib/fat16.c ****             /* calculate data size to write to cluster */
1096:../lib/fat16.c ****             uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1097:../lib/fat16.c ****             (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1098:../lib/fat16.c ****             uint16_t write_length = cluster_size - first_cluster_offset;
1099:../lib/fat16.c ****             if(write_length > buffer_left)
1100:../lib/fat16.c ****                 write_length = buffer_left;
1101:../lib/fat16.c ****     
1102:../lib/fat16.c ****             /* write data which fits into the current cluster */
1103:../lib/fat16.c ****             if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1104:../lib/fat16.c ****                 break;
1105:../lib/fat16.c ****     
1106:../lib/fat16.c ****             /* calculate new file position */
1107:../lib/fat16.c ****             buffer += write_length;
1108:../lib/fat16.c ****             buffer_left -= write_length;
1109:../lib/fat16.c ****             fd->pos += write_length;
1110:../lib/fat16.c ****     
1111:../lib/fat16.c ****             if(first_cluster_offset + write_length >= cluster_size)
1112:../lib/fat16.c ****             {
1113:../lib/fat16.c ****                 /* we are on a cluster boundary, so get the next cluster */
1114:../lib/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1115:../lib/fat16.c ****                 if(!cluster_num_next && buffer_left > 0)
1116:../lib/fat16.c ****         /* we reached the last cluster, append a new one */
1117:../lib/fat16.c ****                     cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1118:../lib/fat16.c ****                 if(!cluster_num_next)
1119:../lib/fat16.c ****                 {
1120:../lib/fat16.c ****                     fd->pos_cluster = 0;
1121:../lib/fat16.c ****                     break;
1122:../lib/fat16.c ****                 }
1123:../lib/fat16.c ****     
1124:../lib/fat16.c ****                 cluster_num = cluster_num_next;
1125:../lib/fat16.c ****                 first_cluster_offset = 0;
1126:../lib/fat16.c ****             }
1127:../lib/fat16.c ****     
1128:../lib/fat16.c ****             fd->pos_cluster = cluster_num;
1129:../lib/fat16.c ****     
1130:../lib/fat16.c ****         }
1131:../lib/fat16.c ****         while(buffer_left > 0); /* check if we are done */
1132:../lib/fat16.c ****     
1133:../lib/fat16.c ****         /* update directory entry */
1134:../lib/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1135:../lib/fat16.c ****         {
1136:../lib/fat16.c ****             uint32_t size_old = fd->dir_entry.file_size;
1137:../lib/fat16.c ****     
1138:../lib/fat16.c ****             /* update file size */
1139:../lib/fat16.c ****             fd->dir_entry.file_size = fd->pos;
1140:../lib/fat16.c ****             /* write directory entry */
1141:../lib/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1142:../lib/fat16.c ****             {
1143:../lib/fat16.c ****                 /* We do not return an error here since we actually wrote
1144:../lib/fat16.c ****                                                              * some data to disk. So we calculate t
1145:../lib/fat16.c ****                                                              * we wrote to disk and which lies with
1146:../lib/fat16.c ****                                                              */
1147:../lib/fat16.c ****                 buffer_left = fd->pos - size_old;
1148:../lib/fat16.c ****                 fd->pos = size_old;
1149:../lib/fat16.c ****             }
1150:../lib/fat16.c ****         }
1151:../lib/fat16.c ****     
1152:../lib/fat16.c ****         return buffer_len - buffer_left;
1153:../lib/fat16.c ****     
1154:../lib/fat16.c ****     #else
1155:../lib/fat16.c ****         return -1;
1156:../lib/fat16.c ****     #endif
1157:../lib/fat16.c **** }
1158:../lib/fat16.c **** 
1159:../lib/fat16.c **** /**
1160:../lib/fat16.c ****  * \ingroup fat16_file
1161:../lib/fat16.c ****  * Repositions the read/write file offset.
1162:../lib/fat16.c ****  *
1163:../lib/fat16.c ****  * Changes the file offset where the next call to fat16_read_file()
1164:../lib/fat16.c ****  * or fat16_write_file() starts reading/writing.
1165:../lib/fat16.c ****  *
1166:../lib/fat16.c ****  * If the new offset is beyond the end of the file, fat16_resize_file()
1167:../lib/fat16.c ****  * is implicitly called, i.e. the file is expanded.
1168:../lib/fat16.c ****  *
1169:../lib/fat16.c ****  * The new offset can be given in different ways determined by
1170:../lib/fat16.c ****  * the \c whence parameter:
1171:../lib/fat16.c ****  * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
1172:../lib/fat16.c ****  * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
1173:../lib/fat16.c ****  * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
1174:../lib/fat16.c ****  *
1175:../lib/fat16.c ****  * The resulting absolute offset is written to the location the \c offset
1176:../lib/fat16.c ****  * parameter points to.
1177:../lib/fat16.c ****  *
1178:../lib/fat16.c ****  * \param[in] fd The file decriptor of the file on which to seek.
1179:../lib/fat16.c ****  * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1180:../lib/fat16.c ****  *                   parameter. The function writes the new absolute offset
1181:../lib/fat16.c ****  *                   to this location before it returns.
1182:../lib/fat16.c ****  * \param[in] whence Affects the way \c offset is interpreted, see above.
1183:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1184:../lib/fat16.c ****  */
1185:../lib/fat16.c **** uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
1186:../lib/fat16.c **** {
1187:../lib/fat16.c ****     if(!fd || !offset)
1188:../lib/fat16.c ****         return 0;
1189:../lib/fat16.c **** 
1190:../lib/fat16.c ****     uint32_t new_pos = fd->pos;
1191:../lib/fat16.c ****     switch(whence)
1192:../lib/fat16.c ****     {
1193:../lib/fat16.c ****         case FAT16_SEEK_SET:
1194:../lib/fat16.c ****             new_pos = *offset;
1195:../lib/fat16.c ****             break;
1196:../lib/fat16.c ****         case FAT16_SEEK_CUR:
1197:../lib/fat16.c ****             new_pos += *offset;
1198:../lib/fat16.c ****             break;
1199:../lib/fat16.c ****         case FAT16_SEEK_END:
1200:../lib/fat16.c ****             new_pos = fd->dir_entry.file_size + *offset;
1201:../lib/fat16.c ****             break;
1202:../lib/fat16.c ****         default:
1203:../lib/fat16.c ****             return 0;
1204:../lib/fat16.c ****     }
1205:../lib/fat16.c **** 
1206:../lib/fat16.c ****     if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
1207:../lib/fat16.c ****         return 0;
1208:../lib/fat16.c **** 
1209:../lib/fat16.c ****     fd->pos = new_pos;
1210:../lib/fat16.c ****     fd->pos_cluster = 0;
1211:../lib/fat16.c **** 
1212:../lib/fat16.c ****     *offset = new_pos;
1213:../lib/fat16.c ****     return 1;
1214:../lib/fat16.c **** }
1215:../lib/fat16.c **** 
1216:../lib/fat16.c **** /**
1217:../lib/fat16.c ****  * \ingroup fat16_file
1218:../lib/fat16.c ****  * Resizes a file to have a specific size.
1219:../lib/fat16.c ****  *
1220:../lib/fat16.c ****  * Enlarges or shrinks the file pointed to by the file descriptor to have
1221:../lib/fat16.c ****  * exactly the specified size.
1222:../lib/fat16.c ****  *
1223:../lib/fat16.c ****  * If the file is truncated, all bytes having an equal or larger offset
1224:../lib/fat16.c ****  * than the given size are lost. If the file is expanded, the additional
1225:../lib/fat16.c ****  * bytes are allocated.
1226:../lib/fat16.c ****  *
1227:../lib/fat16.c ****  * \note Please be aware that this function just allocates or deallocates disk
1228:../lib/fat16.c ****  * space, it does not explicitely clear it. To avoid data leakage, this
1229:../lib/fat16.c ****  * must be done manually.
1230:../lib/fat16.c ****  *
1231:../lib/fat16.c ****  * \param[in] fd The file decriptor of the file which to resize.
1232:../lib/fat16.c ****  * \param[in] size The new size of the file.
1233:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1234:../lib/fat16.c ****  */
1235:../lib/fat16.c **** uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
1236:../lib/fat16.c **** {
1237:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1238:../lib/fat16.c ****         if(!fd)
1239:../lib/fat16.c ****             return 0;
1240:../lib/fat16.c ****     
1241:../lib/fat16.c ****         uint16_t cluster_num = fd->dir_entry.cluster;
1242:../lib/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1243:../lib/fat16.c ****         uint32_t size_new = size;
1244:../lib/fat16.c ****     
1245:../lib/fat16.c ****         do
1246:../lib/fat16.c ****         {
1247:../lib/fat16.c ****             if(cluster_num == 0 && size_new == 0)
1248:../lib/fat16.c ****         /* the file stays empty */
1249:../lib/fat16.c ****                 break;
1250:../lib/fat16.c ****     
1251:../lib/fat16.c ****             /* seek to the next cluster as long as we need the space */
1252:../lib/fat16.c ****             while(size_new > cluster_size)
1253:../lib/fat16.c ****             {
1254:../lib/fat16.c ****                 /* get next cluster of file */
1255:../lib/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1256:../lib/fat16.c ****                 if(cluster_num_next)
1257:../lib/fat16.c ****                 {
1258:../lib/fat16.c ****                     cluster_num = cluster_num_next;
1259:../lib/fat16.c ****                     size_new -= cluster_size;
1260:../lib/fat16.c ****                 }
1261:../lib/fat16.c ****                 else
1262:../lib/fat16.c ****                 {
1263:../lib/fat16.c ****                     break;
1264:../lib/fat16.c ****                 }
1265:../lib/fat16.c ****             }
1266:../lib/fat16.c ****     
1267:../lib/fat16.c ****             if(size_new > cluster_size || cluster_num == 0)
1268:../lib/fat16.c ****             {
1269:../lib/fat16.c ****                 /* Allocate new cluster chain and append
1270:../lib/fat16.c ****                                                              * it to the existing one, if available
1271:../lib/fat16.c ****                                                              */
1272:../lib/fat16.c ****                 uint16_t cluster_count = size_new / cluster_size;
1273:../lib/fat16.c ****                 if((uint32_t) cluster_count * cluster_size < size_new)
1274:../lib/fat16.c ****                     ++cluster_count;
1275:../lib/fat16.c ****                 uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_cou
1276:../lib/fat16.c ****                 if(!cluster_new_chain)
1277:../lib/fat16.c ****                     return 0;
1278:../lib/fat16.c ****     
1279:../lib/fat16.c ****                 if(!cluster_num)
1280:../lib/fat16.c ****                 {
1281:../lib/fat16.c ****                     cluster_num = cluster_new_chain;
1282:../lib/fat16.c ****                     fd->dir_entry.cluster = cluster_num;
1283:../lib/fat16.c ****                 }
1284:../lib/fat16.c ****             }
1285:../lib/fat16.c ****     
1286:../lib/fat16.c ****             /* write new directory entry */
1287:../lib/fat16.c ****             fd->dir_entry.file_size = size;
1288:../lib/fat16.c ****             if(size == 0)
1289:../lib/fat16.c ****                 fd->dir_entry.cluster = 0;
1290:../lib/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1291:../lib/fat16.c ****                 return 0;
1292:../lib/fat16.c ****     
1293:../lib/fat16.c ****             if(size == 0)
1294:../lib/fat16.c ****             {
1295:../lib/fat16.c ****                 /* free all clusters of file */
1296:../lib/fat16.c ****                 fat16_free_clusters(fd->fs, cluster_num);
1297:../lib/fat16.c ****             }
1298:../lib/fat16.c ****             else if(size_new <= cluster_size)
1299:../lib/fat16.c ****             {
1300:../lib/fat16.c ****                 /* free all clusters no longer needed */
1301:../lib/fat16.c ****                 fat16_terminate_clusters(fd->fs, cluster_num);
1302:../lib/fat16.c ****             }
1303:../lib/fat16.c ****     
1304:../lib/fat16.c ****         }
1305:../lib/fat16.c ****         while(0);
1306:../lib/fat16.c ****     
1307:../lib/fat16.c ****         /* correct file position */
1308:../lib/fat16.c ****         if(size < fd->pos)
1309:../lib/fat16.c ****         {
1310:../lib/fat16.c ****             fd->pos = size;
1311:../lib/fat16.c ****             fd->pos_cluster = 0;
1312:../lib/fat16.c ****         }
1313:../lib/fat16.c ****     
1314:../lib/fat16.c ****         return 1;
1315:../lib/fat16.c ****     #else
1316:../lib/fat16.c ****         return 0;
1317:../lib/fat16.c ****     #endif
1318:../lib/fat16.c **** }
1319:../lib/fat16.c **** 
1320:../lib/fat16.c **** /**
1321:../lib/fat16.c ****  * \ingroup fat16_dir
1322:../lib/fat16.c ****  * Opens a directory.
1323:../lib/fat16.c ****  *
1324:../lib/fat16.c ****  * \param[in] fs The filesystem on which the directory to open resides.
1325:../lib/fat16.c ****  * \param[in] dir_entry The directory entry which stands for the directory to open.
1326:../lib/fat16.c ****  * \returns An opaque directory descriptor on success, 0 on failure.
1327:../lib/fat16.c ****  * \see fat16_close_dir
1328:../lib/fat16.c ****  */
1329:../lib/fat16.c **** struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_st
1330:../lib/fat16.c **** {
1331:../lib/fat16.c ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
1332:../lib/fat16.c ****         return 0;
1333:../lib/fat16.c **** 
1334:../lib/fat16.c ****     struct fat16_dir_struct* dd = malloc(sizeof(*dd));
1335:../lib/fat16.c ****     if(!dd)
1336:../lib/fat16.c ****         return 0;
1337:../lib/fat16.c **** 
1338:../lib/fat16.c ****     memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
1339:../lib/fat16.c ****     dd->fs = fs;
1340:../lib/fat16.c ****     dd->entry_next = 0;
1341:../lib/fat16.c **** 
1342:../lib/fat16.c ****     return dd;
1343:../lib/fat16.c **** }
1344:../lib/fat16.c **** 
1345:../lib/fat16.c **** /**
1346:../lib/fat16.c ****  * \ingroup fat16_dir
1347:../lib/fat16.c ****  * Closes a directory descriptor.
1348:../lib/fat16.c ****  *
1349:../lib/fat16.c ****  * This function destroys a directory descriptor which was
1350:../lib/fat16.c ****  * previously obtained by calling fat16_open_dir(). When this
1351:../lib/fat16.c ****  * function returns, the given descriptor will be invalid.
1352:../lib/fat16.c ****  *
1353:../lib/fat16.c ****  * \param[in] dd The directory descriptor to close.
1354:../lib/fat16.c ****  * \see fat16_open_dir
1355:../lib/fat16.c ****  */
1356:../lib/fat16.c **** void fat16_close_dir(struct fat16_dir_struct* dd)
1357:../lib/fat16.c **** {
1358:../lib/fat16.c ****     if(dd)
1359:../lib/fat16.c ****         free(dd);
1360:../lib/fat16.c **** }
1361:../lib/fat16.c **** 
1362:../lib/fat16.c **** /**
1363:../lib/fat16.c ****  * \ingroup fat16_dir
1364:../lib/fat16.c ****  * Reads the next directory entry contained within a parent directory.
1365:../lib/fat16.c ****  *
1366:../lib/fat16.c ****  * \param[in] dd The descriptor of the parent directory from which to read the entry.
1367:../lib/fat16.c ****  * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1368:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1369:../lib/fat16.c ****  * \see fat16_reset_dir
1370:../lib/fat16.c ****  */
1371:../lib/fat16.c **** uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
1372:../lib/fat16.c **** {
1373:../lib/fat16.c ****     if(!dd || !dir_entry)
1374:../lib/fat16.c ****         return 0;
1375:../lib/fat16.c **** 
1376:../lib/fat16.c ****     if(dd->dir_entry.cluster == 0)
1377:../lib/fat16.c ****     {
1378:../lib/fat16.c ****         /* read entry from root directory */
1379:../lib/fat16.c ****         if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
1380:../lib/fat16.c ****         {
1381:../lib/fat16.c ****             ++dd->entry_next;
1382:../lib/fat16.c ****             return 1;
1383:../lib/fat16.c ****         }
1384:../lib/fat16.c ****     }
1385:../lib/fat16.c ****     else
1386:../lib/fat16.c ****     {
1387:../lib/fat16.c ****         /* read entry from a subdirectory */
1388:../lib/fat16.c ****         if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
1389:../lib/fat16.c ****         {
1390:../lib/fat16.c ****             ++dd->entry_next;
1391:../lib/fat16.c ****             return 1;
1392:../lib/fat16.c ****         }
1393:../lib/fat16.c ****     }
1394:../lib/fat16.c **** 
1395:../lib/fat16.c ****     /* restart reading */
1396:../lib/fat16.c ****     dd->entry_next = 0;
1397:../lib/fat16.c **** 
1398:../lib/fat16.c ****     return 0;
1399:../lib/fat16.c **** }
1400:../lib/fat16.c **** 
1401:../lib/fat16.c **** /**
1402:../lib/fat16.c ****  * \ingroup fat16_dir
1403:../lib/fat16.c ****  * Resets a directory handle.
1404:../lib/fat16.c ****  *
1405:../lib/fat16.c ****  * Resets the directory handle such that reading restarts
1406:../lib/fat16.c ****  * with the first directory entry.
1407:../lib/fat16.c ****  *
1408:../lib/fat16.c ****  * \param[in] dd The directory handle to reset.
1409:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1410:../lib/fat16.c ****  * \see fat16_read_dir
1411:../lib/fat16.c ****  */
1412:../lib/fat16.c **** uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
1413:../lib/fat16.c **** {
1414:../lib/fat16.c ****     if(!dd)
1415:../lib/fat16.c ****         return 0;
1416:../lib/fat16.c **** 
1417:../lib/fat16.c ****     dd->entry_next = 0;
1418:../lib/fat16.c ****     return 1;
1419:../lib/fat16.c **** }
1420:../lib/fat16.c **** 
1421:../lib/fat16.c **** /**
1422:../lib/fat16.c ****  * \ingroup fat16_fs
1423:../lib/fat16.c ****  * Writes a directory entry to disk.
1424:../lib/fat16.c ****  *
1425:../lib/fat16.c ****  * \note The file name is not checked for invalid characters.
1426:../lib/fat16.c ****  *
1427:../lib/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1428:../lib/fat16.c ****  * simple. The first eight characters are used for the filename.
1429:../lib/fat16.c ****  * The extension, if any, is made up of the first three characters
1430:../lib/fat16.c ****  * following the last dot within the long filename. If the
1431:../lib/fat16.c ****  * filename (without the extension) is longer than eight characters,
1432:../lib/fat16.c ****  * the lower byte of the cluster number replaces the last two
1433:../lib/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1434:../lib/fat16.c ****  * responsibility to avoid name clashes.
1435:../lib/fat16.c ****  *
1436:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1437:../lib/fat16.c ****  * \param[in] dir_entry The directory entry to write.
1438:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1439:../lib/fat16.c ****  */
 854              	p, #12
 855              	.LCFI9:
 856              		.loc 1 1804 0
 857              		mov	r6, r0
 858              		mov	r7, r1
 859              		beq	.L118
1440:../lib/fat16.c **** nt8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* 
 860              	:
 861 06ac 000050E3 		.loc 1 1808 0
 862 06b0 0030A0E1 		ldr	r5, [r1, #40]
1441:../lib/fat16.c **** 
1442:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1443:../lib/fat16.c ****         if(!fs || !dir_entry)
 863              	L86:
 864 06b4 0030A013 		.loc 1 1809 0
 865 06b8 B033C011 		cmp	r5, #0
 866 06bc 0130A013 		beq	.L118
1444:../lib/fat16.c ****           return 0;
1445:../lib/fat16.c ****     
 867              	7:
 868 06c0 0300A0E1 		.loc 1 1816 0
 869              		mov	r1, sp
 870              		mov	r0, r5
 871              		mov	r2, #12
 872              		ldr	r3, [r6, #0]
 873 06c4 1EFF2FE1 		ldr	ip, [r3, #0]
 874              		mov	lr, pc
 875              		bx	ip
 876              		cmp	r0, #0
 877              		mov	r4, sp
 878              		.loc 1 1823 0
 879              		mov	r0, r5
 880              		mov	r1, sp
1446:../lib/fat16.c ****       device_write_t device_write = fs->partition->device_write;
1447:../lib/fat16.c ****         uint32_t offset = dir_entry->entry_offset;
1448:../lib/fat16.c ****         uint8_t name_len = strlen(dir_entry->long_name);
1449:../lib/fat16.c ****         uint8_t lfn_entry_count = (name_len + 12) / 13;
1450:../lib/fat16.c ****         uint8_t buffer[32];
1451:../lib/fat16.c ****     
1452:../lib/fat16.c ****         /* write 8.3 entry */
1453:../lib/fat16.c ****     
1454:../lib/fat16.c ****         /* generate 8.3 file name */
1455:../lib/fat16.c ****         memset(&buffer[0], ' ', 11);
1456:../lib/fat16.c ****         char* name_ext = strrchr(dir_entry->long_name, '.');
1457:../lib/fat16.c ****         if(name_ext)
1458:../lib/fat16.c ****         {
1459:../lib/fat16.c ****             ++name_ext;
1460:../lib/fat16.c ****     
1461:../lib/fat16.c ****             uint8_t name_ext_len = strlen(name_ext);
1462:../lib/fat16.c ****             name_len -= name_ext_len + 1;
1463:../lib/fat16.c ****     
1464:../lib/fat16.c ****             if(name_ext_len > 3)
1465:../lib/fat16.c ****                 name_ext_len = 3;
1466:../lib/fat16.c ****     
1467:../lib/fat16.c ****             memcpy(&buffer[8], name_ext, name_ext_len);
1468:../lib/fat16.c ****         }
1469:../lib/fat16.c ****     
1470:../lib/fat16.c ****         if(name_len <= 8)
1471:../lib/fat16.c ****         {
1472:../lib/fat16.c ****             memcpy(buffer, dir_entry->long_name, name_len);
1473:../lib/fat16.c ****         }
1474:../lib/fat16.c ****         else
1475:../lib/fat16.c ****         {
1476:../lib/fat16.c ****             memcpy(buffer, dir_entry->long_name, 8);
1477:../lib/fat16.c ****     
1478:../lib/fat16.c ****             /* Minimize 8.3 name clashes by appending
1479:../lib/fat16.c ****                                              * the lower byte of the cluster number.
1480:../lib/fat16.c ****                                              */
1481:../lib/fat16.c ****             uint8_t num = dir_entry->cluster & 0xff;
1482:../lib/fat16.c ****     
1483:../lib/fat16.c ****             buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
1484:../lib/fat16.c ****             num &= 0x0f;
1485:../lib/fat16.c ****             buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
1486:../lib/fat16.c ****         }
1487:../lib/fat16.c ****     
1488:../lib/fat16.c ****         /* fill directory entry buffer */
1489:../lib/fat16.c ****         memset(&buffer[11], 0, sizeof(buffer) - 11);
1490:../lib/fat16.c ****         buffer[0x0b] = dir_entry->attributes;
1491:../lib/fat16.c **** 
1492:../lib/fat16.c ****         //Not used in bootloader
1493:../lib/fat16.c **** 		#ifdef MAIN_FIRMWARE
1494:../lib/fat16.c **** 			//Added modified date/time 12-26-07
1495:../lib/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1496:../lib/fat16.c **** 			//*******************************************
1497:../lib/fat16.c **** 			//char * current_time;
1498:../lib/fat16.c **** 			//*******************************************
1499:../lib/fat16.c **** /*			current_time = GPS_get_time();
1500:../lib/fat16.c **** 			char * current_date;
1501:../lib/fat16.c **** 			current_date = GPS_get_date();
1502:../lib/fat16.c **** 			
1503:../lib/fat16.c **** 			uint16_t modified_time, modified_date;
1504:../lib/fat16.c **** 			uint8_t c_hour, c_minute, c_second;
1505:../lib/fat16.c **** 			uint8_t c_year, c_month, c_day;
1506:../lib/fat16.c **** 			
1507:../lib/fat16.c **** 			c_hour = (current_time[0] - '0') * 10;
1508:../lib/fat16.c **** 			c_hour += (current_time[1] - '0');
1509:../lib/fat16.c **** 			c_minute = (current_time[3] - '0') * 10;
1510:../lib/fat16.c **** 			c_minute += (current_time[4] - '0');
1511:../lib/fat16.c **** 			c_second = (current_time[6] - '0') * 10;
1512:../lib/fat16.c **** 			c_second += (current_time[7] - '0');
1513:../lib/fat16.c **** 			
1514:../lib/fat16.c **** 			c_day = (current_date[0] - '0') * 10;
1515:../lib/fat16.c **** 			c_day += (current_date[1] - '0');
1516:../lib/fat16.c **** 			c_month = (current_date[3] - '0') * 10;
1517:../lib/fat16.c **** 			c_month += (current_date[4] - '0');
1518:../lib/fat16.c **** 			c_year = (current_date[6] - '0') * 10;
1519:../lib/fat16.c **** 			c_year += (current_date[7] - '0');
1520:../lib/fat16.c **** 			
1521:../lib/fat16.c **** 			//Correct for 1980 = 0, 2000 = 20, year code
1522:../lib/fat16.c **** 			c_year += 20;
1523:../lib/fat16.c **** 			
1524:../lib/fat16.c **** 			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
1525:../lib/fat16.c **** 			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);
1526:../lib/fat16.c **** 
1527:../lib/fat16.c **** 			//Do a little error correction
1528:../lib/fat16.c **** 			if (c_year < 26) //26 = 2006
1529:../lib/fat16.c **** 			{
1530:../lib/fat16.c **** 				modified_time = 0;
1531:../lib/fat16.c **** 				modified_date = 0;
1532:../lib/fat16.c **** 			}
1533:../lib/fat16.c **** 
1534:../lib/fat16.c **** 			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
1535:../lib/fat16.c **** 			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
1536:../lib/fat16.c **** 			//rprintf("mod_time=%x\n", modified_time);
1537:../lib/fat16.c **** 			//rprintf("mod_date=%x\n", modified_date);
1538:../lib/fat16.c **** 			
1539:../lib/fat16.c **** 			buffer[0x16] = (modified_time >> 0) & 0xFF;
1540:../lib/fat16.c **** 			buffer[0x17] = (modified_time >> 8) & 0xFF;
1541:../lib/fat16.c **** 			buffer[0x18] = (modified_date >> 0) & 0xFF;
1542:../lib/fat16.c **** 			buffer[0x19] = (modified_date >> 8) & 0xFF;
1543:../lib/fat16.c **** 			*/
1544:../lib/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1545:../lib/fat16.c **** 		#endif
1546:../lib/fat16.c **** 
1547:../lib/fat16.c ****         buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
1548:../lib/fat16.c ****         buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
1549:../lib/fat16.c ****         buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
1550:../lib/fat16.c ****         buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
1551:../lib/fat16.c ****         buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
1552:../lib/fat16.c ****         buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
1553:../lib/fat16.c ****     
1554:../lib/fat16.c ****         /* write to disk */
1555:../lib/fat16.c ****         if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
1556:../lib/fat16.c ****             return 0;
1557:../lib/fat16.c ****     
1558:../lib/fat16.c ****         /* calculate checksum of 8.3 name */
1559:../lib/fat16.c ****         uint8_t checksum = buffer[0];
1560:../lib/fat16.c ****         uint8_t i;
1561:../lib/fat16.c ****         for(i = 1; i < 11; ++i)
1562:../lib/fat16.c ****             checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
1563:../lib/fat16.c ****     
1564:../lib/fat16.c ****         /* write lfn entries */
1565:../lib/fat16.c ****         uint8_t lfn_entry;
1566:../lib/fat16.c ****         for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1567:../lib/fat16.c ****         {
1568:../lib/fat16.c ****             memset(buffer, 0, sizeof(buffer));
1569:../lib/fat16.c ****             memset(&buffer[0x01], 0xff, 10);
1570:../lib/fat16.c ****             memset(&buffer[0x0e], 0xff, 12);
1571:../lib/fat16.c ****             memset(&buffer[0x1c], 0xff, 4);
1572:../lib/fat16.c ****     
1573:../lib/fat16.c ****             buffer[0x00] = lfn_entry;
1574:../lib/fat16.c ****             if(lfn_entry == lfn_entry_count)
1575:../lib/fat16.c ****                 buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
1576:../lib/fat16.c ****     
1577:../lib/fat16.c ****             /* set file name */
1578:../lib/fat16.c ****             const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
1579:../lib/fat16.c ****             i = 1;
1580:../lib/fat16.c ****             while(i < 0x1f)
1581:../lib/fat16.c ****             {
1582:../lib/fat16.c ****                 buffer[i++] = *long_name_curr;
1583:../lib/fat16.c ****                 buffer[i++] = 0;
1584:../lib/fat16.c ****     
1585:../lib/fat16.c ****                 switch(i)
1586:../lib/fat16.c ****                 {
1587:../lib/fat16.c ****                     case 0x0b:
1588:../lib/fat16.c ****                         i = 0x0e;
1589:../lib/fat16.c ****                         break;
1590:../lib/fat16.c ****                     case 0x1a:
1591:../lib/fat16.c ****                         i = 0x1c;
1592:../lib/fat16.c ****                         break;
1593:../lib/fat16.c ****                 }
1594:../lib/fat16.c ****     
1595:../lib/fat16.c ****                 if(!*long_name_curr++)
1596:../lib/fat16.c ****                     break;
1597:../lib/fat16.c ****             }
1598:../lib/fat16.c ****     
1599:../lib/fat16.c ****             /* mark as lfn entry */
1600:../lib/fat16.c ****             buffer[0x0b] = 0x0f;
1601:../lib/fat16.c ****     
1602:../lib/fat16.c ****             /* set checksum */
1603:../lib/fat16.c ****             buffer[0x0d] = checksum;
1604:../lib/fat16.c ****     
1605:../lib/fat16.c ****             /* write entry */
1606:../lib/fat16.c ****             device_write(offset, buffer, sizeof(buffer));
1607:../lib/fat16.c ****     
1608:../lib/fat16.c ****             offset += sizeof(buffer);
1609:../lib/fat16.c ****         }
1610:../lib/fat16.c ****     
1611:../lib/fat16.c ****         return 1;
1612:../lib/fat16.c ****     
1613:../lib/fat16.c ****     #else
1614:../lib/fat16.c ****         return 0;
1615:../lib/fat16.c ****     #endif
1616:../lib/fat16.c **** }
1617:../lib/fat16.c **** 
1618:../lib/fat16.c **** /**
1619:../lib/fat16.c ****  * \ingroup fat16_file
1620:../lib/fat16.c ****  * Creates a file.
1621:../lib/fat16.c ****  *
1622:../lib/fat16.c ****  * Creates a file and obtains the directory entry of the
1623:../lib/fat16.c ****  * new file. If the file to create already exists, the
1624:../lib/fat16.c ****  * directory entry of the existing file will be returned
1625:../lib/fat16.c ****  * within the dir_entry parameter.
1626:../lib/fat16.c ****  *
1627:../lib/fat16.c ****  * \note The file name is not checked for invalid characters.
1628:../lib/fat16.c ****  *
1629:../lib/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1630:../lib/fat16.c ****  * simple. The first eight characters are used for the filename.
1631:../lib/fat16.c ****  * The extension, if any, is made up of the first three characters
1632:../lib/fat16.c ****  * following the last dot within the long filename. If the
1633:../lib/fat16.c ****  * filename (without the extension) is longer than eight characters,
1634:../lib/fat16.c ****  * the lower byte of the cluster number replaces the last two
1635:../lib/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1636:../lib/fat16.c ****  * responsibility to avoid name clashes.
1637:../lib/fat16.c ****  *
1638:../lib/fat16.c ****  * \param[in] parent The handle of the directory in which to create the file.
1639:../lib/fat16.c ****  * \param[in] file The name of the file to create.
1640:../lib/fat16.c ****  * \param[out] dir_entry The directory entry to fill for the new file.
1641:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1642:../lib/fat16.c ****  * \see fat16_delete_file
1643:../lib/fat16.c ****  */
1644:../lib/fat16.c **** uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry
1645:../lib/fat16.c **** {
1646:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1647:../lib/fat16.c ****         if(!parent || !file || !file[0])
1648:../lib/fat16.c ****             return 0;
1649:../lib/fat16.c ****     
1650:../lib/fat16.c ****         /* check if the file already exists */
1651:../lib/fat16.c ****         while(1)
1652:../lib/fat16.c ****         {
1653:../lib/fat16.c ****             if(!fat16_read_dir(parent, dir_entry))
1654:../lib/fat16.c ****                 break;
1655:../lib/fat16.c ****     
1656:../lib/fat16.c ****             if(strcmp(file, dir_entry->long_name) == 0)
1657:../lib/fat16.c ****             {
1658:../lib/fat16.c ****                 fat16_reset_dir(parent);
1659:../lib/fat16.c ****                 return 1;
1660:../lib/fat16.c ****             }
1661:../lib/fat16.c ****         }
1662:../lib/fat16.c ****     
1663:../lib/fat16.c ****         memset(dir_entry, 0, sizeof(*dir_entry));
1664:../lib/fat16.c ****         strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
1665:../lib/fat16.c ****     
1666:../lib/fat16.c ****         /* search for a place where to write the directory entry to disk */
1667:../lib/fat16.c ****         uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
1668:../lib/fat16.c ****         uint8_t free_dir_entries_found = 0;
1669:../lib/fat16.c ****         struct fat16_fs_struct* fs = parent->fs;
1670:../lib/fat16.c ****         uint16_t cluster_num = parent->dir_entry.cluster;
1671:../lib/fat16.c ****         uint32_t dir_entry_offset = 0;
1672:../lib/fat16.c ****         uint32_t offset = 0;
1673:../lib/fat16.c ****         uint32_t offset_to = 0;
1674:../lib/fat16.c ****     
1675:../lib/fat16.c ****         if(cluster_num == 0)
1676:../lib/fat16.c ****         {
1677:../lib/fat16.c ****             /* we read/write from the root directory entry */
1678:../lib/fat16.c ****             offset = fs->header.root_dir_offset;
1679:../lib/fat16.c ****             offset_to = fs->header.cluster_zero_offset;
1680:../lib/fat16.c ****             dir_entry_offset = offset;
1681:../lib/fat16.c ****         }
1682:../lib/fat16.c ****     
1683:../lib/fat16.c ****         while(1)
1684:../lib/fat16.c ****         {
1685:../lib/fat16.c ****             if(offset == offset_to)
1686:../lib/fat16.c ****             {
1687:../lib/fat16.c ****                 if(cluster_num == 0)
1688:../lib/fat16.c **** 				/* We iterated through the whole root directory entry
1689:../lib/fat16.c ****                 * and could not find enough space for the directory entry.
1690:../lib/fat16.c ****                 */
1691:../lib/fat16.c ****                 return 0;
1692:../lib/fat16.c ****     
1693:../lib/fat16.c ****                 if(offset)
1694:../lib/fat16.c ****                 {
1695:../lib/fat16.c ****                     /* We reached a cluster boundary and have to
1696:../lib/fat16.c ****                     * switch to the next cluster.
1697:../lib/fat16.c ****                     */
1698:../lib/fat16.c ****     
1699:../lib/fat16.c ****                     uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
1700:../lib/fat16.c ****                     if(!cluster_next)
1701:../lib/fat16.c ****                     {
1702:../lib/fat16.c ****                         cluster_next = fat16_append_clusters(fs, cluster_num, 1);
1703:../lib/fat16.c ****                         if(!cluster_next)
1704:../lib/fat16.c ****                             return 0;
1705:../lib/fat16.c ****     
1706:../lib/fat16.c ****                         /* we appended a new cluster and know it is free */
1707:../lib/fat16.c ****                         dir_entry_offset = fs->header.cluster_zero_offset +
1708:../lib/fat16.c ****                         (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
1709:../lib/fat16.c ****     
1710:../lib/fat16.c ****                         /* TODO: This cluster has to be zeroed in an efficient way, or at least
1711:../lib/fat16.c ****                         *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
1712:../lib/fat16.c ****                         */
1713:../lib/fat16.c ****                         break;
1714:../lib/fat16.c ****                     }
1715:../lib/fat16.c ****                     cluster_num = cluster_next;
1716:../lib/fat16.c ****                 }
1717:../lib/fat16.c ****     
1718:../lib/fat16.c ****                 offset = fs->header.cluster_zero_offset +
1719:../lib/fat16.c ****                 (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
1720:../lib/fat16.c ****                 offset_to = offset + fs->header.cluster_size;
1721:../lib/fat16.c ****                 dir_entry_offset = offset;
1722:../lib/fat16.c ****                 free_dir_entries_found = 0;
1723:../lib/fat16.c ****             }
1724:../lib/fat16.c ****     
1725:../lib/fat16.c ****             /* read next lfn or 8.3 entry */
1726:../lib/fat16.c ****             uint8_t first_char;
1727:../lib/fat16.c ****             if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1728:../lib/fat16.c ****                 return 0;
1729:../lib/fat16.c ****     
1730:../lib/fat16.c ****             /* check if we found a free directory entry */
1731:../lib/fat16.c ****             if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
1732:../lib/fat16.c ****             {
1733:../lib/fat16.c ****                 /* check if we have the needed number of available entries */
1734:../lib/fat16.c ****                 ++free_dir_entries_found;
1735:../lib/fat16.c ****                 if(free_dir_entries_found >= free_dir_entries_needed)
1736:../lib/fat16.c ****                     break;
1737:../lib/fat16.c ****     
1738:../lib/fat16.c ****                 offset += 32;
1739:../lib/fat16.c ****             }
1740:../lib/fat16.c ****             else
1741:../lib/fat16.c ****             {
1742:../lib/fat16.c ****                 offset += 32;
1743:../lib/fat16.c ****                 dir_entry_offset = offset;
1744:../lib/fat16.c ****                 free_dir_entries_found = 0;
1745:../lib/fat16.c ****             }
1746:../lib/fat16.c ****         }
1747:../lib/fat16.c **** 
1748:../lib/fat16.c ****         /* write directory entry to disk */
1749:../lib/fat16.c ****         dir_entry->entry_offset = dir_entry_offset;
1750:../lib/fat16.c ****         if(!fat16_write_dir_entry(fs, dir_entry))
1751:../lib/fat16.c ****             return 0;
1752:../lib/fat16.c ****     
1753:../lib/fat16.c ****         return 1;
1754:../lib/fat16.c ****     
1755:../lib/fat16.c ****     #else
1756:../lib/fat16.c ****         return 0;
1757:../lib/fat16.c ****     #endif
1758:../lib/fat16.c **** }
1759:../lib/fat16.c **** 
1760:../lib/fat16.c **** /**
1761:../lib/fat16.c ****  * \ingroup fat16_file
1762:../lib/fat16.c ****  * Deletes a file or directory.
1763:../lib/fat16.c ****  *
1764:../lib/fat16.c ****  * It is not checked if the file to delete is a directory.
1765:../lib/fat16.c ****  * If a directory is deleted without first deleting its
1766:../lib/fat16.c ****  * subdirectories and files, disk space occupied by these
1767:../lib/fat16.c ****  * files will get wasted as there is no chance to release
1768:../lib/fat16.c ****  * it and mark it as free.
1769:../lib/fat16.c ****  *
1770:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1771:../lib/fat16.c ****  * \param[in] dir_entry The directory entry of the file to delete.
1772:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1773:../lib/fat16.c ****  * \see fat16_create_file
1774:../lib/fat16.c ****  */
1775:../lib/fat16.c **** uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
1776:../lib/fat16.c **** {
1777:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1778:../lib/fat16.c ****         if(!fs || !dir_entry)
1779:../lib/fat16.c ****             return 0;
1780:../lib/fat16.c ****     
1781:../lib/fat16.c ****         /* get offset of the file's directory entry */
1782:../lib/fat16.c ****         uint32_t dir_entry_offset = dir_entry->entry_offset;
1783:../lib/fat16.c ****         if(!dir_entry_offset)
1784:../lib/fat16.c ****             return 0;
1785:../lib/fat16.c ****     
1786:../lib/fat16.c ****         uint8_t buffer[12];
1787:../lib/fat16.c ****         while(1)
1788:../lib/fat16.c ****         {
1789:../lib/fat16.c ****             /* read directory entry */
1790:../lib/fat16.c ****             if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
1791:../lib/fat16.c ****                 return 0;
1792:../lib/fat16.c ****     
1793:../lib/fat16.c ****             /* mark the directory entry as deleted */
1794:../lib/fat16.c ****             buffer[0] = FAT16_DIRENTRY_DELETED;
1795:../lib/fat16.c ****     
1796:../lib/fat16.c ****             /* write back entry */
1797:../lib/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
1798:../lib/fat16.c ****                 return 0;
1799:../lib/fat16.c ****     
1800:../lib/fat16.c ****             /* check if we deleted the whole entry */
1801:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1802:../lib/fat16.c ****                 break;
 881              	.loc 1 1830 0
 882              		add	r5, r5, #32
 883              		.loc 1 1816 0
 884              		beq	.L118
 885              		.loc 1 1820 0
 886 06c8 F0402DE9 		mvn	r3, #26
 887              		strb	r3, [sp, #0]
1803:../lib/fat16.c **** ng to do is
1804:../lib/fat16.c ****                              * marking all occupied clusters as free.
 888              	 1823 0
 889 06cc 000051E3 		ldr	r3, [r6, #0]
 890 06d0 00005013 		ldr	ip, [r3, #8]
 891              		mov	lr, pc
 892 06d4 0CD04DE2 		bx	ip
 893              		cmp	r0, #0
 894              		beq	.L118
 895 06d8 0060A0E1 		.loc 1 1827 0
 896 06dc 0170A0E1 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 897 06e0 1F00000A 		cmp	r3, #15
 898              		beq	.L127
1805:../lib/fat16.c **** he directory entry. The next thing to do is
1806:../lib/fat16.c ****                              * marking all occupied clusters as free.
1807:../lib/fat16.c ****                              */
1808:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 899              	6 0
 900 06e4 285091E5 		mov	r0, r6
 901              		ldrh	r1, [r7, #34]
1809:../lib/fat16.c **** d clusters as free.
 902              		fat16_free_clusters
 903 06e8 000055E3 		b	.L125
 904 06ec 1C00000A 	.LVL87:
 905              	.L118:
1810:../lib/fat16.c **** he directory entry. The next thing to do is
1811:../lib/fat16.c ****                              * marking all occupied clusters as free.
1812:../lib/fat16.c ****                              */
1813:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1814:../lib/fat16.c ****     #else
1815:../lib/fat16.c ****         return 0;
1816:../lib/fat16.c ****     #endif
 906              		r0, #0
 907 06f0 0D10A0E1 	.L125:
 908 06f4 0500A0E1 		.loc 1 1840 0
 909 06f8 0C20A0E3 		add	sp, sp, #12
 910 06fc 003096E5 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 911 0700 00C093E5 		bx	lr
 912 0704 0FE0A0E1 	.LFE27:
 914 070c 000050E3 		.align	2
 915 0710 0D40A0E1 		.global	fat16_get_fs_size
1817:../lib/fat16.c ****        */
1818:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1819:../lib/fat16.c ****     #else
1820:../lib/fat16.c ****         return 0;
1821:../lib/fat16.c ****     #endif
1822:../lib/fat16.c **** }
1823:../lib/fat16.c **** 
 916              	16_get_fs_size, %function
 917 0714 0500A0E1 	fat16_get_fs_size:
 918 0718 0D10A0E1 	.LFB28:
 919 071c 0C20A0E3 		.loc 1 1850 0
1824:../lib/fat16.c ****   */
1825:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1826:../lib/fat16.c ****     #else
1827:../lib/fat16.c ****         return 0;
1828:../lib/fat16.c ****     #endif
1829:../lib/fat16.c **** }
1830:../lib/fat16.c **** 
 920              	unction supports interworking.
 921 0720 205085E2 		@ args = 0, pretend = 0, frame = 0
 922              		@ frame_needed = 0, uses_anonymous_args = 0
 923 0724 0E00000A 		@ link register save eliminated.
 924              	.LVL88:
 925 0728 1A30E0E3 		.loc 1 1851 0
 926 072c 0030CDE5 		cmp	r0, #0
 927              		.loc 1 1854 0
 928 0730 003096E5 		ldrne	r3, [r0, #12]
 929 0734 08C093E5 		.loc 1 1851 0
 930 0738 0FE0A0E1 		mov	r2, r0
 931 073c 1CFF2FE1 		.loc 1 1854 0
 932 0740 000050E3 		movne	r3, r3, lsr #1
 933 0744 0600000A 		ldrneh	r2, [r0, #18]
 934              		subne	r3, r3, #2
 935 0748 0B30DDE5 		mulne	r2, r3, r2
 936 074c 0F0053E3 		.loc 1 1855 0
 937 0750 E6FFFF0A 		mov	r0, r2
1831:../lib/fat16.c ****   */
1832:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1833:../lib/fat16.c ****     #else
1834:../lib/fat16.c ****         return 0;
1835:../lib/fat16.c ****     #endif
1836:../lib/fat16.c **** }
 938              	50 0
 939 0754 0600A0E1 		@ lr needed for prologue
 940 0758 B212D7E1 		.loc 1 1855 0
 941 075c D9FEFFEB 		bx	lr
 942 0760 000000EA 	.LFE28:
 944              		.align	2
 945 0764 0000A0E3 		.global	fat16_get_fs_free
1837:../lib/fat16.c ****     */
1838:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1839:../lib/fat16.c ****     #else
1840:../lib/fat16.c ****         return 0;
 947              	_fs_free:
 948 0768 0CD08DE2 	.LFB29:
 949 076c F040BDE8 		.loc 1 1868 0
 950 0770 1EFF2FE1 		@ Function supports interworking.
 951              		@ args = 0, pretend = 0, frame = 36
 952              		@ frame_needed = 0, uses_anonymous_args = 0
 953              	.LVL90:
 954              		stmfd	sp!, {r4, r5, r6, r7, lr}
 955              	.LCFI10:
 956              		.loc 1 1869 0
 957              		subs	r6, r0, #0
1841:../lib/fat16.c ****                    */
1842:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1843:../lib/fat16.c ****     #else
1844:../lib/fat16.c ****         return 0;
1845:../lib/fat16.c ****     #endif
1846:../lib/fat16.c **** }
1847:../lib/fat16.c **** 
1848:../lib/fat16.c **** /**
1849:../lib/fat16.c ****  * \ingroup fat16_fs
1850:../lib/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
 958              	8 0
 959              		sub	sp, sp, #44
 960              	.LCFI11:
 961              		.loc 1 1869 0
 962              		beq	.L134
 963              	.LVL91:
1851:../lib/fat16.c **** }
 964              	1 1875 0
 965 0774 000050E3 		mov	r3, #32
1852:../lib/fat16.c ****     */
1853:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1854:../lib/fat16.c ****     #else
 966              	trb	r3, [sp, #42]
 967 0778 0C309015 		.loc 1 1877 0
 968              		ldr	r7, [r6, #8]
 969 077c 0020A0E1 	.LVL92:
 970              		.loc 1 1878 0
 971 0780 A330A011 		ldr	r5, [r6, #12]
 972 0784 B221D011 	.LVL93:
 973 0788 02304312 		.loc 1 1874 0
 974 078c 93020210 		mov	r3, #0	@ movhi
1855:../lib/fat16.c **** as free.
 975              	 [sp, #40]	@ movhi
 976 0790 0200A0E1 		b	.L136
 977              	.LVL94:
 978              	.L137:
 979              	.LBB20:
 980              		.loc 1 1882 0
 981 0794 1EFF2FE1 		ldr	r3, .L145
 982              		cmp	r5, r3
 983              		.loc 1 1885 0
 984              		ldr	r3, .L145+4
 985              		.loc 1 1883 0
 986              		movls	r4, r2, lsr #16
 987              		.loc 1 1885 0
 988              		ldr	ip, [r6, #0]
1856:../lib/fat16.c **** he directory entry. The next thing to do is
1857:../lib/fat16.c ****                              * marking all occupied clusters as free.
1858:../lib/fat16.c ****                              */
1859:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1860:../lib/fat16.c ****     #else
1861:../lib/fat16.c ****         return 0;
1862:../lib/fat16.c ****     #endif
1863:../lib/fat16.c **** }
1864:../lib/fat16.c **** 
1865:../lib/fat16.c **** /**
1866:../lib/fat16.c ****  * \ingroup fat16_fs
1867:../lib/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
1868:../lib/fat16.c ****  *
 989              	#0]
 990              		add	r3, sp, #40
 991              		str	r3, [sp, #4]
 992              		mov	r0, r7
 993              		add	r1, sp, #8
 994 0798 F0402DE9 		mov	r2, #32
 995              		mov	r3, r4
1869:../lib/fat16.c **** **
 996              	, [ip, #4]
 997 079c 006050E2 		mov	lr, pc
 998              		bx	ip
 999 07a0 2CD04DE2 		cmp	r0, #0
 1000              		beq	.L134
 1001              		.loc 1 1896 0
 1002 07a4 2100000A 		rsb	r5, r4, r5
 1003              		.loc 1 1895 0
1870:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1871:../lib/fat16.c ****     #else
1872:../lib/fat16.c ****         return 0;
1873:../lib/fat16.c ****     #endif
1874:../lib/fat16.c **** }
1875:../lib/fat16.c **** 
 1004              	 r7, r4
 1005 07a8 2030A0E3 	.LVL95:
 1006 07ac 2A30CDE5 	.L136:
1876:../lib/fat16.c ****   */
1877:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1007              	E20:
 1008 07b0 087096E5 		.loc 1 1879 0
 1009              		cmp	r5, #0
1878:../lib/fat16.c **** d clusters as free.
 1010              	B21:
 1011 07b4 0C5096E5 		.loc 1 1882 0
 1012              		ldr	r4, .L145+8
 1013              		.loc 1 1883 0
 1014 07b8 0030A0E3 		mov	r2, r5, asl #16
 1015 07bc B832CDE1 	.LBE21:
 1016 07c0 120000EA 		.loc 1 1879 0
 1017              		bne	.L137
 1018              		.loc 1 1899 0
 1019              		ldrh	r2, [r6, #18]
1879:../lib/fat16.c **** he directory entry. The next thing to do is
1880:../lib/fat16.c ****                              * marking all occupied clusters as free.
1881:../lib/fat16.c ****                              */
1882:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1020              	[sp, #40]
 1021 07c4 74309FE5 		mul	r0, r2, r3
 1022 07c8 030055E1 		b	.L143
1883:../lib/fat16.c **** d clusters as free.
1884:../lib/fat16.c ****                              */
1885:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1023              	L96:
 1024 07cc 70309FE5 	.L134:
 1025              		mov	r0, #0
 1026 07d0 2248A091 	.L143:
 1027              		.loc 1 1900 0
 1028 07d4 00C096E5 		add	sp, sp, #44
 1029 07d8 00308DE5 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1030 07dc 28308DE2 		bx	lr
 1031 07e0 04308DE5 	.L146:
 1032 07e4 0700A0E1 		.align	2
 1033 07e8 08108DE2 	.L145:
 1034 07ec 2020A0E3 		.word	65533
 1035 07f0 0430A0E1 		.word	fat16_get_fs_free_callback
 1036 07f4 04C09CE5 		.word	65534
 1037 07f8 0FE0A0E1 	.LFE29:
 1039 0800 000050E3 		.align	2
1886:../lib/fat16.c **** d clusters as free.
1887:../lib/fat16.c ****                              */
1888:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1889:../lib/fat16.c ****     #else
1890:../lib/fat16.c ****         return 0;
1891:../lib/fat16.c ****     #endif
1892:../lib/fat16.c **** }
1893:../lib/fat16.c **** 
1894:../lib/fat16.c **** /**
1895:../lib/fat16.c ****  * \ingroup fat16_fs
1896:../lib/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
 1041              	callback:
 1042 0808 055064E0 	.LFB30:
 1043              		.loc 1 1907 0
 1044 080c 047087E0 		@ Function supports interworking.
 1045              		@ args = 0, pretend = 0, frame = 0
 1046              		@ frame_needed = 0, uses_anonymous_args = 0
 1047              	.LVL97:
 1048              		stmfd	sp!, {r4, lr}
 1049 0810 000055E3 	.LCFI12:
 1050              	.LVL98:
 1051              		.loc 1 1909 0
 1052 0814 2C409FE5 		ldrb	r4, [r2, #2]	@ zero_extendqisi2
 1053              	.LVL99:
 1054 0818 0528A0E1 	.LVL100:
 1055              		.loc 1 1907 0
 1056              		mov	ip, r2
 1057 081c E8FFFF1A 	.LVL101:
1897:../lib/fat16.c **** }
1898:../lib/fat16.c **** 
1899:../lib/fat16.c **** /**
 1058              	ov	r1, r0
 1059 0820 B221D6E1 	.LVL102:
 1060 0824 B832DDE1 		mov	lr, #0
 1061 0828 920300E0 		b	.L154
 1062 082c 000000EA 	.L149:
 1063              		.loc 1 1913 0
 1064              		ldrb	r3, [lr, r0]	@ zero_extendqisi2
 1065 0830 0000A0E3 		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 1066              	.LVL103:
1900:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1067              	 r3, r2, asl #8
 1068 0834 2CD08DE2 		.loc 1 1914 0
 1069 0838 F040BDE8 		ldreqh	r3, [ip, #0]
 1070 083c 1EFF2FE1 		addeq	r3, r3, #1
 1071              		streqh	r3, [ip, #0]	@ movhi
 1072              		.loc 1 1916 0
 1073              		add	r1, r1, #2
 1074 0840 FDFF0000 		add	lr, lr, #2
 1075 0844 00000000 	.LVL104:
 1076 0848 FEFF0000 	.L154:
 1077              		.loc 1 1911 0
 1078              		and	r3, lr, #255
 1079              		cmp	r3, r4
 1080              		bcc	.L149
 1081              		.loc 1 1920 0
 1082              		mov	r0, #1
1901:../lib/fat16.c **** d clusters as free.
1902:../lib/fat16.c ****                              */
1903:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1904:../lib/fat16.c ****     #else
1905:../lib/fat16.c ****         return 0;
1906:../lib/fat16.c ****     #endif
1907:../lib/fat16.c **** }
 1083              	sp!, {r4, lr}
 1084              		bx	lr
 1085              	.LFE30:
 1087              		.align	2
 1088 084c 10402DE9 		.global	fat16_file_size
 1090              	fat16_file_size:
1908:../lib/fat16.c ****     */
1909:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1091              		.loc 1 1946 0
 1092 0850 0240D2E5 		@ Function supports interworking.
 1093              		@ args = 0, pretend = 0, frame = 0
 1094              		@ frame_needed = 0, uses_anonymous_args = 0
 1095              		@ link register save eliminated.
 1096 0854 02C0A0E1 	.LVL106:
 1097              		.loc 1 1948 0
 1098              		ldr	r0, [r0, #40]
 1099 0858 0010A0E1 	.LVL107:
 1100              		.loc 1 1946 0
 1101 085c 00E0A0E3 		@ lr needed for prologue
 1102 0860 070000EA 		.loc 1 1948 0
 1103              		bx	lr
1910:../lib/fat16.c **** d clusters as free.
1911:../lib/fat16.c ****                              */
1912:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1913:../lib/fat16.c ****     #else
 1104              	e	fat16_file_size, .-fat16_file_size
 1105 0864 0030DEE7 		.align	2
 1106 0868 0120D1E5 		.global	fat16_read_dir
 1108 086c 022493E1 	fat16_read_dir:
1914:../lib/fat16.c **** as free.
 1109              	3:
 1110 0870 B030DC01 		.loc 1 1398 0
 1111 0874 01308302 		@ Function supports interworking.
 1112 0878 B030CC01 		@ args = 0, pretend = 0, frame = 48
1915:../lib/fat16.c **** he directory entry. The next thing to do is
1916:../lib/fat16.c ****                              * marking all occupied clusters as free.
 1113              	rame_needed = 0, uses_anonymous_args = 0
 1114 087c 021081E2 	.LVL108:
 1115 0880 02E08EE2 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1116              	.LCFI13:
 1117              		.loc 1 1399 0
 1118              		mov	sl, r1
 1119 0884 FF300EE2 		rsbs	r1, r1, #1
 1120 0888 040053E1 		movcc	r1, #0
 1121 088c F4FFFF3A 	.LVL109:
1917:../lib/fat16.c **** he directory entry. The next thing to do is
1918:../lib/fat16.c ****                              * marking all occupied clusters as free.
1919:../lib/fat16.c ****                              */
1920:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1122              	#0
 1123 0890 0100A0E3 		cmpne	r0, #0
 1124              		.loc 1 1398 0
 1125 0894 1040BDE8 		sub	sp, sp, #56
 1126 0898 1EFF2FE1 	.LCFI14:
 1127              		.loc 1 1399 0
 1128              		mov	r8, r0
 1129              		beq	.L179
 1130              	.LVL110:
 1131              		.loc 1 1402 0
 1132              		ldrh	r3, [r0, #38]
 1133              		cmp	r3, #0
1921:../lib/fat16.c **** d clusters as free.
1922:../lib/fat16.c ****                              */
1923:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1924:../lib/fat16.c ****     #else
1925:../lib/fat16.c ****         return 0;
1926:../lib/fat16.c ****     #endif
1927:../lib/fat16.c **** }
1928:../lib/fat16.c **** 
1929:../lib/fat16.c **** /**
1930:../lib/fat16.c ****  * \ingroup fat16_fs
1931:../lib/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
1932:../lib/fat16.c ****  *
1933:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1934:../lib/fat16.c ****  * \returns 0 on failure, the filesystem size in bytes otherwise.
1935:../lib/fat16.c ****  */
1936:../lib/fat16.c **** uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
1937:../lib/fat16.c **** {
1938:../lib/fat16.c ****     if(!fs)
1939:../lib/fat16.c ****         return 0;
1940:../lib/fat16.c **** 
1941:../lib/fat16.c ****     return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
1942:../lib/fat16.c **** }
1943:../lib/fat16.c **** 
1944:../lib/fat16.c **** /**
1945:../lib/fat16.c ****  * \ingroup fat16_fs
1946:../lib/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
 1134              	0, #48]
 1135              		ldr	r6, [r0, #0]
 1136              		bne	.L161
 1137              	.LVL111:
 1138              	.LBB26:
 1139              		.loc 1 360 0
1947:../lib/fat16.c **** roup fat16_fs
1948:../lib/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
 1140              	6, #0
 1141 089c 280090E5 		movne	r7, r1
 1142              		orreq	r7, r1, #1
 1143              		cmp	r7, #0
 1144              		bne	.L163
 1145              	.LBB27:
 1146 08a0 1EFF2FE1 		.loc 1 365 0
 1147              		ldr	r3, [r6, #0]
 1148              		.loc 1 370 0
 1149              		add	r5, sp, #44
 1150              		.loc 1 364 0
 1151              		add	r4, r6, #4
 1152              	.LVL112:
 1153              		.loc 1 370 0
 1154              		mov	r1, r7
 1155              		mov	r2, #12
 1156              		mov	r0, r5
 1157              	.LVL113:
 1158              		.loc 1 365 0
 1159 08a4 F04F2DE9 		ldr	r6, [r3, #4]
 1160              	.LVL114:
 1161              		.loc 1 370 0
 1162 08a8 01A0A0E1 		bl	memset
 1163 08ac 011071E2 	.LBE27:
 1164 08b0 0010A033 		.loc 1 372 0
 1165              	.LBB28:
 1166 08b4 00005AE3 		add	r0, r4, #16
 1167 08b8 00005013 		ldmia	r0, {r0, r3}	@ phole ldm
 1168              	.LBE28:
 1169 08bc 38D04DE2 		ldr	r2, .L183
 1170              		rsb	r3, r0, r3
 1171              		mov	r3, r3, asl #16
 1172 08c0 0080A0E1 		add	r4, sp, #12
 1173 08c4 7600000A 	.LVL115:
 1174              		str	r2, [sp, #0]
 1175              	.LBB29:
 1176 08c8 B632D0E1 		.loc 1 371 0
 1177 08cc 000053E3 		strh	r9, [sp, #46]	@ movhi
 1178 08d0 B093D0E1 	.LBE29:
 1179 08d4 006090E5 		.loc 1 372 0
 1180 08d8 2C00001A 		str	r5, [sp, #4]
 1181              		mov	r3, r3, lsr #16
 1182              		mov	r1, r4
 1183              		mov	r2, #32
 1184 08dc 000056E3 		mov	lr, pc
 1185 08e0 0170A011 		bx	r6
 1186 08e4 01708103 	.LBB30:
 1187 08e8 000057E3 		cmp	r0, #0
 1188 08ec 6A00001A 		beq	.L163
 1189              		ldr	r3, [sp, #48]
 1190              		cmp	r3, #0
 1191 08f0 003096E5 		beq	.L163
 1192              		.loc 1 383 0
 1193 08f4 2C508DE2 		mov	r1, r7
 1194              		mov	r2, #44
 1195 08f8 044086E2 		mov	r0, sl
 1196              		bl	memset
 1197              	.LBE30:
 1198 08fc 0710A0E1 		.loc 1 384 0
 1199 0900 0C20A0E3 		ldr	r2, .L183+4
 1200 0904 0500A0E1 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 1201              		stmia	sp, {r2, sl}	@ phole stm
 1202              		mov	r1, r4
 1203 0908 046093E5 		ldr	r0, [sp, #48]
 1204              		mov	r2, #32
 1205              		mov	lr, pc
 1206 090c FEFFFFEB 		bx	r6
 1207              		b	.L182
 1208              	.LVL116:
 1209              	.L161:
 1210 0910 100084E2 	.LBE26:
 1211 0914 090090E8 	.LBB31:
 1212              	.LBB32:
 1213 0918 94219FE5 		.loc 1 408 0
 1214 091c 033060E0 		cmp	r6, #0
 1215 0920 0338A0E1 	.LBE32:
 1216 0924 0C408DE2 	.LBE31:
 1217              		.loc 1 1408 0
 1218 0928 00208DE5 		str	r9, [sp, #8]
 1219              	.LVL117:
 1220              	.LBB33:
 1221 092c BE92CDE1 	.LBB34:
 1222              		.loc 1 408 0
 1223              		beq	.L163
 1224 0930 04508DE5 		cmp	r1, #0
 1225 0934 2338A0E1 		bne	.L163
 1226 0938 0410A0E1 		add	r0, r0, #4
 1227 093c 2020A0E3 	.LVL118:
 1228 0940 0FE0A0E1 		.loc 1 412 0
 1229 0944 16FF2FE1 		ldrb	r3, [r0, #32]	@ zero_extendqisi2
 1230              		tst	r3, #16
 1231 0948 000050E3 		beq	.L163
 1232 094c 5200000A 		.loc 1 419 0
 1233 0950 30309DE5 		ldrh	r7, [r0, #34]
 1234 0954 000053E3 	.LVL119:
 1235 0958 4F00000A 		.loc 1 418 0
 1236              		ldrh	r9, [r6, #18]
 1237 095c 0710A0E1 	.LVL120:
 1238 0960 2C20A0E3 	.LVL121:
 1239 0964 0A00A0E1 	.L172:
 1240 0968 FEFFFFEB 		.loc 1 425 0
 1241              		ldr	r2, [r6, #24]
 1242              		sub	r3, r7, #2
 1243 096c 44219FE5 		mla	r5, r9, r3, r2
 1244 0970 3430DDE5 		.loc 1 428 0
 1245 0974 04048DE8 		add	r4, sp, #44
 1246 0978 0410A0E1 		mov	r1, #0
 1247 097c 30009DE5 		mov	r2, #12
 1248 0980 2020A0E3 		mov	r0, r4
 1249 0984 0FE0A0E1 	.LVL122:
 1250 0988 16FF2FE1 		bl	memset
 1251 098c 390000EA 		.loc 1 429 0
 1252              		ldr	r3, [sp, #8]
 1253              		strh	r3, [sp, #46]	@ movhi
 1254              	.LBE34:
 1255              		.loc 1 430 0
 1256              		ldr	r3, .L183
 1257              		add	fp, sp, #12
 1258 0990 000056E3 		ldr	ip, [r6, #0]
 1259              		mov	r1, fp
 1260              		str	r3, [sp, #0]
 1261              		mov	r0, r5
 1262 0994 08908DE5 		str	r4, [sp, #4]
 1263              		mov	r2, #32
 1264              		mov	r3, r9
 1265              		ldr	ip, [ip, #4]
 1266              		mov	lr, pc
 1267 0998 3F00000A 		bx	ip
 1268 099c 000051E3 	.LBB35:
 1269 09a0 3D00001A 		cmp	r0, #0
 1270 09a4 040080E2 	.LBE35:
 1271              		.loc 1 444 0
 1272              		mov	r1, r7
 1273 09a8 2030D0E5 		mov	r0, r6
 1274 09ac 100013E3 	.LVL123:
 1275 09b0 3900000A 	.LBB36:
 1276              		.loc 1 430 0
 1277 09b4 B272D0E1 		beq	.L163
 1278              		.loc 1 440 0
 1279              		ldr	r3, [sp, #48]
 1280 09b8 B291D6E1 		cmp	r3, #0
 1281              		bne	.L174
 1282              	.LBE36:
 1283              		.loc 1 444 0
 1284              		bl	fat16_get_next_cluster
 1285 09bc 182096E5 	.LVL124:
 1286 09c0 023047E2 	.LBB37:
 1287 09c4 992325E0 		subs	r7, r0, #0
 1288              		beq	.L163
 1289 09c8 2C408DE2 		b	.L172
 1290 09cc 0010A0E3 	.LVL125:
 1291 09d0 0C20A0E3 	.L174:
 1292 09d4 0400A0E1 		.loc 1 448 0
 1293              		mov	r1, #0
 1294 09d8 FEFFFFEB 		mov	r2, #44
 1295              		mov	r0, sl
 1296 09dc 08309DE5 	.LVL126:
 1297 09e0 BE32CDE1 		bl	memset
 1298              	.LBE37:
 1299              		.loc 1 451 0
 1300 09e4 C8309FE5 		ldr	r2, .L183+4
 1301 09e8 0CB08DE2 		ldr	ip, [r6, #0]
 1302 09ec 00C096E5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 1303 09f0 0B10A0E1 		stmia	sp, {r2, sl}	@ phole stm
 1304 09f4 00308DE5 		mov	r1, fp
 1305 09f8 0500A0E1 		ldr	r0, [sp, #48]
 1306 09fc 04408DE5 		mov	r2, #32
 1307 0a00 2020A0E3 		ldr	ip, [ip, #4]
 1308 0a04 0930A0E1 		mov	lr, pc
 1309 0a08 04C09CE5 		bx	ip
 1310 0a0c 0FE0A0E1 	.LVL127:
 1311 0a10 1CFF2FE1 	.L182:
 1312              	.LBB38:
 1313 0a14 000050E3 		cmp	r0, #0
 1314              		beq	.L163
 1315              	.LBE38:
 1316 0a18 0710A0E1 	.LBE33:
 1317 0a1c 0600A0E1 		.loc 1 1414 0
 1318              		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 1319              		cmp	r3, #0
 1320              		.loc 1 1416 0
 1321 0a20 1D00000A 		ldrneh	r3, [r8, #48]
 1322              		movne	r0, #1
 1323 0a24 30309DE5 		addne	r3, r3, #1
 1324 0a28 000053E3 		strneh	r3, [r8, #48]	@ movhi
 1325 0a2c 0300001A 		bne	.L160
 1326              	.LVL128:
 1327              	.L163:
 1328 0a30 FAFDFFEB 		.loc 1 1422 0
 1329              		mov	r3, #0	@ movhi
 1330              		strh	r3, [r8, #48]	@ movhi
 1331 0a34 007050E2 	.L179:
 1332 0a38 1700000A 		mov	r0, #0
 1333 0a3c DEFFFFEA 	.LVL129:
 1334              	.L160:
 1335              		.loc 1 1425 0
 1336              		add	sp, sp, #56
 1337 0a40 0010A0E3 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1338 0a44 2C20A0E3 		bx	lr
 1339 0a48 0A00A0E1 	.L184:
 1340              		.align	2
 1341 0a4c FEFFFFEB 	.L183:
 1342              		.word	fat16_dir_entry_seek_callback
 1343              		.word	fat16_dir_entry_read_callback
 1344 0a50 60209FE5 	.LFE23:
 1346 0a58 3430DDE5 		.align	2
 1347 0a5c 04048DE8 		.global	find_file_in_dir
 1349 0a64 30009DE5 	find_file_in_dir:
 1350 0a68 2020A0E3 	.LFB31:
 1351 0a6c 04C09CE5 		.loc 1 1923 0
 1352 0a70 0FE0A0E1 		@ Function supports interworking.
 1353 0a74 1CFF2FE1 		@ args = 0, pretend = 0, frame = 0
 1354              		@ frame_needed = 0, uses_anonymous_args = 0
 1355              	.LVL130:
 1356              		stmfd	sp!, {r4, r5, r6, lr}
 1357 0a78 000050E3 	.LCFI15:
 1358 0a7c 0600000A 		.loc 1 1923 0
 1359              		mov	r4, r1
 1360              		mov	r6, r2
 1361              		mov	r5, r3
 1362 0a80 0030DAE5 		b	.L186
 1363 0a84 000053E3 	.LVL131:
 1364              	.L187:
 1365 0a88 B033D811 		.loc 1 1926 0
 1366 0a8c 0100A013 		bl	strcmp
 1367 0a90 01308312 	.LVL132:
 1368 0a94 B033C811 		cmp	r0, #0
 1369 0a98 0200001A 		bne	.L186
 1370              	.LBB39:
 1371              	.LBB40:
 1372              		.loc 1 1440 0
 1373 0a9c 0030A0E3 		cmp	r4, #0
 1374 0aa0 B033C8E1 		moveq	r3, #1
 1375              		.loc 1 1443 0
 1376 0aa4 0000A0E3 		movne	r3, #1
 1377              		strneh	r0, [r4, #48]	@ movhi
 1378              		b	.L191
 1379              	.LVL133:
 1380 0aa8 38D08DE2 	.L186:
 1381 0aac F04FBDE8 	.LBE40:
 1382 0ab0 1EFF2FE1 	.LBE39:
 1383              		.loc 1 1924 0
 1384              		mov	r1, r5
 1385              		mov	r0, r4
 1386 0ab4 00000000 	.LVL134:
 1387 0ab8 00000000 		bl	fat16_read_dir
 1388              		subs	r3, r0, #0
 1389              		.loc 1 1926 0
 1390              		mov	r1, r6
 1391              		mov	r0, r5
 1392              		.loc 1 1924 0
 1393              		bne	.L187
 1394              	.L191:
 1395              		.loc 1 1934 0
 1396              		mov	r0, r3
 1397              		ldmfd	sp!, {r4, r5, r6, lr}
 1398              		bx	lr
 1399              	.LFE31:
 1401              		.global	__divsi3
 1402              		.align	2
 1404 0ac4 0260A0E1 	fat16_write_dir_entry:
 1405 0ac8 0350A0E1 	.LFB25:
 1406 0acc 070000EA 		.loc 1 1467 0
 1407              		@ Function supports interworking.
 1408              		@ args = 0, pretend = 0, frame = 32
 1409              		@ frame_needed = 0, uses_anonymous_args = 0
 1410 0ad0 FEFFFFEB 	.LVL135:
 1411              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1412 0ad4 000050E3 	.LCFI16:
 1413 0ad8 0400001A 		.loc 1 1469 0
 1414              		cmp	r1, #0
 1415              		cmpne	r0, #0
 1416              		.loc 1 1467 0
 1417 0adc 000054E3 		sub	sp, sp, #32
 1418 0ae0 0130A003 	.LCFI17:
 1419              		.loc 1 1469 0
 1420 0ae4 0130A013 		mov	r6, r1
 1421 0ae8 B003C411 		beq	.L197
 1422 0aec 060000EA 	.LVL136:
 1423              		.loc 1 1472 0
 1424              		ldr	r3, [r0, #0]
 1425              		.loc 1 1474 0
 1426              		mov	r0, r1
 1427              	.LVL137:
 1428 0af0 0510A0E1 		.loc 1 1472 0
 1429 0af4 0400A0E1 		ldr	r9, [r3, #8]
 1430              	.LVL138:
 1431 0af8 FEFFFFEB 		.loc 1 1474 0
 1432 0afc 003050E2 		bl	strlen
 1433              		and	r5, r0, #255
 1434 0b00 0610A0E1 	.LVL139:
 1435 0b04 0500A0E1 		.loc 1 1475 0
 1436              		mov	r1, #13
 1437 0b08 F0FFFF1A 		add	r0, r5, #12
 1438              		bl	__divsi3
 1439              		.loc 1 1481 0
 1440 0b0c 0300A0E1 		mov	r1, #32
 1441 0b10 7040BDE8 		.loc 1 1475 0
 1442 0b14 1EFF2FE1 		mov	r3, r0
 1443              		.loc 1 1481 0
 1444              		mov	r2, #11
 1445              		mov	r0, sp
 1446              		.loc 1 1475 0
 1447              		and	sl, r3, #255
 1448              	.LVL140:
 1449              		.loc 1 1473 0
 1450              		ldr	r8, [r6, #40]
 1451              	.LVL141:
 1452              		.loc 1 1481 0
 1453              		bl	memset
 1454              		.loc 1 1482 0
 1455 0b18 F0472DE9 		mov	r0, r6
 1456              		mov	r1, #46
 1457              		bl	strrchr
 1458 0b1c 000051E3 		.loc 1 1483 0
 1459 0b20 00005013 		cmp	r0, #0
 1460              		.loc 1 1481 0
 1461 0b24 20D04DE2 		mov	r7, sp
 1462              		.loc 1 1483 0
 1463              		beq	.L199
 1464 0b28 0160A0E1 	.LBB41:
 1465 0b2c 9800000A 		.loc 1 1485 0
 1466              		add	r4, r0, #1
 1467              	.LVL142:
 1468 0b30 003090E5 		.loc 1 1487 0
 1469              		mov	r0, r4
 1470 0b34 0100A0E1 		bl	strlen
 1471              		and	r2, r0, #255
 1472              	.LVL143:
 1473 0b38 089093E5 		.loc 1 1488 0
 1474              		rsb	r3, r2, r5
 1475              		sub	r3, r3, #1
 1476 0b3c FEFFFFEB 		.loc 1 1493 0
 1477 0b40 FF5000E2 		cmp	r2, #3
 1478              		movcs	r2, #3
 1479              	.LVL144:
 1480 0b44 0D10A0E3 		mov	r1, r4
 1481 0b48 0C0085E2 		add	r0, sp, #8
 1482 0b4c FEFFFFEB 		.loc 1 1488 0
 1483              		and	r5, r3, #255
 1484 0b50 2010A0E3 		.loc 1 1493 0
 1485              		bl	memcpy
 1486 0b54 0030A0E1 	.L199:
 1487              	.LBE41:
 1488 0b58 0B20A0E3 		.loc 1 1496 0
 1489 0b5c 0D00A0E1 		cmp	r5, #8
 1490              		bhi	.L201
 1491 0b60 FFA003E2 		.loc 1 1498 0
 1492              		mov	r0, sp
 1493              		mov	r2, r5
 1494 0b64 288096E5 		mov	r1, r6
 1495              		bl	memcpy
 1496              		b	.L203
 1497 0b68 FEFFFFEB 	.L201:
 1498              	.LBB42:
 1499 0b6c 0600A0E1 		.loc 1 1502 0
 1500 0b70 2E10A0E3 		mov	r2, #8
 1501 0b74 FEFFFFEB 		mov	r0, sp
 1502              		mov	r1, r6
 1503 0b78 000050E3 		bl	memcpy
 1504              		.loc 1 1507 0
 1505 0b7c 0D70A0E1 		ldrb	r3, [r6, #34]	@ zero_extendqisi2
 1506              	.LVL145:
 1507 0b80 0B00000A 		.loc 1 1509 0
 1508              		cmp	r3, #159
 1509              		mov	r2, r3, lsr #4
 1510 0b84 014080E2 		.loc 1 1510 0
 1511              		and	r3, r3, #15
 1512              	.LVL146:
 1513 0b88 0400A0E1 		.loc 1 1509 0
 1514 0b8c FEFFFFEB 		addls	r2, r2, #48
 1515 0b90 FF2000E2 		addhi	r2, r2, #97
 1516              		.loc 1 1511 0
 1517              		cmp	r3, #9
 1518 0b94 053062E0 		addls	r3, r3, #48
 1519 0b98 013043E2 	.LVL147:
 1520              		addhi	r3, r3, #97
 1521 0b9c 030052E3 	.LVL148:
 1522 0ba0 0320A023 		.loc 1 1509 0
 1523              		strb	r2, [sp, #6]
 1524 0ba4 0410A0E1 		.loc 1 1511 0
 1525 0ba8 08008DE2 		strb	r3, [sp, #7]
 1526              	.L203:
 1527 0bac FF5003E2 	.LBE42:
 1528              		.loc 1 1515 0
 1529 0bb0 FEFFFFEB 		mov	r1, #0
 1530              		mov	r2, #21
 1531              		add	r0, sp, #11
 1532              		bl	memset
 1533 0bb4 080055E3 		.loc 1 1516 0
 1534 0bb8 0400008A 		ldrb	r3, [r6, #32]	@ zero_extendqisi2
 1535              		strb	r3, [sp, #11]
 1536 0bbc 0D00A0E1 		.loc 1 1573 0
 1537 0bc0 0520A0E1 		ldrh	r2, [r6, #34]
 1538 0bc4 0610A0E1 		.loc 1 1574 0
 1539 0bc8 FEFFFFEB 		mov	r3, r2, lsr #8
 1540 0bcc 0E0000EA 		.loc 1 1573 0
 1541              		strb	r2, [sp, #26]
 1542              		.loc 1 1574 0
 1543              		strb	r3, [sp, #27]
 1544 0bd0 0820A0E3 		.loc 1 1575 0
 1545 0bd4 0D00A0E1 		ldr	r3, [r6, #36]
 1546 0bd8 0610A0E1 		.loc 1 1578 0
 1547 0bdc FEFFFFEB 		mov	r0, r3, lsr #24
 1548              		.loc 1 1576 0
 1549 0be0 2230D6E5 		mov	r2, r3, lsr #8
 1550              		.loc 1 1577 0
 1551              		mov	r1, r3, lsr #16
 1552 0be4 9F0053E3 		.loc 1 1576 0
 1553 0be8 2322A0E1 		strb	r2, [sp, #29]
 1554              		.loc 1 1577 0
 1555 0bec 0F3003E2 		strb	r1, [sp, #30]
 1556              		.loc 1 1578 0
 1557              		strb	r0, [sp, #31]
 1558 0bf0 30208292 		.loc 1 1575 0
 1559 0bf4 61208282 		strb	r3, [sp, #28]
 1560              		.loc 1 1581 0
 1561 0bf8 090053E3 		add	r0, r8, sl, asl #5
 1562 0bfc 30308392 		mov	r1, sp
 1563              		mov	r2, #32
 1564 0c00 61308382 		mov	lr, pc
 1565              		bx	r9
 1566              		cmp	r0, #0
 1567 0c04 0620CDE5 		.loc 1 1515 0
 1568              		mov	r4, sp
 1569 0c08 0730CDE5 	.LVL149:
 1570              		.loc 1 1581 0
 1571              		beq	.L197
 1572              		.loc 1 1585 0
 1573 0c0c 0010A0E3 		ldrb	r7, [sp, #0]	@ zero_extendqisi2
 1574 0c10 1520A0E3 	.LVL150:
 1575 0c14 0B008DE2 		mov	r1, sp
 1576 0c18 FEFFFFEB 	.L211:
 1577              		.loc 1 1588 0
 1578 0c1c 2030D6E5 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 1579 0c20 0B30CDE5 		mov	r3, r7, asl #7
 1580              		orr	r3, r3, r7, lsr #1
 1581 0c24 B222D6E1 		add	r3, r3, r2
 1582              		.loc 1 1587 0
 1583 0c28 2234A0E1 		add	r2, sp, #10
 1584              		cmp	r1, r2
 1585 0c2c 1A20CDE5 		.loc 1 1588 0
 1586              		and	r7, r3, #255
 1587 0c30 1B30CDE5 		.loc 1 1587 0
 1588              		bne	.L211
 1589 0c34 243096E5 		mov	r5, sl
 1590              	.LVL151:
 1591 0c38 230CA0E1 		b	.L213
 1592              	.L214:
 1593 0c3c 2324A0E1 	.LBB43:
 1594              		.loc 1 1594 0
 1595 0c40 2318A0E1 		mov	r1, #0
 1596              		mov	r2, #32
 1597 0c44 1D20CDE5 		mov	r0, sp
 1598              		bl	memset
 1599 0c48 1E10CDE5 		.loc 1 1595 0
 1600              		mov	r1, #255
 1601 0c4c 1F00CDE5 		mov	r2, #10
 1602              		add	r0, sp, #1
 1603 0c50 1C30CDE5 		bl	memset
 1604              		.loc 1 1596 0
 1605 0c54 8A0288E0 		mov	r1, #255
 1606 0c58 0D10A0E1 		mov	r2, #12
 1607 0c5c 2020A0E3 		add	r0, sp, #14
 1608 0c60 0FE0A0E1 		bl	memset
 1609 0c64 19FF2FE1 		.loc 1 1597 0
 1610 0c68 000050E3 		add	r0, sp, #28
 1611              		mov	r1, #255
 1612 0c6c 0D40A0E1 		mov	r2, #4
 1613              		bl	memset
 1614              		.loc 1 1600 0
 1615 0c70 4700000A 		cmp	r5, sl
 1616              		.loc 1 1601 0
 1617 0c74 0070DDE5 		orreq	r3, r5, #64
 1618              		.loc 1 1599 0
 1619 0c78 0D10A0E1 		strb	r5, [sp, #0]
 1620              		.loc 1 1601 0
 1621              		streqb	r3, [sp, #0]
 1622 0c7c 0120F1E5 		mov	r3, #13
 1623 0c80 8733A0E1 		mla	lr, r5, r3, r6
 1624 0c84 A73083E1 		mov	ip, #1
 1625 0c88 023083E0 	.LVL152:
 1626              	.L217:
 1627 0c8c 0A208DE2 		.loc 1 1608 0
 1628 0c90 020051E1 		add	r3, ip, #1
 1629              		and	r3, r3, #255
 1630 0c94 FF7003E2 	.LVL153:
 1631              		.loc 1 1609 0
 1632 0c98 F7FFFF1A 		add	r2, r3, #1
 1633 0c9c 0A50A0E1 		.loc 1 1608 0
 1634              		add	r4, sp, #32
 1635 0ca0 370000EA 		ldrb	r0, [lr, #-13]	@ zero_extendqisi2
 1636              		add	r1, r4, ip
 1637              		.loc 1 1609 0
 1638              		and	ip, r2, #255
 1639 0ca4 0010A0E3 		.loc 1 1611 0
 1640 0ca8 2020A0E3 		cmp	ip, #11
 1641 0cac 0D00A0E1 		.loc 1 1609 0
 1642 0cb0 FEFFFFEB 		add	r2, r4, r3
 1643              		mov	r3, #0
 1644 0cb4 FF10A0E3 	.LVL154:
 1645 0cb8 0A20A0E3 		.loc 1 1608 0
 1646 0cbc 01008DE2 		strb	r0, [r1, #-32]
 1647 0cc0 FEFFFFEB 		.loc 1 1611 0
 1648              		moveq	ip, #14
 1649 0cc4 FF10A0E3 		.loc 1 1609 0
 1650 0cc8 0C20A0E3 		strb	r3, [r2, #-32]
 1651 0ccc 0E008DE2 		.loc 1 1611 0
 1652 0cd0 FEFFFFEB 		beq	.L218
 1653              		cmp	ip, #26
 1654 0cd4 1C008DE2 		addeq	ip, ip, #2
 1655 0cd8 FF10A0E3 	.L218:
 1656 0cdc 0420A0E3 		.loc 1 1621 0
 1657 0ce0 FEFFFFEB 		ldrb	r3, [lr, #-13]	@ zero_extendqisi2
 1658              		cmp	r3, #0
 1659 0ce4 0A0055E1 		.loc 1 1622 0
 1660              		add	lr, lr, #1
 1661 0ce8 40308503 		.loc 1 1621 0
 1662              		beq	.L221
 1663 0cec 0050CDE5 		.loc 1 1606 0
 1664              		cmp	ip, #30
 1665 0cf0 0030CD05 		bls	.L217
 1666 0cf4 0D30A0E3 	.L221:
 1667 0cf8 95632EE0 		.loc 1 1626 0
 1668 0cfc 01C0A0E3 		mov	r3, #15
 1669              		strb	r3, [sp, #11]
 1670              		.loc 1 1632 0
 1671              		mov	r0, r8
 1672 0d00 01308CE2 		.loc 1 1629 0
 1673 0d04 FF3003E2 		strb	r7, [sp, #13]
 1674              		.loc 1 1632 0
 1675              		mov	r1, sp
 1676 0d08 012083E2 		mov	r2, #32
 1677              		mov	lr, pc
 1678 0d0c 20408DE2 		bx	r9
 1679 0d10 0D005EE5 	.LVL155:
 1680 0d14 0C1084E0 	.LBE43:
 1681              		.loc 1 1592 0
 1682 0d18 FFC002E2 		sub	r3, r5, #1
 1683              	.LBB44:
 1684 0d1c 0B005CE3 		.loc 1 1634 0
 1685              		add	r8, r8, #32
 1686 0d20 032084E0 	.LBE44:
 1687 0d24 0030A0E3 		.loc 1 1592 0
 1688              		and	r5, r3, #255
 1689              	.L213:
 1690 0d28 200041E5 		cmp	r5, #0
 1691              		bne	.L214
 1692 0d2c 0EC0A003 		mov	r0, #1
 1693              		b	.L224
 1694 0d30 203042E5 	.LVL156:
 1695              	.L197:
 1696 0d34 0100000A 		mov	r0, #0
 1697 0d38 1A005CE3 	.LVL157:
 1698 0d3c 02C08C02 	.L224:
 1699              		.loc 1 1642 0
 1700              		add	sp, sp, #32
 1701 0d40 0D305EE5 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1702 0d44 000053E3 		bx	lr
 1703              	.LFE25:
 1705              		.global	__udivsi3
 1706 0d4c 0100000A 		.align	2
 1707              		.global	fat16_resize_file
 1709 0d54 E9FFFF9A 	fat16_resize_file:
 1710              	.LFB20:
 1711              		.loc 1 1262 0
 1712 0d58 0F30A0E3 		@ Function supports interworking.
 1713 0d5c 0B30CDE5 		@ args = 0, pretend = 0, frame = 4
 1714              		@ frame_needed = 0, uses_anonymous_args = 0
 1715 0d60 0800A0E1 	.LVL158:
 1716              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1717 0d64 0D70CDE5 	.LCFI18:
 1718              		.loc 1 1264 0
 1719 0d68 0D10A0E1 		subs	r6, r0, #0
 1720 0d6c 2020A0E3 		.loc 1 1262 0
 1721 0d70 0FE0A0E1 		sub	sp, sp, #4
 1722 0d74 19FF2FE1 	.LCFI19:
 1723              		.loc 1 1262 0
 1724              		mov	sl, r1
 1725              		.loc 1 1264 0
 1726 0d78 013045E2 		beq	.L230
 1727              	.LVL159:
 1728              		.loc 1 1267 0
 1729 0d7c 208088E2 		ldrh	r4, [r6, #38]
 1730              	.LVL160:
 1731              		.loc 1 1268 0
 1732 0d80 FF5003E2 		ldr	r3, [r6, #0]
 1733              		.loc 1 1273 0
 1734 0d84 000055E3 		rsbs	r9, r1, #1
 1735 0d88 C5FFFF1A 		movcc	r9, #0
 1736 0d8c 0100A0E3 		cmp	r4, #0
 1737 0d90 000000EA 		cmpeq	r1, #0
 1738              		.loc 1 1268 0
 1739              		ldrh	r8, [r3, #18]
 1740 0d94 0000A0E3 	.LVL161:
 1741              		.loc 1 1275 0
 1742              		movne	r7, r1
 1743              	.LVL162:
 1744 0d98 20D08DE2 		.loc 1 1273 0
 1745 0d9c F047BDE8 		bne	.L234
 1746 0da0 1EFF2FE1 	.LVL163:
 1747              		b	.L232
 1748              	.LVL164:
 1749              	.L235:
 1750              	.LBB49:
 1751              		.loc 1 1281 0
 1752              		ldr	r0, [r6, #0]
 1753              		bl	fat16_get_next_cluster
 1754              	.LVL165:
 1755              		.loc 1 1282 0
 1756              		cmp	r0, #0
 1757              		beq	.L236
 1758              		.loc 1 1289 0
 1759              		rsb	r7, r8, r7
 1760 0da4 F0472DE9 		mov	r4, r0
 1761              	.LVL166:
 1762              	.L234:
 1763 0da8 006050E2 	.LBE49:
 1764              		.loc 1 1278 0
 1765 0dac 04D04DE2 		cmp	r7, r8
 1766              	.LBB50:
 1767              		.loc 1 1281 0
 1768 0db0 01A0A0E1 		mov	r1, r4
 1769              	.LBE50:
 1770 0db4 5B00000A 		.loc 1 1278 0
 1771              		bhi	.L235
 1772              	.LVL167:
 1773 0db8 B642D6E1 		.loc 1 1293 0
 1774              		rsbs	r5, r4, #1
 1775              		movcc	r5, #0
 1776 0dbc 003096E5 		cmp	r5, #0
 1777              		beq	.L239
 1778 0dc0 019071E2 	.LVL168:
 1779 0dc4 0090A033 	.L240:
 1780 0dc8 000054E3 	.LBB51:
 1781 0dcc 00005103 		.loc 1 1298 0
 1782              		mov	r1, r8
 1783 0dd0 B281D3E1 		mov	r0, r7
 1784              		bl	__udivsi3
 1785              		mov	r0, r0, asl #16
 1786 0dd4 0170A011 		mov	r2, r0, lsr #16
 1787              	.LVL169:
 1788              		.loc 1 1299 0
 1789 0dd8 0600001A 		mul	r3, r8, r2
 1790              		cmp	r3, r7
 1791 0ddc 490000EA 		.loc 1 1300 0
 1792              		addcc	r3, r2, #1
 1793              		movcc	r3, r3, asl #16
 1794              		movcc	r2, r3, lsr #16
 1795              		.loc 1 1301 0
 1796 0de0 000096E5 		ldr	r0, [r6, #0]
 1797 0de4 0DFDFFEB 		mov	r1, r4
 1798              		bl	fat16_append_clusters
 1799              	.LVL170:
 1800 0de8 000050E3 		.loc 1 1302 0
 1801 0dec 4F00000A 		cmp	r0, #0
 1802              		beq	.L230
 1803 0df0 077068E0 		.loc 1 1305 0
 1804 0df4 0040A0E1 		cmp	r5, #0
 1805              		.loc 1 1308 0
 1806              		strneh	r0, [r6, #38]	@ movhi
 1807              		movne	r4, r0
 1808              	.LVL171:
 1809 0df8 080057E1 	.L239:
 1810              	.LBE51:
 1811              		.loc 1 1314 0
 1812 0dfc 0410A0E1 		cmp	r9, #0
 1813              		.loc 1 1315 0
 1814              		movne	r3, #0	@ movhi
 1815 0e00 F6FFFF8A 		strneh	r3, [r6, #38]	@ movhi
 1816              		.loc 1 1313 0
 1817              		str	sl, [r6, #40]
 1818 0e04 015074E2 		.loc 1 1316 0
 1819 0e08 0050A033 		ldr	r0, [r6, #0]
 1820 0e0c 000055E3 		add	r1, r6, #4
 1821 0e10 1100000A 		bl	fat16_write_dir_entry
 1822              		cmp	r0, #0
 1823              		beq	.L230
 1824              		.loc 1 1319 0
 1825              		cmp	r9, #0
 1826 0e14 0810A0E1 		.loc 1 1322 0
 1827 0e18 0700A0E1 		movne	r1, r4
 1828 0e1c FEFFFFEB 		ldrne	r0, [r6, #0]
 1829 0e20 0008A0E1 		.loc 1 1319 0
 1830 0e24 2028A0E1 		bne	.L258
 1831              	.LVL172:
 1832              		.loc 1 1324 0
 1833 0e28 980203E0 		cmp	r7, r8
 1834 0e2c 070053E1 		bhi	.L232
 1835              		mov	r3, r4, asl #16
 1836 0e30 01308232 		ldr	r5, [r6, #0]
 1837 0e34 0338A031 	.LVL173:
 1838 0e38 2328A031 		mov	r4, r3, lsr #16
 1839              	.LVL174:
 1840 0e3c 000096E5 	.LBB52:
 1841 0e40 0410A0E1 		.loc 1 895 0
 1842 0e44 55FDFFEB 		cmp	r5, #0
 1843              		cmpne	r4, #1
 1844              		bls	.L232
 1845 0e48 000050E3 		.loc 1 899 0
 1846 0e4c 3500000A 		mov	r1, r4
 1847              	.LVL175:
 1848 0e50 000055E3 		mov	r0, r5
 1849              		bl	fat16_get_next_cluster
 1850 0e54 B602C611 	.LBB53:
 1851 0e58 0040A011 		.loc 1 903 0
 1852              		mvn	r3, #0
 1853              		.loc 1 904 0
 1854              		strb	r3, [sp, #3]
 1855              		.loc 1 903 0
 1856 0e5c 000059E3 		strb	r3, [sp, #2]
 1857              	.LBE53:
 1858 0e60 0030A013 		.loc 1 899 0
 1859 0e64 B632C611 		mov	r7, r0
 1860              	.LVL176:
 1861 0e68 28A086E5 		.loc 1 905 0
 1862              		ldr	r0, [r5, #8]
 1863 0e6c 000096E5 		ldr	r3, [r5, #0]
 1864 0e70 041086E2 		add	r0, r0, r4, asl #1
 1865 0e74 27FFFFEB 		add	r1, sp, #2
 1866 0e78 000050E3 		mov	r2, #2
 1867 0e7c 2900000A 		ldr	ip, [r3, #8]
 1868              		mov	lr, pc
 1869 0e80 000059E3 		bx	ip
 1870              	.LBB54:
 1871 0e84 0410A011 		cmp	r0, #0
 1872 0e88 00009615 		beq	.L232
 1873              		.loc 1 909 0
 1874 0e8c 1C00001A 		cmp	r7, #0
 1875              		beq	.L232
 1876              	.LBE54:
 1877 0e90 080057E1 		.loc 1 910 0
 1878 0e94 1B00008A 		mov	r0, r5
 1879 0e98 0438A0E1 		mov	r1, r7
 1880 0e9c 005096E5 	.LVL177:
 1881              	.L258:
 1882 0ea0 2348A0E1 		bl	fat16_free_clusters
 1883              	.LVL178:
 1884              	.L232:
 1885              	.LBE52:
 1886 0ea4 000055E3 		.loc 1 1334 0
 1887 0ea8 01005413 		ldr	r3, [r6, #48]
 1888 0eac 1500009A 		cmp	sl, r3
 1889              		.loc 1 1337 0
 1890 0eb0 0410A0E1 		movcc	r3, #0	@ movhi
 1891              		.loc 1 1334 0
 1892 0eb4 0500A0E1 		movcs	r0, #1
 1893 0eb8 D8FCFFEB 		.loc 1 1337 0
 1894              		movcc	r0, #1
 1895              		.loc 1 1336 0
 1896 0ebc 0030E0E3 		strcc	sl, [r6, #48]
 1897              		.loc 1 1337 0
 1898 0ec0 0330CDE5 		strcch	r3, [r6, #52]	@ movhi
 1899              		b	.L256
 1900 0ec4 0230CDE5 	.LVL179:
 1901              	.L230:
 1902              		mov	r0, #0
 1903 0ec8 0070A0E1 		b	.L256
 1904              	.LVL180:
 1905              	.L236:
 1906 0ecc 080095E5 		.loc 1 1293 0
 1907 0ed0 003095E5 		rsbs	r5, r4, #1
 1908 0ed4 840080E0 		movcc	r5, #0
 1909 0ed8 02108DE2 		b	.L240
 1910 0edc 0220A0E3 	.LVL181:
 1911 0ee0 08C093E5 	.L256:
 1912 0ee4 0FE0A0E1 		.loc 1 1344 0
 1913 0ee8 1CFF2FE1 		add	sp, sp, #4
 1914              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1915 0eec 000050E3 		bx	lr
 1916 0ef0 0400000A 	.LFE20:
 1918 0ef4 000057E3 		.align	2
 1919 0ef8 0200000A 		.global	fat16_seek_file
 1921              	fat16_seek_file:
 1922 0efc 0500A0E1 	.LFB19:
 1923 0f00 0710A0E1 		.loc 1 1212 0
 1924              		@ Function supports interworking.
 1925              		@ args = 0, pretend = 0, frame = 0
 1926 0f04 EFFCFFEB 		@ frame_needed = 0, uses_anonymous_args = 0
 1927              	.LVL182:
 1928              		.loc 1 1213 0
 1929              		cmp	r1, #0
 1930              		cmpne	r0, #0
 1931 0f08 303096E5 		.loc 1 1212 0
 1932 0f0c 03005AE1 		stmfd	sp!, {r4, r5, r6, lr}
 1933              	.LCFI20:
 1934 0f10 0030A033 		.loc 1 1212 0
 1935              		and	r2, r2, #255
 1936 0f14 0100A023 		.loc 1 1213 0
 1937              		mov	r5, r0
 1938 0f18 0100A033 		mov	r6, r1
 1939              		beq	.L260
 1940 0f1c 30A08635 	.LVL183:
 1941              		.loc 1 1217 0
 1942 0f20 B433C631 		cmp	r2, #1
 1943 0f24 040000EA 		.loc 1 1216 0
 1944              		ldr	r1, [r0, #48]
 1945              	.LVL184:
 1946 0f28 0000A0E3 		.loc 1 1217 0
 1947 0f2c 020000EA 		beq	.L263
 1948              	.LVL185:
 1949              		.loc 1 1220 0
 1950              		ldrcc	r4, [r6, #0]
 1951 0f30 015074E2 	.LVL186:
 1952 0f34 0050A033 		.loc 1 1217 0
 1953 0f38 B5FFFFEA 		bcc	.L265
 1954              		cmp	r2, #2
 1955              		bne	.L260
 1956              		b	.L264
 1957 0f3c 04D08DE2 	.LVL187:
 1958 0f40 F047BDE8 	.L263:
 1959 0f44 1EFF2FE1 		.loc 1 1223 0
 1960              		ldr	r3, [r6, #0]
 1961              		add	r4, r1, r3
 1962              	.LVL188:
 1963              		b	.L265
 1964              	.L264:
 1965              		.loc 1 1226 0
 1966              		ldr	r2, [r0, #40]
 1967              	.LVL189:
 1968              		ldr	r3, [r6, #0]
 1969              		add	r4, r2, r3
 1970              	.LVL190:
 1971              	.L265:
 1972              		.loc 1 1232 0
 1973 0f48 000051E3 		ldr	r3, [r5, #40]
 1974 0f4c 00005013 		cmp	r4, r3
 1975              		bls	.L266
 1976 0f50 70402DE9 	.LVL191:
 1977              		mov	r0, r5
 1978              		mov	r1, r4
 1979 0f54 FF2002E2 	.LVL192:
 1980              		bl	fat16_resize_file
 1981 0f58 0050A0E1 	.LVL193:
 1982 0f5c 0160A0E1 		cmp	r0, #0
 1983 0f60 1B00000A 		beq	.L260
 1984              	.LVL194:
 1985              	.L266:
 1986 0f64 010052E3 		.loc 1 1236 0
 1987              		mov	r3, #0	@ movhi
 1988 0f68 301090E5 		.loc 1 1238 0
 1989              		mov	r0, #1
 1990              		.loc 1 1235 0
 1991 0f6c 0400000A 		str	r4, [r5, #48]
 1992              		.loc 1 1236 0
 1993              		strh	r3, [r5, #52]	@ movhi
 1994 0f70 00409635 		.loc 1 1238 0
 1995              		str	r4, [r6, #0]
 1996              		b	.L268
 1997 0f74 0800003A 	.LVL195:
 1998 0f78 020052E3 	.L260:
 1999 0f7c 1400001A 		.loc 1 1239 0
 2000 0f80 020000EA 		mov	r0, #0
 2001              	.L268:
 2002              		.loc 1 1240 0
 2003              		ldmfd	sp!, {r4, r5, r6, lr}
 2004 0f84 003096E5 		bx	lr
 2005 0f88 034081E0 	.LFE19:
 2007 0f8c 020000EA 		.align	2
 2008              		.global	fat16_write_file
 2010 0f90 282090E5 	fat16_write_file:
 2011              	.LFB18:
 2012 0f94 003096E5 		.loc 1 1066 0
 2013 0f98 034082E0 		@ Function supports interworking.
 2014              		@ args = 0, pretend = 0, frame = 4
 2015              		@ frame_needed = 0, uses_anonymous_args = 0
 2016              	.LVL196:
 2017 0f9c 283095E5 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2018 0fa0 030054E1 	.LCFI21:
 2019 0fa4 0400009A 		mov	r2, r2, asl #16
 2020              	.LVL197:
 2021 0fa8 0500A0E1 		sub	sp, sp, #4
 2022 0fac 0410A0E1 	.LCFI22:
 2023              		.loc 1 1066 0
 2024 0fb0 FEFFFFEB 		mov	r2, r2, lsr #16
 2025              		.loc 1 1069 0
 2026 0fb4 000050E3 		cmp	r1, #0
 2027 0fb8 0500000A 		cmpne	r0, #0
 2028              		mov	r4, r0
 2029              		mov	fp, r1
 2030              		.loc 1 1066 0
 2031 0fbc 0030A0E3 		str	r2, [sp, #0]
 2032              	.LVL198:
 2033 0fc0 0100A0E3 		.loc 1 1069 0
 2034              		beq	.L271
 2035 0fc4 304085E5 	.LVL199:
 2036              		cmp	r2, #0
 2037 0fc8 B433C5E1 		beq	.L271
 2038              		.loc 1 1071 0
 2039 0fcc 004086E5 		ldr	sl, [r0, #48]
 2040 0fd0 000000EA 		ldr	r3, [r0, #40]
 2041              		cmp	sl, r3
 2042              		bhi	.L271
 2043              	.LVL200:
 2044 0fd4 0000A0E3 		.loc 1 1075 0
 2045              		ldrh	r5, [r0, #52]
 2046              	.LVL201:
 2047 0fd8 7040BDE8 		.loc 1 1074 0
 2048 0fdc 1EFF2FE1 		ldr	r0, [r0, #0]
 2049              	.LVL202:
 2050              		.loc 1 1080 0
 2051              		cmp	r5, #0
 2052              		.loc 1 1074 0
 2053              		ldrh	r8, [r0, #18]
 2054              	.LVL203:
 2055              		.loc 1 1080 0
 2056              		bne	.L275
 2057              		.loc 1 1082 0
 2058              		ldrh	r5, [r4, #38]
 2059              		.loc 1 1084 0
 2060              		cmp	r5, #0
 2061 0fe0 F04F2DE9 		bne	.L277
 2062              		.loc 1 1086 0
 2063 0fe4 0228A0E1 		cmp	sl, #0
 2064              		bne	.L271
 2065 0fe8 04D04DE2 		.loc 1 1089 0
 2066              		mov	r1, r5
 2067              		mov	r2, #1
 2068 0fec 2228A0E1 		bl	fat16_append_clusters
 2069              		.loc 1 1090 0
 2070 0ff0 000051E3 		cmp	r0, #0
 2071 0ff4 00005013 		.loc 1 1089 0
 2072 0ff8 0040A0E1 		mov	r5, r0
 2073 0ffc 01B0A0E1 		strh	r0, [r4, #38]	@ movhi
 2074              		.loc 1 1090 0
 2075 1000 00208DE5 		beq	.L271
 2076              	.LVL204:
 2077              	.L277:
 2078 1004 7700000A 		.loc 1 1099 0
 2079              		ldr	r6, [r4, #48]
 2080 1008 000052E3 	.LVL205:
 2081 100c 7500000A 		cmp	r6, #0
 2082              		rsbne	r9, r8, #0
 2083 1010 30A090E5 		rsbne	r7, r8, r6
 2084 1014 283090E5 		bne	.L281
 2085 1018 03005AE1 		b	.L275
 2086 101c 7100008A 	.LVL206:
 2087              	.L282:
 2088              	.LBB55:
 2089 1020 B453D0E1 		.loc 1 1106 0
 2090              		ldr	r0, [r4, #0]
 2091              	.LVL207:
 2092 1024 000090E5 		bl	fat16_get_next_cluster
 2093              	.LVL208:
 2094              		.loc 1 1107 0
 2095 1028 000055E3 		cmp	r0, #0
 2096              		cmpeq	r7, #0
 2097 102c B281D0E1 	.LBE55:
 2098              		.loc 1 1099 0
 2099              		add	r6, r6, r9
 2100 1030 2000001A 	.LBB56:
 2101              		.loc 1 1109 0
 2102 1034 B652D4E1 		add	r7, r7, r9
 2103              		mov	r1, r5
 2104 1038 000055E3 		mov	r2, #1
 2105 103c 0800001A 		.loc 1 1107 0
 2106              		.loc 1 1109 0
 2107 1040 00005AE3 		ldreq	r0, [r4, #0]
 2108 1044 6700001A 	.LVL209:
 2109              		bleq	fat16_append_clusters
 2110 1048 0510A0E1 	.LVL210:
 2111 104c 0120A0E3 	.L283:
 2112 1050 D2FCFFEB 		.loc 1 1110 0
 2113              		subs	r5, r0, #0
 2114 1054 000050E3 		beq	.L271
 2115              	.LVL211:
 2116 1058 0050A0E1 	.L281:
 2117 105c B602C4E1 		.loc 1 1103 0
 2118              		cmp	r6, r8
 2119 1060 6000000A 		.loc 1 1106 0
 2120              		mov	r1, r5
 2121              		.loc 1 1103 0
 2122              		bcs	.L282
 2123 1064 306094E5 	.LVL212:
 2124              	.L275:
 2125 1068 000056E3 	.LBE56:
 2126 106c 00906812 		.loc 1 1077 0
 2127 1070 06706810 		mov	r0, sl
 2128 1074 0C00001A 	.LVL213:
 2129 1078 0E0000EA 		mov	r1, r8
 2130              		bl	__umodsi3
 2131              		ldr	r7, [sp, #0]
 2132              	.LVL214:
 2133              		mov	r0, r0, asl #16
 2134 107c 000094E5 		mov	sl, r0, lsr #16
 2135              	.LVL215:
 2136 1080 66FCFFEB 	.LVL216:
 2137              	.L285:
 2138              	.LBB57:
 2139 1084 000050E3 		.loc 1 1123 0
 2140 1088 00005703 		ldr	ip, [r4, #0]
 2141              		.loc 1 1124 0
 2142              		rsb	r3, sl, r8
 2143 108c 096086E0 		.loc 1 1129 0
 2144              		ldr	r2, [ip, #24]
 2145              		.loc 1 1124 0
 2146 1090 097087E0 		mov	r3, r3, asl #16
 2147 1094 0510A0E1 		mov	r3, r3, lsr #16
 2148 1098 0120A0E3 	.LVL217:
 2149              		cmp	r7, r3
 2150              		movcc	r6, r7
 2151 109c 00009405 		movcs	r6, r3
 2152              	.LVL218:
 2153 10a0 BEFCFF0B 		.loc 1 1129 0
 2154              		add	r2, sl, r2
 2155              		sub	r3, r5, #2
 2156              	.LVL219:
 2157 10a4 005050E2 		mla	r0, r8, r3, r2
 2158 10a8 4E00000A 	.LVL220:
 2159              		mov	r1, fp
 2160              		mov	r2, r6
 2161              		ldr	r3, [ip, #0]
 2162 10ac 080056E1 		ldr	ip, [r3, #8]
 2163              		mov	lr, pc
 2164 10b0 0510A0E1 		bx	ip
 2165              		.loc 1 1134 0
 2166 10b4 F0FFFF2A 		rsb	r3, r6, r7
 2167              		.loc 1 1129 0
 2168              		cmp	r0, #0
 2169              	.LBB58:
 2170              		.loc 1 1140 0
 2171 10b8 0A00A0E1 		mov	r1, r5
 2172              	.LBE58:
 2173 10bc 0810A0E1 		.loc 1 1133 0
 2174 10c0 FEFFFFEB 		add	fp, fp, r6
 2175 10c4 00709DE5 		.loc 1 1137 0
 2176              		add	r2, sl, r6
 2177 10c8 0008A0E1 		.loc 1 1134 0
 2178 10cc 20A8A0E1 		mov	r0, r3, asl #16
 2179              		.loc 1 1129 0
 2180              		beq	.L286
 2181              		.loc 1 1135 0
 2182              		ldr	r3, [r4, #48]
 2183              		.loc 1 1137 0
 2184 10d0 00C094E5 		cmp	r2, r8
 2185              		.loc 1 1135 0
 2186 10d4 08306AE0 		add	r3, r3, r6
 2187              		str	r3, [r4, #48]
 2188 10d8 18209CE5 		.loc 1 1134 0
 2189              		mov	r7, r0, lsr #16
 2190 10dc 0338A0E1 		.loc 1 1137 0
 2191 10e0 2338A0E1 		blt	.L288
 2192              	.LBB59:
 2193 10e4 030057E1 		.loc 1 1140 0
 2194 10e8 0760A031 		ldr	r0, [r4, #0]
 2195 10ec 0360A021 		bl	fat16_get_next_cluster
 2196              		.loc 1 1147 0
 2197              		mov	sl, #0
 2198 10f0 02208AE0 	.LVL221:
 2199 10f4 023045E2 		.loc 1 1141 0
 2200              		cmp	r0, sl
 2201 10f8 982320E0 		movne	r3, #0
 2202              		moveq	r3, #1
 2203 10fc 0B10A0E1 		cmp	r7, sl
 2204 1100 0620A0E1 		moveq	r3, #0
 2205 1104 00309CE5 		cmp	r3, sl
 2206 1108 08C093E5 		.loc 1 1143 0
 2207 110c 0FE0A0E1 		mov	r1, r5
 2208 1110 1CFF2FE1 		mov	r2, #1
 2209              		.loc 1 1141 0
 2210 1114 073066E0 		.loc 1 1143 0
 2211              		ldrne	r0, [r4, #0]
 2212 1118 000050E3 	.LVL222:
 2213              		blne	fat16_append_clusters
 2214              	.LVL223:
 2215 111c 0510A0E1 	.L290:
 2216              		.loc 1 1144 0
 2217              		cmp	r0, #0
 2218 1120 06B08BE0 		.loc 1 1147 0
 2219              		mov	r5, r0
 2220 1124 06208AE0 		.loc 1 1144 0
 2221              		beq	.L300
 2222 1128 0308A0E1 	.LVL224:
 2223              	.L288:
 2224 112c 1800000A 	.LBE59:
 2225              	.LBE57:
 2226 1130 303094E5 		.loc 1 1157 0
 2227              		cmp	r7, #0
 2228 1134 080052E1 	.LBB60:
 2229              		.loc 1 1154 0
 2230 1138 063083E0 		strh	r5, [r4, #52]	@ movhi
 2231 113c 303084E5 	.LBE60:
 2232              		.loc 1 1157 0
 2233 1140 2078A0E1 		bne	.L285
 2234              	.L286:
 2235 1144 0F0000BA 		.loc 1 1160 0
 2236              		ldr	r3, [r4, #48]
 2237              		ldr	r5, [r4, #40]
 2238 1148 000094E5 	.LVL225:
 2239 114c 33FCFFEB 		cmp	r3, r5
 2240              		bls	.L295
 2241 1150 00A0A0E3 	.LBB61:
 2242              		.loc 1 1165 0
 2243              		str	r3, [r4, #40]
 2244 1154 0A0050E1 		.loc 1 1167 0
 2245 1158 0030A013 		ldr	r0, [r4, #0]
 2246 115c 0130A003 	.LVL226:
 2247 1160 0A0057E1 		add	r1, r4, #4
 2248 1164 0030A003 		bl	fat16_write_dir_entry
 2249 1168 0A0053E1 		cmp	r0, #0
 2250              		.loc 1 1173 0
 2251 116c 0510A0E1 		ldreq	r3, [r4, #48]
 2252 1170 0120A0E3 		rsbeq	r3, r5, r3
 2253              		moveq	r3, r3, asl #16
 2254              		.loc 1 1174 0
 2255 1174 00009415 		streq	r5, [r4, #48]
 2256              		.loc 1 1173 0
 2257 1178 88FCFF1B 		moveq	r7, r3, lsr #16
 2258              	.LVL227:
 2259              	.L295:
 2260              	.LBE61:
 2261 117c 000050E3 		.loc 1 1178 0
 2262              		ldr	r2, [sp, #0]
 2263 1180 0050A0E1 		rsb	r3, r7, r2
 2264              		mov	r3, r3, asl #16
 2265 1184 1500000A 		mov	r0, r3, asr #16
 2266              	.LVL228:
 2267              		b	.L298
 2268              	.LVL229:
 2269              	.L300:
 2270              	.LBB62:
 2271 1188 000057E3 	.LBB63:
 2272              		.loc 1 1146 0
 2273              		strh	r0, [r4, #52]	@ movhi
 2274 118c B453C4E1 		b	.L286
 2275              	.LVL230:
 2276              	.L271:
 2277 1190 CEFFFF1A 	.LBE63:
 2278              	.LBE62:
 2279              		.loc 1 1178 0
 2280 1194 303094E5 		mvn	r0, #0
 2281 1198 285094E5 	.LVL231:
 2282              	.L298:
 2283 119c 050053E1 		.loc 1 1183 0
 2284 11a0 0900009A 		add	sp, sp, #4
 2285              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2286              		bx	lr
 2287 11a4 283084E5 	.LFE18:
 2289 11a8 000094E5 		.align	2
 2290              		.global	fat16_close_dir
 2292 11b0 58FEFFEB 	fat16_close_dir:
 2293 11b4 000050E3 	.LFB22:
 2294              		.loc 1 1383 0
 2295 11b8 30309405 		@ Function supports interworking.
 2296 11bc 03306500 		@ args = 0, pretend = 0, frame = 0
 2297 11c0 0338A001 		@ frame_needed = 0, uses_anonymous_args = 0
 2298              	.LVL232:
 2299 11c4 30508405 		.loc 1 1384 0
 2300              		cmp	r0, #0
 2301 11c8 2378A001 		.loc 1 1383 0
 2302              		str	lr, [sp, #-4]!
 2303              	.LCFI23:
 2304              		.loc 1 1384 0
 2305              		.loc 1 1385 0
 2306 11cc 00209DE5 		blne	free
 2307 11d0 023067E0 	.LVL233:
 2308 11d4 0338A0E1 	.LVL234:
 2309 11d8 4308A0E1 	.L304:
 2310              		.loc 1 1386 0
 2311 11dc 020000EA 		ldr	lr, [sp], #4
 2312              		bx	lr
 2313              	.LFE22:
 2315              		.align	2
 2316              		.global	fat16_close_file
 2318 11e4 EAFFFFEA 	fat16_close_file:
 2319              	.LFB16:
 2320              		.loc 1 952 0
 2321              		@ Function supports interworking.
 2322              		@ args = 0, pretend = 0, frame = 0
 2323              		@ frame_needed = 0, uses_anonymous_args = 0
 2324 11e8 0000E0E3 	.LVL235:
 2325              		.loc 1 953 0
 2326              		cmp	r0, #0
 2327              		.loc 1 952 0
 2328 11ec 04D08DE2 		str	lr, [sp, #-4]!
 2329 11f0 F04FBDE8 	.LCFI24:
 2330 11f4 1EFF2FE1 		.loc 1 953 0
 2331              		.loc 1 954 0
 2332              		blne	free
 2333              	.LVL236:
 2334              	.LVL237:
 2335              	.L308:
 2336              		.loc 1 955 0
 2337              		ldr	lr, [sp], #4
 2338              		bx	lr
 2339              	.LFE16:
 2341              		.align	2
 2342              		.global	fat16_close
 2344 11f8 000050E3 	fat16_close:
 2345              	.LFB3:
 2346 11fc 04E02DE5 		.loc 1 245 0
 2347              		@ Function supports interworking.
 2348              		@ args = 0, pretend = 0, frame = 0
 2349              		@ frame_needed = 0, uses_anonymous_args = 0
 2350 1200 FEFFFF1B 	.LVL238:
 2351              		.loc 1 246 0
 2352              		cmp	r0, #0
 2353              		.loc 1 245 0
 2354              		str	lr, [sp, #-4]!
 2355 1204 04E09DE4 	.LCFI25:
 2356 1208 1EFF2FE1 		.loc 1 246 0
 2357              		.loc 1 249 0
 2358              		blne	free
 2359              	.LVL239:
 2360              	.LVL240:
 2361              	.L312:
 2362              		.loc 1 250 0
 2363              		ldr	lr, [sp], #4
 2364              		bx	lr
 2365              	.LFE3:
 2367              		.align	2
 2368              		.global	fat16_open_dir
 2370 120c 000050E3 	fat16_open_dir:
 2371              	.LFB21:
 2372 1210 04E02DE5 		.loc 1 1356 0
 2373              		@ Function supports interworking.
 2374              		@ args = 0, pretend = 0, frame = 0
 2375              		@ frame_needed = 0, uses_anonymous_args = 0
 2376 1214 FEFFFF1B 	.LVL241:
 2377              		.loc 1 1357 0
 2378              		cmp	r1, #0
 2379              		cmpne	r0, #0
 2380              		.loc 1 1356 0
 2381 1218 04E09DE4 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2382 121c 1EFF2FE1 	.LCFI26:
 2383              		.loc 1 1357 0
 2384              		mov	r7, r0
 2385              		mov	r5, r1
 2386              		movne	r8, #0
 2387              		moveq	r8, #1
 2388              		beq	.L314
 2389              	.LVL242:
 2390              		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2391              		tst	r3, #16
 2392              		.loc 1 1360 0
 2393              		mov	r0, #52
 2394              		.loc 1 1357 0
 2395              		beq	.L314
 2396 1220 000050E3 	.LVL243:
 2397              		.loc 1 1360 0
 2398 1224 04E02DE5 		bl	malloc
 2399              	.LVL244:
 2400              		.loc 1 1361 0
 2401              		cmp	r0, #0
 2402 1228 FEFFFF1B 		.loc 1 1360 0
 2403              		mov	r6, r0
 2404              	.LVL245:
 2405              		.loc 1 1364 0
 2406              		add	r4, r0, #4
 2407 122c 04E09DE4 		.loc 1 1361 0
 2408 1230 1EFF2FE1 		beq	.L314
 2409              	.LVL246:
 2410              		.loc 1 1364 0
 2411              		mov	ip, r5
 2412              		ldmia	ip!, {r0, r1, r2, r3}
 2413              	.LVL247:
 2414              		mov	lr, r4
 2415              		stmia	lr!, {r0, r1, r2, r3}
 2416              		ldmia	ip!, {r0, r1, r2, r3}
 2417              		stmia	lr!, {r0, r1, r2, r3}
 2418              		ldmia	ip, {r0, r1, r2}
 2419              		.loc 1 1365 0
 2420              		str	r7, [r6, #0]
 2421              		.loc 1 1364 0
 2422 1234 000051E3 		stmia	lr, {r0, r1, r2}
 2423 1238 00005013 		.loc 1 1366 0
 2424              		strh	r8, [r6, #48]	@ movhi
 2425 123c F0412DE9 		b	.L318
 2426              	.LVL248:
 2427              	.L314:
 2428 1240 0070A0E1 		.loc 1 1368 0
 2429 1244 0150A0E1 		mov	r6, #0
 2430 1248 0080A013 	.LVL249:
 2431 124c 0180A003 	.L318:
 2432 1250 1300000A 		.loc 1 1369 0
 2433              		mov	r0, r6
 2434 1254 2030D1E5 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2435 1258 100013E3 		bx	lr
 2436              	.LFE21:
 2438              		.align	2
 2439 1260 0F00000A 		.global	fat16_open_file
 2441              	fat16_open_file:
 2442 1264 FEFFFFEB 	.LFB15:
 2443              		.loc 1 928 0
 2444              		@ Function supports interworking.
 2445 1268 000050E3 		@ args = 0, pretend = 0, frame = 0
 2446              		@ frame_needed = 0, uses_anonymous_args = 0
 2447 126c 0060A0E1 	.LVL250:
 2448              		.loc 1 929 0
 2449              		cmp	r1, #0
 2450 1270 044080E2 		cmpne	r0, #0
 2451              		.loc 1 928 0
 2452 1274 0A00000A 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2453              	.LCFI27:
 2454              		.loc 1 929 0
 2455 1278 05C0A0E1 		mov	r5, r1
 2456 127c 0F00BCE8 		mov	r7, r0
 2457              		beq	.L321
 2458 1280 04E0A0E1 	.LVL251:
 2459 1284 0F00AEE8 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2460 1288 0F00BCE8 		ands	r8, r3, #16
 2461 128c 0F00AEE8 		.loc 1 932 0
 2462 1290 07009CE8 		mov	r0, #56
 2463              		.loc 1 929 0
 2464 1294 007086E5 		bne	.L321
 2465              	.LVL252:
 2466 1298 07008EE8 		.loc 1 932 0
 2467              		bl	malloc
 2468 129c B083C6E1 	.LVL253:
 2469 12a0 000000EA 		.loc 1 933 0
 2470              		cmp	r0, #0
 2471              		.loc 1 932 0
 2472              		mov	r6, r0
 2473 12a4 0060A0E3 	.LVL254:
 2474              		.loc 1 936 0
 2475              		add	r4, r0, #4
 2476              		.loc 1 933 0
 2477 12a8 0600A0E1 		beq	.L321
 2478 12ac F041BDE8 	.LVL255:
 2479 12b0 1EFF2FE1 		.loc 1 936 0
 2480              		mov	ip, r5
 2481              		ldmia	ip!, {r0, r1, r2, r3}
 2482              	.LVL256:
 2483              		mov	lr, r4
 2484              		stmia	lr!, {r0, r1, r2, r3}
 2485              		ldmia	ip!, {r0, r1, r2, r3}
 2486              		stmia	lr!, {r0, r1, r2, r3}
 2487              		ldmia	ip, {r0, r1, r2}
 2488              		stmia	lr, {r0, r1, r2}
 2489              		.loc 1 939 0
 2490              		ldrh	r5, [r5, #34]
 2491              	.LVL257:
 2492              		.loc 1 937 0
 2493 12b4 000051E3 		str	r7, [r6, #0]
 2494 12b8 00005013 		.loc 1 938 0
 2495              		str	r8, [r6, #48]
 2496 12bc F0412DE9 		.loc 1 939 0
 2497              		strh	r5, [r6, #52]	@ movhi
 2498              		b	.L325
 2499 12c0 0150A0E1 	.LVL258:
 2500 12c4 0070A0E1 	.L321:
 2501 12c8 1500000A 		.loc 1 941 0
 2502              		mov	r6, #0
 2503 12cc 2030D1E5 	.LVL259:
 2504 12d0 108013E2 	.L325:
 2505              		.loc 1 942 0
 2506 12d4 3800A0E3 		mov	r0, r6
 2507              		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2508 12d8 1100001A 		bx	lr
 2509              	.LFE15:
 2511 12dc FEFFFFEB 		.align	2
 2512              		.global	open_file_in_dir
 2514 12e0 000050E3 	open_file_in_dir:
 2515              	.LFB32:
 2516 12e4 0060A0E1 		.loc 1 1937 0
 2517              		@ Function supports interworking.
 2518              		@ args = 0, pretend = 0, frame = 44
 2519 12e8 044080E2 		@ frame_needed = 0, uses_anonymous_args = 0
 2520              	.LVL260:
 2521 12ec 0C00000A 		stmfd	sp!, {r4, r5, lr}
 2522              	.LCFI28:
 2523              		sub	sp, sp, #44
 2524 12f0 05C0A0E1 	.LCFI29:
 2525 12f4 0F00BCE8 		.loc 1 1939 0
 2526              		mov	r3, sp
 2527 12f8 04E0A0E1 		.loc 1 1937 0
 2528 12fc 0F00AEE8 		mov	r4, r0
 2529 1300 0F00BCE8 		.loc 1 1939 0
 2530 1304 0F00AEE8 		bl	find_file_in_dir
 2531 1308 07009CE8 	.LVL261:
 2532 130c 07008EE8 		cmp	r0, #0
 2533              		mov	r3, r0
 2534 1310 B252D5E1 		mov	r5, sp
 2535              		.loc 1 1942 0
 2536              		mov	r0, r4
 2537 1314 007086E5 		mov	r1, sp
 2538              		.loc 1 1939 0
 2539 1318 308086E5 		beq	.L330
 2540              	.LVL262:
 2541 131c B453C6E1 		.loc 1 1942 0
 2542 1320 000000EA 		bl	fat16_open_file
 2543              	.LVL263:
 2544              		mov	r3, r0
 2545              	.LVL264:
 2546 1324 0060A0E3 	.L330:
 2547              		.loc 1 1943 0
 2548              		mov	r0, r3
 2549              		add	sp, sp, #44
 2550 1328 0600A0E1 		ldmfd	sp!, {r4, r5, lr}
 2551 132c F041BDE8 		bx	lr
 2552 1330 1EFF2FE1 	.LFE32:
 2554              		.align	2
 2555              		.global	fat16_get_dir_entry_of_path
 2557              	fat16_get_dir_entry_of_path:
 2558              	.LFB10:
 2559              		.loc 1 626 0
 2560              		@ Function supports interworking.
 2561              		@ args = 0, pretend = 0, frame = 0
 2562              		@ frame_needed = 0, uses_anonymous_args = 0
 2563              	.LVL265:
 2564              		.loc 1 627 0
 2565 1334 30402DE9 		cmp	r1, #0
 2566              		cmpne	r0, #0
 2567 1338 2CD04DE2 		.loc 1 626 0
 2568              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2569              	.LCFI30:
 2570 133c 0D30A0E1 		.loc 1 627 0
 2571              		mov	r9, r0
 2572 1340 0040A0E1 		mov	r4, r1
 2573              		.loc 1 626 0
 2574 1344 FEFFFFEB 		mov	r5, r2
 2575              		.loc 1 627 0
 2576 1348 000050E3 		beq	.L333
 2577 134c 0030A0E1 	.LVL266:
 2578 1350 0D50A0E1 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 2579              		cmp	r2, #0
 2580 1354 0400A0E1 		cmpne	r3, #0
 2581 1358 0D10A0E1 		movne	r1, #0
 2582              		moveq	r1, #1
 2583 135c 0100000A 		beq	.L333
 2584              	.LVL267:
 2585              		.loc 1 630 0
 2586 1360 FEFFFFEB 		cmp	r3, #47
 2587              		.loc 1 634 0
 2588 1364 0030A0E1 		mov	r0, r2
 2589              		mov	r2, #44
 2590              	.LVL268:
 2591              		.loc 1 631 0
 2592 1368 0300A0E1 		addeq	r4, r4, #1
 2593 136c 2CD08DE2 		.loc 1 634 0
 2594 1370 3040BDE8 		bl	memset
 2595 1374 1EFF2FE1 	.LVL269:
 2596              		.loc 1 635 0
 2597              		mov	r3, #16
 2598              		strb	r3, [r5, #32]
 2599              		.loc 1 637 0
 2600              		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 2601              		cmp	r3, #0
 2602              		beq	.L338
 2603              	.LVL270:
 2604              	.L356:
 2605              	.LBB64:
 2606              		.loc 1 642 0
 2607              		mov	r0, r9
 2608              		mov	r1, r5
 2609 1378 000051E3 		bl	fat16_open_dir
 2610 137c 00005013 		.loc 1 643 0
 2611              		subs	r7, r0, #0
 2612 1380 F0472DE9 		beq	.L333
 2613              		.loc 1 647 0
 2614              		mov	r0, r4
 2615 1384 0090A0E1 		mov	r1, #47
 2616 1388 0140A0E1 		bl	strchr
 2617              		.loc 1 648 0
 2618 138c 0250A0E1 		subs	r8, r0, #0
 2619              		bne	.L341
 2620 1390 3C00000A 		.loc 1 649 0
 2621              		mov	r0, r4
 2622 1394 0030D1E5 		bl	strlen
 2623 1398 000052E3 		add	r8, r4, r0
 2624 139c 00005313 	.L341:
 2625 13a0 0010A013 		.loc 1 650 0
 2626 13a4 0110A003 		rsb	r3, r4, r8
 2627 13a8 3600000A 		and	r6, r3, #255
 2628              		b	.L358
 2629              	.L344:
 2630 13ac 2F0053E3 		.loc 1 656 0
 2631              		bl	strlen
 2632 13b0 0200A0E1 		cmp	r0, r6
 2633 13b4 2C20A0E3 		mov	r1, r5
 2634              		mov	r2, r6
 2635              		mov	r0, r4
 2636 13b8 01408402 		bne	.L358
 2637              	.LVL271:
 2638 13bc FEFFFFEB 		bl	strncmp
 2639              	.LVL272:
 2640              		subs	sl, r0, #0
 2641 13c0 1030A0E3 		bne	.L358
 2642 13c4 2030C5E5 		.loc 1 660 0
 2643              		mov	r0, r7
 2644 13c8 0030D4E5 		bl	fat16_close_dir
 2645 13cc 000053E3 		.loc 1 663 0
 2646 13d0 2E00000A 		ldrb	r3, [r4, r6]	@ zero_extendqisi2
 2647              		cmp	r3, #0
 2648              		beq	.L338
 2649              		.loc 1 667 0
 2650              		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 2651 13d4 0900A0E1 		tst	r3, #16
 2652 13d8 0510A0E1 		beq	.L333
 2653 13dc FEFFFFEB 		.loc 1 670 0
 2654              		add	r4, r8, #1
 2655 13e0 007050E2 		mov	r7, sl
 2656 13e4 2700000A 		b	.L349
 2657              	.LVL273:
 2658 13e8 0400A0E1 	.L358:
 2659 13ec 2F10A0E3 		.loc 1 653 0
 2660 13f0 FEFFFFEB 		mov	r1, r5
 2661              		mov	r0, r7
 2662 13f4 008050E2 		bl	fat16_read_dir
 2663 13f8 0200001A 		cmp	r0, #0
 2664              		.loc 1 656 0
 2665 13fc 0400A0E1 		mov	r0, r5
 2666 1400 FEFFFFEB 		.loc 1 653 0
 2667 1404 008084E0 		bne	.L344
 2668              	.L349:
 2669              		.loc 1 678 0
 2670 1408 083064E0 		mov	r0, r7
 2671 140c FF6003E2 		bl	fat16_close_dir
 2672 1410 130000EA 		b	.L356
 2673              	.LVL274:
 2674              	.L333:
 2675 1414 FEFFFFEB 		.loc 1 679 0
 2676 1418 060050E1 		mov	r0, #0
 2677 141c 0510A0E1 		b	.L350
 2678 1420 0620A0E1 	.LVL275:
 2679 1424 0400A0E1 	.L338:
 2680 1428 0D00001A 		mov	r0, #1
 2681              	.LVL276:
 2682 142c FEFFFFEB 	.L350:
 2683              	.LBE64:
 2684 1430 00A050E2 		.loc 1 682 0
 2685 1434 0A00001A 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2686              		bx	lr
 2687 1438 0700A0E1 	.LFE10:
 2689              		.section	.rodata.str1.4,"aMS",%progbits,1
 2690 1440 0630D4E7 		.align	2
 2691 1444 000053E3 	.LC0:
 2692 1448 1000000A 		.ascii	"MALLOC FAILS\012\015\000"
 2693              		.align	2
 2694 144c 2030D5E5 	.LC1:
 2695 1450 100013E3 		.ascii	"Failed Reading Header\012\015\000"
 2696 1454 0B00000A 		.text
 2697              		.align	2
 2698 1458 014088E2 		.global	fat16_open
 2700 1460 050000EA 	fat16_open:
 2701              	.LFB2:
 2702              		.loc 1 205 0
 2703              		@ Function supports interworking.
 2704 1464 0510A0E1 		@ args = 0, pretend = 0, frame = 60
 2705 1468 0700A0E1 		@ frame_needed = 0, uses_anonymous_args = 0
 2706 146c FEFFFFEB 	.LVL277:
 2707 1470 000050E3 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2708              	.LCFI31:
 2709 1474 0500A0E1 		.loc 1 206 0
 2710              		subs	r8, r0, #0
 2711 1478 E5FFFF1A 		.loc 1 205 0
 2712              		sub	sp, sp, #60
 2713              	.LCFI32:
 2714 147c 0700A0E1 		.loc 1 206 0
 2715 1480 FEFFFFEB 		beq	.L374
 2716 1484 D2FFFFEA 	.LVL278:
 2717              		ldr	r3, [r8, #8]
 2718              		cmp	r3, #0
 2719              		beq	.L374
 2720 1488 0000A0E3 		.loc 1 215 0
 2721 148c 000000EA 		mov	r0, #28
 2722              		bl	malloc
 2723              		.loc 1 216 0
 2724 1490 0100A0E3 		subs	fp, r0, #0
 2725              		bne	.L363
 2726              		.loc 1 218 0
 2727              		ldr	r0, .L375
 2728              		bl	rprintf
 2729 1494 F047BDE8 		mov	sl, fp
 2730 1498 1EFF2FE1 	.LVL279:
 2731              		b	.L365
 2732              	.LVL280:
 2733              	.L363:
 2734              		.loc 1 221 0
 2735              		mov	r1, #0
 2736 0000 4D414C4C 		mov	r2, #28
 2736      4F432046 
 2736      41494C53 
 2736      0A0D00
 2737 000f 00       		bl	memset
 2738              	.LBB67:
 2739 0010 4661696C 	.LBB68:
 2739      65642052 
 2739      65616469 
 2739      6E672048 
 2739      65616465 
 2740              		.loc 1 273 0
 2741              		ldr	r3, [r8, #16]
 2742              		mov	r3, r3, asl #9
 2743              		str	r3, [sp, #8]
 2744              	.LVL281:
 2745              	.LVL282:
 2746              	.LBE68:
 2747              	.LBE67:
 2748              		.loc 1 223 0
 2749              		str	r8, [fp, #0]
 2750              	.LBB69:
 2751 149c F04F2DE9 		.loc 1 275 0
 2752              		add	r0, r3, #11
 2753              		add	r1, sp, #35
 2754 14a0 008050E2 		mov	r2, #25
 2755              		ldr	ip, [r8, #0]
 2756 14a4 3CD04DE2 		mov	lr, pc
 2757              		bx	ip
 2758              	.LBB70:
 2759 14a8 7100000A 		cmp	r0, #0
 2760              	.LVL283:
 2761 14ac 083098E5 	.LBE70:
 2762 14b0 000053E3 	.LBE69:
 2763 14b4 6E00000A 		.loc 1 215 0
 2764              		mov	sl, fp
 2765 14b8 1C00A0E3 	.LVL284:
 2766 14bc FEFFFFEB 	.LBB71:
 2767              	.LBB72:
 2768 14c0 00B050E2 		.loc 1 275 0
 2769 14c4 0300001A 		beq	.L366
 2770              		.loc 1 289 0
 2771 14c8 B8019FE5 		ldrb	r2, [sp, #46]	@ zero_extendqisi2
 2772 14cc FEFFFFEB 		ldrb	r3, [sp, #47]	@ zero_extendqisi2
 2773 14d0 0BA0A0E1 		.loc 1 295 0
 2774              		orrs	r3, r2, r3, asl #8
 2775 14d4 670000EA 		.loc 1 279 0
 2776              		ldrb	r0, [sp, #35]	@ zero_extendqisi2
 2777              		ldrb	r2, [sp, #36]	@ zero_extendqisi2
 2778              		.loc 1 295 0
 2779 14d8 0010A0E3 		str	r3, [sp, #16]
 2780 14dc 1C20A0E3 		.loc 1 282 0
 2781 14e0 FEFFFFEB 		ldrb	r6, [sp, #38]	@ zero_extendqisi2
 2782              		.loc 1 280 0
 2783              		ldrb	r3, [sp, #37]	@ zero_extendqisi2
 2784              		.loc 1 279 0
 2785 14e4 103098E5 		str	r0, [sp, #28]
 2786 14e8 8334A0E1 		str	r2, [sp, #24]
 2787 14ec 08308DE5 		.loc 1 280 0
 2788              		str	r3, [sp, #4]
 2789              	.LVL285:
 2790              		.loc 1 282 0
 2791              		str	r6, [sp, #20]
 2792              		ldrb	r1, [sp, #39]	@ zero_extendqisi2
 2793 14f0 00808BE5 		.loc 1 283 0
 2794              		ldrb	r9, [sp, #40]	@ zero_extendqisi2
 2795              	.LVL286:
 2796 14f4 0B0083E2 		.loc 1 285 0
 2797 14f8 23108DE2 		ldrb	r7, [sp, #41]	@ zero_extendqisi2
 2798 14fc 1920A0E3 		ldrb	r5, [sp, #42]	@ zero_extendqisi2
 2799 1500 00C098E5 		.loc 1 287 0
 2800 1504 0FE0A0E1 		ldrb	r4, [sp, #43]	@ zero_extendqisi2
 2801 1508 1CFF2FE1 		ldrb	lr, [sp, #44]	@ zero_extendqisi2
 2802              		.loc 1 293 0
 2803 150c 000050E3 		ldrb	ip, [sp, #56]	@ zero_extendqisi2
 2804              		ldrb	r2, [sp, #57]	@ zero_extendqisi2
 2805              		ldrb	r3, [sp, #58]	@ zero_extendqisi2
 2806              		ldrb	r0, [sp, #59]	@ zero_extendqisi2
 2807              		.loc 1 295 0
 2808 1510 0BA0A0E1 		beq	.L366
 2809              		.loc 1 293 0
 2810              		mov	r3, r3, asl #16
 2811              		orr	r2, ip, r2, asl #8
 2812              		orr	r3, r3, r0, asl #24
 2813 1514 5200000A 		.loc 1 299 0
 2814              		orrs	r6, r2, r3
 2815 1518 2E20DDE5 	.LVL287:
 2816 151c 2F30DDE5 		bne	.L369
 2817              		.loc 1 301 0
 2818 1520 033492E1 		orrs	r2, r4, lr, asl #8
 2819              		beq	.L366
 2820 1524 2300DDE5 		.loc 1 305 0
 2821 1528 2420DDE5 		mov	r6, r2
 2822              	.L369:
 2823 152c 10308DE5 		.loc 1 312 0
 2824              		ldr	r0, [sp, #16]
 2825 1530 2660DDE5 		mul	r0, r9, r0
 2826              		.loc 1 279 0
 2827 1534 2530DDE5 		ldr	r2, [sp, #28]
 2828              		.loc 1 312 0
 2829 1538 1C008DE5 		str	r0, [sp, #12]
 2830 153c 18208DE5 		.loc 1 279 0
 2831              		ldr	r0, [sp, #24]
 2832 1540 04308DE5 		.loc 1 285 0
 2833              		orr	r3, r7, r5, asl #8
 2834              	.LVL288:
 2835 1544 14608DE5 		.loc 1 279 0
 2836 1548 2710DDE5 		orr	r5, r2, r0, asl #8
 2837              	.LVL289:
 2838 154c 2890DDE5 		.loc 1 312 0
 2839              		ldr	r2, [sp, #20]
 2840              		.loc 1 313 0
 2841 1550 2970DDE5 		mov	r3, r3, asl #5
 2842 1554 2A50DDE5 	.LVL290:
 2843              		.loc 1 312 0
 2844 1558 2B40DDE5 		orr	r9, r2, r1, asl #8
 2845 155c 2CE0DDE5 	.LVL291:
 2846              		.loc 1 313 0
 2847 1560 38C0DDE5 		str	r3, [sp, #0]
 2848 1564 3920DDE5 		add	r0, r3, r5
 2849 1568 3A30DDE5 		ldr	r3, [sp, #12]
 2850 156c 3B00DDE5 		mov	r1, r5
 2851              		sub	r0, r0, #1
 2852 1570 3B00000A 		rsb	r4, r9, r6
 2853              		rsb	r4, r3, r4
 2854 1574 0338A0E1 		bl	__divsi3
 2855 1578 02248CE1 		ldr	r1, [sp, #4]
 2856 157c 003C83E1 		rsb	r0, r0, r4
 2857              		bl	__udivsi3
 2858 1580 036092E1 		.loc 1 314 0
 2859              		sub	r3, r0, #4080
 2860 1584 0200001A 		sub	r3, r3, #5
 2861              		cmp	r3, #61440
 2862 1588 0E2494E1 		.loc 1 313 0
 2863 158c 3400000A 		mov	r7, r0
 2864              		.loc 1 314 0
 2865 1590 0260A0E1 		bcs	.L366
 2866              		.loc 1 321 0
 2867              		add	r4, sl, #4
 2868 1594 10009DE5 	.LVL292:
 2869 1598 990000E0 		.loc 1 318 0
 2870              		mov	r3, #6
 2871 159c 1C209DE5 		strb	r3, [r8, #12]
 2872              		.loc 1 322 0
 2873 15a0 0C008DE5 		mov	r1, #0
 2874              		mov	r2, #24
 2875 15a4 18009DE5 		mov	r0, r4
 2876              		bl	memset
 2877 15a8 053487E1 		.loc 1 326 0
 2878              		ldr	ip, [sp, #8]
 2879              		mla	ip, r5, r9, ip
 2880 15ac 005482E1 		.loc 1 335 0
 2881              		ldr	lr, [sp, #12]
 2882              		.loc 1 333 0
 2883 15b0 14209DE5 		ldr	r0, [sp, #4]
 2884              		.loc 1 335 0
 2885 15b4 8332A0E1 		mla	lr, r5, lr, ip
 2886              		.loc 1 324 0
 2887              		mul	r1, r5, r6
 2888 15b8 019482E1 		.loc 1 333 0
 2889              		mul	r0, r5, r0
 2890              		.loc 1 340 0
 2891 15bc 00308DE5 		ldr	r6, [sp, #0]
 2892 15c0 050083E0 	.LVL293:
 2893 15c4 0C309DE5 		.loc 1 330 0
 2894 15c8 0510A0E1 		mov	r3, r7, asl #1
 2895 15cc 010040E2 		.loc 1 340 0
 2896 15d0 064069E0 		add	r2, lr, r6
 2897 15d4 044063E0 		.loc 1 330 0
 2898 15d8 FEFFFFEB 		add	r3, r3, #4
 2899 15dc 04109DE5 		.loc 1 340 0
 2900 15e0 040060E0 		str	r2, [r4, #20]
 2901 15e4 FEFFFFEB 		.loc 1 324 0
 2902              		str	r1, [sl, #4]
 2903 15e8 FF3E40E2 		.loc 1 330 0
 2904 15ec 053043E2 		str	r3, [r4, #8]
 2905 15f0 0F0A53E3 		.loc 1 333 0
 2906              		strh	r0, [r4, #14]	@ movhi
 2907 15f4 0070A0E1 		.loc 1 326 0
 2908              		str	ip, [r4, #4]
 2909 15f8 1900002A 		.loc 1 332 0
 2910              		strh	r5, [r4, #12]	@ movhi
 2911 15fc 04408AE2 		.loc 1 335 0
 2912              		str	lr, [r4, #16]
 2913              		b	.L365
 2914 1600 0630A0E3 	.LVL294:
 2915 1604 0C30C8E5 	.L366:
 2916              	.LBE72:
 2917 1608 0010A0E3 	.LBE71:
 2918 160c 1820A0E3 		.loc 1 226 0
 2919 1610 0400A0E1 		ldr	r0, .L375+4
 2920 1614 FEFFFFEB 		bl	rprintf
 2921              		.loc 1 227 0
 2922 1618 08C09DE5 		mov	r0, fp
 2923 161c 95C92CE0 		bl	free
 2924              	.LVL295:
 2925 1620 0CE09DE5 	.L374:
 2926              		mov	sl, #0
 2927 1624 04009DE5 	.LVL296:
 2928              	.L365:
 2929 1628 95CE2EE0 		.loc 1 232 0
 2930              		mov	r0, sl
 2931 162c 950601E0 		add	sp, sp, #60
 2932              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2933 1630 950000E0 		bx	lr
 2934              	.L376:
 2935 1634 00609DE5 		.align	2
 2936              	.L375:
 2937              		.word	.LC0
 2938 1638 8730A0E1 		.word	.LC1
 2939              	.LFE2:
 2941              		.align	2
 2942 1640 043083E2 		.global	fat16_create_file
 2944 1644 142084E5 	fat16_create_file:
 2945              	.LFB26:
 2946 1648 04108AE5 		.loc 1 1671 0
 2947              		@ Function supports interworking.
 2948 164c 083084E5 		@ args = 0, pretend = 0, frame = 4
 2949              		@ frame_needed = 0, uses_anonymous_args = 0
 2950 1650 BE00C4E1 	.LVL297:
 2951              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2952 1654 04C084E5 	.LCFI33:
 2953              		.loc 1 1673 0
 2954 1658 BC50C4E1 		rsbs	r6, r0, #1
 2955              		movcc	r6, #0
 2956 165c 10E084E5 		cmp	r0, #0
 2957 1660 040000EA 		cmpne	r1, #0
 2958              		.loc 1 1671 0
 2959              		sub	sp, sp, #4
 2960              	.LCFI34:
 2961              		.loc 1 1673 0
 2962              		mov	r5, r0
 2963 1664 20009FE5 		mov	r4, r1
 2964 1668 FEFFFFEB 		.loc 1 1671 0
 2965              		mov	r8, r2
 2966 166c 0B00A0E1 		.loc 1 1673 0
 2967 1670 FEFFFFEB 		beq	.L378
 2968              	.LVL298:
 2969              		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 2970 1674 00A0A0E3 		cmp	r3, #0
 2971              		beq	.L378
 2972              	.L408:
 2973              		.loc 1 1679 0
 2974 1678 0A00A0E1 		mov	r1, r8
 2975 167c 3CD08DE2 		mov	r0, r5
 2976 1680 F04FBDE8 		bl	fat16_read_dir
 2977 1684 1EFF2FE1 		subs	sl, r0, #0
 2978              		.loc 1 1682 0
 2979              		mov	r1, r8
 2980              		mov	r0, r4
 2981 1688 00000000 		.loc 1 1679 0
 2982 168c 10000000 		beq	.L381
 2983              	.LVL299:
 2984              		.loc 1 1682 0
 2985              		bl	strcmp
 2986              	.LVL300:
 2987              		cmp	r0, #0
 2988              		bne	.L408
 2989              	.LBB77:
 2990              	.LBB78:
 2991              		.loc 1 1440 0
 2992              		cmp	r6, #0
 2993              		addne	r0, r0, #1
 2994              		.loc 1 1443 0
 2995 1690 F04F2DE9 		moveq	r0, #1
 2996              		streqh	r6, [r5, #48]	@ movhi
 2997              		b	.L386
 2998 1694 016070E2 	.LVL301:
 2999 1698 0060A033 	.L381:
 3000 169c 000050E3 	.LBE78:
 3001 16a0 00005113 	.LBE77:
 3002              		.loc 1 1689 0
 3003 16a4 04D04DE2 		mov	r1, sl
 3004              	.LVL302:
 3005              		mov	r2, #44
 3006 16a8 0050A0E1 		mov	r0, r8
 3007 16ac 0140A0E1 	.LVL303:
 3008              		bl	memset
 3009 16b0 0280A0E1 		.loc 1 1690 0
 3010              		mov	r1, r4
 3011 16b4 6500000A 		mov	r2, #31
 3012              		mov	r0, r8
 3013 16b8 0030D1E5 		bl	strncpy
 3014 16bc 000053E3 		.loc 1 1693 0
 3015 16c0 6200000A 		mov	r0, r4
 3016              		bl	strlen
 3017              		mov	r1, #13
 3018 16c4 0810A0E1 		bl	__udivsi3
 3019 16c8 0500A0E1 		.loc 1 1696 0
 3020 16cc FEFFFFEB 		ldrh	r7, [r5, #38]
 3021 16d0 00A050E2 	.LVL304:
 3022              		.loc 1 1695 0
 3023 16d4 0810A0E1 		ldr	r5, [r5, #0]
 3024 16d8 0400A0E1 	.LVL305:
 3025              		.loc 1 1701 0
 3026 16dc 0700000A 		cmp	r7, #0
 3027              		.loc 1 1704 0
 3028              		ldreq	r4, [r5, #20]
 3029 16e0 FEFFFFEB 	.LVL306:
 3030              		.loc 1 1701 0
 3031 16e4 000050E3 		movne	r6, sl
 3032 16e8 F5FFFF1A 	.LVL307:
 3033              		.loc 1 1693 0
 3034              		add	r0, r0, #2
 3035              		.loc 1 1705 0
 3036 16ec 000056E3 		ldreq	sl, [r5, #24]
 3037 16f0 01008012 	.LVL308:
 3038              		.loc 1 1693 0
 3039 16f4 0100A003 		and	fp, r0, #255
 3040 16f8 B063C501 	.LVL309:
 3041 16fc 540000EA 		.loc 1 1701 0
 3042              		movne	r4, r6
 3043              		movne	sl, r6
 3044              		.loc 1 1705 0
 3045              		moveq	r6, r4
 3046              		mov	r9, #0
 3047 1700 0A10A0E1 	.LVL310:
 3048              	.LVL311:
 3049 1704 2C20A0E3 	.L413:
 3050 1708 0800A0E1 	.LBB79:
 3051              		.loc 1 1711 0
 3052 170c FEFFFFEB 		cmp	r4, sl
 3053              		bne	.L391
 3054 1710 0410A0E1 		.loc 1 1713 0
 3055 1714 1F20A0E3 		cmp	r7, #0
 3056 1718 0800A0E1 		beq	.L378
 3057 171c FEFFFFEB 		.loc 1 1719 0
 3058              		cmp	r4, #0
 3059 1720 0400A0E1 		beq	.L394
 3060 1724 FEFFFFEB 	.LBB80:
 3061 1728 0D10A0E3 		.loc 1 1725 0
 3062 172c FEFFFFEB 		mov	r0, r5
 3063              		mov	r1, r7
 3064 1730 B672D5E1 		bl	fat16_get_next_cluster
 3065              		.loc 1 1726 0
 3066              		cmp	r0, #0
 3067 1734 005095E5 	.LVL312:
 3068              		bne	.L396
 3069              		.loc 1 1728 0
 3070 1738 000057E3 		mov	r1, r7
 3071              		mov	r0, r5
 3072 173c 14409505 	.LVL313:
 3073              		mov	r2, #1
 3074              		bl	fat16_append_clusters
 3075 1740 0A60A011 		.loc 1 1729 0
 3076              		cmp	r0, #0
 3077              		beq	.L378
 3078 1744 020080E2 		.loc 1 1733 0
 3079              		ldrh	r1, [r5, #18]
 3080 1748 18A09505 		ldr	r2, [r5, #24]
 3081              		sub	r3, r0, #2
 3082              		mla	r6, r1, r3, r2
 3083 174c FFB000E2 		b	.L399
 3084              	.LVL314:
 3085              	.L396:
 3086 1750 0640A011 		.loc 1 1739 0
 3087 1754 06A0A011 		mov	r7, r0
 3088              	.L394:
 3089 1758 0460A001 	.LBE80:
 3090 175c 0090A0E3 		.loc 1 1744 0
 3091              		ldrh	r1, [r5, #18]
 3092              		ldr	r2, [r5, #24]
 3093              		sub	r3, r7, #2
 3094              		mla	r4, r1, r3, r2
 3095              		.loc 1 1746 0
 3096 1760 0A0054E1 		mov	r9, #0
 3097 1764 1B00001A 		add	sl, r4, r1
 3098              		mov	r6, r4
 3099 1768 000057E3 	.L391:
 3100 176c 3700000A 		.loc 1 1753 0
 3101              		ldr	r3, [r5, #0]
 3102 1770 000054E3 		mov	r0, r4
 3103 1774 1000000A 	.LVL315:
 3104              		add	r1, sp, #3
 3105              		mov	r2, #1
 3106 1778 0500A0E1 		ldr	ip, [r3, #0]
 3107 177c 0710A0E1 		mov	lr, pc
 3108 1780 A6FAFFEB 		bx	ip
 3109              		cmp	r0, #0
 3110 1784 000050E3 		beq	.L378
 3111              		.loc 1 1757 0
 3112 1788 0A00001A 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 3113              		cmp	r3, #0
 3114 178c 0710A0E1 		cmpne	r3, #229
 3115 1790 0500A0E1 		movne	r3, #0
 3116              		moveq	r3, #1
 3117 1794 0120A0E3 		.loc 1 1768 0
 3118 1798 00FBFFEB 		addne	r6, r4, #32
 3119              		movne	r9, r3
 3120 179c 000050E3 		movne	r4, r6
 3121 17a0 2A00000A 		.loc 1 1757 0
 3122              		bne	.L413
 3123 17a4 B211D5E1 		.loc 1 1760 0
 3124 17a8 182095E5 		add	r3, r9, #1
 3125 17ac 023040E2 		and	r9, r3, #255
 3126 17b0 912326E0 		.loc 1 1761 0
 3127 17b4 1E0000EA 		cmp	r9, fp
 3128              		.loc 1 1764 0
 3129              		addcc	r4, r4, #32
 3130              		bcc	.L413
 3131 17b8 0070A0E1 	.L399:
 3132              	.LBE79:
 3133              		.loc 1 1775 0
 3134              		str	r6, [r8, #40]
 3135 17bc B211D5E1 		.loc 1 1776 0
 3136 17c0 182095E5 		mov	r0, r5
 3137 17c4 023047E2 		mov	r1, r8
 3138 17c8 912324E0 		bl	fat16_write_dir_entry
 3139              		subs	r0, r0, #0
 3140 17cc 0090A0E3 		movne	r0, #1
 3141 17d0 01A084E0 		b	.L386
 3142 17d4 0460A0E1 	.LVL316:
 3143              	.L378:
 3144              		mov	r0, #0
 3145 17d8 003095E5 	.L386:
 3146 17dc 0400A0E1 		.loc 1 1784 0
 3147              		add	sp, sp, #4
 3148 17e0 03108DE2 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3149 17e4 0120A0E3 		bx	lr
 3150 17e8 00C093E5 	.LFE26:
 3152 17f0 1CFF2FE1 		.section	.debug_frame,"",%progbits
 3153 17f4 000050E3 	.Lframe0:
 3154 17f8 1400000A 		.4byte	.LECIE0-.LSCIE0
 3155              	.LSCIE0:
 3156 17fc 0330DDE5 		.4byte	0xffffffff
 3157 1800 000053E3 		.byte	0x1
 3158 1804 E5005313 		.ascii	"\000"
 3159 1808 0030A013 		.uleb128 0x1
 3160 180c 0130A003 		.sleb128 -4
 3161              		.byte	0xe
 3162 1810 20608412 		.byte	0xc
 3163 1814 0390A011 		.uleb128 0xd
 3164 1818 0640A011 		.uleb128 0x0
 3165              		.align	2
 3166 181c CFFFFF1A 	.LECIE0:
 3167              	.LSFDE0:
 3168 1820 013089E2 		.4byte	.LEFDE0-.LASFDE0
 3169 1824 FF9003E2 	.LASFDE0:
 3170              		.4byte	.Lframe0
 3171 1828 0B0059E1 		.4byte	.LFB7
 3172              		.4byte	.LFE7-.LFB7
 3173 182c 20408432 		.align	2
 3174 1830 CAFFFF3A 	.LEFDE0:
 3175              	.LSFDE2:
 3176              		.4byte	.LEFDE2-.LASFDE2
 3177              	.LASFDE2:
 3178 1834 286088E5 		.4byte	.Lframe0
 3179              		.4byte	.LFB8
 3180 1838 0500A0E1 		.4byte	.LFE8-.LFB8
 3181 183c 0810A0E1 		.byte	0x4
 3182 1840 B4FCFFEB 		.4byte	.LCFI0-.LFB8
 3183 1844 000050E2 		.byte	0xe
 3184 1848 0100A013 		.uleb128 0xc
 3185 184c 000000EA 		.byte	0x8e
 3186              		.uleb128 0x1
 3187              		.byte	0x85
 3188 1850 0000A0E3 		.uleb128 0x2
 3189              		.byte	0x84
 3190              		.uleb128 0x3
 3191 1854 04D08DE2 		.align	2
 3192 1858 F04FBDE8 	.LEFDE2:
 3193 185c 1EFF2FE1 	.LSFDE4:
 3194              		.4byte	.LEFDE4-.LASFDE4
 3195              	.LASFDE4:
 3821              		.4byte	0x0
DEFINED SYMBOLS
                            *ABS*:00000000 fat16.c
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:12     .text:00000000 fat16_dir_entry_seek_callback
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:22     .text:00000000 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:76     .text:00000070 fat16_dir_entry_read_callback
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:270    .text:00000220 fat16_get_next_cluster
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:344    .text:000002c4 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:349    .text:000002c8 fat16_free_clusters
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:356    .text:000002c8 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:458    .text:0000039c $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:463    .text:000003a0 fat16_append_clusters
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:470    .text:000003a0 $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:638    .text:00000510 fat16_read_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:852    .text:000006ac fat16_reset_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:879    .text:000006c8 fat16_delete_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:956    .text:00000774 fat16_get_fs_size
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:987    .text:00000798 fat16_get_fs_free
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1074   .text:00000840 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1081   .text:0000084c fat16_get_fs_free_callback
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1088   .text:0000084c $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1132   .text:0000089c fat16_file_size
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1152   .text:000008a4 fat16_read_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1386   .text:00000ab4 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1393   .text:00000abc find_file_in_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1400   .text:00000abc $a
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1448   .text:00000b18 fat16_write_dir_entry
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1753   .text:00000da4 fat16_resize_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:1965   .text:00000f48 fat16_seek_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2054   .text:00000fe0 fat16_write_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2336   .text:000011f8 fat16_close_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2362   .text:0000120c fat16_close_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2388   .text:00001220 fat16_close
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2414   .text:00001234 fat16_open_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2485   .text:000012b4 fat16_open_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2558   .text:00001334 open_file_in_dir
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2601   .text:00001378 fat16_get_dir_entry_of_path
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2744   .text:0000149c fat16_open
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2981   .text:00001688 $d
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2988   .text:00001690 fat16_create_file
C:\DOCUME~1\Ryan\LOCALS~1\Temp/ccwraaaa.s:2995   .text:00001690 $a

UNDEFINED SYMBOLS
__umodsi3
memset
strcmp
__divsi3
strlen
strrchr
memcpy
__udivsi3
free
malloc
strchr
strncmp
rprintf
strncpy
