
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008ea4  00010000  00010000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000894  40000000  00018ea4  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000009e0  40000894  40000894  00018894  2**2
                  ALLOC
  3 .stack        00000c00  40001300  40001300  000188a0  2**4
                  CONTENTS
  4 .comment      000003b1  00000000  00000000  000194a0  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000388  00000000  00000000  00019858  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000c21  00000000  00000000  00019be0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000063d2  00000000  00000000  0001a801  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001f8c  00000000  00000000  00020bd3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001d7d  00000000  00000000  00022b5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001260  00000000  00000000  000248dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001ef2  00000000  00000000  00025b3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003dab  00000000  00000000  00027a2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003b8  00000000  00000000  0002b7d9  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00010000 <__Vectors>:
// Exception Vectors
// Mapped to Address 0.
// Absolute addressing mode must be used.

__Vectors:        LDR     PC,Reset_Addr         
   10000:	e59ff018 	ldr	pc, [pc, #24]	; 10020 <Reset_Addr>
                LDR     PC,Undef_Addr
   10004:	e59ff018 	ldr	pc, [pc, #24]	; 10024 <Undef_Addr>
                LDR     PC,SWI_Addr
   10008:	e59ff018 	ldr	pc, [pc, #24]	; 10028 <SWI_Addr>
                LDR     PC,PAbt_Addr
   1000c:	e59ff018 	ldr	pc, [pc, #24]	; 1002c <PAbt_Addr>
                LDR     PC,DAbt_Addr
   10010:	e59ff018 	ldr	pc, [pc, #24]	; 10030 <DAbt_Addr>
                NOP                            /* Reserved Vector */
   10014:	e1a00000 	nop			(mov r0,r0)
//                LDR     PC,IRQ_Addr
//                LDR     PC,[PC, #-0x0FF0]      /* Vector from VicVectAddr */
                LDR     PC,IRQ_Wrapper_Addr
   10018:	e59ff018 	ldr	pc, [pc, #24]	; 10038 <IRQ_Wrapper_Addr>
                LDR     PC,FIQ_Addr
   1001c:	e59ff018 	ldr	pc, [pc, #24]	; 1003c <FIQ_Addr>

00010020 <Reset_Addr>:
   10020:	00010098 	muleq	r1, r8, r0

00010024 <Undef_Addr>:
   10024:	00010040 	andeq	r0, r1, r0, asr #32

00010028 <SWI_Addr>:
   10028:	00000000 	andeq	r0, r0, r0

0001002c <PAbt_Addr>:
   1002c:	00010044 	andeq	r0, r1, r4, asr #32

00010030 <DAbt_Addr>:
   10030:	00010048 	andeq	r0, r1, r8, asr #32
   10034:	00000000 	andeq	r0, r0, r0

00010038 <IRQ_Wrapper_Addr>:
   10038:	00010050 	andeq	r0, r1, r0, asr r0

0001003c <FIQ_Addr>:
   1003c:	0001004c 	andeq	r0, r1, ip, asr #32

00010040 <Undef_Handler>:

Reset_Addr:       .word     Reset_Handler
Undef_Addr:       .word     Undef_Handler
// SWI_Addr:         .word     SWI_Handler
// SWI_Wrapper_Addr: .word     SWI_Wrapper
SWI_Addr:         .word     0      /* in swi_handler.S */
PAbt_Addr:        .word     PAbt_Handler
DAbt_Addr:        .word     DAbt_Handler
                  .word     0                      /* Reserved Address */
// IRQ_Addr:         .word     __IRQ_Handler
IRQ_Wrapper_Addr: .word    __IRQ_Wrapper
FIQ_Addr:         .word     FIQ_Handler

Undef_Handler:  B       Undef_Handler
   10040:	eafffffe 	b	10040 <Undef_Handler>

00010044 <PAbt_Handler>:
/* SWI_Handler:    B       SWI_Handler */
PAbt_Handler:   B       PAbt_Handler
   10044:	eafffffe 	b	10044 <PAbt_Handler>

00010048 <DAbt_Handler>:
DAbt_Handler:   B       DAbt_Handler
   10048:	eafffffe 	b	10048 <DAbt_Handler>

0001004c <FIQ_Handler>:
/* IRQ_Handler:    B       IRQ_Handler */
FIQ_Handler:    B       FIQ_Handler
   1004c:	eafffffe 	b	1004c <FIQ_Handler>

00010050 <__IRQ_Wrapper>:

.size   __Vectors, . - __Vectors



.arm
.section .init, "ax"

.if (VECTREMAPPED)
/* mthomas: Dummy used during startup - mind the nops since the 
   flash-utility will overwrite the "reserved vector"-address
   with the checksum */
				B Reset_Handler
				NOP
				NOP
				NOP
				NOP
				NOP  /* Reserved Address */
				NOP
				NOP
.endif

.arm
.section .init, "ax"
.global __startup
.func __startup
__startup:

Reset_Handler:  


// Memory Mapping
                .set MEMMAP, 0xE01FC040  /* Memory Mapping Control */

.if (REMAP)
                LDR     R0, =MEMMAP
.if     (EXTMEM_MODE)                
                MOV     R1, #3
.elseif (RAM_MODE) || (VECTREMAPPED)
.print "MEMMAP to 2 on init"
                MOV     R1, #2
.else
                MOV     R1, #1
.endif
                STR     R1, [R0]
.endif

// Setup Stack for each mode
                LDR     R0, =Top_Stack

// Enter Undefined Instruction Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_UND|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #UND_Stack_Size

// Enter Abort Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_ABT|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #ABT_Stack_Size

// Enter FIQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_FIQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #FIQ_Stack_Size

// Enter IRQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_IRQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #IRQ_Stack_Size

// Enter Supervisor Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #SVC_Stack_Size

// Enter User Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SYS /* Interrupts enabled */
//				MSR     CPSR_c, #Mode_USR|I_Bit|F_Bit /* Interrupts disabled */
                MOV     SP, R0


.if (RAM_MODE==0)
/* Relocate .data section (Copy from ROM to RAM) */
                LDR     R1, =_etext 
                LDR     R2, =_data 
                LDR     R3, =_edata 
                CMP     R2, R3
                BEQ     DataIsEmpty
LoopRel:        CMP     R2, R3 
                LDRLO   R0, [R1], #4 
                STRLO   R0, [R2], #4 
                BLO     LoopRel 
DataIsEmpty:
.endif
 
/* Clear .bss section (Zero init) */
                MOV     R0, #0 
                LDR     R1, =__bss_start__ 
                LDR     R2, =__bss_end__ 
                CMP     R1,R2
                BEQ     BSSIsEmpty
LoopZI:         CMP     R1, R2 
                STRLO   R0, [R1], #4 
                BLO     LoopZI 
BSSIsEmpty:


// call C++ constructors of global objects
		LDR 	r0, =__ctors_start__
		LDR 	r1, =__ctors_end__
ctor_loop:
		CMP 	r0, r1
		BEQ 	ctor_end
		LDR 	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
		MOV 	lr, pc
		MOV 	pc, r2
		LDMFD 	sp!, {r0-r1}
		B 		ctor_loop
ctor_end:

// Enter the C code
                //LDR     R0,=INIT
                LDR     R0,=main
                TST     R0,#1             // Bit-0 set: main is Thumb
                LDREQ   LR,=__exit_ARM    // ARM Mode
                LDRNE   LR,=__exit_THUMB  // Thumb Mode
                BX      R0

.size   __startup, . - __startup
.endfunc

.arm
.global __exit_ARM
.func __exit_ARM
__exit_ARM:
                B       __exit_ARM
.size   __exit_ARM, . - __exit_ARM
.endfunc

.thumb
.global __exit_THUMB
.func __exit_THUMB
__exit_THUMB:
                B       __exit_THUMB
.size   __exit_THUMB, . - __exit_THUMB
.endfunc


/* mthomas: the following code is inspired by various examples and
   documents from ARM, Atmel, Anglia Designs and others */


.text
.arm

.if (VECTREMAPPED)
.print "Handlers in section .vectmapped -> .data"
.section .vectmapped, "ax"
.else
.print "Handlers in section .vectorg -> .code/.text"
.section .vectorg, "ax"
.endif

.set VIC_base_addr, 0xFFFFF000
.set VIC_vect_offs, 0x30

        .arm
        .global __IRQ_Wrapper
        .func   __IRQ_Wrapper
__IRQ_Wrapper:
/*- Manage Exception Entry  */
/*- Adjust and save LR_irq in IRQ stack  */
            sub         lr, lr, #4
   10050:	e24ee004 	sub	lr, lr, #4	; 0x4
            stmfd       sp!, {lr}
   10054:	e92d4000 	stmdb	sp!, {lr}

/*- Save SPSR need to be saved for nested interrupt */
            mrs         r14, SPSR
   10058:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
   1005c:	e92d4000 	stmdb	sp!, {lr}

/*- Save and r0 in IRQ stack  */
            stmfd       sp!, {r0}
   10060:	e92d0001 	stmdb	sp!, {r0}

/*- Write in the IVR to support Protect Mode  */
/*- No effect in Normal Mode  */
/*- De-assert the NIRQ and clear the source in Protect Mode */
/* R14 = LR */
            ldr         r14, =VIC_base_addr
   10064:	e59fe028 	ldr	lr, [pc, #40]	; 10094 <.text+0x94>
            ldr         r0 , [r14, #VIC_vect_offs]
   10068:	e59e0030 	ldr	r0, [lr, #48]
            /*str         r14, [r14, #VIC_vect_offs]*/

/*- Enable Interrupt and Switch in Supervisor Mode */
            msr         CPSR_c, #Mode_SVC
   1006c:	e321f013 	msr	CPSR_c, #19	; 0x13

/*- Save scratch/used registers and LR in User Stack */
            /*stmfd       sp!, { r1-r3, r12, r14}*/
            stmfd       sp!, { r1-r12, r14 }
   10070:	e92d5ffe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Branch to the routine pointed by the VIC-Vector-Address  */
            mov         r14, pc
   10074:	e1a0e00f 	mov	lr, pc
            bx          r0
   10078:	e12fff10 	bx	r0
/*- Restore scratch/used registers and LR from User Stack*/
            /* ldmia       sp!, { r1-r3, r12, r14} */
            ldmia       sp!, { r1-r12, r14 }
   1007c:	e8bd5ffe 	ldmia	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Disable Interrupt and switch back in IRQ mode */
            msr         CPSR_c, #I_Bit | Mode_IRQ
   10080:	e321f092 	msr	CPSR_c, #146	; 0x92

#if 0
/* VICVectAddr=0 is already done in the ISRs of the Philips-Examples 
   so commented out here */
/*- Mark the End of Interrupt on the VIC */
            ldr         r14, =VIC_base_addr
            str         r14, [r14, #VIC_vect_offs]
#endif

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r0}
   10084:	e8bd0001 	ldmia	sp!, {r0}

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r14}
   10088:	e8bd4000 	ldmia	sp!, {lr}
            msr         SPSR_cxsf, r14
   1008c:	e16ff00e 	msr	SPSR_fsxc, lr

/*- Restore adjusted  LR_irq from IRQ stack directly in the PC */
            ldmia       sp!, {pc}^
   10090:	e8fd8000 	ldmia	sp!, {pc}^
   10094:	fffff000 	undefined instruction 0xfffff000

00010098 <__startup>:
   10098:	e59f00c8 	ldr	r0, [pc, #200]	; 10168 <.text+0x168>
   1009c:	e321f0db 	msr	CPSR_c, #219	; 0xdb
   100a0:	e1a0d000 	mov	sp, r0
   100a4:	e2400080 	sub	r0, r0, #128	; 0x80
   100a8:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
   100ac:	e1a0d000 	mov	sp, r0
   100b0:	e2400080 	sub	r0, r0, #128	; 0x80
   100b4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
   100b8:	e1a0d000 	mov	sp, r0
   100bc:	e2400080 	sub	r0, r0, #128	; 0x80
   100c0:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
   100c4:	e1a0d000 	mov	sp, r0
   100c8:	e2400c02 	sub	r0, r0, #512	; 0x200
   100cc:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
   100d0:	e1a0d000 	mov	sp, r0
   100d4:	e2400080 	sub	r0, r0, #128	; 0x80
   100d8:	e321f01f 	msr	CPSR_c, #31	; 0x1f
   100dc:	e1a0d000 	mov	sp, r0
   100e0:	e59f1084 	ldr	r1, [pc, #132]	; 1016c <.text+0x16c>
   100e4:	e59f2084 	ldr	r2, [pc, #132]	; 10170 <.text+0x170>
   100e8:	e59f3084 	ldr	r3, [pc, #132]	; 10174 <.text+0x174>
   100ec:	e1520003 	cmp	r2, r3
   100f0:	0a000003 	beq	10104 <DataIsEmpty>

000100f4 <LoopRel>:
   100f4:	e1520003 	cmp	r2, r3
   100f8:	34910004 	ldrcc	r0, [r1], #4
   100fc:	34820004 	strcc	r0, [r2], #4
   10100:	3afffffb 	bcc	100f4 <LoopRel>

00010104 <DataIsEmpty>:
   10104:	e3a00000 	mov	r0, #0	; 0x0
   10108:	e59f1068 	ldr	r1, [pc, #104]	; 10178 <.text+0x178>
   1010c:	e59f2068 	ldr	r2, [pc, #104]	; 1017c <.text+0x17c>
   10110:	e1510002 	cmp	r1, r2
   10114:	0a000002 	beq	10124 <BSSIsEmpty>

00010118 <LoopZI>:
   10118:	e1510002 	cmp	r1, r2
   1011c:	34810004 	strcc	r0, [r1], #4
   10120:	3afffffc 	bcc	10118 <LoopZI>

00010124 <BSSIsEmpty>:
   10124:	e59f0054 	ldr	r0, [pc, #84]	; 10180 <.text+0x180>
   10128:	e59f1054 	ldr	r1, [pc, #84]	; 10184 <.text+0x184>

0001012c <ctor_loop>:
   1012c:	e1500001 	cmp	r0, r1
   10130:	0a000005 	beq	1014c <ctor_end>
   10134:	e4902004 	ldr	r2, [r0], #4
   10138:	e92d0003 	stmdb	sp!, {r0, r1}
   1013c:	e1a0e00f 	mov	lr, pc
   10140:	e1a0f002 	mov	pc, r2
   10144:	e8bd0003 	ldmia	sp!, {r0, r1}
   10148:	eafffff7 	b	1012c <ctor_loop>

0001014c <ctor_end>:
   1014c:	e59f0034 	ldr	r0, [pc, #52]	; 10188 <.text+0x188>
   10150:	e3100001 	tst	r0, #1	; 0x1
   10154:	059fe030 	ldreq	lr, [pc, #48]	; 1018c <.text+0x18c>
   10158:	159fe030 	ldrne	lr, [pc, #48]	; 10190 <.text+0x190>
   1015c:	e12fff10 	bx	r0

00010160 <__exit_ARM>:
   10160:	eafffffe 	b	10160 <__exit_ARM>

00010164 <__exit_THUMB>:
   10164:	e7fe      	b.n	10164 <__exit_THUMB>
   10166:	0000      	lsls	r0, r0, #0
   10168:	1f00      	subs	r0, r0, #4
   1016a:	4000      	ands	r0, r0
   1016c:	8ea4      	ldrh	r4, [r4, #52]
   1016e:	0001      	lsls	r1, r0, #0
   10170:	0000      	lsls	r0, r0, #0
   10172:	4000      	ands	r0, r0
   10174:	0894      	lsrs	r4, r2, #2
   10176:	4000      	ands	r0, r0
   10178:	0894      	lsrs	r4, r2, #2
   1017a:	4000      	ands	r0, r0
   1017c:	1274      	asrs	r4, r6, #9
   1017e:	4000      	ands	r0, r0
   10180:	8ea4      	ldrh	r4, [r4, #52]
   10182:	0001      	lsls	r1, r0, #0
   10184:	8ea4      	ldrh	r4, [r4, #52]
   10186:	0001      	lsls	r1, r0, #0
   10188:	1348      	asrs	r0, r1, #13
   1018a:	0001      	lsls	r1, r0, #0
   1018c:	0160      	lsls	r0, r4, #5
   1018e:	0001      	lsls	r1, r0, #0
   10190:	0164      	lsls	r4, r4, #5
   10192:	0001      	lsls	r1, r0, #0

00010194 <delay_ms>:
//The function will cause the firmware to delay for "count" milleseconds.
void delay_ms(int count)
{
    int i;
    count *= 10000;
   10194:	e59f301c 	ldr	r3, [pc, #28]	; 101b8 <.text+0x1b8>
   10198:	e0000093 	mul	r0, r3, r0
   1019c:	e3a03000 	mov	r3, #0	; 0x0
   101a0:	ea000001 	b	101ac <delay_ms+0x18>
    for (i = 0; i < count; i++)
        asm volatile ("nop");
   101a4:	e1a00000 	nop			(mov r0,r0)
   101a8:	e2833001 	add	r3, r3, #1	; 0x1
   101ac:	e1530000 	cmp	r3, r0
   101b0:	bafffffb 	blt	101a4 <delay_ms+0x10>
}
   101b4:	e12fff1e 	bx	lr
   101b8:	00002710 	andeq	r2, r0, r0, lsl r7

000101bc <getButton>:

//Usage: bootUp();
//Inputs: None
//This function initializes the serial port, the SD card, the I/O pins and the interrupts
void bootUp(void)
{
    rprintf_devopen(putc_serial0); //Init rprintf
    delay_ms(10); //Delay for power to stablize

    //Bring up SD and FAT
    if(!sd_raw_init())
    {
        rprintf("SD Init Error\n");
    }
    if(openroot())
    {
        rprintf("SD OpenRoot Error\n");
    }
     
	//Initialize I/O Ports and Peripherals
	//Setup the MP3 I/O Lines
	IODIR0 |= MP3_XCS;
	IODIR0 &= ~MP3_DREQ;
	PINSEL1 |= 0x00000C00;	//Set the MP3_DREQ Pin to be a capture pin
	IODIR1 |= MP3_XDCS | MP3_GPIO0 | MP3_XRES;	
	
	//Setupt the FM Trans. Lines
	IODIR1 |= FM_LA; 												//FM Trans Outputs (Leave SPI pins unconfigured for now)
	IODIR1 |= FM_CS;
	
	//Setup the SD Card I/O Lines
	IODIR0 |= SD_CS;												//SD Card Outputs
	
	//Setup the Accelerometer I/O Lines
	IODIR0 |= (GS1 | GS2);											//Accelerometer Outputs
	PINSEL0 |= (MMA_X_PINSEL | MMA_Y_PINSEL | MMA_Z_PINSEL);		//Make sure that ADC pins have ADC Functions selected
	IOCLR0 = (GS1 | GS2);											//Init. Accel. to 1.5G Mode
	
	//Setup the LCD I/O Lines
	IODIR0 |= (LCD_RES | LCD_CS);									//LCD Outputs
	
	//Setup the LED Lines										
	IODIR0 |= (LED_BLU | LED_RED | LED_GRN);						//Led's
	ledBlueOff();
	ledRedOff();
	ledGrnOff();
	
	//Setup the Buttons
	IODIR1 &= (~SW_UP & ~SW_DWN & ~SW_MID);		//Button Inputs

	IODIR0 &= ~(1<<23);							//Set the Vbus line as an input

    //Setupt the Interrupts
	VPBDIV=1;										// Set PCLK equal to the System Clock	
	VICIntSelect = ~0x30; 							// Timer 0 AND TIMER 1 interrupt is an IRQ interrupt
    VICIntEnable = 0x10; 							// Enable Timer 0 Interrupts (Don't start sending song data with Timer 1)
    VICVectCntl0= 0x25; 							// Use slot 0 for timer 1 interrupt
    VICVectAddr0 = (unsigned int)timer1ISR; 		// Set the address of ISR for slot 1		
    VICVectCntl1 = 0x24; 							// Use slot 1 for timer 0 interrupt
    VICVectAddr1 = (unsigned int)timer0ISR; 		// Set the address of ISR for slot 1
	
	//Configure Timer0
	T0PR = 300;										//Divide Clock by 300 for 40kHz PS
	T0TCR |=0X01;									//Enable the clock
	T0CTCR=0;										//Timer Mode
	T0MCR=0x0003;									//Interrupt and Reset Timer on Match
	T0MR0=1000;										//Interrupt on 40Hz
	
	//Configure Timer1
	T1PR = 200;										//Divide Clock by 300 for 40kHz PS
	T1TCR |=0X01;									//Enable the clock
	T1CTCR=0;										//Timer Mode
	T1CCR=0x0A00;									//Capture and interrupt on the rising edge of DREQ
	
	//Setup the SPI Port
    S0SPCCR = 64;              											// SCK = 1 MHz, counter > 8 and even
    S0SPCR  = 0x20;                										// Master, no interrupt enable, 8 bits	
}

//Usage: None (Automatically Called by FW)
//Inputs: None
//This function is a global interrupt called by a match on the Timer 0 match.  This interrupt
//	is responsible for sending music to the MP3 player when it is needed. 
//WARNING: Altering the Timer 0 Prescale register or Timer 0 Match value will put proper MP3 playing at risk.
//			Adding superfluous code to this interrupt section may also contribute to improper MP3 playback.
static void timer1ISR(void)
{
	vs1002Config();												//Enable MP3 Comm. Lines
	while(IOPIN0 & MP3_DREQ){
		vs1002SendMusic(current_song.data, MAXBUFFERSIZE);		//Send the buffered song data
		if(fat16_read_file(current_song.handle, current_song.data, MAXBUFFERSIZE) <= 0)song_is_over=1;	//Buffer more data if available
		else song_is_over=0;									//if there's no more data available, set the flag, else leave it alone
	}	
	vs1002Finish();												//Disable MP3 Comm. Lines
	T1IR = 0xFF; 												//Clear the timer 0 interrupt
	VICVectAddr = 0; 											//Update VIC priorities	
}

//Usage: None (Automatically Called by FW)
//Inputs: None
//This function is a global interrupt called by a match on the Timer 1 match.  The interrupt
// is responsible for determining if a button has been pressed or if the screen has been rotated
// and setting the appropriate global flag if either has occured.
static void timer0ISR(void)
{
	button_pressed=getButton();			//Find out if a button has been pressed, and which one
	cur_position=MMA_get_y();			//Get the current position of the screen
	if((prev_position<700 && cur_position>700)||(prev_position>700 && cur_position<700))update_screen=1; 
	else update_screen=0;				//Determine if the accelerometer has been rotated
	prev_position=cur_position;			//Save the position value for later reference
	T0IR = 0xFF;						//Clear the timer interrupt
	VICVectAddr =0;						//Update the VIC priorities
}

//Usage: button_value=getButton();
//Inputs:  None
//Outputs: None
//Function returns the value of the button that is currently being pressed.
// UP_BUT, DWN_BUT, and MID_BUT values can be viewed in MP3Dev.h
char getButton(void){
	if(!(IOPIN1 & SW_UP)) return UP_BUT;
   101bc:	e59f2030 	ldr	r2, [pc, #48]	; 101f4 <.text+0x1f4>
   101c0:	e5923010 	ldr	r3, [r2, #16]
   101c4:	e3130502 	tst	r3, #8388608	; 0x800000
   101c8:	e3a00002 	mov	r0, #2	; 0x2
   101cc:	012fff1e 	bxeq	lr
	else if(!(IOPIN1 & SW_DWN)) return DWN_BUT;
   101d0:	e5923010 	ldr	r3, [r2, #16]
   101d4:	e3130602 	tst	r3, #2097152	; 0x200000
   101d8:	e3a00001 	mov	r0, #1	; 0x1
   101dc:	012fff1e 	bxeq	lr
	else if(!(IOPIN1 & SW_MID)) return MID_BUT;
   101e0:	e5923010 	ldr	r3, [r2, #16]
   101e4:	e3130501 	tst	r3, #4194304	; 0x400000
   101e8:	13a00000 	movne	r0, #0	; 0x0
   101ec:	03a00003 	moveq	r0, #3	; 0x3
	return NO_BUT;
}
   101f0:	e12fff1e 	bx	lr
   101f4:	e0028000 	and	r8, r2, r0

000101f8 <getNewFiles>:


void getNewFiles(DisplayStruct *files, FileStruct *file_list){
   101f8:	e92d4010 	stmdb	sp!, {r4, lr}
	if(files->current_page < files->total_pages){
   101fc:	e5d02006 	ldrb	r2, [r0, #6]
   10200:	e5d03005 	ldrb	r3, [r0, #5]
   10204:	e1520003 	cmp	r2, r3
   10208:	e1a04001 	mov	r4, r1
		for(int i =0; i<NUMROWS; i++){
			for(int j=0; j<MAXFILENAMELEN; j++){
				files->list[i].file_name[j] = file_list[files->current_page*NUMROWS+i].file_name[j];
			}
		}
	}
	else{
		for(int i=0; i<(NUMBEROFFILES-files->total_pages*NUMROWS); i++){
			for(int j=0; j<MAXFILENAMELEN; j++){
				files->list[i].file_name[j] = file_list[files->current_page*NUMROWS+i].file_name[j];
			}
		}
		for(int i=(NUMBEROFFILES-files->total_pages*NUMROWS); i<NUMROWS; i++)files->list[i].file_name[0]='\0';
	}
}
   1020c:	33a0e000 	movcc	lr, #0	; 0x0
   10210:	3a000030 	bcc	102d8 <getNewFiles+0xe0>
   10214:	e59f30cc 	ldr	r3, [pc, #204]	; 102e8 <.text+0x2e8>
   10218:	e5931000 	ldr	r1, [r3]
   1021c:	e3a0e000 	mov	lr, #0	; 0x0
   10220:	ea00001b 	b	10294 <getNewFiles+0x9c>
   10224:	e5d02006 	ldrb	r2, [r0, #6]
   10228:	e3a0300f 	mov	r3, #15	; 0xf
   1022c:	e023e392 	mla	r3, r2, r3, lr
   10230:	e08c3283 	add	r3, ip, r3, lsl #5
   10234:	e7d32004 	ldrb	r2, [r3, r4]
   10238:	e080300c 	add	r3, r0, ip
   1023c:	e28cc001 	add	ip, ip, #1	; 0x1
   10240:	e083328e 	add	r3, r3, lr, lsl #5
   10244:	e35c001e 	cmp	ip, #30	; 0x1e
   10248:	e5c3200c 	strb	r2, [r3, #12]
   1024c:	1afffff4 	bne	10224 <getNewFiles+0x2c>
   10250:	e28ee001 	add	lr, lr, #1	; 0x1
   10254:	e35e000f 	cmp	lr, #15	; 0xf
   10258:	0a000020 	beq	102e0 <getNewFiles+0xe8>
   1025c:	ea00001d 	b	102d8 <getNewFiles+0xe0>
   10260:	e3a0c000 	mov	ip, #0	; 0x0
   10264:	e5d02006 	ldrb	r2, [r0, #6]
   10268:	e3a0300f 	mov	r3, #15	; 0xf
   1026c:	e023e392 	mla	r3, r2, r3, lr
   10270:	e08c3283 	add	r3, ip, r3, lsl #5
   10274:	e7d32004 	ldrb	r2, [r3, r4]
   10278:	e080300c 	add	r3, r0, ip
   1027c:	e28cc001 	add	ip, ip, #1	; 0x1
   10280:	e083328e 	add	r3, r3, lr, lsl #5
   10284:	e35c001e 	cmp	ip, #30	; 0x1e
   10288:	e5c3200c 	strb	r2, [r3, #12]
   1028c:	1afffff4 	bne	10264 <getNewFiles+0x6c>
   10290:	e28ee001 	add	lr, lr, #1	; 0x1
   10294:	e5d03005 	ldrb	r3, [r0, #5]
   10298:	e3a0200f 	mov	r2, #15	; 0xf
   1029c:	e0030392 	mul	r3, r2, r3
   102a0:	e0632001 	rsb	r2, r3, r1
   102a4:	e15e0002 	cmp	lr, r2
   102a8:	baffffec 	blt	10260 <getNewFiles+0x68>
   102ac:	e1a03282 	mov	r3, r2, lsl #5
   102b0:	e283300c 	add	r3, r3, #12	; 0xc
   102b4:	e0800003 	add	r0, r0, r3
   102b8:	ea000001 	b	102c4 <getNewFiles+0xcc>
   102bc:	e3a03000 	mov	r3, #0	; 0x0
   102c0:	e5403020 	strb	r3, [r0, #-32]
   102c4:	e352000e 	cmp	r2, #14	; 0xe
   102c8:	e2800020 	add	r0, r0, #32	; 0x20
   102cc:	e2822001 	add	r2, r2, #1	; 0x1
   102d0:	dafffff9 	ble	102bc <getNewFiles+0xc4>
   102d4:	ea000001 	b	102e0 <getNewFiles+0xe8>
   102d8:	e3a0c000 	mov	ip, #0	; 0x0
   102dc:	eaffffd0 	b	10224 <getNewFiles+0x2c>
   102e0:	e8bd4010 	ldmia	sp!, {r4, lr}
   102e4:	e12fff1e 	bx	lr
   102e8:	40000898 	mulmi	r0, r8, r8

000102ec <fillSettings>:

//Usage: file_is_open = loadSongInfo(&current_song, &file_manager);
//Inputs: SongStruct *song: Pointer to the struct in which the song information will be loaded
//		  DisplayStruct *selected_song: Pointer to the song whose information will be loaded
//The function takes the currently selected file name from the selected_song structure and loads
// the vital file information into the song structure.  The function also opens the song and prepares
// it to be played.  If the function succesfully opens the song, a 1 is returned, else a 0 is returned.
char loadSongInfo(SongStruct *song, DisplayStruct *selected_song){
	//Get the selected songs file name
	for(int i=0; i<MAXFILENAMELEN; i++){
		song->file_name[i] = selected_song->list[selected_song->current_index].file_name[i];
	}
	//Get the selected songs display name
	for(int i=0; i<MAXDISPLEN; i++){
		if((song->file_name[i] == '.') || (i==MAXDISPLEN-1)){
			song->name[i]='\0';
			i=MAXDISPLEN;
		}	
		else song->name[i]=song->file_name[i];
	}
	
	PINSEL0 |= (SCLK_PINSEL | MISO_PINSEL | MOSI_PINSEL);	//Make sure SPI is selected for reading the card
	//Check to see if the selected song is valid
	if(!root_file_exists(song->file_name)){
		PINSEL0 &= 0xFFFFC00F;
		return 0;
	}	
	//Open the selected song
	else{
		song->handle=root_open(song->file_name);
		song->size=fat16_file_size(song->handle);
		fat16_read_file(song->handle, song->data, MAXBUFFERSIZE);
	}
	
	
	PINSEL0 &= 0xFFFFC00F;
	return 1;
}

//Usage: CloseSong(&current_song);
//Inputs: SongStruct *song: Pointer to a song structure to be closed
//Function closes a song that is currently open.
void closeSong(SongStruct *song){
	PINSEL0 |= (SCLK_PINSEL | MISO_PINSEL | MOSI_PINSEL);
	fat16_close_file(song->handle);
	PINSEL0 &= 0xFFFFC00F;
}

//Usage: highlightRow(&current_display, PREVIOUS);
//Inputs: DisplayStruct *current_display: Pointer to the display structure whose current row value should be changed.
//		  char direction: direction value can be PREVIOUS or NEXT.  Value indicates which row should be highlighted
//Depending on "direction" this value highlights a row, and manages the current_row and current_index values.
void highlightRow(DisplayStruct *display, char direction){
	PINSEL0 &= 0xFFFFC00F;		//Hand over SPI lines to LCD talk
	LCDSetRowColor(display->current_row, 0, display->back_color, display->orientation);
	LCDPrintString(display->list[display->current_index].file_name, 0,display->text_color, display->current_row,0,display->orientation);
	if(direction == PREVIOUS){
		display->current_row--;
		display->current_index--;
	}
	else{
		display->current_row++;
		display->current_index++;		
	}
	LCDSetRowColor(display->current_row, 0, display->text_color, display->orientation);
	LCDPrintString(display->list[display->current_index].file_name, 0,display->back_color, display->current_row,0,display->orientation);	
}

//Usage: printMenu(&settings_menu);
//Inputs: DisplayStruct *display: Pointer to the display struct to be displayed on the LCD.
//This function writes the title, along with all of the file names in the display struct to the screen.
void printMenu(DisplayStruct *display){
	PINSEL0 &= 0xFFFFC00F;		//Hand over SPI lines to LCD talk
	if(display->current_page==0)LCDPrintString(display->title,0, display->text_color, 0,0,display->orientation);
	for(int j=0; j<NUMROWS; j++){
		LCDPrintString(display->list[j].file_name,0, display->text_color, j+1,0,display->orientation);
	}
	LCDSetRowColor(display->current_row, 0, display->text_color, display->orientation);
	LCDPrintString(display->list[display->current_index].file_name, 0,display->back_color, display->current_row,0,display->orientation);
}

//Usage: fillSettings(&settings_menu, &settings_values);
//Inputs: DisplayStruct *menu: Struct whose file names should be loaded with the settings menu
//		  SettingsStruct *values: settings struct whose initial values should be set
//This function fills the input display struct with a list of settings, along with a "settings" title.  It
//also loads the default display values along with the default settings values. 
void fillSettings(DisplayStruct *menu){
   102ec:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   102f0:	e59f509c 	ldr	r5, [pc, #156]	; 10394 <.text+0x394>
   102f4:	e59f809c 	ldr	r8, [pc, #156]	; 10398 <.text+0x398>
   102f8:	e59f709c 	ldr	r7, [pc, #156]	; 1039c <.text+0x39c>
   102fc:	e59f609c 	ldr	r6, [pc, #156]	; 103a0 <.text+0x3a0>
   10300:	e1a04000 	mov	r4, r0
   10304:	e1a0e000 	mov	lr, r0
	for(int i=0; i<MAXDISPLEN; i++){
		menu->list[0].file_name[i] = volume[i];
   10308:	e4d52001 	ldrb	r2, [r5], #1
   1030c:	e59f3090 	ldr	r3, [pc, #144]	; 103a4 <.text+0x3a4>
		menu->list[1].file_name[i] = radio_power[i];
   10310:	e4d81001 	ldrb	r1, [r8], #1
		menu->list[2].file_name[i] = radio_channel_menu[i];
   10314:	e4d70001 	ldrb	r0, [r7], #1
		menu->title[i] = settings[i];
   10318:	e4d6c001 	ldrb	ip, [r6], #1
   1031c:	e1550003 	cmp	r5, r3
   10320:	e5ce200c 	strb	r2, [lr, #12]
   10324:	e5ce102c 	strb	r1, [lr, #44]
   10328:	e5ce004c 	strb	r0, [lr, #76]
   1032c:	e5cec1ec 	strb	ip, [lr, #492]
   10330:	e28ee001 	add	lr, lr, #1	; 0x1
   10334:	1afffff3 	bne	10308 <fillSettings+0x1c>
   10338:	e1a03004 	mov	r3, r4
   1033c:	e3a02003 	mov	r2, #3	; 0x3
	}
	for(int i=3; i<NUMROWS; i++){
   10340:	e2822001 	add	r2, r2, #1	; 0x1
		menu->list[i].file_name[0]='\0';
   10344:	e3a01000 	mov	r1, #0	; 0x0
   10348:	e352000f 	cmp	r2, #15	; 0xf
   1034c:	e5c3106c 	strb	r1, [r3, #108]
   10350:	e2833020 	add	r3, r3, #32	; 0x20
   10354:	1afffff9 	bne	10340 <fillSettings+0x54>
	}
	menu->text_color=white;
   10358:	e59f3048 	ldr	r3, [pc, #72]	; 103a8 <.text+0x3a8>
   1035c:	e5d33000 	ldrb	r3, [r3]
   10360:	e5c43003 	strb	r3, [r4, #3]
	menu->back_color=black;
   10364:	e59f3040 	ldr	r3, [pc, #64]	; 103ac <.text+0x3ac>
   10368:	e5d32000 	ldrb	r2, [r3]
	menu->current_row=1;
   1036c:	e3a03001 	mov	r3, #1	; 0x1
	menu->current_column=0;
	menu->current_index=0;
	menu->orientation = ORIENTLEFT;
	menu->current_page=0;
	menu->total_pages = 0;
   10370:	e5c41005 	strb	r1, [r4, #5]
   10374:	e5c42004 	strb	r2, [r4, #4]
   10378:	e5c43002 	strb	r3, [r4, #2]
   1037c:	e5c43000 	strb	r3, [r4]
   10380:	e5c41001 	strb	r1, [r4, #1]
   10384:	e5841008 	str	r1, [r4, #8]
   10388:	e5c41006 	strb	r1, [r4, #6]
}
   1038c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   10390:	e12fff1e 	bx	lr
   10394:	0001830c 	andeq	r8, r1, ip, lsl #6
   10398:	00018320 	andeq	r8, r1, r0, lsr #6
   1039c:	0001832c 	andeq	r8, r1, ip, lsr #6
   103a0:	0001833c 	andeq	r8, r1, ip, lsr r3
   103a4:	00018322 	andeq	r8, r1, r2, lsr #6
   103a8:	40000f28 	andmi	r0, r0, r8, lsr #30
   103ac:	40000009 	andmi	r0, r0, r9

000103b0 <reset>:

//Usage: handleUpButton(current_display, &Files[0]);
//Inputs: 	DisplayStruct *display: Display currently being shown to the user.
//			FileStruct *Files: List of files on the SD card
//Outputs: None
//Description: This function will highlight the previous row on the screen.  If the file menu is being shown,
// and the first file is currently selected, the function will get the previous group of files and display them.
void handleUpButton(DisplayStruct *display, FileStruct *Files){
	if(display->current_row >1){	//See if the currently highlighted row is at the top of the page
		highlightRow(display, PREVIOUS); //If it isn't, then highlight the previous row
	}
	//If the current row is at the top of the page, and there are previous songs, then get them.
	else if((display->current_row == 1) && (display->current_page > 0)){	//If a prev. page exists, load it
		//Load previous 15 songs and reset row, index and offset values
		display->current_page-=1;					//Set the "new" current page to be loaded
		//if(file_is_open)quickClear(display);
		//else LCDClear(display->back_color);
		quickClear(display);
		display->current_row=15;					//Start current row at bottom of next screen
		display->current_index=14;					//
		getNewFiles(&file_manager, &Files[0]);		//Load the previous page
		printMenu(display);							//	display previous page
	}
}

//Usage: handleDownButton(current_display, &Files[0]);
//Inputs: 	DisplayStruct *display: Display currently being shown to the user.
//			FileStruct *Files: List of files on the SD card
//Outputs: None
//Description: This function will highlight the next row on the screen.  If the file menu is being shown,
// and the last file is currently selected, the function will get the next group of files and display them.
void handleDownButton(DisplayStruct *display, FileStruct *Files){
	if(display->current_row <15){	//See if the currently highlighted row is at the bottom of the page
		highlightRow(display, NEXT);	//If it's not, then highlight the next row
	}
	//If the current highlighted row is at the bottom, and there're more songs, then get them
	else if((display->current_row == 15) && (display->current_page < display->total_pages)){
		//Load next 15 songs and reset row, index and offset values
		display->current_page+=1;		
		//if(file_is_open)quickClear(display);
		//else LCDClear(display->back_color);
		quickClear(display);
		display->current_row=1;
		display->current_index=0;
		getNewFiles(&file_manager, &Files[0]);
		printMenu(display);				
	}
}

//Usage: handleMiddleButton();
//Inputs: None
//Outputs: None
//Description: This function is called when the middle button is pressed.
//  The function performs an action based on the current state of the MP3 player.
//	(1.-If the file menu is displayed, and a song is not being played, the function starts the currently highlighted song.)
//	(2.-If the file menu is displayed and a song IS being played, the fucntion stops the currently playing song)
//	(3.-If the settings menu is displayed, the function opens the selected setting and allows the user to edit the setting.)
void handleMiddleButton(void){
	VICIntEnClr = 0x10;
	delay_ms(250);
	
	//If the File Menu is being displayed, middle button acts like play/stop
	if(current_display == &file_manager){
		if(!file_is_open){				//If a file isn't already playing then this acts like a play button
			file_is_open=loadSongInfo(&current_song, &file_manager);	//Get the current song info.
			if(!file_is_open){			//Make sure this is a valid file
				LCDClear(white);
				LCDPrintString(NotFound, 0, black, 1,0,current_display->orientation);
				delay_ms(1000);
				LCDClear(black);
				printMenu(&file_manager);
			}	
			else{
				vs1002Config();							//Enable the MP3 Comm. Lines
				vs1002SCIWrite(SCI_MODE, SM_SDINEW);	//Make sure the MP3 player is in the right mode.
				vs1002Finish();							//Disable the MP3 Comm. Lines
				ledBlueOn();
				//Send first song data
				vs1002Config();										//Enable MP3 Comm. Lines
				while((IOPIN0 & MP3_DREQ) != 0){
					vs1002SendMusic(current_song.data, MAXBUFFERSIZE);	//Send the buffered song data
					if(fat16_read_file(current_song.handle, current_song.data, MAXBUFFERSIZE) <= 0)song_is_over=1;	//Buffer more data if available
					else song_is_over=0;									//if there's no more data available, set the flag, else leave it alone
				}
				vs1002Finish();
				PINSEL1 |= 0x00000C00;						
				VICIntEnable |= 0x20;		//Enable Timer 1 Interrupts(This is the "Song Sending" interrupt).
				IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
			}
		}	
		else{							//If a file is already open then this acts like a stop button
			VICIntEnClr = 0x20;											//Disable Time 0 Interrupts(Stop the "Song Sending" interrupt)
			ledBlueOff();
			vs1002Config();												//Enable the MP3 Comm Lines
			vs1002SCIWrite(SCI_MODE, SM_OUTOFWAV);						//Tell the MP3 Player to jump out of WAV decoding
			for(int i=0; i<150; i++)vs1002SCIWrite(SCI_MODE, 0x00);	//Send 150 zeroes to the player to clear it's FIFO.
			vs1002Finish();												//Disable the MP3 Comm. Lines
			IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);			//Assign LCD pins as Outputs
			closeSong(&current_song);									//Close the current song
			file_is_open=0;												//Clear the global flag
			VICIntEnable = 0x10;
		}
	}
	
	//Else we are on the Settings menu, and we need to handle the settins options
	else{
		if(file_is_open)quickClear(current_display);
		else LCDClear(settings_menu.back_color);
		LCDPrintString(current_display->list[current_display->current_index].file_name,0,current_display->text_color,1,0,current_display->orientation);
		VICIntEnable|=0x10;
		if(current_display->current_row==VOLUMEMENU){
			VICIntEnable |= 0x10;
			LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
			LCDPrintString("%d", volume_setting, white, 2, 0, current_display->orientation);
			while(button_pressed < MID_BUT){
				VICIntEnClr = 0x10;				//Stop Interrupts to
				delay_ms(150);					//	debounce the switch					
				if(button_pressed==UP_BUT){
					if(volume_setting < 32){
						volume_setting+=1;
						vs1002Config();				//Enable the MP3 Comm. Lines
						vs1002SetVolume(INCREASE);	//Lower the volume
						vs1002Finish();				//Disable MP3 Comm. Lines
					}	
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", volume_setting, current_display->text_color, 2, 0, current_display->orientation);
				}
				else if(button_pressed==DWN_BUT){
					if(volume_setting >= 0){
						volume_setting--;
						vs1002Config();			//Enable the MP3 Comm. Lines
						vs1002SetVolume(DECREASE);	//Lower the volume
						vs1002Finish();			//Disable MP3 Comm. Lines
					}
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", volume_setting, white, 2, 0, current_display->orientation);
				}
				VICIntEnable |= 0x10;
			}
		}	
		else if(current_display->current_row==RADIOCMENU){
			LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
			LCDPrintString("%d", radio_channel, white, 2, 0, current_display->orientation);
			button_pressed=NO_BUT;
			VICIntEnable |= 0x10;
			while(button_pressed < MID_BUT){
				VICIntEnClr = 0x10;	//Stop Interrupts to
				delay_ms(100);		//	debounce the switch					
				if(button_pressed==UP_BUT){
					//Increase Radio Channel
					if(radio_channel < 1075)radio_channel+=2;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", radio_channel, white, 2, 0, current_display->orientation);
				}
				else if(button_pressed==DWN_BUT){
					//Decrease Radio Channel
					if(radio_channel > 885)radio_channel-=2;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("%d", radio_channel, white, 2, 0, current_display->orientation);
				}
				ns73SetChannel(radio_channel);
				VICIntEnable |= 0x10;
			}
			IOCLR1 |= FM_CS;				//Select the FM transmitter
			delay_ms(100);
			ns73Config();					//Configigure the FM Trans. I/O
			ns73SetChannel(radio_channel);	//Set the channel	
			IOSET1 |= FM_CS;				//Unselect the FM transmitter
		}
		else if(current_display->current_row==RADIOPMENU){
			LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
			if(radio_enable)LCDPrintString("On", 0, current_display->text_color, 2,0,current_display->orientation);
			else LCDPrintString("Off", 0, current_display->text_color, 2,0,current_display->orientation);
			button_pressed=NO_BUT;
			VICIntEnable |= 0x10;
			while(button_pressed < MID_BUT){
				VICIntEnClr = 0x10;	//Stop Interrupts to
				delay_ms(100);		//	debounce the switch					
				if(button_pressed==UP_BUT){
					//Enable Radio
					radio_enable=ON;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("On", 0, current_display->text_color, 2,0,current_display->orientation);
					
					IOCLR1 |= FM_CS;			//Select the FM transmitter
					delay_ms(100);
					ns73Config();				//Configigure the FM Trans. I/O
					ns73Send(R0, PE | AG);		//Power up the radio	
					IOSET1 |= FM_CS;			//Unselect the FM transmitter

				}
				else if(button_pressed==DWN_BUT){
					//Disable Radio
					radio_enable=OFF;
					LCDSetRowColor(2, 0, current_display->back_color, current_display->orientation);
					LCDPrintString("Off", 0, current_display->text_color, 2,0,current_display->orientation);

					IOCLR1 |= FM_CS;			//Select the FM transmitter
					delay_ms(100);
					ns73Config();				//Configigure the FM Trans. I/O
					ns73Send(R0, MUTE);		//Power up the radio	
					IOSET1 |= FM_CS;			//Unselect the FM transmitter	

				}
				VICIntEnable |= 0x10;
			}
		}
		if(file_is_open)quickClear(current_display);
		else LCDClear(current_display->back_color);
		printMenu(current_display);
	}
	VICIntEnable |= 0x10;
}


//Usage: quickClear(currentDisplay);
//Inputs: DisplayStruct *display - pointer to the display that contains the current display
//Outputs: None
//Description: Rather than painting every pixel a specific color (like LCDClear does) this routine
//			   will simply color all of the text the same color as the background, giving the illusion
//			   of a clear screen.  Only works with the background color.  Much faster than LCDClear, and is
//			   good to use while an MP3 is playing.
void quickClear(DisplayStruct *display){
	PINSEL0 &= 0xFFFFC00F;		//Hand over SPI lines to LCD talk
	//If we're on the first page of the menu, we also need to clear the title.
	if(display->current_page==0){
		LCDPrintString(display->title,0, display->back_color, 0,0,display->orientation);
		
	}
	LCDSetRowColor(display->current_row, 0, display->back_color, display->orientation);
	for(int j=0; j<NUMROWS; j++){
		LCDPrintString(display->list[j].file_name,0, display->back_color, j+1,0,display->orientation);
		LCDPrintString(newline,0, black, j+1,0,0);
	}
}

void reset(void)
{
    // Intentionally fault Watchdog to trigger a reset condition
    WDMOD |= 3;
   103b0:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
   103b4:	e5923000 	ldr	r3, [r2]
   103b8:	e3833003 	orr	r3, r3, #3	; 0x3
   103bc:	e5823000 	str	r3, [r2]
    WDFEED = 0xAA;
   103c0:	e3a010aa 	mov	r1, #170	; 0xaa
    WDFEED = 0x55;
   103c4:	e3a03055 	mov	r3, #85	; 0x55
   103c8:	e5821008 	str	r1, [r2, #8]
   103cc:	e5823008 	str	r3, [r2, #8]
    WDFEED = 0xAA;
    WDFEED = 0x00;
   103d0:	e3a03000 	mov	r3, #0	; 0x0
   103d4:	e5821008 	str	r1, [r2, #8]
   103d8:	e5823008 	str	r3, [r2, #8]
}
   103dc:	e12fff1e 	bx	lr

000103e0 <quickClear>:
   103e0:	e59f20bc 	ldr	r2, [pc, #188]	; 104a4 <.text+0x4a4>
   103e4:	e5923000 	ldr	r3, [r2]
   103e8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   103ec:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   103f0:	e3c33030 	bic	r3, r3, #48	; 0x30
   103f4:	e5823000 	str	r3, [r2]
   103f8:	e5d0e006 	ldrb	lr, [r0, #6]
   103fc:	e35e0000 	cmp	lr, #0	; 0x0
   10400:	e24dd008 	sub	sp, sp, #8	; 0x8
   10404:	e1a06000 	mov	r6, r0
   10408:	1a000007 	bne	1042c <quickClear+0x4c>
   1040c:	e5d0c002 	ldrb	ip, [r0, #2]
   10410:	e5d02004 	ldrb	r2, [r0, #4]
   10414:	e1a0100e 	mov	r1, lr
   10418:	e2800f7b 	add	r0, r0, #492	; 0x1ec
   1041c:	e1a0300e 	mov	r3, lr
   10420:	e58dc004 	str	ip, [sp, #4]
   10424:	e58de000 	str	lr, [sp]
   10428:	eb00122e 	bl	14ce8 <LCDPrintString>
   1042c:	e5d60000 	ldrb	r0, [r6]
   10430:	e3a01000 	mov	r1, #0	; 0x0
   10434:	e5d62004 	ldrb	r2, [r6, #4]
   10438:	e5d63002 	ldrb	r3, [r6, #2]
   1043c:	eb0012fb 	bl	15030 <LCDSetRowColor>
   10440:	e3a05000 	mov	r5, #0	; 0x0
   10444:	e1a00285 	mov	r0, r5, lsl #5
   10448:	e3a04000 	mov	r4, #0	; 0x0
   1044c:	e5d6c002 	ldrb	ip, [r6, #2]
   10450:	e2855001 	add	r5, r5, #1	; 0x1
   10454:	e280000c 	add	r0, r0, #12	; 0xc
   10458:	e5d62004 	ldrb	r2, [r6, #4]
   1045c:	e0860000 	add	r0, r6, r0
   10460:	e1a01004 	mov	r1, r4
   10464:	e1a03005 	mov	r3, r5
   10468:	e88d1010 	stmia	sp, {r4, ip}
   1046c:	eb00121d 	bl	14ce8 <LCDPrintString>
   10470:	e59f3030 	ldr	r3, [pc, #48]	; 104a8 <.text+0x4a8>
   10474:	e1a01004 	mov	r1, r4
   10478:	e5d32000 	ldrb	r2, [r3]
   1047c:	e59f0028 	ldr	r0, [pc, #40]	; 104ac <.text+0x4ac>
   10480:	e1a03005 	mov	r3, r5
   10484:	e58d4000 	str	r4, [sp]
   10488:	e58d4004 	str	r4, [sp, #4]
   1048c:	eb001215 	bl	14ce8 <LCDPrintString>
   10490:	e355000f 	cmp	r5, #15	; 0xf
   10494:	1affffea 	bne	10444 <quickClear+0x64>
   10498:	e28dd008 	add	sp, sp, #8	; 0x8
   1049c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   104a0:	e12fff1e 	bx	lr
   104a4:	e002c000 	and	ip, r2, r0
   104a8:	40000009 	andmi	r0, r0, r9
   104ac:	00018308 	andeq	r8, r1, r8, lsl #6

000104b0 <printMenu>:
   104b0:	e59f20c4 	ldr	r2, [pc, #196]	; 1057c <.text+0x57c>
   104b4:	e5923000 	ldr	r3, [r2]
   104b8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   104bc:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   104c0:	e3c33030 	bic	r3, r3, #48	; 0x30
   104c4:	e5823000 	str	r3, [r2]
   104c8:	e5d0e006 	ldrb	lr, [r0, #6]
   104cc:	e35e0000 	cmp	lr, #0	; 0x0
   104d0:	e24dd008 	sub	sp, sp, #8	; 0x8
   104d4:	e1a05000 	mov	r5, r0
   104d8:	1a000007 	bne	104fc <printMenu+0x4c>
   104dc:	e5d0c002 	ldrb	ip, [r0, #2]
   104e0:	e5d02003 	ldrb	r2, [r0, #3]
   104e4:	e1a0100e 	mov	r1, lr
   104e8:	e2800f7b 	add	r0, r0, #492	; 0x1ec
   104ec:	e1a0300e 	mov	r3, lr
   104f0:	e58dc004 	str	ip, [sp, #4]
   104f4:	e58de000 	str	lr, [sp]
   104f8:	eb0011fa 	bl	14ce8 <LCDPrintString>
   104fc:	e3a04000 	mov	r4, #0	; 0x0
   10500:	e1a00284 	mov	r0, r4, lsl #5
   10504:	e5d5c002 	ldrb	ip, [r5, #2]
   10508:	e2844001 	add	r4, r4, #1	; 0x1
   1050c:	e3a06000 	mov	r6, #0	; 0x0
   10510:	e280000c 	add	r0, r0, #12	; 0xc
   10514:	e5d52003 	ldrb	r2, [r5, #3]
   10518:	e0850000 	add	r0, r5, r0
   1051c:	e1a01006 	mov	r1, r6
   10520:	e1a03004 	mov	r3, r4
   10524:	e88d1040 	stmia	sp, {r6, ip}
   10528:	eb0011ee 	bl	14ce8 <LCDPrintString>
   1052c:	e354000f 	cmp	r4, #15	; 0xf
   10530:	1afffff2 	bne	10500 <printMenu+0x50>
   10534:	e5d50000 	ldrb	r0, [r5]
   10538:	e1a01006 	mov	r1, r6
   1053c:	e5d52003 	ldrb	r2, [r5, #3]
   10540:	e5d53002 	ldrb	r3, [r5, #2]
   10544:	eb0012b9 	bl	15030 <LCDSetRowColor>
   10548:	e5950008 	ldr	r0, [r5, #8]
   1054c:	e1a00280 	mov	r0, r0, lsl #5
   10550:	e5d5c002 	ldrb	ip, [r5, #2]
   10554:	e280000c 	add	r0, r0, #12	; 0xc
   10558:	e5d52004 	ldrb	r2, [r5, #4]
   1055c:	e5d53000 	ldrb	r3, [r5]
   10560:	e0850000 	add	r0, r5, r0
   10564:	e1a01006 	mov	r1, r6
   10568:	e88d1040 	stmia	sp, {r6, ip}
   1056c:	eb0011dd 	bl	14ce8 <LCDPrintString>
   10570:	e28dd008 	add	sp, sp, #8	; 0x8
   10574:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   10578:	e12fff1e 	bx	lr
   1057c:	e002c000 	and	ip, r2, r0

00010580 <highlightRow>:
   10580:	e59f20d8 	ldr	r2, [pc, #216]	; 10660 <.text+0x660>
   10584:	e5923000 	ldr	r3, [r2]
   10588:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   1058c:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10590:	e3c33030 	bic	r3, r3, #48	; 0x30
   10594:	e5823000 	str	r3, [r2]
   10598:	e1a05000 	mov	r5, r0
   1059c:	e24dd008 	sub	sp, sp, #8	; 0x8
   105a0:	e5d52004 	ldrb	r2, [r5, #4]
   105a4:	e5d53002 	ldrb	r3, [r5, #2]
   105a8:	e1a04001 	mov	r4, r1
   105ac:	e5d00000 	ldrb	r0, [r0]
   105b0:	e3a01000 	mov	r1, #0	; 0x0
   105b4:	eb00129d 	bl	15030 <LCDSetRowColor>
   105b8:	e5950008 	ldr	r0, [r5, #8]
   105bc:	e1a00280 	mov	r0, r0, lsl #5
   105c0:	e5d5e002 	ldrb	lr, [r5, #2]
   105c4:	e3a0c000 	mov	ip, #0	; 0x0
   105c8:	e280000c 	add	r0, r0, #12	; 0xc
   105cc:	e5d52003 	ldrb	r2, [r5, #3]
   105d0:	e5d53000 	ldrb	r3, [r5]
   105d4:	e1a0100c 	mov	r1, ip
   105d8:	e0850000 	add	r0, r5, r0
   105dc:	e88d5000 	stmia	sp, {ip, lr}
   105e0:	eb0011c0 	bl	14ce8 <LCDPrintString>
   105e4:	e5d53000 	ldrb	r3, [r5]
   105e8:	e20440ff 	and	r4, r4, #255	; 0xff
   105ec:	e3540001 	cmp	r4, #1	; 0x1
   105f0:	e2430001 	sub	r0, r3, #1	; 0x1
   105f4:	e2831001 	add	r1, r3, #1	; 0x1
   105f8:	e5953008 	ldr	r3, [r5, #8]
   105fc:	15c51000 	strneb	r1, [r5]
   10600:	05c50000 	streqb	r0, [r5]
   10604:	e2432001 	sub	r2, r3, #1	; 0x1
   10608:	e2833001 	add	r3, r3, #1	; 0x1
   1060c:	05852008 	streq	r2, [r5, #8]
   10610:	15853008 	strne	r3, [r5, #8]
   10614:	e5d50000 	ldrb	r0, [r5]
   10618:	e5d52003 	ldrb	r2, [r5, #3]
   1061c:	e5d53002 	ldrb	r3, [r5, #2]
   10620:	e3a01000 	mov	r1, #0	; 0x0
   10624:	eb001281 	bl	15030 <LCDSetRowColor>
   10628:	e5950008 	ldr	r0, [r5, #8]
   1062c:	e1a00280 	mov	r0, r0, lsl #5
   10630:	e3a0c000 	mov	ip, #0	; 0x0
   10634:	e5d5e002 	ldrb	lr, [r5, #2]
   10638:	e280000c 	add	r0, r0, #12	; 0xc
   1063c:	e5d52004 	ldrb	r2, [r5, #4]
   10640:	e5d53000 	ldrb	r3, [r5]
   10644:	e0850000 	add	r0, r5, r0
   10648:	e1a0100c 	mov	r1, ip
   1064c:	e88d5000 	stmia	sp, {ip, lr}
   10650:	eb0011a4 	bl	14ce8 <LCDPrintString>
   10654:	e28dd008 	add	sp, sp, #8	; 0x8
   10658:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1065c:	e12fff1e 	bx	lr
   10660:	e002c000 	and	ip, r2, r0

00010664 <handleDownButton>:
   10664:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   10668:	e5d03000 	ldrb	r3, [r0]
   1066c:	e353000e 	cmp	r3, #14	; 0xe
   10670:	e1a05001 	mov	r5, r1
   10674:	e1a04000 	mov	r4, r0
   10678:	e3a01000 	mov	r1, #0	; 0x0
   1067c:	8a000001 	bhi	10688 <handleDownButton+0x24>
   10680:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10684:	eaffffbd 	b	10580 <highlightRow>
   10688:	e353000f 	cmp	r3, #15	; 0xf
   1068c:	1a000010 	bne	106d4 <handleDownButton+0x70>
   10690:	e5d03006 	ldrb	r3, [r0, #6]
   10694:	e5d02005 	ldrb	r2, [r0, #5]
   10698:	e1520003 	cmp	r2, r3
   1069c:	e2831001 	add	r1, r3, #1	; 0x1
   106a0:	9a00000b 	bls	106d4 <handleDownButton+0x70>
   106a4:	e5c01006 	strb	r1, [r0, #6]
   106a8:	ebffff4c 	bl	103e0 <quickClear>
   106ac:	e3a03001 	mov	r3, #1	; 0x1
   106b0:	e5c43000 	strb	r3, [r4]
   106b4:	e3a03000 	mov	r3, #0	; 0x0
   106b8:	e5843008 	str	r3, [r4, #8]
   106bc:	e1a01005 	mov	r1, r5
   106c0:	e59f0014 	ldr	r0, [pc, #20]	; 106dc <.text+0x6dc>
   106c4:	ebfffecb 	bl	101f8 <getNewFiles>
   106c8:	e1a00004 	mov	r0, r4
   106cc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   106d0:	eaffff76 	b	104b0 <printMenu>
   106d4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   106d8:	e12fff1e 	bx	lr
   106dc:	40000908 	andmi	r0, r0, r8, lsl #18

000106e0 <handleUpButton>:
   106e0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   106e4:	e5d03000 	ldrb	r3, [r0]
   106e8:	e3530001 	cmp	r3, #1	; 0x1
   106ec:	e1a05001 	mov	r5, r1
   106f0:	e1a04000 	mov	r4, r0
   106f4:	e3a01001 	mov	r1, #1	; 0x1
   106f8:	9a000001 	bls	10704 <handleUpButton+0x24>
   106fc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10700:	eaffff9e 	b	10580 <highlightRow>
   10704:	1a00000f 	bne	10748 <handleUpButton+0x68>
   10708:	e5d03006 	ldrb	r3, [r0, #6]
   1070c:	e3530000 	cmp	r3, #0	; 0x0
   10710:	e2432001 	sub	r2, r3, #1	; 0x1
   10714:	0a00000b 	beq	10748 <handleUpButton+0x68>
   10718:	e5c02006 	strb	r2, [r0, #6]
   1071c:	ebffff2f 	bl	103e0 <quickClear>
   10720:	e3a0300f 	mov	r3, #15	; 0xf
   10724:	e5c43000 	strb	r3, [r4]
   10728:	e3a0300e 	mov	r3, #14	; 0xe
   1072c:	e5843008 	str	r3, [r4, #8]
   10730:	e1a01005 	mov	r1, r5
   10734:	e59f0014 	ldr	r0, [pc, #20]	; 10750 <.text+0x750>
   10738:	ebfffeae 	bl	101f8 <getNewFiles>
   1073c:	e1a00004 	mov	r0, r4
   10740:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   10744:	eaffff59 	b	104b0 <printMenu>
   10748:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1074c:	e12fff1e 	bx	lr
   10750:	40000908 	andmi	r0, r0, r8, lsl #18

00010754 <timer1ISR>:
   10754:	e92d4010 	stmdb	sp!, {r4, lr}
   10758:	eb0012e4 	bl	152f0 <vs1002Config>
   1075c:	ea00000b 	b	10790 <timer1ISR+0x3c>
   10760:	eb0012ff 	bl	15364 <vs1002SendMusic>
   10764:	e59f305c 	ldr	r3, [pc, #92]	; 107c8 <.text+0x7c8>
   10768:	e3a02020 	mov	r2, #32	; 0x20
   1076c:	e283103d 	add	r1, r3, #61	; 0x3d
   10770:	e5930034 	ldr	r0, [r3, #52]
   10774:	eb000b01 	bl	13380 <fat16_read_file>
   10778:	e1a00800 	mov	r0, r0, lsl #16
   1077c:	e3500000 	cmp	r0, #0	; 0x0
   10780:	e59f2044 	ldr	r2, [pc, #68]	; 107cc <.text+0x7cc>
   10784:	d3a03001 	movle	r3, #1	; 0x1
   10788:	c3a03000 	movgt	r3, #0	; 0x0
   1078c:	e5c23000 	strb	r3, [r2]
   10790:	e59f3038 	ldr	r3, [pc, #56]	; 107d0 <.text+0x7d0>
   10794:	e5933000 	ldr	r3, [r3]
   10798:	e2134602 	ands	r4, r3, #2097152	; 0x200000
   1079c:	e59f0030 	ldr	r0, [pc, #48]	; 107d4 <.text+0x7d4>
   107a0:	e3a01020 	mov	r1, #32	; 0x20
   107a4:	1affffed 	bne	10760 <timer1ISR+0xc>
   107a8:	eb0012da 	bl	15318 <vs1002Finish>
   107ac:	e59f2024 	ldr	r2, [pc, #36]	; 107d8 <.text+0x7d8>
   107b0:	e3a030ff 	mov	r3, #255	; 0xff
   107b4:	e5823000 	str	r3, [r2]
   107b8:	e3e03000 	mvn	r3, #0	; 0x0
   107bc:	e5034fcf 	str	r4, [r3, #-4047]
   107c0:	e8bd4010 	ldmia	sp!, {r4, lr}
   107c4:	e12fff1e 	bx	lr
   107c8:	400008a8 	andmi	r0, r0, r8, lsr #17
   107cc:	40000896 	mulmi	r0, r6, r8
   107d0:	e0028000 	and	r8, r2, r0
   107d4:	400008e5 	andmi	r0, r0, r5, ror #17
   107d8:	e0008000 	and	r8, r0, r0

000107dc <closeSong>:
   107dc:	e92d4010 	stmdb	sp!, {r4, lr}
   107e0:	e59f4028 	ldr	r4, [pc, #40]	; 10810 <.text+0x810>
   107e4:	e5943000 	ldr	r3, [r4]
   107e8:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   107ec:	e5843000 	str	r3, [r4]
   107f0:	e5900034 	ldr	r0, [r0, #52]
   107f4:	eb000e20 	bl	1407c <fat16_close_file>
   107f8:	e5943000 	ldr	r3, [r4]
   107fc:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   10800:	e3c33030 	bic	r3, r3, #48	; 0x30
   10804:	e5843000 	str	r3, [r4]
   10808:	e8bd4010 	ldmia	sp!, {r4, lr}
   1080c:	e12fff1e 	bx	lr
   10810:	e002c000 	and	ip, r2, r0

00010814 <loadSongInfo>:
   10814:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   10818:	e1a02000 	mov	r2, r0
   1081c:	e1a04000 	mov	r4, r0
   10820:	e3a00000 	mov	r0, #0	; 0x0
   10824:	e5913008 	ldr	r3, [r1, #8]
   10828:	e0813283 	add	r3, r1, r3, lsl #5
   1082c:	e0833000 	add	r3, r3, r0
   10830:	e5d3300c 	ldrb	r3, [r3, #12]
   10834:	e2800001 	add	r0, r0, #1	; 0x1
   10838:	e350001e 	cmp	r0, #30	; 0x1e
   1083c:	e5c23016 	strb	r3, [r2, #22]
   10840:	e2822001 	add	r2, r2, #1	; 0x1
   10844:	1afffff6 	bne	10824 <loadSongInfo+0x10>
   10848:	e1a03004 	mov	r3, r4
   1084c:	e3a01000 	mov	r1, #0	; 0x0
   10850:	e5d32016 	ldrb	r2, [r3, #22]
   10854:	e3510015 	cmp	r1, #21	; 0x15
   10858:	1352002e 	cmpne	r2, #46	; 0x2e
   1085c:	e2833001 	add	r3, r3, #1	; 0x1
   10860:	0a000011 	beq	108ac <loadSongInfo+0x98>
   10864:	e7c12004 	strb	r2, [r1, r4]
   10868:	e2811001 	add	r1, r1, #1	; 0x1
   1086c:	e3510016 	cmp	r1, #22	; 0x16
   10870:	1afffff6 	bne	10850 <loadSongInfo+0x3c>
   10874:	e59f607c 	ldr	r6, [pc, #124]	; 108f8 <.text+0x8f8>
   10878:	e5963000 	ldr	r3, [r6]
   1087c:	e2845016 	add	r5, r4, #22	; 0x16
   10880:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   10884:	e1a00005 	mov	r0, r5
   10888:	e5863000 	str	r3, [r6]
   1088c:	eb000539 	bl	11d78 <root_file_exists>
   10890:	e3500000 	cmp	r0, #0	; 0x0
   10894:	1a000007 	bne	108b8 <loadSongInfo+0xa4>
   10898:	e5963000 	ldr	r3, [r6]
   1089c:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   108a0:	e3c33030 	bic	r3, r3, #48	; 0x30
   108a4:	e5863000 	str	r3, [r6]
   108a8:	ea000010 	b	108f0 <loadSongInfo+0xdc>
   108ac:	e3a03000 	mov	r3, #0	; 0x0
   108b0:	e7c43001 	strb	r3, [r4, r1]
   108b4:	eaffffee 	b	10874 <loadSongInfo+0x60>
   108b8:	e1a00005 	mov	r0, r5
   108bc:	eb0005f7 	bl	120a0 <root_open>
   108c0:	e5840034 	str	r0, [r4, #52]
   108c4:	eb000b90 	bl	1370c <fat16_file_size>
   108c8:	e284103d 	add	r1, r4, #61	; 0x3d
   108cc:	e5840038 	str	r0, [r4, #56]
   108d0:	e3a02020 	mov	r2, #32	; 0x20
   108d4:	e5940034 	ldr	r0, [r4, #52]
   108d8:	eb000aa8 	bl	13380 <fat16_read_file>
   108dc:	e5963000 	ldr	r3, [r6]
   108e0:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   108e4:	e3c33030 	bic	r3, r3, #48	; 0x30
   108e8:	e5863000 	str	r3, [r6]
   108ec:	e3a00001 	mov	r0, #1	; 0x1
   108f0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   108f4:	e12fff1e 	bx	lr
   108f8:	e002c000 	and	ip, r2, r0

000108fc <handleMiddleButton>:
   108fc:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10900:	e3a03010 	mov	r3, #16	; 0x10
   10904:	e59f8770 	ldr	r8, [pc, #1904]	; 1107c <.text+0x107c>
   10908:	e3e05000 	mvn	r5, #0	; 0x0
   1090c:	e5053feb 	str	r3, [r5, #-4075]
   10910:	e24dd008 	sub	sp, sp, #8	; 0x8
   10914:	e3a000fa 	mov	r0, #250	; 0xfa
   10918:	ebfffe1d 	bl	10194 <delay_ms>
   1091c:	e5986000 	ldr	r6, [r8]
   10920:	e59f3758 	ldr	r3, [pc, #1880]	; 11080 <.text+0x1080>
   10924:	e1560003 	cmp	r6, r3
   10928:	e59f4754 	ldr	r4, [pc, #1876]	; 11084 <.text+0x1084>
   1092c:	1a000065 	bne	10ac8 <handleMiddleButton+0x1cc>
   10930:	e5d47000 	ldrb	r7, [r4]
   10934:	e3570000 	cmp	r7, #0	; 0x0
   10938:	1a000043 	bne	10a4c <handleMiddleButton+0x150>
   1093c:	e59f0744 	ldr	r0, [pc, #1860]	; 11088 <.text+0x1088>
   10940:	e1a01006 	mov	r1, r6
   10944:	ebffffb2 	bl	10814 <loadSongInfo>
   10948:	e3500000 	cmp	r0, #0	; 0x0
   1094c:	e1a05000 	mov	r5, r0
   10950:	e5c40000 	strb	r0, [r4]
   10954:	1a000012 	bne	109a4 <handleMiddleButton+0xa8>
   10958:	e59f372c 	ldr	r3, [pc, #1836]	; 1108c <.text+0x108c>
   1095c:	e5d30000 	ldrb	r0, [r3]
   10960:	eb001022 	bl	149f0 <LCDClear>
   10964:	e58d5000 	str	r5, [sp]
   10968:	e5983000 	ldr	r3, [r8]
   1096c:	e59f471c 	ldr	r4, [pc, #1820]	; 11090 <.text+0x1090>
   10970:	e5d3c002 	ldrb	ip, [r3, #2]
   10974:	e5d42000 	ldrb	r2, [r4]
   10978:	e1a01005 	mov	r1, r5
   1097c:	e3a03001 	mov	r3, #1	; 0x1
   10980:	e59f070c 	ldr	r0, [pc, #1804]	; 11094 <.text+0x1094>
   10984:	e58dc004 	str	ip, [sp, #4]
   10988:	eb0010d6 	bl	14ce8 <LCDPrintString>
   1098c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
   10990:	ebfffdff 	bl	10194 <delay_ms>
   10994:	e5d40000 	ldrb	r0, [r4]
   10998:	eb001014 	bl	149f0 <LCDClear>
   1099c:	e1a00006 	mov	r0, r6
   109a0:	ea0001ad 	b	1105c <handleMiddleButton+0x760>
   109a4:	eb001251 	bl	152f0 <vs1002Config>
   109a8:	e1a00007 	mov	r0, r7
   109ac:	e3a01b02 	mov	r1, #2048	; 0x800
   109b0:	eb001298 	bl	15418 <vs1002SCIWrite>
   109b4:	eb001257 	bl	15318 <vs1002Finish>
   109b8:	e59f36d8 	ldr	r3, [pc, #1752]	; 11098 <.text+0x1098>
   109bc:	e3a02202 	mov	r2, #536870912	; 0x20000000
   109c0:	e583200c 	str	r2, [r3, #12]
   109c4:	eb001249 	bl	152f0 <vs1002Config>
   109c8:	ea00000b 	b	109fc <handleMiddleButton+0x100>
   109cc:	eb001264 	bl	15364 <vs1002SendMusic>
   109d0:	e59f36b0 	ldr	r3, [pc, #1712]	; 11088 <.text+0x1088>
   109d4:	e3a02020 	mov	r2, #32	; 0x20
   109d8:	e283103d 	add	r1, r3, #61	; 0x3d
   109dc:	e5930034 	ldr	r0, [r3, #52]
   109e0:	eb000a66 	bl	13380 <fat16_read_file>
   109e4:	e1a00800 	mov	r0, r0, lsl #16
   109e8:	e3500000 	cmp	r0, #0	; 0x0
   109ec:	e59f26a8 	ldr	r2, [pc, #1704]	; 1109c <.text+0x109c>
   109f0:	d3a03001 	movle	r3, #1	; 0x1
   109f4:	c3a03000 	movgt	r3, #0	; 0x0
   109f8:	e5c23000 	strb	r3, [r2]
   109fc:	e59f4694 	ldr	r4, [pc, #1684]	; 11098 <.text+0x1098>
   10a00:	e5943000 	ldr	r3, [r4]
   10a04:	e3130602 	tst	r3, #2097152	; 0x200000
   10a08:	e59f0690 	ldr	r0, [pc, #1680]	; 110a0 <.text+0x10a0>
   10a0c:	e3a01020 	mov	r1, #32	; 0x20
   10a10:	1affffed 	bne	109cc <handleMiddleButton+0xd0>
   10a14:	eb00123f 	bl	15318 <vs1002Finish>
   10a18:	e59f2684 	ldr	r2, [pc, #1668]	; 110a4 <.text+0x10a4>
   10a1c:	e5923004 	ldr	r3, [r2, #4]
   10a20:	e3833b03 	orr	r3, r3, #3072	; 0xc00
   10a24:	e5823004 	str	r3, [r2, #4]
   10a28:	e3e02000 	mvn	r2, #0	; 0x0
   10a2c:	e5123fef 	ldr	r3, [r2, #-4079]
   10a30:	e3833020 	orr	r3, r3, #32	; 0x20
   10a34:	e5023fef 	str	r3, [r2, #-4079]
   10a38:	e5943008 	ldr	r3, [r4, #8]
   10a3c:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   10a40:	e3833050 	orr	r3, r3, #80	; 0x50
   10a44:	e5843008 	str	r3, [r4, #8]
   10a48:	ea000184 	b	11060 <handleMiddleButton+0x764>
   10a4c:	e3a03020 	mov	r3, #32	; 0x20
   10a50:	e5053feb 	str	r3, [r5, #-4075]
   10a54:	e59f363c 	ldr	r3, [pc, #1596]	; 11098 <.text+0x1098>
   10a58:	e3a02202 	mov	r2, #536870912	; 0x20000000
   10a5c:	e5832004 	str	r2, [r3, #4]
   10a60:	eb001222 	bl	152f0 <vs1002Config>
   10a64:	e3a00000 	mov	r0, #0	; 0x0
   10a68:	e3a01008 	mov	r1, #8	; 0x8
   10a6c:	eb001269 	bl	15418 <vs1002SCIWrite>
   10a70:	e3a04000 	mov	r4, #0	; 0x0
   10a74:	e3a00000 	mov	r0, #0	; 0x0
   10a78:	e2844001 	add	r4, r4, #1	; 0x1
   10a7c:	e1a01000 	mov	r1, r0
   10a80:	eb001264 	bl	15418 <vs1002SCIWrite>
   10a84:	e3540096 	cmp	r4, #150	; 0x96
   10a88:	1afffff9 	bne	10a74 <handleMiddleButton+0x178>
   10a8c:	eb001221 	bl	15318 <vs1002Finish>
   10a90:	e59f2600 	ldr	r2, [pc, #1536]	; 11098 <.text+0x1098>
   10a94:	e5923008 	ldr	r3, [r2, #8]
   10a98:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   10a9c:	e3833050 	orr	r3, r3, #80	; 0x50
   10aa0:	e5823008 	str	r3, [r2, #8]
   10aa4:	e59f05dc 	ldr	r0, [pc, #1500]	; 11088 <.text+0x1088>
   10aa8:	ebffff4b 	bl	107dc <closeSong>
   10aac:	e59f35d0 	ldr	r3, [pc, #1488]	; 11084 <.text+0x1084>
   10ab0:	e3a02000 	mov	r2, #0	; 0x0
   10ab4:	e5c32000 	strb	r2, [r3]
   10ab8:	e2822010 	add	r2, r2, #16	; 0x10
   10abc:	e3e03000 	mvn	r3, #0	; 0x0
   10ac0:	e5032fef 	str	r2, [r3, #-4079]
   10ac4:	ea000165 	b	11060 <handleMiddleButton+0x764>
   10ac8:	e5d43000 	ldrb	r3, [r4]
   10acc:	e3530000 	cmp	r3, #0	; 0x0
   10ad0:	0a000002 	beq	10ae0 <handleMiddleButton+0x1e4>
   10ad4:	e1a00006 	mov	r0, r6
   10ad8:	ebfffe40 	bl	103e0 <quickClear>
   10adc:	ea000002 	b	10aec <handleMiddleButton+0x1f0>
   10ae0:	e59f35c0 	ldr	r3, [pc, #1472]	; 110a8 <.text+0x10a8>
   10ae4:	e5d30004 	ldrb	r0, [r3, #4]
   10ae8:	eb000fc0 	bl	149f0 <LCDClear>
   10aec:	e59f7588 	ldr	r7, [pc, #1416]	; 1107c <.text+0x107c>
   10af0:	e5973000 	ldr	r3, [r7]
   10af4:	e3a05000 	mov	r5, #0	; 0x0
   10af8:	e5930008 	ldr	r0, [r3, #8]
   10afc:	e5d32003 	ldrb	r2, [r3, #3]
   10b00:	e58d5000 	str	r5, [sp]
   10b04:	e1a00280 	mov	r0, r0, lsl #5
   10b08:	e5d3c002 	ldrb	ip, [r3, #2]
   10b0c:	e280000c 	add	r0, r0, #12	; 0xc
   10b10:	e0830000 	add	r0, r3, r0
   10b14:	e3e06000 	mvn	r6, #0	; 0x0
   10b18:	e3a03001 	mov	r3, #1	; 0x1
   10b1c:	e1a01005 	mov	r1, r5
   10b20:	e58dc004 	str	ip, [sp, #4]
   10b24:	eb00106f 	bl	14ce8 <LCDPrintString>
   10b28:	e5163fef 	ldr	r3, [r6, #-4079]
   10b2c:	e3833010 	orr	r3, r3, #16	; 0x10
   10b30:	e5063fef 	str	r3, [r6, #-4079]
   10b34:	e5972000 	ldr	r2, [r7]
   10b38:	e5d24000 	ldrb	r4, [r2]
   10b3c:	e3540001 	cmp	r4, #1	; 0x1
   10b40:	1a00005b 	bne	10cb4 <handleMiddleButton+0x3b8>
   10b44:	e5163fef 	ldr	r3, [r6, #-4079]
   10b48:	e3833010 	orr	r3, r3, #16	; 0x10
   10b4c:	e5063fef 	str	r3, [r6, #-4079]
   10b50:	e1a01005 	mov	r1, r5
   10b54:	e5d23002 	ldrb	r3, [r2, #2]
   10b58:	e3a00002 	mov	r0, #2	; 0x2
   10b5c:	e5d22004 	ldrb	r2, [r2, #4]
   10b60:	eb001132 	bl	15030 <LCDSetRowColor>
   10b64:	e58d5000 	str	r5, [sp]
   10b68:	e59f351c 	ldr	r3, [pc, #1308]	; 1108c <.text+0x108c>
   10b6c:	e5971000 	ldr	r1, [r7]
   10b70:	e5d32000 	ldrb	r2, [r3]
   10b74:	e59f3530 	ldr	r3, [pc, #1328]	; 110ac <.text+0x10ac>
   10b78:	e5d1c002 	ldrb	ip, [r1, #2]
   10b7c:	e59f052c 	ldr	r0, [pc, #1324]	; 110b0 <.text+0x10b0>
   10b80:	e5931000 	ldr	r1, [r3]
   10b84:	e3a03002 	mov	r3, #2	; 0x2
   10b88:	e58dc004 	str	ip, [sp, #4]
   10b8c:	eb001055 	bl	14ce8 <LCDPrintString>
   10b90:	ea00003f 	b	10c94 <handleMiddleButton+0x398>
   10b94:	e3a02010 	mov	r2, #16	; 0x10
   10b98:	e3e03000 	mvn	r3, #0	; 0x0
   10b9c:	e5032feb 	str	r2, [r3, #-4075]
   10ba0:	ebfffd7b 	bl	10194 <delay_ms>
   10ba4:	e3540002 	cmp	r4, #2	; 0x2
   10ba8:	1a000017 	bne	10c0c <handleMiddleButton+0x310>
   10bac:	e5953000 	ldr	r3, [r5]
   10bb0:	e353001f 	cmp	r3, #31	; 0x1f
   10bb4:	e2832001 	add	r2, r3, #1	; 0x1
   10bb8:	ca000004 	bgt	10bd0 <handleMiddleButton+0x2d4>
   10bbc:	e5852000 	str	r2, [r5]
   10bc0:	eb0011ca 	bl	152f0 <vs1002Config>
   10bc4:	e3a00031 	mov	r0, #49	; 0x31
   10bc8:	eb00124e 	bl	15508 <vs1002SetVolume>
   10bcc:	eb0011d1 	bl	15318 <vs1002Finish>
   10bd0:	e5962000 	ldr	r2, [r6]
   10bd4:	e1a00004 	mov	r0, r4
   10bd8:	e5d23002 	ldrb	r3, [r2, #2]
   10bdc:	e3a01000 	mov	r1, #0	; 0x0
   10be0:	e5d22004 	ldrb	r2, [r2, #4]
   10be4:	eb001111 	bl	15030 <LCDSetRowColor>
   10be8:	e5961000 	ldr	r1, [r6]
   10bec:	e3a03000 	mov	r3, #0	; 0x0
   10bf0:	e5d12003 	ldrb	r2, [r1, #3]
   10bf4:	e58d3000 	str	r3, [sp]
   10bf8:	e59f04b0 	ldr	r0, [pc, #1200]	; 110b0 <.text+0x10b0>
   10bfc:	e5d1c002 	ldrb	ip, [r1, #2]
   10c00:	e5951000 	ldr	r1, [r5]
   10c04:	e1a03004 	mov	r3, r4
   10c08:	ea00001b 	b	10c7c <handleMiddleButton+0x380>
   10c0c:	e3540001 	cmp	r4, #1	; 0x1
   10c10:	e59f6464 	ldr	r6, [pc, #1124]	; 1107c <.text+0x107c>
   10c14:	e59f5490 	ldr	r5, [pc, #1168]	; 110ac <.text+0x10ac>
   10c18:	1a000019 	bne	10c84 <handleMiddleButton+0x388>
   10c1c:	e5953000 	ldr	r3, [r5]
   10c20:	e3530000 	cmp	r3, #0	; 0x0
   10c24:	e2432001 	sub	r2, r3, #1	; 0x1
   10c28:	ba000004 	blt	10c40 <handleMiddleButton+0x344>
   10c2c:	e5852000 	str	r2, [r5]
   10c30:	eb0011ae 	bl	152f0 <vs1002Config>
   10c34:	e3a00030 	mov	r0, #48	; 0x30
   10c38:	eb001232 	bl	15508 <vs1002SetVolume>
   10c3c:	eb0011b5 	bl	15318 <vs1002Finish>
   10c40:	e5962000 	ldr	r2, [r6]
   10c44:	e3a00002 	mov	r0, #2	; 0x2
   10c48:	e5d23002 	ldrb	r3, [r2, #2]
   10c4c:	e3a01000 	mov	r1, #0	; 0x0
   10c50:	e5d22004 	ldrb	r2, [r2, #4]
   10c54:	eb0010f5 	bl	15030 <LCDSetRowColor>
   10c58:	e3a03000 	mov	r3, #0	; 0x0
   10c5c:	e58d3000 	str	r3, [sp]
   10c60:	e5961000 	ldr	r1, [r6]
   10c64:	e59f3420 	ldr	r3, [pc, #1056]	; 1108c <.text+0x108c>
   10c68:	e5d1c002 	ldrb	ip, [r1, #2]
   10c6c:	e59f043c 	ldr	r0, [pc, #1084]	; 110b0 <.text+0x10b0>
   10c70:	e5951000 	ldr	r1, [r5]
   10c74:	e5d32000 	ldrb	r2, [r3]
   10c78:	e3a03002 	mov	r3, #2	; 0x2
   10c7c:	e58dc004 	str	ip, [sp, #4]
   10c80:	eb001018 	bl	14ce8 <LCDPrintString>
   10c84:	e3e02000 	mvn	r2, #0	; 0x0
   10c88:	e5123fef 	ldr	r3, [r2, #-4079]
   10c8c:	e3833010 	orr	r3, r3, #16	; 0x10
   10c90:	e5023fef 	str	r3, [r2, #-4079]
   10c94:	e59f3418 	ldr	r3, [pc, #1048]	; 110b4 <.text+0x10b4>
   10c98:	e5d34000 	ldrb	r4, [r3]
   10c9c:	e3540002 	cmp	r4, #2	; 0x2
   10ca0:	e59f63d4 	ldr	r6, [pc, #980]	; 1107c <.text+0x107c>
   10ca4:	e59f5400 	ldr	r5, [pc, #1024]	; 110ac <.text+0x10ac>
   10ca8:	e3a00096 	mov	r0, #150	; 0x96
   10cac:	9affffb8 	bls	10b94 <handleMiddleButton+0x298>
   10cb0:	ea0000dc 	b	11028 <handleMiddleButton+0x72c>
   10cb4:	e3540003 	cmp	r4, #3	; 0x3
   10cb8:	1a000064 	bne	10e50 <handleMiddleButton+0x554>
   10cbc:	e5d23002 	ldrb	r3, [r2, #2]
   10cc0:	e3a00002 	mov	r0, #2	; 0x2
   10cc4:	e3a01000 	mov	r1, #0	; 0x0
   10cc8:	e5d22004 	ldrb	r2, [r2, #4]
   10ccc:	eb0010d7 	bl	15030 <LCDSetRowColor>
   10cd0:	e58d5000 	str	r5, [sp]
   10cd4:	e59f33b0 	ldr	r3, [pc, #944]	; 1108c <.text+0x108c>
   10cd8:	e5971000 	ldr	r1, [r7]
   10cdc:	e5d32000 	ldrb	r2, [r3]
   10ce0:	e59f33d0 	ldr	r3, [pc, #976]	; 110b8 <.text+0x10b8>
   10ce4:	e5d1c002 	ldrb	ip, [r1, #2]
   10ce8:	e59f03c0 	ldr	r0, [pc, #960]	; 110b0 <.text+0x10b0>
   10cec:	e5931000 	ldr	r1, [r3]
   10cf0:	e3a03002 	mov	r3, #2	; 0x2
   10cf4:	e58dc004 	str	ip, [sp, #4]
   10cf8:	eb000ffa 	bl	14ce8 <LCDPrintString>
   10cfc:	e5163fef 	ldr	r3, [r6, #-4079]
   10d00:	e3833010 	orr	r3, r3, #16	; 0x10
   10d04:	e5063fef 	str	r3, [r6, #-4079]
   10d08:	e59f33a4 	ldr	r3, [pc, #932]	; 110b4 <.text+0x10b4>
   10d0c:	e5c35000 	strb	r5, [r3]
   10d10:	e3a02010 	mov	r2, #16	; 0x10
   10d14:	e3e03000 	mvn	r3, #0	; 0x0
   10d18:	e3a00064 	mov	r0, #100	; 0x64
   10d1c:	e5032feb 	str	r2, [r3, #-4075]
   10d20:	ebfffd1b 	bl	10194 <delay_ms>
   10d24:	e3550002 	cmp	r5, #2	; 0x2
   10d28:	e59f634c 	ldr	r6, [pc, #844]	; 1107c <.text+0x107c>
   10d2c:	e59f4384 	ldr	r4, [pc, #900]	; 110b8 <.text+0x10b8>
   10d30:	e1a00005 	mov	r0, r5
   10d34:	e3a01000 	mov	r1, #0	; 0x0
   10d38:	1a000012 	bne	10d88 <handleMiddleButton+0x48c>
   10d3c:	e5942000 	ldr	r2, [r4]
   10d40:	e59f3374 	ldr	r3, [pc, #884]	; 110bc <.text+0x10bc>
   10d44:	e1520003 	cmp	r2, r3
   10d48:	e2822002 	add	r2, r2, #2	; 0x2
   10d4c:	e596c000 	ldr	ip, [r6]
   10d50:	d5842000 	strle	r2, [r4]
   10d54:	e5dc3002 	ldrb	r3, [ip, #2]
   10d58:	e5dc2004 	ldrb	r2, [ip, #4]
   10d5c:	eb0010b3 	bl	15030 <LCDSetRowColor>
   10d60:	e3a03000 	mov	r3, #0	; 0x0
   10d64:	e58d3000 	str	r3, [sp]
   10d68:	e59f331c 	ldr	r3, [pc, #796]	; 1108c <.text+0x108c>
   10d6c:	e5961000 	ldr	r1, [r6]
   10d70:	e5d32000 	ldrb	r2, [r3]
   10d74:	e5d1c002 	ldrb	ip, [r1, #2]
   10d78:	e59f0330 	ldr	r0, [pc, #816]	; 110b0 <.text+0x10b0>
   10d7c:	e5941000 	ldr	r1, [r4]
   10d80:	e1a03005 	mov	r3, r5
   10d84:	ea000017 	b	10de8 <handleMiddleButton+0x4ec>
   10d88:	e3550001 	cmp	r5, #1	; 0x1
   10d8c:	e59f62e8 	ldr	r6, [pc, #744]	; 1107c <.text+0x107c>
   10d90:	e3a00002 	mov	r0, #2	; 0x2
   10d94:	e3a01000 	mov	r1, #0	; 0x0
   10d98:	e59f4318 	ldr	r4, [pc, #792]	; 110b8 <.text+0x10b8>
   10d9c:	1a000013 	bne	10df0 <handleMiddleButton+0x4f4>
   10da0:	e5942000 	ldr	r2, [r4]
   10da4:	e59f3314 	ldr	r3, [pc, #788]	; 110c0 <.text+0x10c0>
   10da8:	e1520003 	cmp	r2, r3
   10dac:	e2422002 	sub	r2, r2, #2	; 0x2
   10db0:	e596c000 	ldr	ip, [r6]
   10db4:	c5842000 	strgt	r2, [r4]
   10db8:	e5dc3002 	ldrb	r3, [ip, #2]
   10dbc:	e5dc2004 	ldrb	r2, [ip, #4]
   10dc0:	eb00109a 	bl	15030 <LCDSetRowColor>
   10dc4:	e3a03000 	mov	r3, #0	; 0x0
   10dc8:	e58d3000 	str	r3, [sp]
   10dcc:	e5961000 	ldr	r1, [r6]
   10dd0:	e59f32b4 	ldr	r3, [pc, #692]	; 1108c <.text+0x108c>
   10dd4:	e5d1c002 	ldrb	ip, [r1, #2]
   10dd8:	e59f02d0 	ldr	r0, [pc, #720]	; 110b0 <.text+0x10b0>
   10ddc:	e5941000 	ldr	r1, [r4]
   10de0:	e5d32000 	ldrb	r2, [r3]
   10de4:	e3a03002 	mov	r3, #2	; 0x2
   10de8:	e58dc004 	str	ip, [sp, #4]
   10dec:	eb000fbd 	bl	14ce8 <LCDPrintString>
   10df0:	e59f62c0 	ldr	r6, [pc, #704]	; 110b8 <.text+0x10b8>
   10df4:	e5960000 	ldr	r0, [r6]
   10df8:	eb00125a 	bl	15768 <ns73SetChannel>
   10dfc:	e59f32b0 	ldr	r3, [pc, #688]	; 110b4 <.text+0x10b4>
   10e00:	e3e02000 	mvn	r2, #0	; 0x0
   10e04:	e5d35000 	ldrb	r5, [r3]
   10e08:	e5123fef 	ldr	r3, [r2, #-4079]
   10e0c:	e3550002 	cmp	r5, #2	; 0x2
   10e10:	e3833010 	orr	r3, r3, #16	; 0x10
   10e14:	e5023fef 	str	r3, [r2, #-4079]
   10e18:	9affffbc 	bls	10d10 <handleMiddleButton+0x414>
   10e1c:	e59f4274 	ldr	r4, [pc, #628]	; 11098 <.text+0x1098>
   10e20:	e594301c 	ldr	r3, [r4, #28]
   10e24:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   10e28:	e584301c 	str	r3, [r4, #28]
   10e2c:	e3a00064 	mov	r0, #100	; 0x64
   10e30:	ebfffcd7 	bl	10194 <delay_ms>
   10e34:	eb00127d 	bl	15830 <ns73Config>
   10e38:	e5960000 	ldr	r0, [r6]
   10e3c:	eb001249 	bl	15768 <ns73SetChannel>
   10e40:	e5943014 	ldr	r3, [r4, #20]
   10e44:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   10e48:	e5843014 	str	r3, [r4, #20]
   10e4c:	ea000075 	b	11028 <handleMiddleButton+0x72c>
   10e50:	e3540002 	cmp	r4, #2	; 0x2
   10e54:	1a000073 	bne	11028 <handleMiddleButton+0x72c>
   10e58:	e5d23002 	ldrb	r3, [r2, #2]
   10e5c:	e3a01000 	mov	r1, #0	; 0x0
   10e60:	e1a00004 	mov	r0, r4
   10e64:	e5d22004 	ldrb	r2, [r2, #4]
   10e68:	eb001070 	bl	15030 <LCDSetRowColor>
   10e6c:	e59f3250 	ldr	r3, [pc, #592]	; 110c4 <.text+0x10c4>
   10e70:	e5d33000 	ldrb	r3, [r3]
   10e74:	e3530000 	cmp	r3, #0	; 0x0
   10e78:	e5971000 	ldr	r1, [r7]
   10e7c:	0a000006 	beq	10e9c <handleMiddleButton+0x5a0>
   10e80:	e5d12003 	ldrb	r2, [r1, #3]
   10e84:	e58d5000 	str	r5, [sp]
   10e88:	e59f0238 	ldr	r0, [pc, #568]	; 110c8 <.text+0x10c8>
   10e8c:	e5d1c002 	ldrb	ip, [r1, #2]
   10e90:	e1a03004 	mov	r3, r4
   10e94:	e1a01005 	mov	r1, r5
   10e98:	ea000005 	b	10eb4 <handleMiddleButton+0x5b8>
   10e9c:	e5d12003 	ldrb	r2, [r1, #3]
   10ea0:	e58d3000 	str	r3, [sp]
   10ea4:	e59f0220 	ldr	r0, [pc, #544]	; 110cc <.text+0x10cc>
   10ea8:	e5d1c002 	ldrb	ip, [r1, #2]
   10eac:	e1a01003 	mov	r1, r3
   10eb0:	e1a03004 	mov	r3, r4
   10eb4:	e58dc004 	str	ip, [sp, #4]
   10eb8:	eb000f8a 	bl	14ce8 <LCDPrintString>
   10ebc:	e3e02000 	mvn	r2, #0	; 0x0
   10ec0:	e5123fef 	ldr	r3, [r2, #-4079]
   10ec4:	e3833010 	orr	r3, r3, #16	; 0x10
   10ec8:	e5023fef 	str	r3, [r2, #-4079]
   10ecc:	e59f31e0 	ldr	r3, [pc, #480]	; 110b4 <.text+0x10b4>
   10ed0:	e3a01000 	mov	r1, #0	; 0x0
   10ed4:	e5c31000 	strb	r1, [r3]
   10ed8:	e1a05001 	mov	r5, r1
   10edc:	e3a02010 	mov	r2, #16	; 0x10
   10ee0:	e3e03000 	mvn	r3, #0	; 0x0
   10ee4:	e3a00064 	mov	r0, #100	; 0x64
   10ee8:	e5032feb 	str	r2, [r3, #-4075]
   10eec:	ebfffca8 	bl	10194 <delay_ms>
   10ef0:	e3a06000 	mov	r6, #0	; 0x0
   10ef4:	e3550002 	cmp	r5, #2	; 0x2
   10ef8:	e59f717c 	ldr	r7, [pc, #380]	; 1107c <.text+0x107c>
   10efc:	e59f4194 	ldr	r4, [pc, #404]	; 11098 <.text+0x1098>
   10f00:	e1a00005 	mov	r0, r5
   10f04:	e1a01006 	mov	r1, r6
   10f08:	1a00001c 	bne	10f80 <handleMiddleButton+0x684>
   10f0c:	e59f31b0 	ldr	r3, [pc, #432]	; 110c4 <.text+0x10c4>
   10f10:	e3a02001 	mov	r2, #1	; 0x1
   10f14:	e5c32000 	strb	r2, [r3]
   10f18:	e5972000 	ldr	r2, [r7]
   10f1c:	e5d23002 	ldrb	r3, [r2, #2]
   10f20:	e5d22004 	ldrb	r2, [r2, #4]
   10f24:	eb001041 	bl	15030 <LCDSetRowColor>
   10f28:	e5973000 	ldr	r3, [r7]
   10f2c:	e5d32003 	ldrb	r2, [r3, #3]
   10f30:	e58d6000 	str	r6, [sp]
   10f34:	e5d3c002 	ldrb	ip, [r3, #2]
   10f38:	e1a01006 	mov	r1, r6
   10f3c:	e1a03005 	mov	r3, r5
   10f40:	e59f0180 	ldr	r0, [pc, #384]	; 110c8 <.text+0x10c8>
   10f44:	e58dc004 	str	ip, [sp, #4]
   10f48:	eb000f66 	bl	14ce8 <LCDPrintString>
   10f4c:	e594301c 	ldr	r3, [r4, #28]
   10f50:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   10f54:	e584301c 	str	r3, [r4, #28]
   10f58:	e3a00064 	mov	r0, #100	; 0x64
   10f5c:	ebfffc8c 	bl	10194 <delay_ms>
   10f60:	eb001232 	bl	15830 <ns73Config>
   10f64:	e1a00006 	mov	r0, r6
   10f68:	e3a01081 	mov	r1, #129	; 0x81
   10f6c:	eb0011ba 	bl	1565c <ns73Send>
   10f70:	e5943014 	ldr	r3, [r4, #20]
   10f74:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   10f78:	e5843014 	str	r3, [r4, #20]
   10f7c:	ea000021 	b	11008 <handleMiddleButton+0x70c>
   10f80:	e3a04000 	mov	r4, #0	; 0x0
   10f84:	e3550001 	cmp	r5, #1	; 0x1
   10f88:	e59f70ec 	ldr	r7, [pc, #236]	; 1107c <.text+0x107c>
   10f8c:	e3a00002 	mov	r0, #2	; 0x2
   10f90:	e1a01004 	mov	r1, r4
   10f94:	e59f60fc 	ldr	r6, [pc, #252]	; 11098 <.text+0x1098>
   10f98:	1a00001a 	bne	11008 <handleMiddleButton+0x70c>
   10f9c:	e59f3120 	ldr	r3, [pc, #288]	; 110c4 <.text+0x10c4>
   10fa0:	e5972000 	ldr	r2, [r7]
   10fa4:	e5c34000 	strb	r4, [r3]
   10fa8:	e5d23002 	ldrb	r3, [r2, #2]
   10fac:	e5d22004 	ldrb	r2, [r2, #4]
   10fb0:	eb00101e 	bl	15030 <LCDSetRowColor>
   10fb4:	e5973000 	ldr	r3, [r7]
   10fb8:	e5d32003 	ldrb	r2, [r3, #3]
   10fbc:	e58d4000 	str	r4, [sp]
   10fc0:	e5d3c002 	ldrb	ip, [r3, #2]
   10fc4:	e1a01004 	mov	r1, r4
   10fc8:	e3a03002 	mov	r3, #2	; 0x2
   10fcc:	e59f00f8 	ldr	r0, [pc, #248]	; 110cc <.text+0x10cc>
   10fd0:	e58dc004 	str	ip, [sp, #4]
   10fd4:	eb000f43 	bl	14ce8 <LCDPrintString>
   10fd8:	e596301c 	ldr	r3, [r6, #28]
   10fdc:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   10fe0:	e586301c 	str	r3, [r6, #28]
   10fe4:	e3a00064 	mov	r0, #100	; 0x64
   10fe8:	ebfffc69 	bl	10194 <delay_ms>
   10fec:	eb00120f 	bl	15830 <ns73Config>
   10ff0:	e1a00004 	mov	r0, r4
   10ff4:	e3a01004 	mov	r1, #4	; 0x4
   10ff8:	eb001197 	bl	1565c <ns73Send>
   10ffc:	e5963014 	ldr	r3, [r6, #20]
   11000:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11004:	e5863014 	str	r3, [r6, #20]
   11008:	e59f30a4 	ldr	r3, [pc, #164]	; 110b4 <.text+0x10b4>
   1100c:	e3e02000 	mvn	r2, #0	; 0x0
   11010:	e5d35000 	ldrb	r5, [r3]
   11014:	e5123fef 	ldr	r3, [r2, #-4079]
   11018:	e3550002 	cmp	r5, #2	; 0x2
   1101c:	e3833010 	orr	r3, r3, #16	; 0x10
   11020:	e5023fef 	str	r3, [r2, #-4079]
   11024:	9affffac 	bls	10edc <handleMiddleButton+0x5e0>
   11028:	e59f3054 	ldr	r3, [pc, #84]	; 11084 <.text+0x1084>
   1102c:	e5d33000 	ldrb	r3, [r3]
   11030:	e3530000 	cmp	r3, #0	; 0x0
   11034:	e59f0040 	ldr	r0, [pc, #64]	; 1107c <.text+0x107c>
   11038:	0a000002 	beq	11048 <handleMiddleButton+0x74c>
   1103c:	e5900000 	ldr	r0, [r0]
   11040:	ebfffce6 	bl	103e0 <quickClear>
   11044:	ea000002 	b	11054 <handleMiddleButton+0x758>
   11048:	e5903000 	ldr	r3, [r0]
   1104c:	e5d30004 	ldrb	r0, [r3, #4]
   11050:	eb000e66 	bl	149f0 <LCDClear>
   11054:	e59f3020 	ldr	r3, [pc, #32]	; 1107c <.text+0x107c>
   11058:	e5930000 	ldr	r0, [r3]
   1105c:	ebfffd13 	bl	104b0 <printMenu>
   11060:	e3e02000 	mvn	r2, #0	; 0x0
   11064:	e5123fef 	ldr	r3, [r2, #-4079]
   11068:	e3833010 	orr	r3, r3, #16	; 0x10
   1106c:	e5023fef 	str	r3, [r2, #-4079]
   11070:	e28dd008 	add	sp, sp, #8	; 0x8
   11074:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   11078:	e12fff1e 	bx	lr
   1107c:	40000d10 	andmi	r0, r0, r0, lsl sp
   11080:	40000908 	andmi	r0, r0, r8, lsl #18
   11084:	40000895 	mulmi	r0, r5, r8
   11088:	400008a8 	andmi	r0, r0, r8, lsr #17
   1108c:	40000f28 	andmi	r0, r0, r8, lsr #30
   11090:	40000009 	andmi	r0, r0, r9
   11094:	000182e8 	andeq	r8, r1, r8, ror #5
   11098:	e0028000 	and	r8, r2, r0
   1109c:	40000896 	mulmi	r0, r6, r8
   110a0:	400008e5 	andmi	r0, r0, r5, ror #17
   110a4:	e002c000 	and	ip, r2, r0
   110a8:	40000b0c 	andmi	r0, r0, ip, lsl #22
   110ac:	40000000 	andmi	r0, r0, r0
   110b0:	000189c0 	andeq	r8, r1, r0, asr #19
   110b4:	4000089c 	mulmi	r0, ip, r8
   110b8:	40000004 	andmi	r0, r0, r4
   110bc:	00000432 	andeq	r0, r0, r2, lsr r4
   110c0:	00000375 	andeq	r0, r0, r5, ror r3
   110c4:	40000894 	mulmi	r0, r4, r8
   110c8:	000189c4 	andeq	r8, r1, r4, asr #19
   110cc:	000189c8 	andeq	r8, r1, r8, asr #19

000110d0 <bootUp>:
   110d0:	e52de004 	str	lr, [sp, #-4]!
   110d4:	e59f01a0 	ldr	r0, [pc, #416]	; 1127c <.text+0x127c>
   110d8:	eb00021c 	bl	11950 <rprintf_devopen>
   110dc:	e3a0000a 	mov	r0, #10	; 0xa
   110e0:	ebfffc2b 	bl	10194 <delay_ms>
   110e4:	eb000660 	bl	12a6c <sd_raw_init>
   110e8:	e3500000 	cmp	r0, #0	; 0x0
   110ec:	059f018c 	ldreq	r0, [pc, #396]	; 11280 <.text+0x1280>
   110f0:	0b00022a 	bleq	119a0 <rprintf>
   110f4:	eb000406 	bl	12114 <openroot>
   110f8:	e3500000 	cmp	r0, #0	; 0x0
   110fc:	159f0180 	ldrne	r0, [pc, #384]	; 11284 <.text+0x1284>
   11100:	1b000226 	blne	119a0 <rprintf>
   11104:	e59f217c 	ldr	r2, [pc, #380]	; 11288 <.text+0x1288>
   11108:	e5923008 	ldr	r3, [r2, #8]
   1110c:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   11110:	e5823008 	str	r3, [r2, #8]
   11114:	e5923008 	ldr	r3, [r2, #8]
   11118:	e3c33602 	bic	r3, r3, #2097152	; 0x200000
   1111c:	e5823008 	str	r3, [r2, #8]
   11120:	e59f1164 	ldr	r1, [pc, #356]	; 1128c <.text+0x128c>
   11124:	e5913004 	ldr	r3, [r1, #4]
   11128:	e3833b03 	orr	r3, r3, #3072	; 0xc00
   1112c:	e5813004 	str	r3, [r1, #4]
   11130:	e5923018 	ldr	r3, [r2, #24]
   11134:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   11138:	e3833803 	orr	r3, r3, #196608	; 0x30000
   1113c:	e5823018 	str	r3, [r2, #24]
   11140:	e5923018 	ldr	r3, [r2, #24]
   11144:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
   11148:	e5823018 	str	r3, [r2, #24]
   1114c:	e5923018 	ldr	r3, [r2, #24]
   11150:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   11154:	e5823018 	str	r3, [r2, #24]
   11158:	e5923008 	ldr	r3, [r2, #8]
   1115c:	e3833080 	orr	r3, r3, #128	; 0x80
   11160:	e5823008 	str	r3, [r2, #8]
   11164:	e5923008 	ldr	r3, [r2, #8]
   11168:	e3833b03 	orr	r3, r3, #3072	; 0xc00
   1116c:	e5823008 	str	r3, [r2, #8]
   11170:	e5913000 	ldr	r3, [r1]
   11174:	e38334cf 	orr	r3, r3, #-822083584	; 0xcf000000
   11178:	e5813000 	str	r3, [r1]
   1117c:	e3a03b03 	mov	r3, #3072	; 0xc00
   11180:	e582300c 	str	r3, [r2, #12]
   11184:	e5923008 	ldr	r3, [r2, #8]
   11188:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   1118c:	e5823008 	str	r3, [r2, #8]
   11190:	e5923008 	ldr	r3, [r2, #8]
   11194:	e3833207 	orr	r3, r3, #1879048192	; 0x70000000
   11198:	e5823008 	str	r3, [r2, #8]
   1119c:	e3a03202 	mov	r3, #536870912	; 0x20000000
   111a0:	e5823004 	str	r3, [r2, #4]
   111a4:	e0833003 	add	r3, r3, r3
   111a8:	e5823004 	str	r3, [r2, #4]
   111ac:	e283320d 	add	r3, r3, #-805306368	; 0xd0000000
   111b0:	e5823004 	str	r3, [r2, #4]
   111b4:	e5923018 	ldr	r3, [r2, #24]
   111b8:	e3c3360e 	bic	r3, r3, #14680064	; 0xe00000
   111bc:	e5823018 	str	r3, [r2, #24]
   111c0:	e5923008 	ldr	r3, [r2, #8]
   111c4:	e3c33502 	bic	r3, r3, #8388608	; 0x800000
   111c8:	e5823008 	str	r3, [r2, #8]
   111cc:	e59f30bc 	ldr	r3, [pc, #188]	; 11290 <.text+0x1290>
   111d0:	e3a02001 	mov	r2, #1	; 0x1
   111d4:	e3e01000 	mvn	r1, #0	; 0x0
   111d8:	e5832100 	str	r2, [r3, #256]
   111dc:	e3e03030 	mvn	r3, #48	; 0x30
   111e0:	e5013ff3 	str	r3, [r1, #-4083]
   111e4:	e2833041 	add	r3, r3, #65	; 0x41
   111e8:	e5013fef 	str	r3, [r1, #-4079]
   111ec:	e2833015 	add	r3, r3, #21	; 0x15
   111f0:	e5013dff 	str	r3, [r1, #-3583]
   111f4:	e59f3098 	ldr	r3, [pc, #152]	; 11294 <.text+0x1294>
   111f8:	e5013eff 	str	r3, [r1, #-3839]
   111fc:	e3a03024 	mov	r3, #36	; 0x24
   11200:	e5013dfb 	str	r3, [r1, #-3579]
   11204:	e59f308c 	ldr	r3, [pc, #140]	; 11298 <.text+0x1298>
   11208:	e59f008c 	ldr	r0, [pc, #140]	; 1129c <.text+0x129c>
   1120c:	e5013efb 	str	r3, [r1, #-3835]
   11210:	e3a03f4b 	mov	r3, #300	; 0x12c
   11214:	e580300c 	str	r3, [r0, #12]
   11218:	e5903004 	ldr	r3, [r0, #4]
   1121c:	e3833001 	orr	r3, r3, #1	; 0x1
   11220:	e5803004 	str	r3, [r0, #4]
   11224:	e3a0c000 	mov	ip, #0	; 0x0
   11228:	e3a03003 	mov	r3, #3	; 0x3
   1122c:	e580c070 	str	ip, [r0, #112]
   11230:	e59f2068 	ldr	r2, [pc, #104]	; 112a0 <.text+0x12a0>
   11234:	e5803014 	str	r3, [r0, #20]
   11238:	e3a03ffa 	mov	r3, #1000	; 0x3e8
   1123c:	e5803018 	str	r3, [r0, #24]
   11240:	e2433e32 	sub	r3, r3, #800	; 0x320
   11244:	e582300c 	str	r3, [r2, #12]
   11248:	e5923004 	ldr	r3, [r2, #4]
   1124c:	e3833001 	orr	r3, r3, #1	; 0x1
   11250:	e5823004 	str	r3, [r2, #4]
   11254:	e59f1048 	ldr	r1, [pc, #72]	; 112a4 <.text+0x12a4>
   11258:	e3a03c0a 	mov	r3, #2560	; 0xa00
   1125c:	e582c070 	str	ip, [r2, #112]
   11260:	e5823028 	str	r3, [r2, #40]
   11264:	e2433d27 	sub	r3, r3, #2496	; 0x9c0
   11268:	e581300c 	str	r3, [r1, #12]
   1126c:	e3a03020 	mov	r3, #32	; 0x20
   11270:	e5813000 	str	r3, [r1]
   11274:	e49de004 	ldr	lr, [sp], #4
   11278:	e12fff1e 	bx	lr
   1127c:	00011cac 	andeq	r1, r1, ip, lsr #25
   11280:	000189cc 	andeq	r8, r1, ip, asr #19
   11284:	000189dc 	ldreqd	r8, [r1], -ip
   11288:	e0028000 	and	r8, r2, r0
   1128c:	e002c000 	and	ip, r2, r0
   11290:	e01fc000 	ands	ip, pc, r0
   11294:	00010754 	andeq	r0, r1, r4, asr r7
   11298:	000112a8 	andeq	r1, r1, r8, lsr #5
   1129c:	e0004000 	and	r4, r0, r0
   112a0:	e0008000 	and	r8, r0, r0
   112a4:	e0020000 	and	r0, r2, r0

000112a8 <timer0ISR>:
   112a8:	e52de004 	str	lr, [sp, #-4]!
   112ac:	ebfffbc2 	bl	101bc <getButton>
   112b0:	e59f3078 	ldr	r3, [pc, #120]	; 11330 <.text+0x1330>
   112b4:	e5c30000 	strb	r0, [r3]
   112b8:	eb000d65 	bl	14854 <MMA_get_y>
   112bc:	e59f3070 	ldr	r3, [pc, #112]	; 11334 <.text+0x1334>
   112c0:	e59f1070 	ldr	r1, [pc, #112]	; 11338 <.text+0x1338>
   112c4:	e5932000 	ldr	r2, [r3]
   112c8:	e59f306c 	ldr	r3, [pc, #108]	; 1133c <.text+0x133c>
   112cc:	e1520001 	cmp	r2, r1
   112d0:	e5830000 	str	r0, [r3]
   112d4:	e59fc064 	ldr	ip, [pc, #100]	; 11340 <.text+0x1340>
   112d8:	ca000002 	bgt	112e8 <timer0ISR+0x40>
   112dc:	e3500faf 	cmp	r0, #700	; 0x2bc
   112e0:	ca000004 	bgt	112f8 <timer0ISR+0x50>
   112e4:	ea000005 	b	11300 <timer0ISR+0x58>
   112e8:	e3520faf 	cmp	r2, #700	; 0x2bc
   112ec:	0a000003 	beq	11300 <timer0ISR+0x58>
   112f0:	e1500001 	cmp	r0, r1
   112f4:	ca000001 	bgt	11300 <timer0ISR+0x58>
   112f8:	e3a03001 	mov	r3, #1	; 0x1
   112fc:	ea000000 	b	11304 <timer0ISR+0x5c>
   11300:	e3a03000 	mov	r3, #0	; 0x0
   11304:	e5cc3000 	strb	r3, [ip]
   11308:	e59f3034 	ldr	r3, [pc, #52]	; 11344 <.text+0x1344>
   1130c:	e3a020ff 	mov	r2, #255	; 0xff
   11310:	e5832000 	str	r2, [r3]
   11314:	e59f3018 	ldr	r3, [pc, #24]	; 11334 <.text+0x1334>
   11318:	e3a02000 	mov	r2, #0	; 0x0
   1131c:	e5830000 	str	r0, [r3]
   11320:	e3e03000 	mvn	r3, #0	; 0x0
   11324:	e5032fcf 	str	r2, [r3, #-4047]
   11328:	e49de004 	ldr	lr, [sp], #4
   1132c:	e12fff1e 	bx	lr
   11330:	4000089c 	mulmi	r0, ip, r8
   11334:	400008a0 	andmi	r0, r0, r0, lsr #17
   11338:	000002bb 	streqh	r0, [r0], -fp
   1133c:	400008a4 	andmi	r0, r0, r4, lsr #17
   11340:	4000089d 	mulmi	r0, sp, r8
   11344:	e0004000 	and	r4, r0, r0

00011348 <main>:
   11348:	e1a0c00d 	mov	ip, sp
   1134c:	e92dddf0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, ip, lr, pc}
   11350:	e24cb004 	sub	fp, ip, #4	; 0x4
   11354:	e24dd008 	sub	sp, sp, #8	; 0x8
   11358:	ebffff5c 	bl	110d0 <bootUp>
   1135c:	eb000fe3 	bl	152f0 <vs1002Config>
   11360:	eb000ff3 	bl	15334 <vs1002Reset>
   11364:	eb001045 	bl	15480 <vs1002Init>
   11368:	e3a04000 	mov	r4, #0	; 0x0
   1136c:	e3a00030 	mov	r0, #48	; 0x30
   11370:	eb001064 	bl	15508 <vs1002SetVolume>
   11374:	e2843001 	add	r3, r4, #1	; 0x1
   11378:	e20340ff 	and	r4, r3, #255	; 0xff
   1137c:	e3540002 	cmp	r4, #2	; 0x2
   11380:	1afffff9 	bne	1136c <main+0x24>
   11384:	eb000fe3 	bl	15318 <vs1002Finish>
   11388:	eb000f5e 	bl	15108 <LCDInit>
   1138c:	e59f350c 	ldr	r3, [pc, #1292]	; 118a0 <.text+0x18a0>
   11390:	e59f450c 	ldr	r4, [pc, #1292]	; 118a4 <.text+0x18a4>
   11394:	e5d30000 	ldrb	r0, [r3]
   11398:	eb000d94 	bl	149f0 <LCDClear>
   1139c:	eb000dd1 	bl	14ae8 <LCDPrintLogo>
   113a0:	e594301c 	ldr	r3, [r4, #28]
   113a4:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   113a8:	e584301c 	str	r3, [r4, #28]
   113ac:	e3a00fe1 	mov	r0, #900	; 0x384
   113b0:	ebfffb77 	bl	10194 <delay_ms>
   113b4:	eb00111d 	bl	15830 <ns73Config>
   113b8:	eb0010fd 	bl	157b4 <ns73Init>
   113bc:	e59f04e4 	ldr	r0, [pc, #1252]	; 118a8 <.text+0x18a8>
   113c0:	eb0010e8 	bl	15768 <ns73SetChannel>
   113c4:	e5943014 	ldr	r3, [r4, #20]
   113c8:	e3833201 	orr	r3, r3, #268435456	; 0x10000000
   113cc:	e5843014 	str	r3, [r4, #20]
   113d0:	e3a00064 	mov	r0, #100	; 0x64
   113d4:	ebfffb6e 	bl	10194 <delay_ms>
   113d8:	e59f24cc 	ldr	r2, [pc, #1228]	; 118ac <.text+0x18ac>
   113dc:	e5923000 	ldr	r3, [r2]
   113e0:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   113e4:	e5823000 	str	r3, [r2]
   113e8:	e3a07000 	mov	r7, #0	; 0x0
   113ec:	e3a00000 	mov	r0, #0	; 0x0
   113f0:	eb0002c2 	bl	11f00 <rootDirectory_files_stream>
   113f4:	e2504000 	subs	r4, r0, #0	; 0x0
   113f8:	e2877001 	add	r7, r7, #1	; 0x1
   113fc:	1afffffa 	bne	113ec <main+0xa4>
   11400:	e2873006 	add	r3, r7, #6	; 0x6
   11404:	e3c33003 	bic	r3, r3, #3	; 0x3
   11408:	e063d00d 	rsb	sp, r3, sp
   1140c:	e28da008 	add	sl, sp, #8	; 0x8
   11410:	e1a0000a 	mov	r0, sl
   11414:	e2871001 	add	r1, r7, #1	; 0x1
   11418:	eb00028c 	bl	11e50 <rootDirectory_files>
   1141c:	e1a03280 	mov	r3, r0, lsl #5
   11420:	e2833004 	add	r3, r3, #4	; 0x4
   11424:	e063d00d 	rsb	sp, r3, sp
   11428:	e28d8008 	add	r8, sp, #8	; 0x8
   1142c:	e59f347c 	ldr	r3, [pc, #1148]	; 118b0 <.text+0x18b0>
   11430:	e1a06000 	mov	r6, r0
   11434:	e1a05004 	mov	r5, r4
   11438:	e1a00004 	mov	r0, r4
   1143c:	e1a0e008 	mov	lr, r8
   11440:	e5836000 	str	r6, [r3]
   11444:	ea000013 	b	11498 <main+0x150>
   11448:	e3a02000 	mov	r2, #0	; 0x0
   1144c:	e1550007 	cmp	r5, r7
   11450:	83a03000 	movhi	r3, #0	; 0x0
   11454:	87ce3002 	strhib	r3, [lr, r2]
   11458:	8a000008 	bhi	11480 <main+0x138>
   1145c:	e7da1005 	ldrb	r1, [sl, r5]
   11460:	e084c008 	add	ip, r4, r8
   11464:	e351002c 	cmp	r1, #44	; 0x2c
   11468:	e1a0300c 	mov	r3, ip
   1146c:	17c31002 	strneb	r1, [r3, r2]
   11470:	03a03000 	moveq	r3, #0	; 0x0
   11474:	07cc3002 	streqb	r3, [ip, r2]
   11478:	e2855001 	add	r5, r5, #1	; 0x1
   1147c:	03a0201f 	moveq	r2, #31	; 0x1f
   11480:	e2822001 	add	r2, r2, #1	; 0x1
   11484:	e352001f 	cmp	r2, #31	; 0x1f
   11488:	daffffef 	ble	1144c <main+0x104>
   1148c:	e2800001 	add	r0, r0, #1	; 0x1
   11490:	e2844020 	add	r4, r4, #32	; 0x20
   11494:	e28ee020 	add	lr, lr, #32	; 0x20
   11498:	e1500006 	cmp	r0, r6
   1149c:	baffffe9 	blt	11448 <main+0x100>
   114a0:	e3a0100f 	mov	r1, #15	; 0xf
   114a4:	e1a00006 	mov	r0, r6
   114a8:	eb001ac8 	bl	17fd0 <__aeabi_idiv>
   114ac:	e59f4400 	ldr	r4, [pc, #1024]	; 118b4 <.text+0x18b4>
   114b0:	e2400001 	sub	r0, r0, #1	; 0x1
   114b4:	e20050ff 	and	r5, r0, #255	; 0xff
   114b8:	e3a0100f 	mov	r1, #15	; 0xf
   114bc:	e1a00006 	mov	r0, r6
   114c0:	e5c45005 	strb	r5, [r4, #5]
   114c4:	eb001b46 	bl	181e4 <__modsi3>
   114c8:	e3500000 	cmp	r0, #0	; 0x0
   114cc:	12853001 	addne	r3, r5, #1	; 0x1
   114d0:	15c43005 	strneb	r3, [r4, #5]
   114d4:	e59f33c4 	ldr	r3, [pc, #964]	; 118a0 <.text+0x18a0>
   114d8:	e5d3c000 	ldrb	ip, [r3]
   114dc:	e59f33d4 	ldr	r3, [pc, #980]	; 118b8 <.text+0x18b8>
   114e0:	e5d33000 	ldrb	r3, [r3]
   114e4:	e3a02000 	mov	r2, #0	; 0x0
   114e8:	e5c43004 	strb	r3, [r4, #4]
   114ec:	e3a03001 	mov	r3, #1	; 0x1
   114f0:	e1a00004 	mov	r0, r4
   114f4:	e1a01008 	mov	r1, r8
   114f8:	e5c4c003 	strb	ip, [r4, #3]
   114fc:	e5c43000 	strb	r3, [r4]
   11500:	e5842008 	str	r2, [r4, #8]
   11504:	e5c42002 	strb	r2, [r4, #2]
   11508:	e5c42006 	strb	r2, [r4, #6]
   1150c:	ebfffb39 	bl	101f8 <getNewFiles>
   11510:	e59f13a4 	ldr	r1, [pc, #932]	; 118bc <.text+0x18bc>
   11514:	e1a00004 	mov	r0, r4
   11518:	e4d12001 	ldrb	r2, [r1], #1
   1151c:	e59f339c 	ldr	r3, [pc, #924]	; 118c0 <.text+0x18c0>
   11520:	e1510003 	cmp	r1, r3
   11524:	e5c021ec 	strb	r2, [r0, #492]
   11528:	e2800001 	add	r0, r0, #1	; 0x1
   1152c:	1afffff9 	bne	11518 <main+0x1d0>
   11530:	e59f038c 	ldr	r0, [pc, #908]	; 118c4 <.text+0x18c4>
   11534:	ebfffb6c 	bl	102ec <fillSettings>
   11538:	e59f136c 	ldr	r1, [pc, #876]	; 118ac <.text+0x18ac>
   1153c:	e5913000 	ldr	r3, [r1]
   11540:	e59f236c 	ldr	r2, [pc, #876]	; 118b4 <.text+0x18b4>
   11544:	e59f437c 	ldr	r4, [pc, #892]	; 118c8 <.text+0x18c8>
   11548:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   1154c:	e3c33030 	bic	r3, r3, #48	; 0x30
   11550:	e5d20004 	ldrb	r0, [r2, #4]
   11554:	e5842000 	str	r2, [r4]
   11558:	e5813000 	str	r3, [r1]
   1155c:	eb000d23 	bl	149f0 <LCDClear>
   11560:	e5940000 	ldr	r0, [r4]
   11564:	ebfffbd1 	bl	104b0 <printMenu>
   11568:	e59f5334 	ldr	r5, [pc, #820]	; 118a4 <.text+0x18a4>
   1156c:	e5953000 	ldr	r3, [r5]
   11570:	e3130502 	tst	r3, #8388608	; 0x800000
   11574:	0a000013 	beq	115c8 <main+0x280>
   11578:	e59f3320 	ldr	r3, [pc, #800]	; 118a0 <.text+0x18a0>
   1157c:	e5d30000 	ldrb	r0, [r3]
   11580:	eb000d1a 	bl	149f0 <LCDClear>
   11584:	e3a03004 	mov	r3, #4	; 0x4
   11588:	e58d3000 	str	r3, [sp]
   1158c:	e59f3334 	ldr	r3, [pc, #820]	; 118c8 <.text+0x18c8>
   11590:	e5931000 	ldr	r1, [r3]
   11594:	e59f331c 	ldr	r3, [pc, #796]	; 118b8 <.text+0x18b8>
   11598:	e5d1c002 	ldrb	ip, [r1, #2]
   1159c:	e5d32000 	ldrb	r2, [r3]
   115a0:	e3a01000 	mov	r1, #0	; 0x0
   115a4:	e3a03007 	mov	r3, #7	; 0x7
   115a8:	e59f031c 	ldr	r0, [pc, #796]	; 118cc <.text+0x18cc>
   115ac:	e58dc004 	str	ip, [sp, #4]
   115b0:	eb000dcc 	bl	14ce8 <LCDPrintString>
   115b4:	e3a02030 	mov	r2, #48	; 0x30
   115b8:	e3e03000 	mvn	r3, #0	; 0x0
   115bc:	e5032feb 	str	r2, [r3, #-4075]
   115c0:	eb0010ad 	bl	1587c <main_msc>
   115c4:	ebfffb79 	bl	103b0 <reset>
   115c8:	e59f3300 	ldr	r3, [pc, #768]	; 118d0 <.text+0x18d0>
   115cc:	e5d33000 	ldrb	r3, [r3]
   115d0:	e3530000 	cmp	r3, #0	; 0x0
   115d4:	1a000042 	bne	116e4 <main+0x39c>
   115d8:	e59f32f4 	ldr	r3, [pc, #756]	; 118d4 <.text+0x18d4>
   115dc:	e5d34000 	ldrb	r4, [r3]
   115e0:	e3540000 	cmp	r4, #0	; 0x0
   115e4:	1a000052 	bne	11734 <main+0x3ec>
   115e8:	e59f32e8 	ldr	r3, [pc, #744]	; 118d8 <.text+0x18d8>
   115ec:	e5d33000 	ldrb	r3, [r3]
   115f0:	e3530000 	cmp	r3, #0	; 0x0
   115f4:	0a00004e 	beq	11734 <main+0x3ec>
   115f8:	e3a02020 	mov	r2, #32	; 0x20
   115fc:	e3e03000 	mvn	r3, #0	; 0x0
   11600:	e5032feb 	str	r2, [r3, #-4075]
   11604:	e59f02d0 	ldr	r0, [pc, #720]	; 118dc <.text+0x18dc>
   11608:	ebfffc73 	bl	107dc <closeSong>
   1160c:	e59fc2a0 	ldr	ip, [pc, #672]	; 118b4 <.text+0x18b4>
   11610:	e3a03202 	mov	r3, #536870912	; 0x20000000
   11614:	e5dc2000 	ldrb	r2, [ip]
   11618:	e5853004 	str	r3, [r5, #4]
   1161c:	e59f32bc 	ldr	r3, [pc, #700]	; 118e0 <.text+0x18e0>
   11620:	e352000e 	cmp	r2, #14	; 0xe
   11624:	e5c34000 	strb	r4, [r3]
   11628:	92822001 	addls	r2, r2, #1	; 0x1
   1162c:	959c3008 	ldrls	r3, [ip, #8]
   11630:	95cc2000 	strlsb	r2, [ip]
   11634:	92833001 	addls	r3, r3, #1	; 0x1
   11638:	958c3008 	strls	r3, [ip, #8]
   1163c:	e5dc3000 	ldrb	r3, [ip]
   11640:	e353000f 	cmp	r3, #15	; 0xf
   11644:	1a00000b 	bne	11678 <main+0x330>
   11648:	e5dc2006 	ldrb	r2, [ip, #6]
   1164c:	e5dc3005 	ldrb	r3, [ip, #5]
   11650:	e1520003 	cmp	r2, r3
   11654:	2a000007 	bcs	11678 <main+0x330>
   11658:	e2822001 	add	r2, r2, #1	; 0x1
   1165c:	e3a03001 	mov	r3, #1	; 0x1
   11660:	e1a0000c 	mov	r0, ip
   11664:	e1a01008 	mov	r1, r8
   11668:	e5cc3000 	strb	r3, [ip]
   1166c:	e58c4008 	str	r4, [ip, #8]
   11670:	e5cc2006 	strb	r2, [ip, #6]
   11674:	ebfffadf 	bl	101f8 <getNewFiles>
   11678:	e59f4234 	ldr	r4, [pc, #564]	; 118b4 <.text+0x18b4>
   1167c:	e5d43000 	ldrb	r3, [r4]
   11680:	e0843283 	add	r3, r4, r3, lsl #5
   11684:	e5d3302c 	ldrb	r3, [r3, #44]
   11688:	e3530000 	cmp	r3, #0	; 0x0
   1168c:	0a000014 	beq	116e4 <main+0x39c>
   11690:	e5d40004 	ldrb	r0, [r4, #4]
   11694:	eb000cd5 	bl	149f0 <LCDClear>
   11698:	e1a00004 	mov	r0, r4
   1169c:	ebfffb83 	bl	104b0 <printMenu>
   116a0:	e1a01004 	mov	r1, r4
   116a4:	e59f0230 	ldr	r0, [pc, #560]	; 118dc <.text+0x18dc>
   116a8:	ebfffc59 	bl	10814 <loadSongInfo>
   116ac:	e59f322c 	ldr	r3, [pc, #556]	; 118e0 <.text+0x18e0>
   116b0:	e5c30000 	strb	r0, [r3]
   116b4:	eb000f0d 	bl	152f0 <vs1002Config>
   116b8:	e3a00000 	mov	r0, #0	; 0x0
   116bc:	e3a01b02 	mov	r1, #2048	; 0x800
   116c0:	eb000f54 	bl	15418 <vs1002SCIWrite>
   116c4:	eb000f13 	bl	15318 <vs1002Finish>
   116c8:	e59f31d4 	ldr	r3, [pc, #468]	; 118a4 <.text+0x18a4>
   116cc:	e3a02202 	mov	r2, #536870912	; 0x20000000
   116d0:	e583200c 	str	r2, [r3, #12]
   116d4:	e3e02000 	mvn	r2, #0	; 0x0
   116d8:	e5123fef 	ldr	r3, [r2, #-4079]
   116dc:	e3833020 	orr	r3, r3, #32	; 0x20
   116e0:	e5023fef 	str	r3, [r2, #-4079]
   116e4:	e59f31e4 	ldr	r3, [pc, #484]	; 118d0 <.text+0x18d0>
   116e8:	e5d33000 	ldrb	r3, [r3]
   116ec:	e3530002 	cmp	r3, #2	; 0x2
   116f0:	1a000004 	bne	11708 <main+0x3c0>
   116f4:	e59f31cc 	ldr	r3, [pc, #460]	; 118c8 <.text+0x18c8>
   116f8:	e1a01008 	mov	r1, r8
   116fc:	e5930000 	ldr	r0, [r3]
   11700:	ebfffbf6 	bl	106e0 <handleUpButton>
   11704:	ea00005d 	b	11880 <main+0x538>
   11708:	e3530001 	cmp	r3, #1	; 0x1
   1170c:	1a000004 	bne	11724 <main+0x3dc>
   11710:	e59f31b0 	ldr	r3, [pc, #432]	; 118c8 <.text+0x18c8>
   11714:	e1a01008 	mov	r1, r8
   11718:	e5930000 	ldr	r0, [r3]
   1171c:	ebfffbd0 	bl	10664 <handleDownButton>
   11720:	ea000056 	b	11880 <main+0x538>
   11724:	e3530003 	cmp	r3, #3	; 0x3
   11728:	1a000001 	bne	11734 <main+0x3ec>
   1172c:	ebfffc72 	bl	108fc <handleMiddleButton>
   11730:	ea000052 	b	11880 <main+0x538>
   11734:	e59f3198 	ldr	r3, [pc, #408]	; 118d4 <.text+0x18d4>
   11738:	e5d33000 	ldrb	r3, [r3]
   1173c:	e3530000 	cmp	r3, #0	; 0x0
   11740:	0a00004e 	beq	11880 <main+0x538>
   11744:	e3a02010 	mov	r2, #16	; 0x10
   11748:	e3e03000 	mvn	r3, #0	; 0x0
   1174c:	e3a00f4b 	mov	r0, #300	; 0x12c
   11750:	e5032feb 	str	r2, [r3, #-4075]
   11754:	ebfffa8e 	bl	10194 <delay_ms>
   11758:	eb000c3d 	bl	14854 <MMA_get_y>
   1175c:	e3500faf 	cmp	r0, #700	; 0x2bc
   11760:	da00001c 	ble	117d8 <main+0x490>
   11764:	e59f3178 	ldr	r3, [pc, #376]	; 118e4 <.text+0x18e4>
   11768:	e5933000 	ldr	r3, [r3]
   1176c:	e3530faf 	cmp	r3, #700	; 0x2bc
   11770:	da000018 	ble	117d8 <main+0x490>
   11774:	e59f3164 	ldr	r3, [pc, #356]	; 118e0 <.text+0x18e0>
   11778:	e5d33000 	ldrb	r3, [r3]
   1177c:	e3530000 	cmp	r3, #0	; 0x0
   11780:	e59f0140 	ldr	r0, [pc, #320]	; 118c8 <.text+0x18c8>
   11784:	0a000002 	beq	11794 <main+0x44c>
   11788:	e5900000 	ldr	r0, [r0]
   1178c:	ebfffb13 	bl	103e0 <quickClear>
   11790:	ea000002 	b	117a0 <main+0x458>
   11794:	e5903000 	ldr	r3, [r0]
   11798:	e5d30004 	ldrb	r0, [r3, #4]
   1179c:	eb000c93 	bl	149f0 <LCDClear>
   117a0:	e59f3138 	ldr	r3, [pc, #312]	; 118e0 <.text+0x18e0>
   117a4:	e5d33000 	ldrb	r3, [r3]
   117a8:	e59f2114 	ldr	r2, [pc, #276]	; 118c4 <.text+0x18c4>
   117ac:	e3530000 	cmp	r3, #0	; 0x0
   117b0:	e3a03001 	mov	r3, #1	; 0x1
   117b4:	e5c23002 	strb	r3, [r2, #2]
   117b8:	e59f3108 	ldr	r3, [pc, #264]	; 118c8 <.text+0x18c8>
   117bc:	e59f10e0 	ldr	r1, [pc, #224]	; 118a4 <.text+0x18a4>
   117c0:	e5832000 	str	r2, [r3]
   117c4:	e3a03202 	mov	r3, #536870912	; 0x20000000
   117c8:	e5813004 	str	r3, [r1, #4]
   117cc:	1283320f 	addne	r3, r3, #-268435456	; 0xf0000000
   117d0:	03a03101 	moveq	r3, #1073741824	; 0x40000000
   117d4:	ea000021 	b	11860 <main+0x518>
   117d8:	eb000c1d 	bl	14854 <MMA_get_y>
   117dc:	e59f2104 	ldr	r2, [pc, #260]	; 118e8 <.text+0x18e8>
   117e0:	e1500002 	cmp	r0, r2
   117e4:	ca00001e 	bgt	11864 <main+0x51c>
   117e8:	e59f30f4 	ldr	r3, [pc, #244]	; 118e4 <.text+0x18e4>
   117ec:	e5933000 	ldr	r3, [r3]
   117f0:	e1530002 	cmp	r3, r2
   117f4:	ca00001a 	bgt	11864 <main+0x51c>
   117f8:	e59f30e0 	ldr	r3, [pc, #224]	; 118e0 <.text+0x18e0>
   117fc:	e5d33000 	ldrb	r3, [r3]
   11800:	e3530000 	cmp	r3, #0	; 0x0
   11804:	e59f00bc 	ldr	r0, [pc, #188]	; 118c8 <.text+0x18c8>
   11808:	0a000002 	beq	11818 <main+0x4d0>
   1180c:	e5900000 	ldr	r0, [r0]
   11810:	ebfffaf2 	bl	103e0 <quickClear>
   11814:	ea000002 	b	11824 <main+0x4dc>
   11818:	e5903000 	ldr	r3, [r0]
   1181c:	e5d30004 	ldrb	r0, [r3, #4]
   11820:	eb000c72 	bl	149f0 <LCDClear>
   11824:	e59f30b4 	ldr	r3, [pc, #180]	; 118e0 <.text+0x18e0>
   11828:	e5d33000 	ldrb	r3, [r3]
   1182c:	e59f2080 	ldr	r2, [pc, #128]	; 118b4 <.text+0x18b4>
   11830:	e59f106c 	ldr	r1, [pc, #108]	; 118a4 <.text+0x18a4>
   11834:	e3530000 	cmp	r3, #0	; 0x0
   11838:	e3a03000 	mov	r3, #0	; 0x0
   1183c:	e5c23002 	strb	r3, [r2, #2]
   11840:	e2833201 	add	r3, r3, #268435456	; 0x10000000
   11844:	e5813004 	str	r3, [r1, #4]
   11848:	e59f3078 	ldr	r3, [pc, #120]	; 118c8 <.text+0x18c8>
   1184c:	e5832000 	str	r2, [r3]
   11850:	e3a03101 	mov	r3, #1073741824	; 0x40000000
   11854:	e5813004 	str	r3, [r1, #4]
   11858:	0a000001 	beq	11864 <main+0x51c>
   1185c:	e283320e 	add	r3, r3, #-536870912	; 0xe0000000
   11860:	e581300c 	str	r3, [r1, #12]
   11864:	e59f305c 	ldr	r3, [pc, #92]	; 118c8 <.text+0x18c8>
   11868:	e5930000 	ldr	r0, [r3]
   1186c:	ebfffb0f 	bl	104b0 <printMenu>
   11870:	e3e02000 	mvn	r2, #0	; 0x0
   11874:	e5123fef 	ldr	r3, [r2, #-4079]
   11878:	e3833010 	orr	r3, r3, #16	; 0x10
   1187c:	e5023fef 	str	r3, [r2, #-4079]
   11880:	e3e00000 	mvn	r0, #0	; 0x0
   11884:	e5102fef 	ldr	r2, [r0, #-4079]
   11888:	e59f3040 	ldr	r3, [pc, #64]	; 118d0 <.text+0x18d0>
   1188c:	e3822010 	orr	r2, r2, #16	; 0x10
   11890:	e3a01000 	mov	r1, #0	; 0x0
   11894:	e5c31000 	strb	r1, [r3]
   11898:	e5002fef 	str	r2, [r0, #-4079]
   1189c:	eaffff31 	b	11568 <main+0x220>
   118a0:	40000f28 	andmi	r0, r0, r8, lsr #30
   118a4:	e0028000 	and	r8, r2, r0
   118a8:	000003cd 	andeq	r0, r0, sp, asr #7
   118ac:	e002c000 	and	ip, r2, r0
   118b0:	40000898 	mulmi	r0, r8, r8
   118b4:	40000908 	andmi	r0, r0, r8, lsl #18
   118b8:	40000009 	andmi	r0, r0, r9
   118bc:	000182d0 	ldreqd	r8, [r1], -r0
   118c0:	000182e6 	andeq	r8, r1, r6, ror #5
   118c4:	40000b0c 	andmi	r0, r0, ip, lsl #22
   118c8:	40000d10 	andmi	r0, r0, r0, lsl sp
   118cc:	000182f8 	streqd	r8, [r1], -r8
   118d0:	4000089c 	mulmi	r0, ip, r8
   118d4:	4000089d 	mulmi	r0, sp, r8
   118d8:	40000896 	mulmi	r0, r6, r8
   118dc:	400008a8 	andmi	r0, r0, r8, lsr #17
   118e0:	40000895 	mulmi	r0, r5, r8
   118e4:	400008a0 	andmi	r0, r0, r0, lsr #17
   118e8:	000002bb 	streqh	r0, [r0], -fp

000118ec <_read_r>:
	}
*/
//	return len - i;
	return 0;
}
   118ec:	e3a00000 	mov	r0, #0	; 0x0
   118f0:	e12fff1e 	bx	lr

000118f4 <_write_r>:

_ssize_t _write_r (
    struct _reent *r, 
    int file, 
    const void *ptr, 
    size_t len)
{
/*
	int i;
	const unsigned char *p;
	
	p = (const unsigned char*) ptr;
	
	for (i = 0; i < len; i++) {
		if (*p == '\n' ) uart0Putch('\r');
		uart0Putch(*p++);
	}
*/
	return len;
}
   118f4:	e1a00003 	mov	r0, r3
   118f8:	e12fff1e 	bx	lr

000118fc <_close_r>:

int _close_r(
    struct _reent *r, 
    int file)
{
	return 0;
}
   118fc:	e3a00000 	mov	r0, #0	; 0x0
   11900:	e12fff1e 	bx	lr

00011904 <_lseek_r>:

_off_t _lseek_r(
    struct _reent *r, 
    int file, 
    _off_t ptr, 
    int dir)
{
	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
}
   11904:	e3a00000 	mov	r0, #0	; 0x0
   11908:	e12fff1e 	bx	lr

0001190c <_fstat_r>:


int _fstat_r(
    struct _reent *r, 
    int file, 
    struct stat *st)
{
	/*  Always set as character device.				*/
	st->st_mode = S_IFCHR;	
   1190c:	e3a03a02 	mov	r3, #8192	; 0x2000
		/* assigned to strong type with implicit 	*/
		/* signed/unsigned conversion.  Required by 	*/
		/* newlib.					*/

	return 0;
}
   11910:	e3a00000 	mov	r0, #0	; 0x0
   11914:	e5823004 	str	r3, [r2, #4]
   11918:	e12fff1e 	bx	lr

0001191c <isatty>:

int isatty(int file); /* avoid warning */

int isatty(int file)
{
	return 1;
}
   1191c:	e3a00001 	mov	r0, #1	; 0x1
   11920:	e12fff1e 	bx	lr

00011924 <_sbrk_r>:

#if 0
static void _exit (int n) {
label:  goto label; /* endless loop */
}
#endif 

/* "malloc clue function" */

	/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************/
/*  Support function.  Adjusts end of heap to provide more memory to	*/
/* memory allocator. Simple and dumb with no sanity checks.		*/
/*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
/*			support multiple threads of operation.		*/
/*  ptrdiff_t nbytes	-- number of bytes to add.			*/
/*  Returns pointer to start of new heap area.				*/
/*  Note:  This implementation is not thread safe (despite taking a	*/
/* _reent structure as a parameter).  					*/
/*  Since _s_r is not used in the current implementation, the following	*/
/* messages must be suppressed.						*/

void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error	*/

	if (!heap_ptr) {	/*  Initialize if first time through.		*/
   11924:	e59f201c 	ldr	r2, [pc, #28]	; 11948 <.text+0x1948>
   11928:	e5923000 	ldr	r3, [r2]
   1192c:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
   11930:	059f3014 	ldreq	r3, [pc, #20]	; 1194c <.text+0x194c>
   11934:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.			*/
   11938:	e5920000 	ldr	r0, [r2]
	heap_ptr += nbytes;	/*  Increase heap.				*/
   1193c:	e0803001 	add	r3, r0, r1
   11940:	e5823000 	str	r3, [r2]
	
	return base;		/*  Return pointer to start of new heap area.	*/
}
   11944:	e12fff1e 	bx	lr
   11948:	40000d14 	andmi	r0, r0, r4, lsl sp
   1194c:	40001f00 	andmi	r1, r0, r0, lsl #30

00011950 <rprintf_devopen>:
static int (*putcharfunc)(int c);

void rprintf_devopen( int(*put)(int) )
{
    putcharfunc = put;
   11950:	e59f3004 	ldr	r3, [pc, #4]	; 1195c <.text+0x195c>
   11954:	e5830000 	str	r0, [r3]
}
   11958:	e12fff1e 	bx	lr
   1195c:	40000d18 	andmi	r0, r0, r8, lsl sp

00011960 <myputchar>:

static void myputchar(unsigned char c)
{
   11960:	e92d4010 	stmdb	sp!, {r4, lr}
   11964:	e20040ff 	and	r4, r0, #255	; 0xff
    if(c == '\n') putcharfunc('\r');
   11968:	e354000a 	cmp	r4, #10	; 0xa
   1196c:	e3a0000d 	mov	r0, #13	; 0xd
   11970:	059f3024 	ldreq	r3, [pc, #36]	; 1199c <.text+0x199c>
   11974:	0593c000 	ldreq	ip, [r3]
   11978:	01a0e00f 	moveq	lr, pc
   1197c:	012fff1c 	bxeq	ip
    putcharfunc(c);
   11980:	e1a00004 	mov	r0, r4
   11984:	e59f3010 	ldr	r3, [pc, #16]	; 1199c <.text+0x199c>
   11988:	e593c000 	ldr	ip, [r3]
   1198c:	e1a0e00f 	mov	lr, pc
   11990:	e12fff1c 	bx	ip
}
   11994:	e8bd4010 	ldmia	sp!, {r4, lr}
   11998:	e12fff1e 	bx	lr
   1199c:	40000d18 	andmi	r0, r0, r8, lsl sp

000119a0 <rprintf>:

void rprintf(char const *format, ...)
{
   119a0:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
   119a4:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   119a8:	e24dd010 	sub	sp, sp, #16	; 0x10
    unsigned char scratch[SCRATCH];
    unsigned char format_flag;
    unsigned short base;
    unsigned char *ptr;
    unsigned char issigned=0;
    va_list ap;

    #ifdef USE_LONG
        // #warning "use long"
        unsigned char islong=0;
        unsigned long u_val=0;
        long s_val=0;
    #else
        unsigned int u_val=0;
        int s_val=0;
    #endif

    unsigned char fill;
    unsigned char width;

    va_start (ap, format);
   119ac:	e28d3030 	add	r3, sp, #48	; 0x30
   119b0:	e58d300c 	str	r3, [sp, #12]
   119b4:	e59d502c 	ldr	r5, [sp, #44]
    for (;;)
    {
		delay_ms(1); //Added for VCOM testing - without it, rprintf will overrun the VCOM buffer causing it to crash
   119b8:	e3a00001 	mov	r0, #1	; 0x1
   119bc:	ebfff9f4 	bl	10194 <delay_ms>
   119c0:	ea000002 	b	119d0 <rprintf+0x30>
		
        while ((format_flag = *(format++)) != '%')
        {      // Until '%' or '\0'
            if (!format_flag){va_end (ap); return;}
   119c4:	e3530000 	cmp	r3, #0	; 0x0
   119c8:	0a00008e 	beq	11c08 <rprintf+0x268>
                myputchar(format_flag);
   119cc:	ebffffe3 	bl	11960 <myputchar>
   119d0:	e4d53001 	ldrb	r3, [r5], #1
   119d4:	e3530025 	cmp	r3, #37	; 0x25
   119d8:	e1a00003 	mov	r0, r3
   119dc:	1afffff8 	bne	119c4 <rprintf+0x24>
        }

        issigned=0; //default unsigned
        base = 10;

        format_flag = *format++; //get char after '%'
   119e0:	e4d52001 	ldrb	r2, [r5], #1

        #ifdef PADDING
            width=0; //no formatting
            fill=0;  //no formatting
            if(format_flag=='0' || format_flag==' ') //SPACE or ZERO padding  ?
   119e4:	e3520020 	cmp	r2, #32	; 0x20
   119e8:	13520030 	cmpne	r2, #48	; 0x30
   119ec:	13a03000 	movne	r3, #0	; 0x0
   119f0:	03a03001 	moveq	r3, #1	; 0x1
   119f4:	11a07003 	movne	r7, r3
   119f8:	11a00002 	movne	r0, r2
   119fc:	11a0a007 	movne	sl, r7
   11a00:	1a000007 	bne	11a24 <rprintf+0x84>
            {
                fill=format_flag;
                format_flag = *format++; //get char after padding char
   11a04:	e4d50001 	ldrb	r0, [r5], #1
                if(format_flag>='0' && format_flag<='9')
   11a08:	e2403030 	sub	r3, r0, #48	; 0x30
   11a0c:	e20370ff 	and	r7, r3, #255	; 0xff
   11a10:	e3570009 	cmp	r7, #9	; 0x9
                {
                    width=format_flag-'0';
                    format_flag = *format++; //get char after width char
   11a14:	94d50001 	ldrlsb	r0, [r5], #1
   11a18:	81a0a002 	movhi	sl, r2
   11a1c:	83a07000 	movhi	r7, #0	; 0x0
   11a20:	91a0a002 	movls	sl, r2
                }
            }
        #endif

        #ifdef USE_LONG
            islong=0; //default int value
            #ifdef USE_UPPER
            if(format_flag=='l' || format_flag=='L') //Long value
   11a24:	e350004c 	cmp	r0, #76	; 0x4c
   11a28:	1350006c 	cmpne	r0, #108	; 0x6c
            #else
            if(format_flag=='l') //Long value
            #endif
        {
            islong=1;
            format_flag = *format++; //get char after 'l' or 'L'
   11a2c:	04d50001 	ldreqb	r0, [r5], #1
   11a30:	13a03000 	movne	r3, #0	; 0x0
   11a34:	03a03001 	moveq	r3, #1	; 0x1
   11a38:	03a03001 	moveq	r3, #1	; 0x1
        }
        #endif

        switch (format_flag)
   11a3c:	e3500058 	cmp	r0, #88	; 0x58
   11a40:	0a00003e 	beq	11b40 <rprintf+0x1a0>
   11a44:	8a00000b 	bhi	11a78 <rprintf+0xd8>
   11a48:	e3500049 	cmp	r0, #73	; 0x49
   11a4c:	0a00006a 	beq	11bfc <rprintf+0x25c>
   11a50:	8a000003 	bhi	11a64 <rprintf+0xc4>
   11a54:	e3500043 	cmp	r0, #67	; 0x43
   11a58:	0a000015 	beq	11ab4 <rprintf+0x114>
   11a5c:	e3500044 	cmp	r0, #68	; 0x44
   11a60:	ea00000a 	b	11a90 <rprintf+0xf0>
   11a64:	e3500053 	cmp	r0, #83	; 0x53
   11a68:	0a000017 	beq	11acc <rprintf+0x12c>
   11a6c:	e3500055 	cmp	r0, #85	; 0x55
   11a70:	1a000013 	bne	11ac4 <rprintf+0x124>
   11a74:	ea000020 	b	11afc <rprintf+0x15c>
   11a78:	e3500069 	cmp	r0, #105	; 0x69
   11a7c:	0a00005e 	beq	11bfc <rprintf+0x25c>
   11a80:	8a000004 	bhi	11a98 <rprintf+0xf8>
   11a84:	e3500063 	cmp	r0, #99	; 0x63
   11a88:	0a000009 	beq	11ab4 <rprintf+0x114>
   11a8c:	e3500064 	cmp	r0, #100	; 0x64
   11a90:	1a00000b 	bne	11ac4 <rprintf+0x124>
   11a94:	ea000058 	b	11bfc <rprintf+0x25c>
   11a98:	e3500075 	cmp	r0, #117	; 0x75
   11a9c:	0a000016 	beq	11afc <rprintf+0x15c>
   11aa0:	e3500078 	cmp	r0, #120	; 0x78
   11aa4:	0a000025 	beq	11b40 <rprintf+0x1a0>
   11aa8:	e3500073 	cmp	r0, #115	; 0x73
   11aac:	1a000004 	bne	11ac4 <rprintf+0x124>
   11ab0:	ea000005 	b	11acc <rprintf+0x12c>
        {
            #ifdef USE_CHAR
                case 'c':
                    #ifdef USE_UPPER
                    case 'C':
                #endif
                format_flag = va_arg(ap,int);
   11ab4:	e59d200c 	ldr	r2, [sp, #12]
   11ab8:	e2823004 	add	r3, r2, #4	; 0x4
   11abc:	e58d300c 	str	r3, [sp, #12]
   11ac0:	e5d20000 	ldrb	r0, [r2]
                // no break -> run into default
            #endif

            default:
                myputchar(format_flag);
   11ac4:	ebffffa5 	bl	11960 <myputchar>
   11ac8:	eaffffba 	b	119b8 <rprintf+0x18>
                continue;

                #ifdef USE_STRING
                    #ifdef USE_UPPER
                    case 'S':
                #endif
                case 's':
                ptr = (unsigned char*)va_arg(ap,char *);
   11acc:	e59d300c 	ldr	r3, [sp, #12]
   11ad0:	e5936000 	ldr	r6, [r3]
   11ad4:	e3a04000 	mov	r4, #0	; 0x0
   11ad8:	e2833004 	add	r3, r3, #4	; 0x4
   11adc:	e58d300c 	str	r3, [sp, #12]
   11ae0:	ea000000 	b	11ae8 <rprintf+0x148>
                while(*ptr) { myputchar(*ptr); ptr++; }
   11ae4:	ebffff9d 	bl	11960 <myputchar>
   11ae8:	e7d43006 	ldrb	r3, [r4, r6]
   11aec:	e2530000 	subs	r0, r3, #0	; 0x0
   11af0:	e2844001 	add	r4, r4, #1	; 0x1
   11af4:	1afffffa 	bne	11ae4 <rprintf+0x144>
   11af8:	eaffffae 	b	119b8 <rprintf+0x18>
                    continue;
                #endif

                #ifdef USE_OCTAL
                    case 'o':
                    #ifdef USE_UPPER
                    case 'O':
                #endif
                base = 8;
                myputchar('0');
                goto CONVERSION_LOOP;
                #endif

                #ifdef USE_INTEGER //don't use %i, is same as %d
                    case 'i':
                    #ifdef USE_UPPER
                    case 'I':
                #endif
                #endif
                case 'd':
                #ifdef USE_UPPER
                    case 'D':
                #endif
                issigned=1;
                // no break -> run into next case
            case 'u':
                #ifdef USE_UPPER
                    case 'U':
                #endif

                //don't insert some case below this if USE_HEX is undefined !
                //or put       goto CONVERSION_LOOP;  before next case.
                #ifdef USE_HEX
                    goto CONVERSION_LOOP;
                    case 'x':
                    #ifdef USE_UPPER
                    case 'X':
                #endif
                base = 16;
                #endif

                CONVERSION_LOOP:
   11afc:	e3a0800a 	mov	r8, #10	; 0xa
   11b00:	ea00000f 	b	11b44 <rprintf+0x1a4>

                if(issigned) //Signed types
                {
                    #ifdef USE_LONG
                        if(islong) { s_val = va_arg(ap,long); }
   11b04:	e59d300c 	ldr	r3, [sp, #12]
   11b08:	e5934000 	ldr	r4, [r3]
   11b0c:	e2833004 	add	r3, r3, #4	; 0x4
   11b10:	e58d300c 	str	r3, [sp, #12]
   11b14:	ea000003 	b	11b28 <rprintf+0x188>
                            else { s_val = va_arg(ap,int); }
   11b18:	e59d200c 	ldr	r2, [sp, #12]
   11b1c:	e2823004 	add	r3, r2, #4	; 0x4
   11b20:	e58d300c 	str	r3, [sp, #12]
   11b24:	e5924000 	ldr	r4, [r2]
                        #else
                        s_val = va_arg(ap,int);
                    #endif

                    if(s_val < 0) //Value negativ ?
   11b28:	e3540000 	cmp	r4, #0	; 0x0
                    {
                        s_val = - s_val; //Make it positiv
                        myputchar('-');    //Output sign
   11b2c:	b3a0002d 	movlt	r0, #45	; 0x2d
   11b30:	b2644000 	rsblt	r4, r4, #0	; 0x0
   11b34:	bbffff89 	bllt	11960 <myputchar>
                    }

                    u_val = (unsigned long)s_val;
   11b38:	e3a0800a 	mov	r8, #10	; 0xa
   11b3c:	ea000008 	b	11b64 <rprintf+0x1c4>
   11b40:	e3a08010 	mov	r8, #16	; 0x10
   11b44:	e59d200c 	ldr	r2, [sp, #12]
                }
                else //Unsigned types
                {
                    #ifdef USE_LONG
                        if(islong) { u_val = va_arg(ap,unsigned long); }
   11b48:	e3530000 	cmp	r3, #0	; 0x0
   11b4c:	12823004 	addne	r3, r2, #4	; 0x4
                            else { u_val = va_arg(ap,unsigned int); }
   11b50:	02823004 	addeq	r3, r2, #4	; 0x4
   11b54:	15924000 	ldrne	r4, [r2]
   11b58:	158d300c 	strne	r3, [sp, #12]
   11b5c:	058d300c 	streq	r3, [sp, #12]
   11b60:	05924000 	ldreq	r4, [r2]
                        #else
                        u_val = va_arg(ap,unsigned int);
                    #endif
                }

                ptr = scratch + SCRATCH;
                *--ptr = 0;
   11b64:	e3a03000 	mov	r3, #0	; 0x0
   11b68:	e5cd300b 	strb	r3, [sp, #11]
   11b6c:	e28d600b 	add	r6, sp, #11	; 0xb
                do
                {
                    char ch = u_val % base + '0';
   11b70:	e1a00004 	mov	r0, r4
   11b74:	e1a01008 	mov	r1, r8
   11b78:	eb001965 	bl	18114 <__umodsi3>
   11b7c:	e2800030 	add	r0, r0, #48	; 0x30
   11b80:	e20030ff 	and	r3, r0, #255	; 0xff
                    #ifdef USE_HEX
                        if (ch > '9')
   11b84:	e3530039 	cmp	r3, #57	; 0x39
                        {
                            ch += 'a' - '9' - 1;
                            #ifdef USE_UPPERHEX
                            ch-=0x20;
   11b88:	e2832007 	add	r2, r3, #7	; 0x7
   11b8c:	820230ff 	andhi	r3, r2, #255	; 0xff
                        #endif
                    }
                    #endif
                    *--ptr = ch;
   11b90:	e5463001 	strb	r3, [r6, #-1]
                    u_val /= base;
   11b94:	e1a00004 	mov	r0, r4
   11b98:	e1a01008 	mov	r1, r8
   11b9c:	eb0018c6 	bl	17ebc <__aeabi_uidiv>

                    #ifdef PADDING
                        if(width) width--; //calculate number of padding chars
   11ba0:	e3570000 	cmp	r7, #0	; 0x0
   11ba4:	e2473001 	sub	r3, r7, #1	; 0x1
   11ba8:	120370ff 	andne	r7, r3, #255	; 0xff
                    #endif
                }
                while (u_val);
   11bac:	e3500000 	cmp	r0, #0	; 0x0
   11bb0:	e2466001 	sub	r6, r6, #1	; 0x1
   11bb4:	e1a04000 	mov	r4, r0
   11bb8:	1affffec 	bne	11b70 <rprintf+0x1d0>
   11bbc:	e1a01007 	mov	r1, r7
   11bc0:	e1a02006 	mov	r2, r6
   11bc4:	ea000000 	b	11bcc <rprintf+0x22c>

                #ifdef PADDING
                    while(width--) *--ptr = fill; //insert padding chars
   11bc8:	e562a001 	strb	sl, [r2, #-1]!
   11bcc:	e2473001 	sub	r3, r7, #1	; 0x1
   11bd0:	e20370ff 	and	r7, r3, #255	; 0xff
   11bd4:	e35700ff 	cmp	r7, #255	; 0xff
   11bd8:	1afffffa 	bne	11bc8 <rprintf+0x228>
   11bdc:	e0614006 	rsb	r4, r1, r6
   11be0:	ea000000 	b	11be8 <rprintf+0x248>
                #endif

                while(*ptr) { myputchar(*ptr); ptr++; }
   11be4:	ebffff5d 	bl	11960 <myputchar>
   11be8:	e5d43000 	ldrb	r3, [r4]
   11bec:	e2530000 	subs	r0, r3, #0	; 0x0
   11bf0:	e2844001 	add	r4, r4, #1	; 0x1
   11bf4:	1afffffa 	bne	11be4 <rprintf+0x244>
   11bf8:	eaffff6e 	b	119b8 <rprintf+0x18>
   11bfc:	e3530000 	cmp	r3, #0	; 0x0
   11c00:	1affffbf 	bne	11b04 <rprintf+0x164>
   11c04:	eaffffc3 	b	11b18 <rprintf+0x178>
                    }
        }
    }
   11c08:	e28dd010 	add	sp, sp, #16	; 0x10
   11c0c:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   11c10:	e28dd010 	add	sp, sp, #16	; 0x10
   11c14:	e12fff1e 	bx	lr

00011c18 <init_serial0>:
void init_serial0 ( unsigned long baudrate )
{
    unsigned long Fdiv;

    PINSEL0 = 0x00000005;                  /* Enable RxD0 and TxD0              */
   11c18:	e59f3040 	ldr	r3, [pc, #64]	; 11c60 <.text+0x1c60>
   11c1c:	e92d4010 	stmdb	sp!, {r4, lr}
   11c20:	e3a02005 	mov	r2, #5	; 0x5
    U0LCR = 0x83;                          /* 8 bits, no Parity, 1 Stop bit     */
   11c24:	e59f4038 	ldr	r4, [pc, #56]	; 11c64 <.text+0x1c64>
   11c28:	e5832000 	str	r2, [r3]
   11c2c:	e3a03083 	mov	r3, #131	; 0x83
   11c30:	e1a01000 	mov	r1, r0
   11c34:	e584300c 	str	r3, [r4, #12]
    Fdiv = ( Fpclk / 16 ) / baudrate ;     /* baud rate                        */
   11c38:	e59f0028 	ldr	r0, [pc, #40]	; 11c68 <.text+0x1c68>
   11c3c:	eb00189e 	bl	17ebc <__aeabi_uidiv>
    U0DLM = Fdiv / 256;
    U0DLL = Fdiv % 256;
   11c40:	e20030ff 	and	r3, r0, #255	; 0xff
   11c44:	e1a00420 	mov	r0, r0, lsr #8
   11c48:	e5840004 	str	r0, [r4, #4]
   11c4c:	e5843000 	str	r3, [r4]
    U0LCR = 0x03;                           /* DLAB = 0                         */
   11c50:	e3a03003 	mov	r3, #3	; 0x3
   11c54:	e584300c 	str	r3, [r4, #12]
}
   11c58:	e8bd4010 	ldmia	sp!, {r4, lr}
   11c5c:	e12fff1e 	bx	lr
   11c60:	e002c000 	and	ip, r2, r0
   11c64:	e000c000 	and	ip, r0, r0
   11c68:	000e4e1c 	andeq	r4, lr, ip, lsl lr

00011c6c <putchar_serial0>:

/* Write character to Serial Port 0 with \n -> \r\n  */
int putchar_serial0 (int ch)
{
    if (ch == '\n')
   11c6c:	e350000a 	cmp	r0, #10	; 0xa
   11c70:	1a000005 	bne	11c8c <putchar_serial0+0x20>
    {
        while (!(U0LSR & 0x20));
   11c74:	e59f202c 	ldr	r2, [pc, #44]	; 11ca8 <.text+0x1ca8>
   11c78:	e5923014 	ldr	r3, [r2, #20]
   11c7c:	e3130020 	tst	r3, #32	; 0x20
   11c80:	0afffffb 	beq	11c74 <putchar_serial0+0x8>
        U0THR = CR;                  /* output CR */
   11c84:	e3a0300d 	mov	r3, #13	; 0xd
   11c88:	e5823000 	str	r3, [r2]
    }
    while (!(U0LSR & 0x20));
   11c8c:	e59f2014 	ldr	r2, [pc, #20]	; 11ca8 <.text+0x1ca8>
   11c90:	e5923014 	ldr	r3, [r2, #20]
   11c94:	e3130020 	tst	r3, #32	; 0x20
   11c98:	0afffffb 	beq	11c8c <putchar_serial0+0x20>
    return (U0THR = ch);
   11c9c:	e5820000 	str	r0, [r2]
   11ca0:	e5920000 	ldr	r0, [r2]
}
   11ca4:	e12fff1e 	bx	lr
   11ca8:	e000c000 	and	ip, r0, r0

00011cac <putc_serial0>:

/* Write character to Serial Port 0 without \n -> \r\n  */
int putc_serial0 (int ch)
{
    while (!(U0LSR & 0x20));
   11cac:	e59f2014 	ldr	r2, [pc, #20]	; 11cc8 <.text+0x1cc8>
   11cb0:	e5923014 	ldr	r3, [r2, #20]
   11cb4:	e3130020 	tst	r3, #32	; 0x20
   11cb8:	0afffffb 	beq	11cac <putc_serial0>
    return (U0THR = ch);
   11cbc:	e5820000 	str	r0, [r2]
   11cc0:	e5920000 	ldr	r0, [r2]
}
   11cc4:	e12fff1e 	bx	lr
   11cc8:	e000c000 	and	ip, r0, r0

00011ccc <putstring_serial0>:


void putstring_serial0 (const char *string)
{
   11ccc:	e92d4010 	stmdb	sp!, {r4, lr}
   11cd0:	e1a04000 	mov	r4, r0
   11cd4:	ea000000 	b	11cdc <putstring_serial0+0x10>
    char ch;

    while ((ch = *string))
    {
        putchar_serial0(ch);
   11cd8:	ebffffe3 	bl	11c6c <putchar_serial0>
   11cdc:	e5d43000 	ldrb	r3, [r4]
   11ce0:	e2530000 	subs	r0, r3, #0	; 0x0
        string++;
   11ce4:	e2844001 	add	r4, r4, #1	; 0x1
   11ce8:	1afffffa 	bne	11cd8 <putstring_serial0+0xc>
    }
}
   11cec:	e8bd4010 	ldmia	sp!, {r4, lr}
   11cf0:	e12fff1e 	bx	lr

00011cf4 <getkey_serial0>:


/* Read character from Serial Port   */
int getkey_serial0 (void)
{
	if (U0LSR & 0x01)
   11cf4:	e59f2010 	ldr	r2, [pc, #16]	; 11d0c <.text+0x1d0c>
   11cf8:	e5923014 	ldr	r3, [r2, #20]
   11cfc:	e2133001 	ands	r3, r3, #1	; 0x1
   11d00:	e1a00003 	mov	r0, r3
    {
        return (U0RBR);
   11d04:	15920000 	ldrne	r0, [r2]
    }
    else
    {
        return 0;
    }
}
   11d08:	e12fff1e 	bx	lr
   11d0c:	e000c000 	and	ip, r0, r0

00011d10 <getc0>:

/* Read character from Serial Port   */
int getc0 (void)
{
	while ( (U0LSR & 0x01) == 0 ); //Wait for character
   11d10:	e59f2010 	ldr	r2, [pc, #16]	; 11d28 <.text+0x1d28>
   11d14:	e5923014 	ldr	r3, [r2, #20]
   11d18:	e3130001 	tst	r3, #1	; 0x1
   11d1c:	0afffffb 	beq	11d10 <getc0>
	return U0RBR;
   11d20:	e5920000 	ldr	r0, [r2]
}
   11d24:	e12fff1e 	bx	lr
   11d28:	e000c000 	and	ip, r0, r0

00011d2c <SPI0_send_recv>:
char SPI0_send_recv(char c)
{
    char in;

    S0SPDR = c;						//Place data to be sent into SPI data register
   11d2c:	e59f3024 	ldr	r3, [pc, #36]	; 11d58 <.text+0x1d58>
   11d30:	e20000ff 	and	r0, r0, #255	; 0xff
   11d34:	e5830008 	str	r0, [r3, #8]
    while(!(S0SPSR & SPIF));		//Wait for transfer to complete
   11d38:	e59f2018 	ldr	r2, [pc, #24]	; 11d58 <.text+0x1d58>
   11d3c:	e5923004 	ldr	r3, [r2, #4]
   11d40:	e3130080 	tst	r3, #128	; 0x80
   11d44:	0afffffb 	beq	11d38 <SPI0_send_recv+0xc>
	in=S0SPSR;
   11d48:	e5923004 	ldr	r3, [r2, #4]
    in = S0SPDR&0xff;				//Return the character placed in the SPI data register by the slave
   11d4c:	e5920008 	ldr	r0, [r2, #8]
   11d50:	e20000ff 	and	r0, r0, #255	; 0xff
    
	return in;
}
   11d54:	e12fff1e 	bx	lr
   11d58:	e0020000 	and	r0, r2, r0

00011d5c <SPI0_recv>:
   11d5c:	e52de004 	str	lr, [sp, #-4]!
   11d60:	e3a000ff 	mov	r0, #255	; 0xff
   11d64:	ebfffff0 	bl	11d2c <SPI0_send_recv>
   11d68:	e49de004 	ldr	lr, [sp], #4
   11d6c:	e12fff1e 	bx	lr

00011d70 <SPI0_send>:
   11d70:	e20000ff 	and	r0, r0, #255	; 0xff
   11d74:	eaffffec 	b	11d2c <SPI0_send_recv>

00011d78 <root_file_exists>:

/* returns 1 if file exists, 0 else */
int root_file_exists(char* name)
{
    return(find_file_in_dir(fs,dd,name,&dir_entry));
   11d78:	e59f3020 	ldr	r3, [pc, #32]	; 11da0 <.text+0x1da0>
   11d7c:	e5931000 	ldr	r1, [r3]
   11d80:	e59f301c 	ldr	r3, [pc, #28]	; 11da4 <.text+0x1da4>
   11d84:	e1a02000 	mov	r2, r0
   11d88:	e52de004 	str	lr, [sp, #-4]!
   11d8c:	e5930000 	ldr	r0, [r3]
   11d90:	e59f3010 	ldr	r3, [pc, #16]	; 11da8 <.text+0x1da8>
   11d94:	eb0006e4 	bl	1392c <find_file_in_dir>
}
   11d98:	e49de004 	ldr	lr, [sp], #4
   11d9c:	e12fff1e 	bx	lr
   11da0:	40001270 	andmi	r1, r0, r0, ror r2
   11da4:	40001238 	andmi	r1, r0, r8, lsr r2
   11da8:	4000123c 	andmi	r1, r0, ip, lsr r2

00011dac <root_delete>:

/* returns NULL if error, pointer if file opened */
struct fat16_file_struct * root_open_new(char* name)
{
    if(fat16_create_file(dd,name,&dir_entry))
    {
        return(open_file_in_dir(fs,dd,name));
    }
    else
    {
        return NULL;
    }
}

struct fat16_file_struct * root_open(char* name)
{
    return(open_file_in_dir(fs,dd,name));
}

uint8_t print_disk_info(const struct fat16_fs_struct* disk_fs)
{
    if(!disk_fs)
        return 0;

    struct sd_raw_info disk_info;
    if(!sd_raw_get_info(&disk_info))
        return 0;

//    int temp = get_output();
//    set_output(UART_ONLY);
    rprintf("manuf:  0x%02x\n\r", disk_info.manufacturer);
    rprintf("oem:    %s\n\r", disk_info.oem);
    rprintf("prod:   %s\n\r", disk_info.product);
    rprintf("rev:    %02x\n\r", disk_info.revision);
    rprintf("serial: 0x%08lx\n\r", disk_info.serial);
    rprintf("date:   %02d/%02d\n\r", disk_info.manufacturing_month, disk_info.manufacturing_year);
    rprintf("size:   %ld\n\r", disk_info.capacity);
    rprintf("copy:   %d\n\r", disk_info.flag_copy);
    rprintf("wr.pr.: %d/%d\n\r", disk_info.flag_write_protect_temp, disk_info.flag_write_protect);
    rprintf("format: %d\n\r", disk_info.format);
    rprintf("free:   %ld/%ld\n\r", fat16_get_fs_free(disk_fs), fat16_get_fs_size(disk_fs));
//    set_output(temp);
    return 1;
}

void root_disk_info(void)
{
    print_disk_info(fs);
}

/* sequential calls return sequential characters
 * of the sequence of file names in the rootdir
 * in place of '\0' it returns ',' only
 * returning a zero when the end of all files
 * has been reached.
 *
 * Assert (1) reset whenever you want to re-start
 */
char rootDirectory_files_stream(int reset)
{

    static int idx = 0;

    /* If reset, we need to reset the dir */
    if(reset)
    {
        fat16_reset_dir(dd);
        return 0;
    }

    /* Whenever IDX is zero, we're gonna start a new file,
       * so read a new one.
       * if there's no new file,
       * return 0, because it's over
       */
    if(idx == 0)
    {
        if(fat16_read_dir(dd,&dir_entry)==0)
        {
            return '\0';
        }
    }

    /* If we've reached the end of a string,
       * return comma instead of \0,
       * so the list is comma delimited,
       * and terminated with a zero
       */
    if(dir_entry.long_name[idx]=='\0')
    {
        idx = 0;
        return ',';
    }


    return dir_entry.long_name[idx++];

}
//Description: Fills buf with len number of chars.  Returns the number of files
//				that were cycled through during the read
//Pre: buf is an array of characters at least as big as len
//		len is the size of the array to read
//Post: buf contains the characters of the filenames in Root, starting at the first file
//		and ending after len characters
int rootDirectory_files(char* buf, int len)
{
    int i;
    int num=0;
    /* Loop will walk through every file in directory dd */
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        i = 0;
        /* Spin through the filename */
        while(dir_entry.long_name[i]!='\0')
        {
            /* And copy each character into buf */
            *buf++=dir_entry.long_name[i++];
            len--;
            if(len==1)
            {
                /* Buf if we ever get to the end of buf, quit */
                *buf='\0';
                return 1;
            }
        }
        *buf++=',';
        num++;
        len--;
        if(len==1)
        {
            /* Buf if we ever get to the end of buf, quit */
            *buf='\0';
            return 1;
        }
    }
    *buf='\0';
    return num;
}

void root_format(void)
{
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        fat16_delete_file(fs,&dir_entry);
        fat16_reset_dir(dd);
    }
}

int root_delete(char* filename)
{
   11dac:	e92d4010 	stmdb	sp!, {r4, lr}
    if(find_file_in_dir(fs,dd,filename,&dir_entry))
   11db0:	e59f3038 	ldr	r3, [pc, #56]	; 11df0 <.text+0x1df0>
   11db4:	e59f4038 	ldr	r4, [pc, #56]	; 11df4 <.text+0x1df4>
   11db8:	e5931000 	ldr	r1, [r3]
   11dbc:	e1a02000 	mov	r2, r0
   11dc0:	e59f3030 	ldr	r3, [pc, #48]	; 11df8 <.text+0x1df8>
   11dc4:	e5940000 	ldr	r0, [r4]
   11dc8:	eb0006d7 	bl	1392c <find_file_in_dir>
   11dcc:	e3500000 	cmp	r0, #0	; 0x0
    {
        fat16_delete_file(fs,&dir_entry);
   11dd0:	e59f1020 	ldr	r1, [pc, #32]	; 11df8 <.text+0x1df8>
   11dd4:	e3a00001 	mov	r0, #1	; 0x1
   11dd8:	0a000002 	beq	11de8 <root_delete+0x3c>
   11ddc:	e5940000 	ldr	r0, [r4]
   11de0:	eb0005d4 	bl	13538 <fat16_delete_file>
   11de4:	e3a00000 	mov	r0, #0	; 0x0
        return 0;
    }
    return 1;
}
   11de8:	e8bd4010 	ldmia	sp!, {r4, lr}
   11dec:	e12fff1e 	bx	lr
   11df0:	40001270 	andmi	r1, r0, r0, ror r2
   11df4:	40001238 	andmi	r1, r0, r8, lsr r2
   11df8:	4000123c 	andmi	r1, r0, ip, lsr r2

00011dfc <root_format>:
   11dfc:	e92d4010 	stmdb	sp!, {r4, lr}
   11e00:	e59f303c 	ldr	r3, [pc, #60]	; 11e44 <.text+0x1e44>
   11e04:	e5930000 	ldr	r0, [r3]
   11e08:	ea000003 	b	11e1c <root_format+0x20>
   11e0c:	e59f3034 	ldr	r3, [pc, #52]	; 11e48 <.text+0x1e48>
   11e10:	e5930000 	ldr	r0, [r3]
   11e14:	eb0005c7 	bl	13538 <fat16_delete_file>
   11e18:	e5940000 	ldr	r0, [r4]
   11e1c:	e59f4020 	ldr	r4, [pc, #32]	; 11e44 <.text+0x1e44>
   11e20:	eb0005bd 	bl	1351c <fat16_reset_dir>
   11e24:	e59f1020 	ldr	r1, [pc, #32]	; 11e4c <.text+0x1e4c>
   11e28:	e5940000 	ldr	r0, [r4]
   11e2c:	eb000638 	bl	13714 <fat16_read_dir>
   11e30:	e3500000 	cmp	r0, #0	; 0x0
   11e34:	e59f1010 	ldr	r1, [pc, #16]	; 11e4c <.text+0x1e4c>
   11e38:	1afffff3 	bne	11e0c <root_format+0x10>
   11e3c:	e8bd4010 	ldmia	sp!, {r4, lr}
   11e40:	e12fff1e 	bx	lr
   11e44:	40001270 	andmi	r1, r0, r0, ror r2
   11e48:	40001238 	andmi	r1, r0, r8, lsr r2
   11e4c:	4000123c 	andmi	r1, r0, ip, lsr r2

00011e50 <rootDirectory_files>:
   11e50:	e59f30a0 	ldr	r3, [pc, #160]	; 11ef8 <.text+0x1ef8>
   11e54:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   11e58:	e1a04000 	mov	r4, r0
   11e5c:	e5930000 	ldr	r0, [r3]
   11e60:	e1a05001 	mov	r5, r1
   11e64:	eb0005ac 	bl	1351c <fat16_reset_dir>
   11e68:	e3a06000 	mov	r6, #0	; 0x0
   11e6c:	ea000017 	b	11ed0 <rootDirectory_files+0x80>
   11e70:	e3520001 	cmp	r2, #1	; 0x1
   11e74:	e5c41000 	strb	r1, [r4]
   11e78:	e1a04000 	mov	r4, r0
   11e7c:	1a000004 	bne	11e94 <rootDirectory_files+0x44>
   11e80:	e3a03000 	mov	r3, #0	; 0x0
   11e84:	e1a06002 	mov	r6, r2
   11e88:	e5c03000 	strb	r3, [r0]
   11e8c:	ea000016 	b	11eec <rootDirectory_files+0x9c>
   11e90:	e59f3064 	ldr	r3, [pc, #100]	; 11efc <.text+0x1efc>
   11e94:	e5d31000 	ldrb	r1, [r3]
   11e98:	e2452001 	sub	r2, r5, #1	; 0x1
   11e9c:	e3510000 	cmp	r1, #0	; 0x0
   11ea0:	e2833001 	add	r3, r3, #1	; 0x1
   11ea4:	e1a05002 	mov	r5, r2
   11ea8:	e2840001 	add	r0, r4, #1	; 0x1
   11eac:	1affffef 	bne	11e70 <rootDirectory_files+0x20>
   11eb0:	e3a0302c 	mov	r3, #44	; 0x2c
   11eb4:	e3520001 	cmp	r2, #1	; 0x1
   11eb8:	e5c43000 	strb	r3, [r4]
   11ebc:	e1a04000 	mov	r4, r0
   11ec0:	01a06002 	moveq	r6, r2
   11ec4:	05c01000 	streqb	r1, [r0]
   11ec8:	0a000007 	beq	11eec <rootDirectory_files+0x9c>
   11ecc:	e2866001 	add	r6, r6, #1	; 0x1
   11ed0:	e59f3020 	ldr	r3, [pc, #32]	; 11ef8 <.text+0x1ef8>
   11ed4:	e59f1020 	ldr	r1, [pc, #32]	; 11efc <.text+0x1efc>
   11ed8:	e5930000 	ldr	r0, [r3]
   11edc:	eb00060c 	bl	13714 <fat16_read_dir>
   11ee0:	e3500000 	cmp	r0, #0	; 0x0
   11ee4:	1affffe9 	bne	11e90 <rootDirectory_files+0x40>
   11ee8:	e5c40000 	strb	r0, [r4]
   11eec:	e1a00006 	mov	r0, r6
   11ef0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   11ef4:	e12fff1e 	bx	lr
   11ef8:	40001270 	andmi	r1, r0, r0, ror r2
   11efc:	4000123c 	andmi	r1, r0, ip, lsr r2

00011f00 <rootDirectory_files_stream>:
   11f00:	e3500000 	cmp	r0, #0	; 0x0
   11f04:	e52de004 	str	lr, [sp, #-4]!
   11f08:	0a000004 	beq	11f20 <rootDirectory_files_stream+0x20>
   11f0c:	e59f3064 	ldr	r3, [pc, #100]	; 11f78 <.text+0x1f78>
   11f10:	e5930000 	ldr	r0, [r3]
   11f14:	eb000580 	bl	1351c <fat16_reset_dir>
   11f18:	e3a00000 	mov	r0, #0	; 0x0
   11f1c:	ea000013 	b	11f70 <rootDirectory_files_stream+0x70>
   11f20:	e59f3054 	ldr	r3, [pc, #84]	; 11f7c <.text+0x1f7c>
   11f24:	e5933000 	ldr	r3, [r3]
   11f28:	e3530000 	cmp	r3, #0	; 0x0
   11f2c:	e59f104c 	ldr	r1, [pc, #76]	; 11f80 <.text+0x1f80>
   11f30:	1a000004 	bne	11f48 <rootDirectory_files_stream+0x48>
   11f34:	e59f303c 	ldr	r3, [pc, #60]	; 11f78 <.text+0x1f78>
   11f38:	e5930000 	ldr	r0, [r3]
   11f3c:	eb0005f4 	bl	13714 <fat16_read_dir>
   11f40:	e3500000 	cmp	r0, #0	; 0x0
   11f44:	0a000009 	beq	11f70 <rootDirectory_files_stream+0x70>
   11f48:	e59f102c 	ldr	r1, [pc, #44]	; 11f7c <.text+0x1f7c>
   11f4c:	e59f302c 	ldr	r3, [pc, #44]	; 11f80 <.text+0x1f80>
   11f50:	e5912000 	ldr	r2, [r1]
   11f54:	e7d33002 	ldrb	r3, [r3, r2]
   11f58:	e2822001 	add	r2, r2, #1	; 0x1
   11f5c:	e3530000 	cmp	r3, #0	; 0x0
   11f60:	05813000 	streq	r3, [r1]
   11f64:	15812000 	strne	r2, [r1]
   11f68:	e3a0002c 	mov	r0, #44	; 0x2c
   11f6c:	11a00003 	movne	r0, r3
   11f70:	e49de004 	ldr	lr, [sp], #4
   11f74:	e12fff1e 	bx	lr
   11f78:	40001270 	andmi	r1, r0, r0, ror r2
   11f7c:	40000d1c 	andmi	r0, r0, ip, lsl sp
   11f80:	4000123c 	andmi	r1, r0, ip, lsr r2

00011f84 <print_disk_info>:
   11f84:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   11f88:	e2505000 	subs	r5, r0, #0	; 0x0
   11f8c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
   11f90:	e1a0400d 	mov	r4, sp
   11f94:	e1a0000d 	mov	r0, sp
   11f98:	0a00002d 	beq	12054 <print_disk_info+0xd0>
   11f9c:	eb0000f2 	bl	1236c <sd_raw_get_info>
   11fa0:	e3500000 	cmp	r0, #0	; 0x0
   11fa4:	e59f00b8 	ldr	r0, [pc, #184]	; 12064 <.text+0x2064>
   11fa8:	0a000029 	beq	12054 <print_disk_info+0xd0>
   11fac:	e5dd1000 	ldrb	r1, [sp]
   11fb0:	ebfffe7a 	bl	119a0 <rprintf>
   11fb4:	e59f00ac 	ldr	r0, [pc, #172]	; 12068 <.text+0x2068>
   11fb8:	e28d1001 	add	r1, sp, #1	; 0x1
   11fbc:	ebfffe77 	bl	119a0 <rprintf>
   11fc0:	e28d1004 	add	r1, sp, #4	; 0x4
   11fc4:	e59f00a0 	ldr	r0, [pc, #160]	; 1206c <.text+0x206c>
   11fc8:	ebfffe74 	bl	119a0 <rprintf>
   11fcc:	e59f009c 	ldr	r0, [pc, #156]	; 12070 <.text+0x2070>
   11fd0:	e5dd100a 	ldrb	r1, [sp, #10]
   11fd4:	ebfffe71 	bl	119a0 <rprintf>
   11fd8:	e59f0094 	ldr	r0, [pc, #148]	; 12074 <.text+0x2074>
   11fdc:	e59d100c 	ldr	r1, [sp, #12]
   11fe0:	ebfffe6e 	bl	119a0 <rprintf>
   11fe4:	e5dd2010 	ldrb	r2, [sp, #16]
   11fe8:	e59f0088 	ldr	r0, [pc, #136]	; 12078 <.text+0x2078>
   11fec:	e5dd1011 	ldrb	r1, [sp, #17]
   11ff0:	ebfffe6a 	bl	119a0 <rprintf>
   11ff4:	e59f0080 	ldr	r0, [pc, #128]	; 1207c <.text+0x207c>
   11ff8:	e59d1014 	ldr	r1, [sp, #20]
   11ffc:	ebfffe67 	bl	119a0 <rprintf>
   12000:	e59f0078 	ldr	r0, [pc, #120]	; 12080 <.text+0x2080>
   12004:	e5dd1018 	ldrb	r1, [sp, #24]
   12008:	ebfffe64 	bl	119a0 <rprintf>
   1200c:	e5dd2019 	ldrb	r2, [sp, #25]
   12010:	e59f006c 	ldr	r0, [pc, #108]	; 12084 <.text+0x2084>
   12014:	e5dd101a 	ldrb	r1, [sp, #26]
   12018:	ebfffe60 	bl	119a0 <rprintf>
   1201c:	e5dd101b 	ldrb	r1, [sp, #27]
   12020:	e59f0060 	ldr	r0, [pc, #96]	; 12088 <.text+0x2088>
   12024:	ebfffe5d 	bl	119a0 <rprintf>
   12028:	e1a00005 	mov	r0, r5
   1202c:	eb000575 	bl	13608 <fat16_get_fs_free>
   12030:	e1a04000 	mov	r4, r0
   12034:	e1a00005 	mov	r0, r5
   12038:	eb000569 	bl	135e4 <fat16_get_fs_size>
   1203c:	e1a01004 	mov	r1, r4
   12040:	e1a02000 	mov	r2, r0
   12044:	e59f0040 	ldr	r0, [pc, #64]	; 1208c <.text+0x208c>
   12048:	ebfffe54 	bl	119a0 <rprintf>
   1204c:	e3a00001 	mov	r0, #1	; 0x1
   12050:	ea000000 	b	12058 <print_disk_info+0xd4>
   12054:	e3a00000 	mov	r0, #0	; 0x0
   12058:	e28dd01c 	add	sp, sp, #28	; 0x1c
   1205c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12060:	e12fff1e 	bx	lr
   12064:	000189f0 	streqd	r8, [r1], -r0
   12068:	00018a04 	andeq	r8, r1, r4, lsl #20
   1206c:	00018a14 	andeq	r8, r1, r4, lsl sl
   12070:	00018a24 	andeq	r8, r1, r4, lsr #20
   12074:	00018a34 	andeq	r8, r1, r4, lsr sl
   12078:	00018a48 	andeq	r8, r1, r8, asr #20
   1207c:	00018a5c 	andeq	r8, r1, ip, asr sl
   12080:	00018a6c 	andeq	r8, r1, ip, ror #20
   12084:	00018a7c 	andeq	r8, r1, ip, ror sl
   12088:	00018a8c 	andeq	r8, r1, ip, lsl #21
   1208c:	00018a9c 	muleq	r1, ip, sl

00012090 <root_disk_info>:
   12090:	e59f3004 	ldr	r3, [pc, #4]	; 1209c <.text+0x209c>
   12094:	e5930000 	ldr	r0, [r3]
   12098:	eaffffb9 	b	11f84 <print_disk_info>
   1209c:	40001238 	andmi	r1, r0, r8, lsr r2

000120a0 <root_open>:
   120a0:	e59f301c 	ldr	r3, [pc, #28]	; 120c4 <.text+0x20c4>
   120a4:	e5931000 	ldr	r1, [r3]
   120a8:	e59f3018 	ldr	r3, [pc, #24]	; 120c8 <.text+0x20c8>
   120ac:	e1a02000 	mov	r2, r0
   120b0:	e52de004 	str	lr, [sp, #-4]!
   120b4:	e5930000 	ldr	r0, [r3]
   120b8:	eb000839 	bl	141a4 <open_file_in_dir>
   120bc:	e49de004 	ldr	lr, [sp], #4
   120c0:	e12fff1e 	bx	lr
   120c4:	40001270 	andmi	r1, r0, r0, ror r2
   120c8:	40001238 	andmi	r1, r0, r8, lsr r2

000120cc <root_open_new>:
   120cc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   120d0:	e59f5030 	ldr	r5, [pc, #48]	; 12108 <.text+0x2108>
   120d4:	e1a04000 	mov	r4, r0
   120d8:	e1a01000 	mov	r1, r0
   120dc:	e59f2028 	ldr	r2, [pc, #40]	; 1210c <.text+0x210c>
   120e0:	e5950000 	ldr	r0, [r5]
   120e4:	eb000905 	bl	14500 <fat16_create_file>
   120e8:	e3500000 	cmp	r0, #0	; 0x0
   120ec:	e1a02004 	mov	r2, r4
   120f0:	159f3018 	ldrne	r3, [pc, #24]	; 12110 <.text+0x2110>
   120f4:	15951000 	ldrne	r1, [r5]
   120f8:	15930000 	ldrne	r0, [r3]
   120fc:	1b000828 	blne	141a4 <open_file_in_dir>
   12100:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12104:	e12fff1e 	bx	lr
   12108:	40001270 	andmi	r1, r0, r0, ror r2
   1210c:	4000123c 	andmi	r1, r0, ip, lsr r2
   12110:	40001238 	andmi	r1, r0, r8, lsr r2

00012114 <openroot>:
   12114:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12118:	e3a03000 	mov	r3, #0	; 0x0
   1211c:	e59f10ac 	ldr	r1, [pc, #172]	; 121d0 <.text+0x21d0>
   12120:	e59f20ac 	ldr	r2, [pc, #172]	; 121d4 <.text+0x21d4>
   12124:	e59f00ac 	ldr	r0, [pc, #172]	; 121d8 <.text+0x21d8>
   12128:	eb000970 	bl	146f0 <partition_open>
   1212c:	e59f40a8 	ldr	r4, [pc, #168]	; 121dc <.text+0x21dc>
   12130:	e1a0c000 	mov	ip, r0
   12134:	e35c0000 	cmp	ip, #0	; 0x0
   12138:	e3e03000 	mvn	r3, #0	; 0x0
   1213c:	e59f108c 	ldr	r1, [pc, #140]	; 121d0 <.text+0x21d0>
   12140:	e59f208c 	ldr	r2, [pc, #140]	; 121d4 <.text+0x21d4>
   12144:	e59f008c 	ldr	r0, [pc, #140]	; 121d8 <.text+0x21d8>
   12148:	e59f5090 	ldr	r5, [pc, #144]	; 121e0 <.text+0x21e0>
   1214c:	e584c000 	str	ip, [r4]
   12150:	1a000005 	bne	1216c <openroot+0x58>
   12154:	eb000965 	bl	146f0 <partition_open>
   12158:	e1a03000 	mov	r3, r0
   1215c:	e3530000 	cmp	r3, #0	; 0x0
   12160:	e59f007c 	ldr	r0, [pc, #124]	; 121e4 <.text+0x21e4>
   12164:	e5843000 	str	r3, [r4]
   12168:	0a000013 	beq	121bc <openroot+0xa8>
   1216c:	e59f3068 	ldr	r3, [pc, #104]	; 121dc <.text+0x21dc>
   12170:	e5930000 	ldr	r0, [r3]
   12174:	eb000864 	bl	1430c <fat16_open>
   12178:	e3500000 	cmp	r0, #0	; 0x0
   1217c:	e5850000 	str	r0, [r5]
   12180:	e59f2060 	ldr	r2, [pc, #96]	; 121e8 <.text+0x21e8>
   12184:	e59f1060 	ldr	r1, [pc, #96]	; 121ec <.text+0x21ec>
   12188:	059f0060 	ldreq	r0, [pc, #96]	; 121f0 <.text+0x21f0>
   1218c:	0a00000a 	beq	121bc <openroot+0xa8>
   12190:	eb000814 	bl	141e8 <fat16_get_dir_entry_of_path>
   12194:	e59f104c 	ldr	r1, [pc, #76]	; 121e8 <.text+0x21e8>
   12198:	e5950000 	ldr	r0, [r5]
   1219c:	eb0007c0 	bl	140a4 <fat16_open_dir>
   121a0:	e59f304c 	ldr	r3, [pc, #76]	; 121f4 <.text+0x21f4>
   121a4:	e1a02000 	mov	r2, r0
   121a8:	e3500000 	cmp	r0, #0	; 0x0
   121ac:	e3a01000 	mov	r1, #0	; 0x0
   121b0:	e59f0040 	ldr	r0, [pc, #64]	; 121f8 <.text+0x21f8>
   121b4:	e5832000 	str	r2, [r3]
   121b8:	1a000001 	bne	121c4 <openroot+0xb0>
   121bc:	ebfffdf7 	bl	119a0 <rprintf>
   121c0:	e3a01001 	mov	r1, #1	; 0x1
   121c4:	e1a00001 	mov	r0, r1
   121c8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   121cc:	e12fff1e 	bx	lr
   121d0:	000129bc 	streqh	r2, [r1], -ip
   121d4:	00012760 	andeq	r2, r1, r0, ror #14
   121d8:	00012600 	andeq	r2, r1, r0, lsl #12
   121dc:	4000126c 	andmi	r1, r0, ip, ror #4
   121e0:	40001238 	andmi	r1, r0, r8, lsr r2
   121e4:	00018ab0 	streqh	r8, [r1], -r0
   121e8:	4000123c 	andmi	r1, r0, ip, lsr r2
   121ec:	00018ae8 	andeq	r8, r1, r8, ror #21
   121f0:	00018acc 	andeq	r8, r1, ip, asr #21
   121f4:	40001270 	andmi	r1, r0, r0, ror r2
   121f8:	00018aec 	andeq	r8, r1, ip, ror #21

000121fc <sd_raw_available>:
 */
unsigned char sd_raw_available()
{
    unsigned int i;
    configure_pin_available();
   121fc:	e59f2028 	ldr	r2, [pc, #40]	; 1222c <.text+0x222c>
   12200:	e5923008 	ldr	r3, [r2, #8]
   12204:	e3c33080 	bic	r3, r3, #128	; 0x80
   12208:	e5823008 	str	r3, [r2, #8]
    for(i=0;i<100000;i++);
    i = get_pin_available();
   1220c:	e5921000 	ldr	r1, [r2]
    configure_pin_ss();
   12210:	e5923008 	ldr	r3, [r2, #8]
   12214:	e3110080 	tst	r1, #128	; 0x80
   12218:	e3833080 	orr	r3, r3, #128	; 0x80
    return i == 0x00;
}
   1221c:	03a00000 	moveq	r0, #0	; 0x0
   12220:	13a00001 	movne	r0, #1	; 0x1
   12224:	e5823008 	str	r3, [r2, #8]
   12228:	e12fff1e 	bx	lr
   1222c:	e0028000 	and	r8, r2, r0

00012230 <sd_raw_locked>:

/**
 * \ingroup sd_raw
 * Checks wether the memory card is locked for write access.
 *
 * \returns 1 if the card is locked, 0 if it is not.
 */
unsigned char sd_raw_locked()
{
    return get_pin_locked() == 0x00;
}
   12230:	e3a00001 	mov	r0, #1	; 0x1
   12234:	e12fff1e 	bx	lr

00012238 <sd_raw_rec_byte>:

/**
 * \ingroup sd_raw
 * Sends a raw byte to the memory card.
 *
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(unsigned char b)
{
    S0SPDR = b;
    /* wait for byte to be shifted out */
    while(!(S0SPSR & 0x80));
}

/**
 * \ingroup sd_raw
 * Receives a raw byte from the memory card.
 *
 * \returns The byte which should be read.
 * \see sd_raw_send_byte
 */
unsigned char sd_raw_rec_byte(void)
{
    /* send dummy data for receiving some */
    S0SPDR = 0xff;
   12238:	e59f3020 	ldr	r3, [pc, #32]	; 12260 <.text+0x2260>
   1223c:	e3a020ff 	mov	r2, #255	; 0xff
   12240:	e5832008 	str	r2, [r3, #8]
    while(!(S0SPSR & 0x80));
   12244:	e59f2014 	ldr	r2, [pc, #20]	; 12260 <.text+0x2260>
   12248:	e5923004 	ldr	r3, [r2, #4]
   1224c:	e3130080 	tst	r3, #128	; 0x80
   12250:	0afffffb 	beq	12244 <sd_raw_rec_byte+0xc>

    return S0SPDR;
   12254:	e5920008 	ldr	r0, [r2, #8]
   12258:	e20000ff 	and	r0, r0, #255	; 0xff
}
   1225c:	e12fff1e 	bx	lr
   12260:	e0020000 	and	r0, r2, r0

00012264 <sd_raw_send_command_r1>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R1 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
{
   12264:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12268:	e20050ff 	and	r5, r0, #255	; 0xff
   1226c:	e1a04001 	mov	r4, r1
    unsigned char response;
    unsigned char i;

    /* wait some clock cycles */
    sd_raw_rec_byte();
   12270:	ebfffff0 	bl	12238 <sd_raw_rec_byte>
   12274:	e59f30c4 	ldr	r3, [pc, #196]	; 12340 <.text+0x2340>
   12278:	e3852040 	orr	r2, r5, #64	; 0x40
   1227c:	e5832008 	str	r2, [r3, #8]
   12280:	e59f20b8 	ldr	r2, [pc, #184]	; 12340 <.text+0x2340>
   12284:	e5923004 	ldr	r3, [r2, #4]
   12288:	e3130080 	tst	r3, #128	; 0x80
   1228c:	0afffffb 	beq	12280 <sd_raw_send_command_r1+0x1c>
   12290:	e1a03c24 	mov	r3, r4, lsr #24
   12294:	e5823008 	str	r3, [r2, #8]
   12298:	e59f20a0 	ldr	r2, [pc, #160]	; 12340 <.text+0x2340>
   1229c:	e5923004 	ldr	r3, [r2, #4]
   122a0:	e3130080 	tst	r3, #128	; 0x80
   122a4:	0afffffb 	beq	12298 <sd_raw_send_command_r1+0x34>
   122a8:	e1a03824 	mov	r3, r4, lsr #16
   122ac:	e20330ff 	and	r3, r3, #255	; 0xff
   122b0:	e5823008 	str	r3, [r2, #8]
   122b4:	e59f2084 	ldr	r2, [pc, #132]	; 12340 <.text+0x2340>
   122b8:	e5923004 	ldr	r3, [r2, #4]
   122bc:	e3130080 	tst	r3, #128	; 0x80
   122c0:	0afffffb 	beq	122b4 <sd_raw_send_command_r1+0x50>
   122c4:	e1a03424 	mov	r3, r4, lsr #8
   122c8:	e20330ff 	and	r3, r3, #255	; 0xff
   122cc:	e5823008 	str	r3, [r2, #8]
   122d0:	e59f2068 	ldr	r2, [pc, #104]	; 12340 <.text+0x2340>
   122d4:	e5923004 	ldr	r3, [r2, #4]
   122d8:	e3130080 	tst	r3, #128	; 0x80
   122dc:	0afffffb 	beq	122d0 <sd_raw_send_command_r1+0x6c>
   122e0:	e20430ff 	and	r3, r4, #255	; 0xff
   122e4:	e5823008 	str	r3, [r2, #8]
   122e8:	e59f2050 	ldr	r2, [pc, #80]	; 12340 <.text+0x2340>
   122ec:	e5923004 	ldr	r3, [r2, #4]
   122f0:	e3130080 	tst	r3, #128	; 0x80
   122f4:	0afffffb 	beq	122e8 <sd_raw_send_command_r1+0x84>
   122f8:	e3550000 	cmp	r5, #0	; 0x0
   122fc:	13a030ff 	movne	r3, #255	; 0xff
   12300:	03a03095 	moveq	r3, #149	; 0x95
   12304:	e5823008 	str	r3, [r2, #8]
   12308:	e59f3030 	ldr	r3, [pc, #48]	; 12340 <.text+0x2340>
   1230c:	e5933004 	ldr	r3, [r3, #4]
   12310:	e3130080 	tst	r3, #128	; 0x80
   12314:	0afffffb 	beq	12308 <sd_raw_send_command_r1+0xa4>
   12318:	e3a04000 	mov	r4, #0	; 0x0

    /* send command via SPI */
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);

    /* receive response */
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
   1231c:	ebffffc5 	bl	12238 <sd_raw_rec_byte>
   12320:	e2843001 	add	r3, r4, #1	; 0x1
        if(response != 0xff)
   12324:	e35000ff 	cmp	r0, #255	; 0xff
   12328:	e20340ff 	and	r4, r3, #255	; 0xff
   1232c:	1a000001 	bne	12338 <sd_raw_send_command_r1+0xd4>
   12330:	e354000a 	cmp	r4, #10	; 0xa
   12334:	1afffff8 	bne	1231c <sd_raw_send_command_r1+0xb8>
            break;
    }

    return response;
}
   12338:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1233c:	e12fff1e 	bx	lr
   12340:	e0020000 	and	r0, r2, r0

00012344 <SDoff>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R2 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
/*
unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
{
    unsigned short response;
    unsigned char i;

    // wait some clock cycles
    sd_raw_rec_byte();

    // send command via SPI
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);

    // receive response
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
        if(response != 0xff)
            break;
    }
    response <<= 8;
    response |= sd_raw_rec_byte();

    return response;
}
*/

/**
 * \ingroup sd_raw
 * Reads raw data from the card.
 *
 * \param[in] offset The offset from which to read.
 * \param[out] buffer The buffer into which to write the data.
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write
 */
unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
{
    unsigned int block_address;
    unsigned short block_offset;
    unsigned short read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_address = offset & 0xfffffe00;
        block_offset = offset & 0x01ff;
        read_length = 512 - block_offset; /* read up to block border */
        if(read_length > length)
            read_length = length;

        #if !SD_RAW_SAVE_RAM
            /* check if the requested data is cached */
            if(block_address != raw_block_address)
            #endif
        {
            #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            /* address card */
            select_card();

            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
            {
                unselect_card();
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);

            #if SD_RAW_SAVE_RAM
                /* read byte block */
                unsigned short read_to = block_offset + read_length;
                for(unsigned short i = 0; i < 512; ++i)
                {
                    unsigned char b = sd_raw_rec_byte();
                    if(i >= block_offset && i < read_to)
                        *buffer++ = b;
                }
            #else
                /* read byte block */
                unsigned char* cache = raw_block;
                unsigned short i;
                for(i = 0; i < 512; ++i)
                    *cache++ = sd_raw_rec_byte();
                raw_block_address = block_address;
    
                memcpy(buffer, raw_block + block_offset, read_length);
                buffer += read_length;
            #endif

            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();

            /* deaddress card */
            unselect_card();

            /* let card some time to finish */
            sd_raw_rec_byte();
        }
        #if !SD_RAW_SAVE_RAM
            else
            {
                /* use cached data */
                memcpy(buffer, raw_block + block_offset, read_length);
            }
        #endif

        length -= read_length;
        offset += read_length;
    }

    return 1;
}

/**
 * \ingroup sd_raw
 * Continuously reads units of \c interval bytes and calls a callback function.
 *
 * This function starts reading at the specified offset. Every \c interval bytes,
 * it calls the callback function with the associated data buffer.
 *
 * By returning zero, the callback may stop reading.
 *
 * \note Within the callback function, you can not start another read or
 *       write operation.
 * \note This function only works if the following conditions are met:
 *       - (offset - (offset % 512)) % interval == 0
 *       - length % interval == 0
 *
 * \param[in] offset Offset from which to start reading.
 * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 * \param[in] interval Number of bytes to read before calling the callback function.
 * \param[in] length Number of bytes to read altogether.
 * \param[in] callback The function to call every interval bytes.
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read, sd_raw_write
 */
unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short interval, unsigned short length, sd_raw_interval_handler callback, void* p)
{
    if(!buffer || interval == 0 || length < interval || !callback)
        return 0;

    #if !SD_RAW_SAVE_RAM
        while(length >= interval)
        {
            /* as reading is now buffered, we directly
                     * hand over the request to sd_raw_read()
                     */
            if(!sd_raw_read(offset, buffer, interval))
                return 0;
            if(!callback(buffer, offset, p))
                break;
            offset += interval;
            length -= interval;
        }
    
        return 1;
    #else
        /* address card */
        select_card();
    
        unsigned short block_offset;
        unsigned short read_length;
        unsigned char* buffer_cur;
        unsigned char finished = 0;
        do
        {
            /* determine byte count to read at once */
            block_offset = offset & 0x01ff;
            read_length = 512 - block_offset;
    
            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
            {
                unselect_card();
                return 0;
            }
    
            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
            unsigned short i;
            /* read up to the data of interest */
            for(i = 0; i < block_offset; ++i)
                sd_raw_rec_byte();
    
            /* read interval bytes of data and execute the callback */
            do
            {
                if(read_length < interval || length < interval)
                    break;
    
                buffer_cur = buffer;
                for(i = 0; i < interval; ++i)
                    *buffer_cur++ = sd_raw_rec_byte();
    
                if(!callback(buffer, offset + (512 - read_length), p))
                {
                    finished = 1;
                    break;
                }
    
                read_length -= interval;
                length -= interval;
    
            }
            while(read_length > 0 && length > 0);
    
            /* read rest of data block */
            while(read_length-- > 0)
                sd_raw_rec_byte();
    
            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();
    
            if(length < interval)
                break;
    
            offset = (offset & 0xfffffe00) + 512;
    
        }
        while(!finished);
    
        /* deaddress card */
        unselect_card();
    
        /* let card some time to finish */
        sd_raw_rec_byte();
    
        return 1;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes raw data to the card.
 *
 * \note If write buffering is enabled, you might have to
 *       call sd_raw_sync() before disconnecting the card
 *       to ensure all remaining data has been written.
 *
 * \param[in] offset The offset where to start writing.
 * \param[in] buffer The buffer containing the data to be written.
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read
 */
unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
{
    #if SD_RAW_WRITE_SUPPORT
    
        if(get_pin_locked())
            return 0;
    
        unsigned int block_address;
        unsigned short block_offset;
        unsigned short write_length;
        while(length > 0)
        {
            /* determine byte count to write at once */
            block_address = offset & 0xfffffe00;
            block_offset = offset & 0x01ff;
            write_length = 512 - block_offset; /* write up to block border */
            if(write_length > length)
                write_length = length;
    
            /* Merge the data to write with the content of the block.
                     * Use the cached block if available.
                     */
            if(block_address != raw_block_address)
            {
                #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            if(block_offset || write_length < 512)
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
                    return 0;
            }
            raw_block_address = block_address;
        }

        if(buffer != raw_block)
        {
            memcpy(raw_block + block_offset, buffer, write_length);

            #if SD_RAW_WRITE_BUFFERING
                raw_block_written = 0;
    
                if(length == write_length)
                    return 1;
            #endif
        }

        buffer += write_length;

        /* address card */
        select_card();

        /* send single block request */
        if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
        {
            unselect_card();
            return 0;
        }

        /* send start byte */
        sd_raw_send_byte(0xfe);

        /* write byte block */
        unsigned char* cache = raw_block;
        unsigned short i;
        for(i = 0; i < 512; ++i)
            sd_raw_send_byte(*cache++);

        /* write dummy crc16 */
        sd_raw_send_byte(0xff);
        sd_raw_send_byte(0xff);

        /* wait while card is busy */
        while(sd_raw_rec_byte() != 0xff);
        sd_raw_rec_byte();

        /* deaddress card */
        unselect_card();

        length -= write_length;
        offset += write_length;

        #if SD_RAW_WRITE_BUFFERING
            raw_block_written = 1;
        #endif
    }

    return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes the write buffer's content to the card.
 *
 * \note When write buffering is enabled, you should
 *       call this function before disconnecting the
 *       card to ensure all remaining data has been
 *       written.
 *
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write
 */
unsigned char sd_raw_sync()
{
    #if SD_RAW_WRITE_SUPPORT
        #if SD_RAW_WRITE_BUFFERING
        if(raw_block_written)
            return 1;
        if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
            return 0;
    #endif
    return 1;
    #else
    return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Reads informational data from the card.
 *
 * This function reads and returns the card's registers
 * containing manufacturing and status information.
 *
 * \note: The information retrieved by this function is
 *        not required in any way to operate on the card,
 *        but it might be nice to display some of the data
 *        to the user.
 *
 * \param[in] info A pointer to the structure into which to save the information.
 * \returns 0 on failure, 1 on success.
 */
unsigned char sd_raw_get_info(struct sd_raw_info* info)
{
    if(!info || !sd_raw_available())
        return 0;

    memset(info, 0, sizeof(*info));

    select_card();

    /* read cid register */
    if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    unsigned char i;
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 0:
                info->manufacturer = b;
                break;
            case 1:
            case 2:
                info->oem[i - 1] = b;
                break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                info->product[i - 3] = b;
                break;
            case 8:
                info->revision = b;
                break;
            case 9:
            case 10:
            case 11:
            case 12:
                info->serial |= (unsigned int) b << ((12 - i) * 8);
                break;
            case 13:
                info->manufacturing_year = b << 4;
                break;
            case 14:
                info->manufacturing_year |= b >> 4;
                info->manufacturing_month = b & 0x0f;
                break;
        }
    }

    /* read csd register */
    unsigned char csd_read_bl_len = 0;
    unsigned char csd_c_size_mult = 0;
    unsigned short csd_c_size = 0;
    if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 5:
                csd_read_bl_len = b & 0x0f;
                break;
            case 6:
                csd_c_size = (unsigned short) (b & 0x03) << 8;
                break;
            case 7:
                csd_c_size |= b;
                csd_c_size <<= 2;
                break;
            case 8:
                csd_c_size |= b >> 6;
                ++csd_c_size;
                break;
            case 9:
                csd_c_size_mult = (b & 0x03) << 1;
                break;
            case 10:
                csd_c_size_mult |= b >> 7;

                info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);

                break;
            case 14:
                if(b & 0x40)
                    info->flag_copy = 1;
                if(b & 0x20)
                    info->flag_write_protect = 1;
                if(b & 0x10)
                    info->flag_write_protect_temp = 1;
                info->format = (b & 0x0c) >> 2;
                break;
        }
    }

    unselect_card();

    return 1;
}

void SDoff(void)
{
    IODIR1 &= ~(CS);
   12344:	e59f201c 	ldr	r2, [pc, #28]	; 12368 <.text+0x2368>
   12348:	e5923018 	ldr	r3, [r2, #24]
   1234c:	e3c33080 	bic	r3, r3, #128	; 0x80
   12350:	e5823018 	str	r3, [r2, #24]
    PINSEL0 &= ~(0x1500);
   12354:	e2822901 	add	r2, r2, #16384	; 0x4000
   12358:	e5923000 	ldr	r3, [r2]
   1235c:	e3c33c15 	bic	r3, r3, #5376	; 0x1500
   12360:	e5823000 	str	r3, [r2]
}
   12364:	e12fff1e 	bx	lr
   12368:	e0028000 	and	r8, r2, r0

0001236c <sd_raw_get_info>:
   1236c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12370:	e2504000 	subs	r4, r0, #0	; 0x0
   12374:	0a000097 	beq	125d8 <.text+0x25d8>
   12378:	ebffff9f 	bl	121fc <sd_raw_available>
   1237c:	e3500000 	cmp	r0, #0	; 0x0
   12380:	0a000094 	beq	125d8 <.text+0x25d8>
   12384:	e59f5270 	ldr	r5, [pc, #624]	; 125fc <.text+0x25fc>
   12388:	e3a01000 	mov	r1, #0	; 0x0
   1238c:	e3a0201c 	mov	r2, #28	; 0x1c
   12390:	e1a00004 	mov	r0, r4
   12394:	eb00158e 	bl	179d4 <memset>
   12398:	e595300c 	ldr	r3, [r5, #12]
   1239c:	e3833080 	orr	r3, r3, #128	; 0x80
   123a0:	e3a0000a 	mov	r0, #10	; 0xa
   123a4:	e3a01000 	mov	r1, #0	; 0x0
   123a8:	e585300c 	str	r3, [r5, #12]
   123ac:	ebffffac 	bl	12264 <sd_raw_send_command_r1>
   123b0:	e3500000 	cmp	r0, #0	; 0x0
   123b4:	15953004 	ldrne	r3, [r5, #4]
   123b8:	13a00000 	movne	r0, #0	; 0x0
   123bc:	13833080 	orrne	r3, r3, #128	; 0x80
   123c0:	15853004 	strne	r3, [r5, #4]
   123c4:	1a00008a 	bne	125f4 <.text+0x25f4>
   123c8:	ebffff9a 	bl	12238 <sd_raw_rec_byte>
   123cc:	e35000fe 	cmp	r0, #254	; 0xfe
   123d0:	1afffffc 	bne	123c8 <sd_raw_get_info+0x5c>
   123d4:	ebffff97 	bl	12238 <sd_raw_rec_byte>
   123d8:	e3a05000 	mov	r5, #0	; 0x0
   123dc:	ea000012 	b	1242c <.text+0x242c>
   123e0:	ebffff94 	bl	12238 <sd_raw_rec_byte>
   123e4:	e355000e 	cmp	r5, #14	; 0xe
   123e8:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
   123ec:	ea000026 	b	1248c <.text+0x248c>
   123f0:	0001242c 	andeq	r2, r1, ip, lsr #8
   123f4:	00012434 	andeq	r2, r1, r4, lsr r4
   123f8:	00012434 	andeq	r2, r1, r4, lsr r4
   123fc:	0001243c 	andeq	r2, r1, ip, lsr r4
   12400:	0001243c 	andeq	r2, r1, ip, lsr r4
   12404:	0001243c 	andeq	r2, r1, ip, lsr r4
   12408:	0001243c 	andeq	r2, r1, ip, lsr r4
   1240c:	0001243c 	andeq	r2, r1, ip, lsr r4
   12410:	00012448 	andeq	r2, r1, r8, asr #8
   12414:	00012450 	andeq	r2, r1, r0, asr r4
   12418:	00012450 	andeq	r2, r1, r0, asr r4
   1241c:	00012450 	andeq	r2, r1, r0, asr r4
   12420:	00012450 	andeq	r2, r1, r0, asr r4
   12424:	00012468 	andeq	r2, r1, r8, ror #8
   12428:	00012474 	andeq	r2, r1, r4, ror r4
   1242c:	e5c40000 	strb	r0, [r4]
   12430:	ea00006a 	b	125e0 <.text+0x25e0>
   12434:	e7c50004 	strb	r0, [r5, r4]
   12438:	ea000013 	b	1248c <.text+0x248c>
   1243c:	e0853004 	add	r3, r5, r4
   12440:	e5c30001 	strb	r0, [r3, #1]
   12444:	ea000010 	b	1248c <.text+0x248c>
   12448:	e5c4000a 	strb	r0, [r4, #10]
   1244c:	ea000063 	b	125e0 <.text+0x25e0>
   12450:	e594200c 	ldr	r2, [r4, #12]
   12454:	e265300c 	rsb	r3, r5, #12	; 0xc
   12458:	e1a03183 	mov	r3, r3, lsl #3
   1245c:	e1822310 	orr	r2, r2, r0, lsl r3
   12460:	e584200c 	str	r2, [r4, #12]
   12464:	ea000008 	b	1248c <.text+0x248c>
   12468:	e1a03200 	mov	r3, r0, lsl #4
   1246c:	e5c43010 	strb	r3, [r4, #16]
   12470:	ea00005a 	b	125e0 <.text+0x25e0>
   12474:	e5d43010 	ldrb	r3, [r4, #16]
   12478:	e200200f 	and	r2, r0, #15	; 0xf
   1247c:	e1833220 	orr	r3, r3, r0, lsr #4
   12480:	e5c43010 	strb	r3, [r4, #16]
   12484:	e5c42011 	strb	r2, [r4, #17]
   12488:	ea000054 	b	125e0 <.text+0x25e0>
   1248c:	e2853001 	add	r3, r5, #1	; 0x1
   12490:	e20350ff 	and	r5, r3, #255	; 0xff
   12494:	e3550011 	cmp	r5, #17	; 0x11
   12498:	9affffd0 	bls	123e0 <sd_raw_get_info+0x74>
   1249c:	e3a00009 	mov	r0, #9	; 0x9
   124a0:	e3a01000 	mov	r1, #0	; 0x0
   124a4:	ebffff6e 	bl	12264 <sd_raw_send_command_r1>
   124a8:	e3500000 	cmp	r0, #0	; 0x0
   124ac:	159f2148 	ldrne	r2, [pc, #328]	; 125fc <.text+0x25fc>
   124b0:	15923004 	ldrne	r3, [r2, #4]
   124b4:	13a00000 	movne	r0, #0	; 0x0
   124b8:	13833080 	orrne	r3, r3, #128	; 0x80
   124bc:	1a000043 	bne	125d0 <.text+0x25d0>
   124c0:	ebffff5c 	bl	12238 <sd_raw_rec_byte>
   124c4:	e35000fe 	cmp	r0, #254	; 0xfe
   124c8:	1afffffc 	bne	124c0 <.text+0x24c0>
   124cc:	ebffff59 	bl	12238 <sd_raw_rec_byte>
   124d0:	e3a07000 	mov	r7, #0	; 0x0
   124d4:	e3a05001 	mov	r5, #1	; 0x1
   124d8:	e1a08007 	mov	r8, r7
   124dc:	e1a06007 	mov	r6, r7
   124e0:	ebffff54 	bl	12238 <sd_raw_rec_byte>
   124e4:	e2453005 	sub	r3, r5, #5	; 0x5
   124e8:	e2852001 	add	r2, r5, #1	; 0x1
   124ec:	e3530009 	cmp	r3, #9	; 0x9
   124f0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   124f4:	ea00002e 	b	125b4 <.text+0x25b4>
   124f8:	00012520 	andeq	r2, r1, r0, lsr #10
   124fc:	00012528 	andeq	r2, r1, r8, lsr #10
   12500:	00012534 	andeq	r2, r1, r4, lsr r5
   12504:	00012540 	andeq	r2, r1, r0, asr #10
   12508:	00012558 	andeq	r2, r1, r8, asr r5
   1250c:	00012564 	andeq	r2, r1, r4, ror #10
   12510:	000125b4 	streqh	r2, [r1], -r4
   12514:	000125b4 	streqh	r2, [r1], -r4
   12518:	000125b4 	streqh	r2, [r1], -r4
   1251c:	00012580 	andeq	r2, r1, r0, lsl #11
   12520:	e200800f 	and	r8, r0, #15	; 0xf
   12524:	ea000030 	b	125ec <.text+0x25ec>
   12528:	e2003003 	and	r3, r0, #3	; 0x3
   1252c:	e1a06403 	mov	r6, r3, lsl #8
   12530:	ea00002d 	b	125ec <.text+0x25ec>
   12534:	e1863000 	orr	r3, r6, r0
   12538:	e1a03903 	mov	r3, r3, lsl #18
   1253c:	ea000003 	b	12550 <.text+0x2550>
   12540:	e1a03900 	mov	r3, r0, lsl #18
   12544:	e1863c23 	orr	r3, r6, r3, lsr #24
   12548:	e2833001 	add	r3, r3, #1	; 0x1
   1254c:	e1a03803 	mov	r3, r3, lsl #16
   12550:	e1a06823 	mov	r6, r3, lsr #16
   12554:	ea000024 	b	125ec <.text+0x25ec>
   12558:	e2003003 	and	r3, r0, #3	; 0x3
   1255c:	e1a07083 	mov	r7, r3, lsl #1
   12560:	ea000021 	b	125ec <.text+0x25ec>
   12564:	e18733a0 	orr	r3, r7, r0, lsr #7
   12568:	e20370ff 	and	r7, r3, #255	; 0xff
   1256c:	e2883002 	add	r3, r8, #2	; 0x2
   12570:	e0873003 	add	r3, r7, r3
   12574:	e1a03316 	mov	r3, r6, lsl r3
   12578:	e5843014 	str	r3, [r4, #20]
   1257c:	ea00001a 	b	125ec <.text+0x25ec>
   12580:	e3100040 	tst	r0, #64	; 0x40
   12584:	13a03001 	movne	r3, #1	; 0x1
   12588:	15c43018 	strneb	r3, [r4, #24]
   1258c:	e3100020 	tst	r0, #32	; 0x20
   12590:	13a03001 	movne	r3, #1	; 0x1
   12594:	15c43019 	strneb	r3, [r4, #25]
   12598:	e3100010 	tst	r0, #16	; 0x10
   1259c:	13a03001 	movne	r3, #1	; 0x1
   125a0:	15c4301a 	strneb	r3, [r4, #26]
   125a4:	e200300c 	and	r3, r0, #12	; 0xc
   125a8:	e1a03143 	mov	r3, r3, asr #2
   125ac:	e5c4301b 	strb	r3, [r4, #27]
   125b0:	ea00000d 	b	125ec <.text+0x25ec>
   125b4:	e20250ff 	and	r5, r2, #255	; 0xff
   125b8:	e3550011 	cmp	r5, #17	; 0x11
   125bc:	9affffc7 	bls	124e0 <.text+0x24e0>
   125c0:	e59f2034 	ldr	r2, [pc, #52]	; 125fc <.text+0x25fc>
   125c4:	e5923004 	ldr	r3, [r2, #4]
   125c8:	e3a00001 	mov	r0, #1	; 0x1
   125cc:	e3833080 	orr	r3, r3, #128	; 0x80
   125d0:	e5823004 	str	r3, [r2, #4]
   125d4:	ea000006 	b	125f4 <.text+0x25f4>
   125d8:	e3a00000 	mov	r0, #0	; 0x0
   125dc:	ea000004 	b	125f4 <.text+0x25f4>
   125e0:	e2853001 	add	r3, r5, #1	; 0x1
   125e4:	e20350ff 	and	r5, r3, #255	; 0xff
   125e8:	eaffff7c 	b	123e0 <sd_raw_get_info+0x74>
   125ec:	e20250ff 	and	r5, r2, #255	; 0xff
   125f0:	eaffffba 	b	124e0 <.text+0x24e0>
   125f4:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   125f8:	e12fff1e 	bx	lr
   125fc:	e0028000 	and	r8, r2, r0

00012600 <sd_raw_read>:
   12600:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12604:	e1a02802 	mov	r2, r2, lsl #16
   12608:	e1a09000 	mov	r9, r0
   1260c:	e1a0a001 	mov	sl, r1
   12610:	e1a08822 	mov	r8, r2, lsr #16
   12614:	ea000046 	b	12734 <sd_raw_read+0x134>
   12618:	e1a06b89 	mov	r6, r9, lsl #23
   1261c:	e1a06ba6 	mov	r6, r6, lsr #23
   12620:	e59f3120 	ldr	r3, [pc, #288]	; 12748 <.text+0x2748>
   12624:	e2662c02 	rsb	r2, r6, #512	; 0x200
   12628:	e1a02802 	mov	r2, r2, lsl #16
   1262c:	e5930000 	ldr	r0, [r3]
   12630:	e3c95f7f 	bic	r5, r9, #508	; 0x1fc
   12634:	e3c55003 	bic	r5, r5, #3	; 0x3
   12638:	e1a02822 	mov	r2, r2, lsr #16
   1263c:	e1580002 	cmp	r8, r2
   12640:	31a07008 	movcc	r7, r8
   12644:	21a07002 	movcs	r7, r2
   12648:	e1550000 	cmp	r5, r0
   1264c:	0a00002f 	beq	12710 <sd_raw_read+0x110>
   12650:	e59f30f4 	ldr	r3, [pc, #244]	; 1274c <.text+0x274c>
   12654:	e5d33000 	ldrb	r3, [r3]
   12658:	e3530000 	cmp	r3, #0	; 0x0
   1265c:	1a000004 	bne	12674 <sd_raw_read+0x74>
   12660:	e59f10e8 	ldr	r1, [pc, #232]	; 12750 <.text+0x2750>
   12664:	e3a02c02 	mov	r2, #512	; 0x200
   12668:	eb00003c 	bl	12760 <sd_raw_write>
   1266c:	e3500000 	cmp	r0, #0	; 0x0
   12670:	0a000032 	beq	12740 <sd_raw_read+0x140>
   12674:	e59f40d8 	ldr	r4, [pc, #216]	; 12754 <.text+0x2754>
   12678:	e594300c 	ldr	r3, [r4, #12]
   1267c:	e3833080 	orr	r3, r3, #128	; 0x80
   12680:	e3a00011 	mov	r0, #17	; 0x11
   12684:	e1a01005 	mov	r1, r5
   12688:	e584300c 	str	r3, [r4, #12]
   1268c:	ebfffef4 	bl	12264 <sd_raw_send_command_r1>
   12690:	e3500000 	cmp	r0, #0	; 0x0
   12694:	15943004 	ldrne	r3, [r4, #4]
   12698:	13a00000 	movne	r0, #0	; 0x0
   1269c:	13833080 	orrne	r3, r3, #128	; 0x80
   126a0:	15843004 	strne	r3, [r4, #4]
   126a4:	1a000025 	bne	12740 <sd_raw_read+0x140>
   126a8:	ebfffee2 	bl	12238 <sd_raw_rec_byte>
   126ac:	e35000fe 	cmp	r0, #254	; 0xfe
   126b0:	1afffffc 	bne	126a8 <sd_raw_read+0xa8>
   126b4:	e59f409c 	ldr	r4, [pc, #156]	; 12758 <.text+0x2758>
   126b8:	ebfffede 	bl	12238 <sd_raw_rec_byte>
   126bc:	e59f3098 	ldr	r3, [pc, #152]	; 1275c <.text+0x275c>
   126c0:	e5440001 	strb	r0, [r4, #-1]
   126c4:	e2844001 	add	r4, r4, #1	; 0x1
   126c8:	e1540003 	cmp	r4, r3
   126cc:	1afffff9 	bne	126b8 <sd_raw_read+0xb8>
   126d0:	e59f3070 	ldr	r3, [pc, #112]	; 12748 <.text+0x2748>
   126d4:	e59f1074 	ldr	r1, [pc, #116]	; 12750 <.text+0x2750>
   126d8:	e1a02007 	mov	r2, r7
   126dc:	e5835000 	str	r5, [r3]
   126e0:	e0861001 	add	r1, r6, r1
   126e4:	e1a0000a 	mov	r0, sl
   126e8:	eb0014b1 	bl	179b4 <memcpy>
   126ec:	ebfffed1 	bl	12238 <sd_raw_rec_byte>
   126f0:	ebfffed0 	bl	12238 <sd_raw_rec_byte>
   126f4:	e59f2058 	ldr	r2, [pc, #88]	; 12754 <.text+0x2754>
   126f8:	e5923004 	ldr	r3, [r2, #4]
   126fc:	e3833080 	orr	r3, r3, #128	; 0x80
   12700:	e5823004 	str	r3, [r2, #4]
   12704:	e08aa007 	add	sl, sl, r7
   12708:	ebfffeca 	bl	12238 <sd_raw_rec_byte>
   1270c:	ea000004 	b	12724 <sd_raw_read+0x124>
   12710:	e59f1038 	ldr	r1, [pc, #56]	; 12750 <.text+0x2750>
   12714:	e1a0000a 	mov	r0, sl
   12718:	e0861001 	add	r1, r6, r1
   1271c:	e1a02007 	mov	r2, r7
   12720:	eb0014a3 	bl	179b4 <memcpy>
   12724:	e0673008 	rsb	r3, r7, r8
   12728:	e1a03803 	mov	r3, r3, lsl #16
   1272c:	e0899007 	add	r9, r9, r7
   12730:	e1a08823 	mov	r8, r3, lsr #16
   12734:	e3580000 	cmp	r8, #0	; 0x0
   12738:	1affffb6 	bne	12618 <sd_raw_read+0x18>
   1273c:	e3a00001 	mov	r0, #1	; 0x1
   12740:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12744:	e12fff1e 	bx	lr
   12748:	40000f20 	andmi	r0, r0, r0, lsr #30
   1274c:	40000f24 	andmi	r0, r0, r4, lsr #30
   12750:	40000d20 	andmi	r0, r0, r0, lsr #26
   12754:	e0028000 	and	r8, r2, r0
   12758:	40000d21 	andmi	r0, r0, r1, lsr #26
   1275c:	40000f21 	andmi	r0, r0, r1, lsr #30

00012760 <sd_raw_write>:
   12760:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12764:	e1a02802 	mov	r2, r2, lsl #16
   12768:	e1a0a000 	mov	sl, r0
   1276c:	e1a08001 	mov	r8, r1
   12770:	e1a07822 	mov	r7, r2, lsr #16
   12774:	ea000069 	b	12920 <sd_raw_write+0x1c0>
   12778:	e1a04b8a 	mov	r4, sl, lsl #23
   1277c:	e1a04ba4 	mov	r4, r4, lsr #23
   12780:	e59f91cc 	ldr	r9, [pc, #460]	; 12954 <.text+0x2954>
   12784:	e2643c02 	rsb	r3, r4, #512	; 0x200
   12788:	e1a03803 	mov	r3, r3, lsl #16
   1278c:	e3ca5f7f 	bic	r5, sl, #508	; 0x1fc
   12790:	e5990000 	ldr	r0, [r9]
   12794:	e3c55003 	bic	r5, r5, #3	; 0x3
   12798:	e1a03823 	mov	r3, r3, lsr #16
   1279c:	e1570003 	cmp	r7, r3
   127a0:	31a06007 	movcc	r6, r7
   127a4:	21a06003 	movcs	r6, r3
   127a8:	e1550000 	cmp	r5, r0
   127ac:	0a000017 	beq	12810 <sd_raw_write+0xb0>
   127b0:	e59f31a0 	ldr	r3, [pc, #416]	; 12958 <.text+0x2958>
   127b4:	e5d33000 	ldrb	r3, [r3]
   127b8:	e3530000 	cmp	r3, #0	; 0x0
   127bc:	1a000004 	bne	127d4 <sd_raw_write+0x74>
   127c0:	e59f1194 	ldr	r1, [pc, #404]	; 1295c <.text+0x295c>
   127c4:	e3a02c02 	mov	r2, #512	; 0x200
   127c8:	ebffffe4 	bl	12760 <sd_raw_write>
   127cc:	e3500000 	cmp	r0, #0	; 0x0
   127d0:	0a000055 	beq	1292c <sd_raw_write+0x1cc>
   127d4:	e59f3184 	ldr	r3, [pc, #388]	; 12960 <.text+0x2960>
   127d8:	e1560003 	cmp	r6, r3
   127dc:	83a03000 	movhi	r3, #0	; 0x0
   127e0:	93a03001 	movls	r3, #1	; 0x1
   127e4:	e3540000 	cmp	r4, #0	; 0x0
   127e8:	13833001 	orrne	r3, r3, #1	; 0x1
   127ec:	e3530000 	cmp	r3, #0	; 0x0
   127f0:	0a000005 	beq	1280c <sd_raw_write+0xac>
   127f4:	e1a00005 	mov	r0, r5
   127f8:	e59f115c 	ldr	r1, [pc, #348]	; 1295c <.text+0x295c>
   127fc:	e3a02c02 	mov	r2, #512	; 0x200
   12800:	ebffff7e 	bl	12600 <sd_raw_read>
   12804:	e3500000 	cmp	r0, #0	; 0x0
   12808:	0a000047 	beq	1292c <sd_raw_write+0x1cc>
   1280c:	e5895000 	str	r5, [r9]
   12810:	e59f3144 	ldr	r3, [pc, #324]	; 1295c <.text+0x295c>
   12814:	e1580003 	cmp	r8, r3
   12818:	0a000008 	beq	12840 <sd_raw_write+0xe0>
   1281c:	e0840003 	add	r0, r4, r3
   12820:	e1a02006 	mov	r2, r6
   12824:	e1a01008 	mov	r1, r8
   12828:	eb001461 	bl	179b4 <memcpy>
   1282c:	e59f3124 	ldr	r3, [pc, #292]	; 12958 <.text+0x2958>
   12830:	e3a02000 	mov	r2, #0	; 0x0
   12834:	e1570006 	cmp	r7, r6
   12838:	e5c32000 	strb	r2, [r3]
   1283c:	0a000041 	beq	12948 <sd_raw_write+0x1e8>
   12840:	e59f411c 	ldr	r4, [pc, #284]	; 12964 <.text+0x2964>
   12844:	e594300c 	ldr	r3, [r4, #12]
   12848:	e3833080 	orr	r3, r3, #128	; 0x80
   1284c:	e1a01005 	mov	r1, r5
   12850:	e3a00018 	mov	r0, #24	; 0x18
   12854:	e584300c 	str	r3, [r4, #12]
   12858:	ebfffe81 	bl	12264 <sd_raw_send_command_r1>
   1285c:	e3500000 	cmp	r0, #0	; 0x0
   12860:	1a000033 	bne	12934 <sd_raw_write+0x1d4>
   12864:	e59f30fc 	ldr	r3, [pc, #252]	; 12968 <.text+0x2968>
   12868:	e3a020fe 	mov	r2, #254	; 0xfe
   1286c:	e5832008 	str	r2, [r3, #8]
   12870:	e59f30f0 	ldr	r3, [pc, #240]	; 12968 <.text+0x2968>
   12874:	e5933004 	ldr	r3, [r3, #4]
   12878:	e3130080 	tst	r3, #128	; 0x80
   1287c:	0afffffb 	beq	12870 <sd_raw_write+0x110>
   12880:	e59f10e4 	ldr	r1, [pc, #228]	; 1296c <.text+0x296c>
   12884:	e5512001 	ldrb	r2, [r1, #-1]
   12888:	e59f30d8 	ldr	r3, [pc, #216]	; 12968 <.text+0x2968>
   1288c:	e5832008 	str	r2, [r3, #8]
   12890:	e59f20d0 	ldr	r2, [pc, #208]	; 12968 <.text+0x2968>
   12894:	e5923004 	ldr	r3, [r2, #4]
   12898:	e3130080 	tst	r3, #128	; 0x80
   1289c:	0afffffb 	beq	12890 <sd_raw_write+0x130>
   128a0:	e59f30c8 	ldr	r3, [pc, #200]	; 12970 <.text+0x2970>
   128a4:	e2811001 	add	r1, r1, #1	; 0x1
   128a8:	e1510003 	cmp	r1, r3
   128ac:	1afffff4 	bne	12884 <sd_raw_write+0x124>
   128b0:	e3a030ff 	mov	r3, #255	; 0xff
   128b4:	e5823008 	str	r3, [r2, #8]
   128b8:	e59f20a8 	ldr	r2, [pc, #168]	; 12968 <.text+0x2968>
   128bc:	e5923004 	ldr	r3, [r2, #4]
   128c0:	e3130080 	tst	r3, #128	; 0x80
   128c4:	0afffffb 	beq	128b8 <sd_raw_write+0x158>
   128c8:	e3a030ff 	mov	r3, #255	; 0xff
   128cc:	e5823008 	str	r3, [r2, #8]
   128d0:	e59f3090 	ldr	r3, [pc, #144]	; 12968 <.text+0x2968>
   128d4:	e5933004 	ldr	r3, [r3, #4]
   128d8:	e3130080 	tst	r3, #128	; 0x80
   128dc:	0afffffb 	beq	128d0 <sd_raw_write+0x170>
   128e0:	ebfffe54 	bl	12238 <sd_raw_rec_byte>
   128e4:	e35000ff 	cmp	r0, #255	; 0xff
   128e8:	1afffffc 	bne	128e0 <sd_raw_write+0x180>
   128ec:	ebfffe51 	bl	12238 <sd_raw_rec_byte>
   128f0:	e59f206c 	ldr	r2, [pc, #108]	; 12964 <.text+0x2964>
   128f4:	e5923004 	ldr	r3, [r2, #4]
   128f8:	e3833080 	orr	r3, r3, #128	; 0x80
   128fc:	e5823004 	str	r3, [r2, #4]
   12900:	e59f3050 	ldr	r3, [pc, #80]	; 12958 <.text+0x2958>
   12904:	e0661007 	rsb	r1, r6, r7
   12908:	e3a02001 	mov	r2, #1	; 0x1
   1290c:	e1a01801 	mov	r1, r1, lsl #16
   12910:	e5c32000 	strb	r2, [r3]
   12914:	e08aa006 	add	sl, sl, r6
   12918:	e0888006 	add	r8, r8, r6
   1291c:	e1a07821 	mov	r7, r1, lsr #16
   12920:	e3570000 	cmp	r7, #0	; 0x0
   12924:	1affff93 	bne	12778 <sd_raw_write+0x18>
   12928:	ea000006 	b	12948 <sd_raw_write+0x1e8>
   1292c:	e3a00000 	mov	r0, #0	; 0x0
   12930:	ea000005 	b	1294c <sd_raw_write+0x1ec>
   12934:	e5943004 	ldr	r3, [r4, #4]
   12938:	e3a00000 	mov	r0, #0	; 0x0
   1293c:	e3833080 	orr	r3, r3, #128	; 0x80
   12940:	e5843004 	str	r3, [r4, #4]
   12944:	ea000000 	b	1294c <sd_raw_write+0x1ec>
   12948:	e3a00001 	mov	r0, #1	; 0x1
   1294c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12950:	e12fff1e 	bx	lr
   12954:	40000f20 	andmi	r0, r0, r0, lsr #30
   12958:	40000f24 	andmi	r0, r0, r4, lsr #30
   1295c:	40000d20 	andmi	r0, r0, r0, lsr #26
   12960:	000001ff 	streqd	r0, [r0], -pc
   12964:	e0028000 	and	r8, r2, r0
   12968:	e0020000 	and	r0, r2, r0
   1296c:	40000d21 	andmi	r0, r0, r1, lsr #26
   12970:	40000f21 	andmi	r0, r0, r1, lsr #30

00012974 <sd_raw_sync>:
   12974:	e52de004 	str	lr, [sp, #-4]!
   12978:	e59f3030 	ldr	r3, [pc, #48]	; 129b0 <.text+0x29b0>
   1297c:	e5d33000 	ldrb	r3, [r3]
   12980:	e3530000 	cmp	r3, #0	; 0x0
   12984:	e59f1028 	ldr	r1, [pc, #40]	; 129b4 <.text+0x29b4>
   12988:	e3a02c02 	mov	r2, #512	; 0x200
   1298c:	e3a00001 	mov	r0, #1	; 0x1
   12990:	1a000004 	bne	129a8 <sd_raw_sync+0x34>
   12994:	e59f301c 	ldr	r3, [pc, #28]	; 129b8 <.text+0x29b8>
   12998:	e5930000 	ldr	r0, [r3]
   1299c:	ebffff6f 	bl	12760 <sd_raw_write>
   129a0:	e2500000 	subs	r0, r0, #0	; 0x0
   129a4:	13a00001 	movne	r0, #1	; 0x1
   129a8:	e49de004 	ldr	lr, [sp], #4
   129ac:	e12fff1e 	bx	lr
   129b0:	40000f24 	andmi	r0, r0, r4, lsr #30
   129b4:	40000d20 	andmi	r0, r0, r0, lsr #26
   129b8:	40000f20 	andmi	r0, r0, r0, lsr #30

000129bc <sd_raw_read_interval>:
   129bc:	e1a02802 	mov	r2, r2, lsl #16
   129c0:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   129c4:	e1a03803 	mov	r3, r3, lsl #16
   129c8:	e3520000 	cmp	r2, #0	; 0x0
   129cc:	13510000 	cmpne	r1, #0	; 0x0
   129d0:	e1a07001 	mov	r7, r1
   129d4:	e1a06000 	mov	r6, r0
   129d8:	e1a05823 	mov	r5, r3, lsr #16
   129dc:	e28d801c 	add	r8, sp, #28	; 0x1c
   129e0:	e8980500 	ldmia	r8, {r8, sl}
   129e4:	e1a04822 	mov	r4, r2, lsr #16
   129e8:	0a00001a 	beq	12a58 <sd_raw_read_interval+0x9c>
   129ec:	e2783001 	rsbs	r3, r8, #1	; 0x1
   129f0:	33a03000 	movcc	r3, #0	; 0x0
   129f4:	e1550004 	cmp	r5, r4
   129f8:	33833001 	orrcc	r3, r3, #1	; 0x1
   129fc:	e3530000 	cmp	r3, #0	; 0x0
   12a00:	0a00000e 	beq	12a40 <sd_raw_read_interval+0x84>
   12a04:	ea000013 	b	12a58 <sd_raw_read_interval+0x9c>
   12a08:	ebfffefc 	bl	12600 <sd_raw_read>
   12a0c:	e3500000 	cmp	r0, #0	; 0x0
   12a10:	e1a01006 	mov	r1, r6
   12a14:	e1a0200a 	mov	r2, sl
   12a18:	e1a00007 	mov	r0, r7
   12a1c:	e0866004 	add	r6, r6, r4
   12a20:	0a00000c 	beq	12a58 <sd_raw_read_interval+0x9c>
   12a24:	e1a0e00f 	mov	lr, pc
   12a28:	e12fff18 	bx	r8
   12a2c:	e3500000 	cmp	r0, #0	; 0x0
   12a30:	0a00000a 	beq	12a60 <sd_raw_read_interval+0xa4>
   12a34:	e0643005 	rsb	r3, r4, r5
   12a38:	e1a03803 	mov	r3, r3, lsl #16
   12a3c:	e1a05823 	mov	r5, r3, lsr #16
   12a40:	e1550004 	cmp	r5, r4
   12a44:	e1a00006 	mov	r0, r6
   12a48:	e1a01007 	mov	r1, r7
   12a4c:	e1a02004 	mov	r2, r4
   12a50:	2affffec 	bcs	12a08 <sd_raw_read_interval+0x4c>
   12a54:	ea000001 	b	12a60 <sd_raw_read_interval+0xa4>
   12a58:	e3a00000 	mov	r0, #0	; 0x0
   12a5c:	ea000000 	b	12a64 <sd_raw_read_interval+0xa8>
   12a60:	e3a00001 	mov	r0, #1	; 0x1
   12a64:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   12a68:	e12fff1e 	bx	lr

00012a6c <sd_raw_init>:
   12a6c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12a70:	e59f41e4 	ldr	r4, [pc, #484]	; 12c5c <.text+0x2c5c>
   12a74:	e5943008 	ldr	r3, [r4, #8]
   12a78:	e3833080 	orr	r3, r3, #128	; 0x80
   12a7c:	e5843008 	str	r3, [r4, #8]
   12a80:	e59f21d8 	ldr	r2, [pc, #472]	; 12c60 <.text+0x2c60>
   12a84:	e5923000 	ldr	r3, [r2]
   12a88:	e3833a01 	orr	r3, r3, #4096	; 0x1000
   12a8c:	e5823000 	str	r3, [r2]
   12a90:	e5923000 	ldr	r3, [r2]
   12a94:	e3833b01 	orr	r3, r3, #1024	; 0x400
   12a98:	e5823000 	str	r3, [r2]
   12a9c:	e5923000 	ldr	r3, [r2]
   12aa0:	e3833c01 	orr	r3, r3, #256	; 0x100
   12aa4:	e5823000 	str	r3, [r2]
   12aa8:	e5943004 	ldr	r3, [r4, #4]
   12aac:	e3833080 	orr	r3, r3, #128	; 0x80
   12ab0:	e5843004 	str	r3, [r4, #4]
   12ab4:	e2422903 	sub	r2, r2, #49152	; 0xc000
   12ab8:	e3a03096 	mov	r3, #150	; 0x96
   12abc:	e582300c 	str	r3, [r2, #12]
   12ac0:	e3a03038 	mov	r3, #56	; 0x38
   12ac4:	e5823000 	str	r3, [r2]
   12ac8:	ebfffdcb 	bl	121fc <sd_raw_available>
   12acc:	e2505000 	subs	r5, r0, #0	; 0x0
   12ad0:	1a000002 	bne	12ae0 <sd_raw_init+0x74>
   12ad4:	e59f0188 	ldr	r0, [pc, #392]	; 12c64 <.text+0x2c64>
   12ad8:	ebfffbb0 	bl	119a0 <rprintf>
   12adc:	ea00004f 	b	12c20 <sd_raw_init+0x1b4>
   12ae0:	e5943008 	ldr	r3, [r4, #8]
   12ae4:	e3833080 	orr	r3, r3, #128	; 0x80
   12ae8:	e5843008 	str	r3, [r4, #8]
   12aec:	e5943004 	ldr	r3, [r4, #4]
   12af0:	e3833080 	orr	r3, r3, #128	; 0x80
   12af4:	e5843004 	str	r3, [r4, #4]
   12af8:	e3a04000 	mov	r4, #0	; 0x0
   12afc:	ebfffdcd 	bl	12238 <sd_raw_rec_byte>
   12b00:	e2843001 	add	r3, r4, #1	; 0x1
   12b04:	e1a03803 	mov	r3, r3, lsl #16
   12b08:	e1a04823 	mov	r4, r3, lsr #16
   12b0c:	e354000a 	cmp	r4, #10	; 0xa
   12b10:	1afffff9 	bne	12afc <sd_raw_init+0x90>
   12b14:	e59f2140 	ldr	r2, [pc, #320]	; 12c5c <.text+0x2c5c>
   12b18:	e592300c 	ldr	r3, [r2, #12]
   12b1c:	e3833080 	orr	r3, r3, #128	; 0x80
   12b20:	e582300c 	str	r3, [r2, #12]
   12b24:	e3a05000 	mov	r5, #0	; 0x0
   12b28:	e3a00000 	mov	r0, #0	; 0x0
   12b2c:	e1a01000 	mov	r1, r0
   12b30:	ebfffdcb 	bl	12264 <sd_raw_send_command_r1>
   12b34:	e1a04000 	mov	r4, r0
   12b38:	e1a01005 	mov	r1, r5
   12b3c:	e59f0124 	ldr	r0, [pc, #292]	; 12c68 <.text+0x2c68>
   12b40:	e1a02004 	mov	r2, r4
   12b44:	ebfffb95 	bl	119a0 <rprintf>
   12b48:	e3540001 	cmp	r4, #1	; 0x1
   12b4c:	e2855001 	add	r5, r5, #1	; 0x1
   12b50:	0a00000a 	beq	12b80 <sd_raw_init+0x114>
   12b54:	e3550c02 	cmp	r5, #512	; 0x200
   12b58:	1afffff2 	bne	12b28 <sd_raw_init+0xbc>
   12b5c:	e59f0108 	ldr	r0, [pc, #264]	; 12c6c <.text+0x2c6c>
   12b60:	e1a01004 	mov	r1, r4
   12b64:	ebfffb8d 	bl	119a0 <rprintf>
   12b68:	e59f20ec 	ldr	r2, [pc, #236]	; 12c5c <.text+0x2c5c>
   12b6c:	e5923004 	ldr	r3, [r2, #4]
   12b70:	e3a00000 	mov	r0, #0	; 0x0
   12b74:	e3833080 	orr	r3, r3, #128	; 0x80
   12b78:	e5823004 	str	r3, [r2, #4]
   12b7c:	ea000034 	b	12c54 <sd_raw_init+0x1e8>
   12b80:	e3a04000 	mov	r4, #0	; 0x0
   12b84:	e3a01000 	mov	r1, #0	; 0x0
   12b88:	e3a00001 	mov	r0, #1	; 0x1
   12b8c:	ebfffdb4 	bl	12264 <sd_raw_send_command_r1>
   12b90:	e2843001 	add	r3, r4, #1	; 0x1
   12b94:	e3100001 	tst	r0, #1	; 0x1
   12b98:	e1a02803 	mov	r2, r3, lsl #16
   12b9c:	0a000004 	beq	12bb4 <sd_raw_init+0x148>
   12ba0:	e59f30c8 	ldr	r3, [pc, #200]	; 12c70 <.text+0x2c70>
   12ba4:	e1540003 	cmp	r4, r3
   12ba8:	e1a04822 	mov	r4, r2, lsr #16
   12bac:	0a00001d 	beq	12c28 <sd_raw_init+0x1bc>
   12bb0:	eafffff3 	b	12b84 <sd_raw_init+0x118>
   12bb4:	e3a00010 	mov	r0, #16	; 0x10
   12bb8:	e3a01c02 	mov	r1, #512	; 0x200
   12bbc:	ebfffda8 	bl	12264 <sd_raw_send_command_r1>
   12bc0:	e3500000 	cmp	r0, #0	; 0x0
   12bc4:	159f2090 	ldrne	r2, [pc, #144]	; 12c5c <.text+0x2c5c>
   12bc8:	15923004 	ldrne	r3, [r2, #4]
   12bcc:	159f00a0 	ldrne	r0, [pc, #160]	; 12c74 <.text+0x2c74>
   12bd0:	13833080 	orrne	r3, r3, #128	; 0x80
   12bd4:	1a000017 	bne	12c38 <sd_raw_init+0x1cc>
   12bd8:	e59fc07c 	ldr	ip, [pc, #124]	; 12c5c <.text+0x2c5c>
   12bdc:	e59c3004 	ldr	r3, [ip, #4]
   12be0:	e3833080 	orr	r3, r3, #128	; 0x80
   12be4:	e58c3004 	str	r3, [ip, #4]
   12be8:	e59f3088 	ldr	r3, [pc, #136]	; 12c78 <.text+0x2c78>
   12bec:	e3e0c000 	mvn	ip, #0	; 0x0
   12bf0:	e583c000 	str	ip, [r3]
   12bf4:	e59f3080 	ldr	r3, [pc, #128]	; 12c7c <.text+0x2c7c>
   12bf8:	e28cc03d 	add	ip, ip, #61	; 0x3d
   12bfc:	e583c00c 	str	ip, [r3, #12]
   12c00:	e59f3078 	ldr	r3, [pc, #120]	; 12c80 <.text+0x2c80>
   12c04:	e3a05001 	mov	r5, #1	; 0x1
   12c08:	e59f1074 	ldr	r1, [pc, #116]	; 12c84 <.text+0x2c84>
   12c0c:	e3a02c02 	mov	r2, #512	; 0x200
   12c10:	e5c35000 	strb	r5, [r3]
   12c14:	ebfffe79 	bl	12600 <sd_raw_read>
   12c18:	e2504000 	subs	r4, r0, #0	; 0x0
   12c1c:	0a000009 	beq	12c48 <sd_raw_init+0x1dc>
   12c20:	e1a00005 	mov	r0, r5
   12c24:	ea00000a 	b	12c54 <sd_raw_init+0x1e8>
   12c28:	e59f202c 	ldr	r2, [pc, #44]	; 12c5c <.text+0x2c5c>
   12c2c:	e5923004 	ldr	r3, [r2, #4]
   12c30:	e59f0050 	ldr	r0, [pc, #80]	; 12c88 <.text+0x2c88>
   12c34:	e3833080 	orr	r3, r3, #128	; 0x80
   12c38:	e5823004 	str	r3, [r2, #4]
   12c3c:	ebfffb57 	bl	119a0 <rprintf>
   12c40:	e3a00000 	mov	r0, #0	; 0x0
   12c44:	ea000002 	b	12c54 <sd_raw_init+0x1e8>
   12c48:	e59f003c 	ldr	r0, [pc, #60]	; 12c8c <.text+0x2c8c>
   12c4c:	ebfffb53 	bl	119a0 <rprintf>
   12c50:	e1a00004 	mov	r0, r4
   12c54:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12c58:	e12fff1e 	bx	lr
   12c5c:	e0028000 	and	r8, r2, r0
   12c60:	e002c000 	and	ip, r2, r0
   12c64:	00018b0c 	andeq	r8, r1, ip, lsl #22
   12c68:	00018b24 	andeq	r8, r1, r4, lsr #22
   12c6c:	00018b38 	andeq	r8, r1, r8, lsr fp
   12c70:	00007fff 	streqd	r7, [r0], -pc
   12c74:	00018b5c 	andeq	r8, r1, ip, asr fp
   12c78:	40000f20 	andmi	r0, r0, r0, lsr #30
   12c7c:	e0020000 	and	r0, r2, r0
   12c80:	40000f24 	andmi	r0, r0, r4, lsr #30
   12c84:	40000d20 	andmi	r0, r0, r0, lsr #26
   12c88:	00018b4c 	andeq	r8, r1, ip, asr #22
   12c8c:	00018b74 	andeq	r8, r1, r4, ror fp

00012c90 <format_card>:

//NES : 10-28-7 
//Low-level formats a 512MB card
//Assumes *many* things
//You must pass this fuction 0xAA to get it to work (safety check)
char format_card(char make_sure)
{
   12c90:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12c94:	e20000ff 	and	r0, r0, #255	; 0xff
	#define MBR_LOCATION	0x00
	#define BR_LOCATION		(MBR_LOCATION+0x80000)
	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))

	//Safety check
	if (make_sure != 0xAA) return 0;
   12c98:	e35000aa 	cmp	r0, #170	; 0xaa
   12c9c:	e24ddc02 	sub	sp, sp, #512	; 0x200
   12ca0:	13a00000 	movne	r0, #0	; 0x0
   12ca4:	1a00006d 	bne	12e60 <format_card+0x1d0>
   12ca8:	e3a04000 	mov	r4, #0	; 0x0
	
	int i;
	unsigned char my_buff[512];
	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
   12cac:	e3a06000 	mov	r6, #0	; 0x0
   12cb0:	e7c4600d 	strb	r6, [r4, sp]
   12cb4:	e2844001 	add	r4, r4, #1	; 0x1
   12cb8:	e3540c02 	cmp	r4, #512	; 0x200
   12cbc:	1afffffa 	bne	12cac <format_card+0x1c>
	
	//Init SD card interface
	sd_raw_init();
   12cc0:	ebffff69 	bl	12a6c <sd_raw_init>

	//Erase Master Boot record
	sd_raw_sync();
   12cc4:	ebffff2a 	bl	12974 <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
   12cc8:	e1a02004 	mov	r2, r4
   12ccc:	e1a0100d 	mov	r1, sp
   12cd0:	e1a00006 	mov	r0, r6
   12cd4:	ebfffea1 	bl	12760 <sd_raw_write>

	//Erase Boot record
	sd_raw_sync();
   12cd8:	ebffff25 	bl	12974 <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
   12cdc:	e1a02004 	mov	r2, r4
   12ce0:	e1a0100d 	mov	r1, sp
   12ce4:	e3a00702 	mov	r0, #524288	; 0x80000
   12ce8:	ebfffe9c 	bl	12760 <sd_raw_write>
   12cec:	e3a04703 	mov	r4, #786432	; 0xc0000

	//Erase FAT tables
	for(i = 0 ; i < 0x00F5 ; i++) //0x00F5 = 245 bytes : comes from byte 0x16 from Boot Record
	{
		sd_raw_sync();
   12cf0:	ebffff1f 	bl	12974 <sd_raw_sync>
		sd_raw_write( (FAT_TABLE + (i*512)), my_buff, 512);
   12cf4:	e1a00004 	mov	r0, r4
   12cf8:	e1a0100d 	mov	r1, sp
   12cfc:	e3a02c02 	mov	r2, #512	; 0x200
   12d00:	ebfffe96 	bl	12760 <sd_raw_write>
   12d04:	e59f3160 	ldr	r3, [pc, #352]	; 12e6c <.text+0x2e6c>
   12d08:	e2844c02 	add	r4, r4, #512	; 0x200
   12d0c:	e1540003 	cmp	r4, r3
   12d10:	e1a0900d 	mov	r9, sp
   12d14:	1afffff5 	bne	12cf0 <format_card+0x60>
	}
	
	//Write Master Boot Record
	#define PART1	0x01BE
	my_buff[PART1 + 0] = 0x00;
	my_buff[PART1 + 1] = 0x00;
	my_buff[PART1 + 2] = 0x01;
	my_buff[PART1 + 3] = 0x01;
	my_buff[PART1 + 4] = 0x06;
   12d18:	e3a03006 	mov	r3, #6	; 0x6
   12d1c:	e5cd31c2 	strb	r3, [sp, #450]
	my_buff[PART1 + 5] = 0x1F;
   12d20:	e2833019 	add	r3, r3, #25	; 0x19
   12d24:	e5cd31c3 	strb	r3, [sp, #451]
	my_buff[PART1 + 6] = 0xE0;
   12d28:	e3e0301f 	mvn	r3, #31	; 0x1f
   12d2c:	e3a04000 	mov	r4, #0	; 0x0
   12d30:	e3a02001 	mov	r2, #1	; 0x1
	my_buff[PART1 + 7] = 0xD3;
	my_buff[PART1 + 8] = 0x00;
	my_buff[PART1 + 9] = 0x04;
	my_buff[PART1 + 10] = 0x00;
	my_buff[PART1 + 11] = 0x00;
	my_buff[PART1 + 12] = 0x00;
	my_buff[PART1 + 13] = 0x4C;
	my_buff[PART1 + 14] = 0x0F;
	my_buff[510] = 0x55;
   12d34:	e3a05055 	mov	r5, #85	; 0x55
   12d38:	e3a06004 	mov	r6, #4	; 0x4
   12d3c:	e3a0704c 	mov	r7, #76	; 0x4c
   12d40:	e3a0800f 	mov	r8, #15	; 0xf
	my_buff[511] = 0xAA;
   12d44:	e3e0a055 	mvn	sl, #85	; 0x55
   12d48:	e5cd31c4 	strb	r3, [sp, #452]
   12d4c:	e3e0302c 	mvn	r3, #44	; 0x2c
   12d50:	e5cd31c5 	strb	r3, [sp, #453]
   12d54:	e5cd21c1 	strb	r2, [sp, #449]
   12d58:	e5cd21c0 	strb	r2, [sp, #448]
   12d5c:	e5cd41be 	strb	r4, [sp, #446]
   12d60:	e5cd41bf 	strb	r4, [sp, #447]
   12d64:	e5cd41c6 	strb	r4, [sp, #454]
   12d68:	e5cd61c7 	strb	r6, [sp, #455]
   12d6c:	e5cd41c8 	strb	r4, [sp, #456]
   12d70:	e5cd41c9 	strb	r4, [sp, #457]
   12d74:	e5cd41ca 	strb	r4, [sp, #458]
   12d78:	e5cd71cb 	strb	r7, [sp, #459]
   12d7c:	e5cd81cc 	strb	r8, [sp, #460]
   12d80:	e5cd51fe 	strb	r5, [sp, #510]
   12d84:	e5cda1ff 	strb	sl, [sp, #511]

	sd_raw_sync();
   12d88:	ebfffef9 	bl	12974 <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
   12d8c:	e1a0100d 	mov	r1, sp
   12d90:	e3a02c02 	mov	r2, #512	; 0x200
   12d94:	e1a00004 	mov	r0, r4
   12d98:	ebfffe70 	bl	12760 <sd_raw_write>
	sd_raw_sync();
   12d9c:	ebfffef4 	bl	12974 <sd_raw_sync>

	//Write Boot Record
	#define BOOTRECORD1	0x80000
	my_buff[0] = 0xEB;
   12da0:	e3e03014 	mvn	r3, #20	; 0x14
   12da4:	e5cd3000 	strb	r3, [sp]
	my_buff[1] = 0xFE;
   12da8:	e2833013 	add	r3, r3, #19	; 0x13
   12dac:	e5cd3001 	strb	r3, [sp, #1]
	my_buff[2] = 0x90;
   12db0:	e3e0306f 	mvn	r3, #111	; 0x6f
   12db4:	e5cd3002 	strb	r3, [sp, #2]
	my_buff[12] = 0x02;
	my_buff[13] = 0x10;
   12db8:	e2833080 	add	r3, r3, #128	; 0x80
   12dbc:	e5cd300d 	strb	r3, [sp, #13]
	my_buff[14] = 0x16;
   12dc0:	e2833006 	add	r3, r3, #6	; 0x6
   12dc4:	e5cd300e 	strb	r3, [sp, #14]
	my_buff[16] = 0x02;
	my_buff[18] = 0x02;
	my_buff[21] = 0xF8;
   12dc8:	e3e03007 	mvn	r3, #7	; 0x7
   12dcc:	e5cd3015 	strb	r3, [sp, #21]
	my_buff[22] = 0xF5;
   12dd0:	e3e0300a 	mvn	r3, #10	; 0xa
   12dd4:	e5cd3016 	strb	r3, [sp, #22]
	my_buff[24] = 0x20;
	my_buff[26] = 0x20;
	my_buff[29] = 0x04;
	my_buff[33] = 0x4C;
	my_buff[34] = 0x0F;
	my_buff[38] = 0x29;
   12dd8:	e2833034 	add	r3, r3, #52	; 0x34
   12ddc:	e5cd3026 	strb	r3, [sp, #38]
	my_buff[54] = 0x46;
   12de0:	e283301d 	add	r3, r3, #29	; 0x1d
   12de4:	e5cd3036 	strb	r3, [sp, #54]
	my_buff[55] = 0x41;
   12de8:	e3a03041 	mov	r3, #65	; 0x41
   12dec:	e5cd3037 	strb	r3, [sp, #55]
	my_buff[56] = 0x54;
   12df0:	e2833013 	add	r3, r3, #19	; 0x13
   12df4:	e5cd3038 	strb	r3, [sp, #56]
	my_buff[57] = 0x31;
   12df8:	e3a03031 	mov	r3, #49	; 0x31
   12dfc:	e3a02020 	mov	r2, #32	; 0x20
   12e00:	e3a01002 	mov	r1, #2	; 0x2
   12e04:	e5cd3039 	strb	r3, [sp, #57]
	my_buff[58] = 0x36;
   12e08:	e2833005 	add	r3, r3, #5	; 0x5
   12e0c:	e5cd303a 	strb	r3, [sp, #58]
   12e10:	e5cd1012 	strb	r1, [sp, #18]
	my_buff[59] = 0x20;
	my_buff[60] = 0x20;
	my_buff[61] = 0x20;
   12e14:	e5cd203d 	strb	r2, [sp, #61]
   12e18:	e5cd100c 	strb	r1, [sp, #12]
   12e1c:	e5cd1010 	strb	r1, [sp, #16]
   12e20:	e5cd2018 	strb	r2, [sp, #24]
   12e24:	e5cd201a 	strb	r2, [sp, #26]
   12e28:	e5cd203b 	strb	r2, [sp, #59]
   12e2c:	e5cd203c 	strb	r2, [sp, #60]
   12e30:	e5cd601d 	strb	r6, [sp, #29]
   12e34:	e5cd7021 	strb	r7, [sp, #33]
   12e38:	e5cd8022 	strb	r8, [sp, #34]
	my_buff[510] = 0x55;
	my_buff[511] = 0xAA;
   12e3c:	e5cda1ff 	strb	sl, [sp, #511]
   12e40:	e5cd51fe 	strb	r5, [sp, #510]
	
	sd_raw_sync();
   12e44:	ebfffeca 	bl	12974 <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
   12e48:	e1a0100d 	mov	r1, sp
   12e4c:	e3a02c02 	mov	r2, #512	; 0x200
   12e50:	e3a00702 	mov	r0, #524288	; 0x80000
   12e54:	ebfffe41 	bl	12760 <sd_raw_write>
	sd_raw_sync();
   12e58:	ebfffec5 	bl	12974 <sd_raw_sync>
   12e5c:	e1a00005 	mov	r0, r5
	
	return(0x55); //Successful format
}
   12e60:	e28ddc02 	add	sp, sp, #512	; 0x200
   12e64:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12e68:	e12fff1e 	bx	lr
   12e6c:	000dea00 	andeq	lr, sp, r0, lsl #20

00012e70 <fat16_dir_entry_seek_callback>:
{
    struct fat16_read_callback_arg* arg = p;

    /* skip deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
   12e70:	e5d03000 	ldrb	r3, [r0]
   12e74:	e3530000 	cmp	r3, #0	; 0x0
   12e78:	135300e5 	cmpne	r3, #229	; 0xe5
   12e7c:	0a000015 	beq	12ed8 <fat16_dir_entry_seek_callback+0x68>
        return 1;

    if(arg->entry_cur == arg->entry_num)
   12e80:	e1d2c0b0 	ldrh	ip, [r2]
   12e84:	e1d230b2 	ldrh	r3, [r2, #2]
   12e88:	e153000c 	cmp	r3, ip
   12e8c:	1a00000b 	bne	12ec0 <fat16_dir_entry_seek_callback+0x50>
    {
        arg->entry_offset = offset;
   12e90:	e5821004 	str	r1, [r2, #4]
        arg->byte_count = buffer[11] == 0x0f ?
   12e94:	e5d0300b 	ldrb	r3, [r0, #11]
   12e98:	e353000f 	cmp	r3, #15	; 0xf
   12e9c:	05d03000 	ldreqb	r3, [r0]
   12ea0:	0203303f 	andeq	r3, r3, #63	; 0x3f
   12ea4:	01a03283 	moveq	r3, r3, lsl #5
   12ea8:	02833020 	addeq	r3, r3, #32	; 0x20
   12eac:	e3a01020 	mov	r1, #32	; 0x20
   12eb0:	e3a00000 	mov	r0, #0	; 0x0
   12eb4:	020310ff 	andeq	r1, r3, #255	; 0xff
   12eb8:	e5c21008 	strb	r1, [r2, #8]
   12ebc:	e12fff1e 	bx	lr
        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
        32;
        return 0;
    }

    /* if we read a 8.3 entry, we reached a new directory entry */
    if(buffer[11] != 0x0f)
   12ec0:	e5d0300b 	ldrb	r3, [r0, #11]
        ++arg->entry_cur;
   12ec4:	e28c1001 	add	r1, ip, #1	; 0x1
   12ec8:	e353000f 	cmp	r3, #15	; 0xf
   12ecc:	e3a00001 	mov	r0, #1	; 0x1
   12ed0:	11c210b0 	strneh	r1, [r2]
   12ed4:	112fff1e 	bxne	lr
   12ed8:	e3a00001 	mov	r0, #1	; 0x1

    return 1;
}
   12edc:	e12fff1e 	bx	lr

00012ee0 <fat16_dir_entry_read_callback>:

/**
 * \ingroup fat16_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
{
   12ee0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    struct fat16_dir_entry_struct* dir_entry = p;

    /* there should not be any deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
   12ee4:	e5d03000 	ldrb	r3, [r0]
   12ee8:	e3530000 	cmp	r3, #0	; 0x0
   12eec:	135300e5 	cmpne	r3, #229	; 0xe5
   12ef0:	e1a0c002 	mov	ip, r2
   12ef4:	0a000062 	beq	13084 <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    if(!dir_entry->entry_offset)
   12ef8:	e5923028 	ldr	r3, [r2, #40]
   12efc:	e3530000 	cmp	r3, #0	; 0x0
        dir_entry->entry_offset = offset;
   12f00:	05821028 	streq	r1, [r2, #40]

    switch(fat16_interpret_dir_entry(dir_entry, buffer))
    {
        case 0: /* failure */
            return 0;
            case 1: /* buffer successfully parsed, continue */
            return 1;
            case 2: /* directory entry complete, finish */
            return 0;
        }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Interprets a raw directory entry and puts the contained
 * information into the directory entry.
 *
 * For a single file there may exist multiple directory
 * entries. All except the last one are lfn entries, which
 * contain parts of the long filename. The last directory
 * entry is a traditional 8.3 style one. It contains all
 * other information like size, cluster, date and time.
 *
 * \param[in,out] dir_entry The directory entry to fill.
 * \param[in] raw_entry A pointer to 32 bytes of raw data.
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
   12f04:	e5d02000 	ldrb	r2, [r0]
   12f08:	e3520000 	cmp	r2, #0	; 0x0
   12f0c:	0a00005c 	beq	13084 <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
   12f10:	e5d0300b 	ldrb	r3, [r0, #11]
   12f14:	e353000f 	cmp	r3, #15	; 0xf
   12f18:	e280500b 	add	r5, r0, #11	; 0xb
   12f1c:	1a000026 	bne	12fbc <fat16_dir_entry_read_callback+0xdc>
    {
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
   12f20:	e202203f 	and	r2, r2, #63	; 0x3f
   12f24:	e3a0300d 	mov	r3, #13	; 0xd
   12f28:	e0030392 	mul	r3, r2, r3
   12f2c:	e243300d 	sub	r3, r3, #13	; 0xd
   12f30:	e1a03803 	mov	r3, r3, lsl #16
   12f34:	e1a02823 	mov	r2, r3, lsr #16

        if(char_offset + 12 < sizeof(dir_entry->long_name))
   12f38:	e282300c 	add	r3, r2, #12	; 0xc
   12f3c:	e353001f 	cmp	r3, #31	; 0x1f
   12f40:	83a00001 	movhi	r0, #1	; 0x1
   12f44:	8a00004f 	bhi	13088 <fat16_dir_entry_read_callback+0x1a8>
        {
            /* Lfn supports unicode, but we do not, for now.
                                                 * So we assume pure ascii and read only every
                                                 * second byte.
                                                 */
            long_name[char_offset + 0] = raw_entry[1];
   12f48:	e5d03001 	ldrb	r3, [r0, #1]
   12f4c:	e7cc3002 	strb	r3, [ip, r2]
            long_name[char_offset + 1] = raw_entry[3];
   12f50:	e5d03003 	ldrb	r3, [r0, #3]
   12f54:	e08c2002 	add	r2, ip, r2
   12f58:	e5c23001 	strb	r3, [r2, #1]
            long_name[char_offset + 2] = raw_entry[5];
   12f5c:	e5d03005 	ldrb	r3, [r0, #5]
   12f60:	e5c23002 	strb	r3, [r2, #2]
            long_name[char_offset + 3] = raw_entry[7];
   12f64:	e5d03007 	ldrb	r3, [r0, #7]
   12f68:	e5c23003 	strb	r3, [r2, #3]
            long_name[char_offset + 4] = raw_entry[9];
   12f6c:	e5d03009 	ldrb	r3, [r0, #9]
   12f70:	e5c23004 	strb	r3, [r2, #4]
            long_name[char_offset + 5] = raw_entry[14];
   12f74:	e5d0300e 	ldrb	r3, [r0, #14]
   12f78:	e5c23005 	strb	r3, [r2, #5]
            long_name[char_offset + 6] = raw_entry[16];
   12f7c:	e5d03010 	ldrb	r3, [r0, #16]
   12f80:	e5c23006 	strb	r3, [r2, #6]
            long_name[char_offset + 7] = raw_entry[18];
   12f84:	e5d03012 	ldrb	r3, [r0, #18]
   12f88:	e5c23007 	strb	r3, [r2, #7]
            long_name[char_offset + 8] = raw_entry[20];
   12f8c:	e5d03014 	ldrb	r3, [r0, #20]
   12f90:	e5c23008 	strb	r3, [r2, #8]
            long_name[char_offset + 9] = raw_entry[22];
   12f94:	e5d03016 	ldrb	r3, [r0, #22]
   12f98:	e5c23009 	strb	r3, [r2, #9]
            long_name[char_offset + 10] = raw_entry[24];
   12f9c:	e5d03018 	ldrb	r3, [r0, #24]
   12fa0:	e5c2300a 	strb	r3, [r2, #10]
            long_name[char_offset + 11] = raw_entry[28];
   12fa4:	e5d0301c 	ldrb	r3, [r0, #28]
   12fa8:	e5c2300b 	strb	r3, [r2, #11]
            long_name[char_offset + 12] = raw_entry[30];
   12fac:	e5d0301e 	ldrb	r3, [r0, #30]
   12fb0:	e3a00001 	mov	r0, #1	; 0x1
   12fb4:	e5c2300c 	strb	r3, [r2, #12]
   12fb8:	ea000032 	b	13088 <fat16_dir_entry_read_callback+0x1a8>
        }

        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
   12fbc:	e5dc2000 	ldrb	r2, [ip]
   12fc0:	e3520000 	cmp	r2, #0	; 0x0
   12fc4:	1a00001d 	bne	13040 <fat16_dir_entry_read_callback+0x160>
   12fc8:	e1a01002 	mov	r1, r2
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
   12fcc:	e7d23000 	ldrb	r3, [r2, r0]
   12fd0:	e3530020 	cmp	r3, #32	; 0x20
   12fd4:	e281e001 	add	lr, r1, #1	; 0x1
   12fd8:	0a000004 	beq	12ff0 <fat16_dir_entry_read_callback+0x110>
   12fdc:	e20e10ff 	and	r1, lr, #255	; 0xff
   12fe0:	e3510008 	cmp	r1, #8	; 0x8
                    break;
                long_name[i] = raw_entry[i];
   12fe4:	e7c2300c 	strb	r3, [r2, ip]
   12fe8:	e2822001 	add	r2, r2, #1	; 0x1
   12fec:	1afffff6 	bne	12fcc <fat16_dir_entry_read_callback+0xec>
            }
            if(raw_entry[8] != ' ')
   12ff0:	e5d03008 	ldrb	r3, [r0, #8]
   12ff4:	e3530020 	cmp	r3, #32	; 0x20
   12ff8:	0a00000e 	beq	13038 <fat16_dir_entry_read_callback+0x158>
            {
                long_name[i++] = '.';
   12ffc:	e3a0302e 	mov	r3, #46	; 0x2e
   13000:	e2812001 	add	r2, r1, #1	; 0x1
   13004:	e7cc3001 	strb	r3, [ip, r1]
   13008:	e20210ff 	and	r1, r2, #255	; 0xff
   1300c:	e1a03000 	mov	r3, r0

                uint8_t j = 8;
                for(; j < 11; ++j)
                {
                    if(raw_entry[j] != ' ')
   13010:	e5d32008 	ldrb	r2, [r3, #8]
   13014:	e3520020 	cmp	r2, #32	; 0x20
   13018:	e280e003 	add	lr, r0, #3	; 0x3
                    {
                        long_name[i++] = raw_entry[j];
   1301c:	e2814001 	add	r4, r1, #1	; 0x1
   13020:	e2833001 	add	r3, r3, #1	; 0x1
   13024:	0a000003 	beq	13038 <fat16_dir_entry_read_callback+0x158>
   13028:	e153000e 	cmp	r3, lr
   1302c:	e7cc2001 	strb	r2, [ip, r1]
   13030:	e20410ff 	and	r1, r4, #255	; 0xff
   13034:	1afffff5 	bne	13010 <fat16_dir_entry_read_callback+0x130>
                    }
                    else
                    {
                        break;
                    }
                }
            }

            long_name[i] = '\0';
   13038:	e3a03000 	mov	r3, #0	; 0x0
   1303c:	e7cc3001 	strb	r3, [ip, r1]
        }

        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
   13040:	e5d53000 	ldrb	r3, [r5]
   13044:	e5cc3020 	strb	r3, [ip, #32]
        dir_entry->cluster = ((uint16_t) raw_entry[26]) |
   13048:	e5d0201b 	ldrb	r2, [r0, #27]
   1304c:	e5d0301a 	ldrb	r3, [r0, #26]
   13050:	e1833402 	orr	r3, r3, r2, lsl #8
   13054:	e1cc32b2 	strh	r3, [ip, #34]
        ((uint16_t) raw_entry[27] << 8);
        dir_entry->file_size = ((uint32_t) raw_entry[28]) |
   13058:	e5d0301e 	ldrb	r3, [r0, #30]
   1305c:	e5d0201c 	ldrb	r2, [r0, #28]
   13060:	e5d0101d 	ldrb	r1, [r0, #29]
   13064:	e5d0001f 	ldrb	r0, [r0, #31]
   13068:	e1a03803 	mov	r3, r3, lsl #16
   1306c:	e1833c00 	orr	r3, r3, r0, lsl #24
   13070:	e1822401 	orr	r2, r2, r1, lsl #8
   13074:	e1822003 	orr	r2, r2, r3
   13078:	e3a00000 	mov	r0, #0	; 0x0
   1307c:	e58c2024 	str	r2, [ip, #36]
   13080:	ea000000 	b	13088 <fat16_dir_entry_read_callback+0x1a8>
   13084:	e3a00000 	mov	r0, #0	; 0x0
   13088:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1308c:	e12fff1e 	bx	lr

00013090 <fat16_get_next_cluster>:
        ((uint32_t) raw_entry[29] << 8) |
        ((uint32_t) raw_entry[30] << 16) |
        ((uint32_t) raw_entry[31] << 24);

        return 2;
    }
}

/**
 * \ingroup fat16_file
 * Retrieves the directory entry of a path.
 *
 * The given path may both describe a file or a directory.
 *
 * \param[in] fs The FAT16 filesystem on which to search.
 * \param[in] path The path of which to read the directory entry.
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !path || path[0] == '\0' || !dir_entry)
        return 0;

    if(path[0] == '/')
        ++path;

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT16_ATTRIB_DIR;

    if(path[0] == '\0')
        return 1;

    while(1)
    {
        struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
        if(!dd)
            break;

        /* extract the next hierarchy we will search for */
        const char* sep_pos = strchr(path, '/');
        if(!sep_pos)
            sep_pos = path + strlen(path);
        uint8_t length_to_sep = sep_pos - path;

        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
                strncmp(path, dir_entry->long_name, length_to_sep) != 0))
            continue;

            fat16_close_dir(dd);
            dd = 0;

            if(path[length_to_sep] == '\0')
    /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT16_ATTRIB_DIR)
            {
                /* we found a parent directory of the file we are searching for */
                path = sep_pos + 1;
                break;
            }

            /* a parent of the file exists, but not the file itself */
            return 0;
        }

        fat16_close_dir(dd);
    }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Retrieves the next following cluster of a given cluster.
 *
 * Using the filesystem file allocation table, this function returns
 * the number of the cluster containing the data directly following
 * the data within the cluster with the given number.
 *
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
   13090:	e52de004 	str	lr, [sp, #-4]!
   13094:	e1a03801 	mov	r3, r1, lsl #16
   13098:	e1a03823 	mov	r3, r3, lsr #16
   1309c:	e24dd004 	sub	sp, sp, #4	; 0x4
    if(!fs || cluster_num < 2)
        return 0;

    /* read appropriate fat entry */
    uint8_t fat_entry[2];
    if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
   130a0:	e3a02002 	mov	r2, #2	; 0x2
   130a4:	e3500000 	cmp	r0, #0	; 0x0
   130a8:	13530001 	cmpne	r3, #1	; 0x1
   130ac:	e08d1002 	add	r1, sp, r2
   130b0:	e1a0c000 	mov	ip, r0
   130b4:	9a00001a 	bls	13124 <fat16_get_next_cluster+0x94>
   130b8:	e5900008 	ldr	r0, [r0, #8]
   130bc:	e0200293 	mla	r0, r3, r2, r0
   130c0:	e59c3000 	ldr	r3, [ip]
   130c4:	e593c000 	ldr	ip, [r3]
   130c8:	e1a0e00f 	mov	lr, pc
   130cc:	e12fff1c 	bx	ip
   130d0:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    /* determine next cluster from fat */
    cluster_num = ((uint16_t) fat_entry[0]) |
    ((uint16_t) fat_entry[1] << 8);
	///*
    if(cluster_num == FAT16_CLUSTER_FREE ||
   130d4:	e59f1058 	ldr	r1, [pc, #88]	; 13134 <.text+0x3134>
   130d8:	0a000011 	beq	13124 <fat16_get_next_cluster+0x94>
   130dc:	e5dd2002 	ldrb	r2, [sp, #2]
   130e0:	e5dd3003 	ldrb	r3, [sp, #3]
   130e4:	e1920403 	orrs	r0, r2, r3, lsl #8
   130e8:	13a03000 	movne	r3, #0	; 0x0
   130ec:	03a03001 	moveq	r3, #1	; 0x1
   130f0:	e1500001 	cmp	r0, r1
   130f4:	03833001 	orreq	r3, r3, #1	; 0x1
   130f8:	e2802010 	add	r2, r0, #16	; 0x10
   130fc:	e3530000 	cmp	r3, #0	; 0x0
   13100:	e1a02802 	mov	r2, r2, lsl #16
   13104:	1a000006 	bne	13124 <fat16_get_next_cluster+0x94>
   13108:	e1500001 	cmp	r0, r1
   1310c:	93a03000 	movls	r3, #0	; 0x0
   13110:	83a03001 	movhi	r3, #1	; 0x1
   13114:	e3520806 	cmp	r2, #393216	; 0x60000
   13118:	93833001 	orrls	r3, r3, #1	; 0x1
   1311c:	e3530000 	cmp	r3, #0	; 0x0
   13120:	0a000000 	beq	13128 <fat16_get_next_cluster+0x98>
        cluster_num == FAT16_CLUSTER_BAD ||
       (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
	   //********************************************************************************
       //(cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
	   (cluster_num >= FAT16_CLUSTER_LAST_MIN))
	   //********************************************************************************
    //*/
	return 0;

    return cluster_num;
   13124:	e3a00000 	mov	r0, #0	; 0x0
}
   13128:	e28dd004 	add	sp, sp, #4	; 0x4
   1312c:	e49de004 	ldr	lr, [sp], #4
   13130:	e12fff1e 	bx	lr
   13134:	0000fff7 	streqd	pc, [r0], -r7

00013138 <fat16_free_clusters>:

/**
 * \ingroup fat16_fs
 * Appends a new cluster chain to an existing one.
 *
 * Set cluster_num to zero to create a completely new one.
 *
 * \param[in] fs The file system on which to operate.
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs)
            return 0;
    
        device_read_t device_read = fs->partition->device_read;
        device_write_t device_write = fs->partition->device_write;
        uint32_t fat_offset = fs->header.fat_offset;
        uint16_t cluster_max = fs->header.fat_size / 2;
        uint16_t cluster_next = 0;
        uint16_t count_left = count;
        uint8_t buffer[2];
        uint16_t cluster_new;
        for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
        {
            if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                return 0;
    
            /* check if this is a free cluster */
            if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
                buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
            {
                /* allocate cluster */
                if(count_left == count)
                {
                    buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
                    buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
                }
                else
                {
                    buffer[0] = cluster_next & 0xff;
                    buffer[1] = (cluster_next >> 8) & 0xff;
                }
    
                if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                    break;
    
                cluster_next = cluster_new;
                if(--count_left == 0)
                    break;
            }
        }
    
        do
        {
            if(count_left > 0)
                break;
    
            /* We allocated a new cluster chain. Now join
                                             * it with the existing one.
                                             */
            if(cluster_num >= 2)
            {
                buffer[0] = cluster_next & 0xff;
                buffer[1] = (cluster_next >> 8) & 0xff;
                if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
                    break;
            }
    
            return cluster_next;
    
        }
        while(0);
    
        /* No space left on device or writing error.
                             * Free up all clusters already allocated.
                             */
        fat16_free_clusters(fs, cluster_next);
    
        return 0;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_fs
 * Frees a cluster chain, or a part thereof.
 *
 * Marks the specified cluster and all clusters which are sequentially
 * referenced by it as free. They may then be used again for future
 * file allocations.
 *
 * \note If this function is used for freeing just a part of a cluster
 *       chain, the new end of the chain is not correctly terminated
 *       within the FAT. Use fat16_terminate_clusters() instead.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat16_terminate_clusters
 */
uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
   13138:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   1313c:	e1a01801 	mov	r1, r1, lsl #16
   13140:	e1a03821 	mov	r3, r1, lsr #16
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
   13144:	e3500000 	cmp	r0, #0	; 0x0
   13148:	13530001 	cmpne	r3, #1	; 0x1
   1314c:	e24dd004 	sub	sp, sp, #4	; 0x4
   13150:	e1a05000 	mov	r5, r0
            return 0;
    
        uint32_t fat_offset = fs->header.fat_offset;
   13154:	85907008 	ldrhi	r7, [r0, #8]
   13158:	8a00001d 	bhi	131d4 <fat16_free_clusters+0x9c>
   1315c:	ea000024 	b	131f4 <fat16_free_clusters+0xbc>
        uint8_t buffer[2];
        while(cluster_num)
        {
            if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
   13160:	e5953000 	ldr	r3, [r5]
   13164:	e593c000 	ldr	ip, [r3]
   13168:	e1a0e00f 	mov	lr, pc
   1316c:	e12fff1c 	bx	ip
                return 0;
    
            /* get next cluster of current cluster before freeing current cluster */
            uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
            ((uint16_t) buffer[1] << 8);
    
            if(cluster_num_next == FAT16_CLUSTER_FREE)
                return 1;
            if(cluster_num_next == FAT16_CLUSTER_BAD ||
                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
               cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
               )
               )
            return 0;
			///*
			//**********************************************************
            //if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
            //    (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
            //   )
			if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN)
			//***********************************************************
			//*/
            cluster_num_next = 0;
    
            /* free cluster */
            buffer[0] = FAT16_CLUSTER_FREE & 0xff;
   13170:	e3a0e000 	mov	lr, #0	; 0x0
   13174:	e150000e 	cmp	r0, lr
            buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
            fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
   13178:	e1a01006 	mov	r1, r6
   1317c:	e3a02002 	mov	r2, #2	; 0x2
   13180:	e1a00004 	mov	r0, r4
   13184:	0a00001a 	beq	131f4 <fat16_free_clusters+0xbc>
   13188:	e5dd3002 	ldrb	r3, [sp, #2]
   1318c:	e5ddc003 	ldrb	ip, [sp, #3]
   13190:	e193340c 	orrs	r3, r3, ip, lsl #8
   13194:	e1a04003 	mov	r4, r3
   13198:	e2833010 	add	r3, r3, #16	; 0x10
   1319c:	e1a03803 	mov	r3, r3, lsl #16
   131a0:	0a000015 	beq	131fc <fat16_free_clusters+0xc4>
   131a4:	e3530807 	cmp	r3, #458752	; 0x70000
   131a8:	9a000011 	bls	131f4 <fat16_free_clusters+0xbc>
   131ac:	e59f3058 	ldr	r3, [pc, #88]	; 1320c <.text+0x320c>
   131b0:	e5cde003 	strb	lr, [sp, #3]
   131b4:	e5cde002 	strb	lr, [sp, #2]
   131b8:	e1540003 	cmp	r4, r3
   131bc:	81a0400e 	movhi	r4, lr
   131c0:	e5953000 	ldr	r3, [r5]
   131c4:	e593c008 	ldr	ip, [r3, #8]
   131c8:	e1a0e00f 	mov	lr, pc
   131cc:	e12fff1c 	bx	ip
   131d0:	e1a03004 	mov	r3, r4
   131d4:	e0874083 	add	r4, r7, r3, lsl #1
   131d8:	e28d6002 	add	r6, sp, #2	; 0x2
   131dc:	e3530000 	cmp	r3, #0	; 0x0
   131e0:	e1a01006 	mov	r1, r6
   131e4:	e3a02002 	mov	r2, #2	; 0x2
   131e8:	e1a00004 	mov	r0, r4
   131ec:	1affffdb 	bne	13160 <fat16_free_clusters+0x28>
   131f0:	ea000001 	b	131fc <fat16_free_clusters+0xc4>
   131f4:	e3a00000 	mov	r0, #0	; 0x0
   131f8:	ea000000 	b	13200 <fat16_free_clusters+0xc8>
   131fc:	e3a00001 	mov	r0, #1	; 0x1
    
            /* We continue in any case here, even if freeing the cluster failed.
                                             * The cluster is lost, but maybe we can still free up some later ones.
                                             */
    
            cluster_num = cluster_num_next;
        }
    
        return 1;
    #else
        return 0;
    #endif
}
   13200:	e28dd004 	add	sp, sp, #4	; 0x4
   13204:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   13208:	e12fff1e 	bx	lr
   1320c:	0000fff7 	streqd	pc, [r0], -r7

00013210 <fat16_append_clusters>:
   13210:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13214:	e1a01801 	mov	r1, r1, lsl #16
   13218:	e24dd014 	sub	sp, sp, #20	; 0x14
   1321c:	e1a02802 	mov	r2, r2, lsl #16
   13220:	e1a01821 	mov	r1, r1, lsr #16
   13224:	e2507000 	subs	r7, r0, #0	; 0x0
   13228:	e58d1000 	str	r1, [sp]
   1322c:	e1a09822 	mov	r9, r2, lsr #16
   13230:	0a00004e 	beq	13370 <fat16_append_clusters+0x160>
   13234:	e5972000 	ldr	r2, [r7]
   13238:	e597300c 	ldr	r3, [r7, #12]
   1323c:	e5921008 	ldr	r1, [r2, #8]
   13240:	e1a03783 	mov	r3, r3, lsl #15
   13244:	e3a04000 	mov	r4, #0	; 0x0
   13248:	e5922000 	ldr	r2, [r2]
   1324c:	e597b008 	ldr	fp, [r7, #8]
   13250:	e1a03823 	mov	r3, r3, lsr #16
   13254:	e1a05009 	mov	r5, r9
   13258:	e1a0a004 	mov	sl, r4
   1325c:	e58d1008 	str	r1, [sp, #8]
   13260:	e58d2004 	str	r2, [sp, #4]
   13264:	e58d300c 	str	r3, [sp, #12]
   13268:	ea000023 	b	132fc <fat16_append_clusters+0xec>
   1326c:	e08b8086 	add	r8, fp, r6, lsl #1
   13270:	e1a00008 	mov	r0, r8
   13274:	e28d1012 	add	r1, sp, #18	; 0x12
   13278:	e3a02002 	mov	r2, #2	; 0x2
   1327c:	e59d3004 	ldr	r3, [sp, #4]
   13280:	e1a0e00f 	mov	lr, pc
   13284:	e12fff13 	bx	r3
   13288:	e3500000 	cmp	r0, #0	; 0x0
   1328c:	0a000037 	beq	13370 <fat16_append_clusters+0x160>
   13290:	e5dd3012 	ldrb	r3, [sp, #18]
   13294:	e3530000 	cmp	r3, #0	; 0x0
   13298:	1a000016 	bne	132f8 <fat16_append_clusters+0xe8>
   1329c:	e5dd3013 	ldrb	r3, [sp, #19]
   132a0:	e3530000 	cmp	r3, #0	; 0x0
   132a4:	1a000013 	bne	132f8 <fat16_append_clusters+0xe8>
   132a8:	e1550009 	cmp	r5, r9
   132ac:	03e03000 	mvneq	r3, #0	; 0x0
   132b0:	11a03424 	movne	r3, r4, lsr #8
   132b4:	05cd3013 	streqb	r3, [sp, #19]
   132b8:	05cd3012 	streqb	r3, [sp, #18]
   132bc:	15cd3013 	strneb	r3, [sp, #19]
   132c0:	15cd4012 	strneb	r4, [sp, #18]
   132c4:	e1a00008 	mov	r0, r8
   132c8:	e28d1012 	add	r1, sp, #18	; 0x12
   132cc:	e3a02002 	mov	r2, #2	; 0x2
   132d0:	e59d3008 	ldr	r3, [sp, #8]
   132d4:	e1a0e00f 	mov	lr, pc
   132d8:	e12fff13 	bx	r3
   132dc:	e3500000 	cmp	r0, #0	; 0x0
   132e0:	0a00000a 	beq	13310 <fat16_append_clusters+0x100>
   132e4:	e2453001 	sub	r3, r5, #1	; 0x1
   132e8:	e1a03803 	mov	r3, r3, lsl #16
   132ec:	e1b05823 	movs	r5, r3, lsr #16
   132f0:	0a000019 	beq	1335c <fat16_append_clusters+0x14c>
   132f4:	e1a04006 	mov	r4, r6
   132f8:	e28aa001 	add	sl, sl, #1	; 0x1
   132fc:	e59d100c 	ldr	r1, [sp, #12]
   13300:	e1a0380a 	mov	r3, sl, lsl #16
   13304:	e15a0001 	cmp	sl, r1
   13308:	e1a06823 	mov	r6, r3, lsr #16
   1330c:	1affffd6 	bne	1326c <fat16_append_clusters+0x5c>
   13310:	e3550000 	cmp	r5, #0	; 0x0
   13314:	1a000012 	bne	13364 <fat16_append_clusters+0x154>
   13318:	e59d3000 	ldr	r3, [sp]
   1331c:	e3530001 	cmp	r3, #1	; 0x1
   13320:	9a00000b 	bls	13354 <fat16_append_clusters+0x144>
   13324:	e59d1000 	ldr	r1, [sp]
   13328:	e1a03424 	mov	r3, r4, lsr #8
   1332c:	e5cd3013 	strb	r3, [sp, #19]
   13330:	e08b0081 	add	r0, fp, r1, lsl #1
   13334:	e5cd4012 	strb	r4, [sp, #18]
   13338:	e28d1012 	add	r1, sp, #18	; 0x12
   1333c:	e3a02002 	mov	r2, #2	; 0x2
   13340:	e59d3008 	ldr	r3, [sp, #8]
   13344:	e1a0e00f 	mov	lr, pc
   13348:	e12fff13 	bx	r3
   1334c:	e3500000 	cmp	r0, #0	; 0x0
   13350:	0a000003 	beq	13364 <fat16_append_clusters+0x154>
   13354:	e1a00004 	mov	r0, r4
   13358:	ea000005 	b	13374 <fat16_append_clusters+0x164>
   1335c:	e1a04006 	mov	r4, r6
   13360:	eaffffec 	b	13318 <fat16_append_clusters+0x108>
   13364:	e1a00007 	mov	r0, r7
   13368:	e1a01004 	mov	r1, r4
   1336c:	ebffff71 	bl	13138 <fat16_free_clusters>
   13370:	e3a00000 	mov	r0, #0	; 0x0
   13374:	e28dd014 	add	sp, sp, #20	; 0x14
   13378:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1337c:	e12fff1e 	bx	lr

00013380 <fat16_read_file>:

/**
 * \ingroup fat16_fs
 * Frees a part of a cluster chain and correctly terminates the rest.
 *
 * Marks the specified cluster as the new end of a cluster chain and
 * frees all following clusters.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The new end of the cluster chain.
 * \returns 0 on failure, 1 on success.
 * \see fat16_free_clusters
 */
uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
            return 0;
    
        /* fetch next cluster before overwriting the cluster entry */
        uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
    
        /* mark cluster as the last one */
        uint8_t buffer[2];
        buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
        buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
        if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
            return 0;
    
        /* free remaining clusters */
        if(cluster_num_next)
            return fat16_free_clusters(fs, cluster_num_next);
        else
            return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Opens a file on a FAT16 filesystem.
 *
 * \param[in] fs The filesystem on which the file to open lies.
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat16_close_file
 */
struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_file_struct* fd = malloc(sizeof(*fd));
    if(!fd)
        return 0;

    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    fd->fs = fs;
    fd->pos = 0;
    fd->pos_cluster = dir_entry->cluster;

    return fd;
}

/**
 * \ingroup fat16_file
 * Closes a file.
 *
 * \param[in] fd The file handle of the file to close.
 * \see fat16_open_file
 */
void fat16_close_file(struct fat16_file_struct* fd)
{
    if(fd)
        free(fd);
}

/**
 * \ingroup fat16_file
 * Reads data from a file.
 *
 * The data requested is read from the current file location.
 *
 * \param[in] fd The file handle of the file from which to read.
 * \param[out] buffer The buffer into which to write.
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat16_write_file
 */
int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
{
   13380:	e1a02802 	mov	r2, r2, lsl #16
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
   13384:	e3510000 	cmp	r1, #0	; 0x0
   13388:	13500000 	cmpne	r0, #0	; 0x0
   1338c:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13390:	e1a06000 	mov	r6, r0
   13394:	e1a0b001 	mov	fp, r1
   13398:	e1a08822 	mov	r8, r2, lsr #16
   1339c:	0a000050 	beq	134e4 <fat16_read_file+0x164>
   133a0:	e3580000 	cmp	r8, #0	; 0x0
   133a4:	0a00004e 	beq	134e4 <fat16_read_file+0x164>
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
   133a8:	e5907030 	ldr	r7, [r0, #48]
   133ac:	e5902028 	ldr	r2, [r0, #40]
   133b0:	e0873008 	add	r3, r7, r8
   133b4:	e1530002 	cmp	r3, r2
   133b8:	9a000003 	bls	133cc <fat16_read_file+0x4c>
        buffer_len = fd->dir_entry.file_size - fd->pos;
   133bc:	e0673002 	rsb	r3, r7, r2
   133c0:	e1a03803 	mov	r3, r3, lsl #16
    if(buffer_len == 0)
   133c4:	e1b08823 	movs	r8, r3, lsr #16
   133c8:	0a000050 	beq	13510 <fat16_read_file+0x190>
        return 0;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
   133cc:	e1d653b4 	ldrh	r5, [r6, #52]
   133d0:	e5963000 	ldr	r3, [r6]
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;

    /* find cluster in which to start reading */
    if(!cluster_num)
   133d4:	e3550000 	cmp	r5, #0	; 0x0
   133d8:	e1d391b2 	ldrh	r9, [r3, #18]
   133dc:	1a000011 	bne	13428 <fat16_read_file+0xa8>
    {
        cluster_num = fd->dir_entry.cluster;
   133e0:	e1d652b6 	ldrh	r5, [r6, #38]

        if(!cluster_num)
   133e4:	e3550000 	cmp	r5, #0	; 0x0
   133e8:	1a000002 	bne	133f8 <fat16_read_file+0x78>
        {
            if(!fd->pos)
   133ec:	e3570000 	cmp	r7, #0	; 0x0
   133f0:	0a000046 	beq	13510 <fat16_read_file+0x190>
   133f4:	ea00003a 	b	134e4 <fat16_read_file+0x164>
                return 0;
            else
                return -1;
        }

        if(fd->pos)
   133f8:	e3570000 	cmp	r7, #0	; 0x0
   133fc:	11a04007 	movne	r4, r7
   13400:	1a000004 	bne	13418 <fat16_read_file+0x98>
   13404:	ea000007 	b	13428 <fat16_read_file+0xa8>
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
   13408:	e5960000 	ldr	r0, [r6]
   1340c:	ebffff1f 	bl	13090 <fat16_get_next_cluster>
                if(!cluster_num)
   13410:	e2505000 	subs	r5, r0, #0	; 0x0
   13414:	0a000032 	beq	134e4 <fat16_read_file+0x164>
   13418:	e1540009 	cmp	r4, r9
   1341c:	e1a01005 	mov	r1, r5
   13420:	e0694004 	rsb	r4, r9, r4
   13424:	2afffff7 	bcs	13408 <fat16_read_file+0x88>
   13428:	e1a00007 	mov	r0, r7
   1342c:	e1a01009 	mov	r1, r9
   13430:	eb001337 	bl	18114 <__umodsi3>
   13434:	e1a00800 	mov	r0, r0, lsl #16
   13438:	e1a0a820 	mov	sl, r0, lsr #16
   1343c:	e1a07008 	mov	r7, r8
                    return -1;
            }
        }
    }

    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
        (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
   13440:	e06a3009 	rsb	r3, sl, r9
   13444:	e596c000 	ldr	ip, [r6]
   13448:	e1a03803 	mov	r3, r3, lsl #16
   1344c:	e1a03823 	mov	r3, r3, lsr #16
   13450:	e1570003 	cmp	r7, r3
   13454:	31a03007 	movcc	r3, r7
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
   13458:	e59c2018 	ldr	r2, [ip, #24]
   1345c:	e1a03803 	mov	r3, r3, lsl #16
   13460:	e1a04823 	mov	r4, r3, lsr #16
   13464:	e08a2002 	add	r2, sl, r2
   13468:	e2453002 	sub	r3, r5, #2	; 0x2
   1346c:	e0202399 	mla	r0, r9, r3, r2
   13470:	e1a0100b 	mov	r1, fp
   13474:	e1a02004 	mov	r2, r4
   13478:	e59c3000 	ldr	r3, [ip]
   1347c:	e593c000 	ldr	ip, [r3]
   13480:	e1a0e00f 	mov	lr, pc
   13484:	e12fff1c 	bx	ip
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
   13488:	e0643007 	rsb	r3, r4, r7
   1348c:	e3500000 	cmp	r0, #0	; 0x0
        fd->pos += copy_length;

        if(first_cluster_offset + copy_length >= cluster_size)
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
   13490:	e1a01005 	mov	r1, r5
   13494:	e08bb004 	add	fp, fp, r4
   13498:	e08a2004 	add	r2, sl, r4
   1349c:	e1a00803 	mov	r0, r3, lsl #16
   134a0:	0a000011 	beq	134ec <fat16_read_file+0x16c>
   134a4:	e5963030 	ldr	r3, [r6, #48]
   134a8:	e1520009 	cmp	r2, r9
   134ac:	e0833004 	add	r3, r3, r4
   134b0:	e5863030 	str	r3, [r6, #48]
   134b4:	e1a07820 	mov	r7, r0, lsr #16
   134b8:	ba000004 	blt	134d0 <fat16_read_file+0x150>
   134bc:	e5960000 	ldr	r0, [r6]
   134c0:	ebfffef2 	bl	13090 <fat16_get_next_cluster>
   134c4:	e2505000 	subs	r5, r0, #0	; 0x0
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
                return buffer_len - buffer_left;
   134c8:	e3a0a000 	mov	sl, #0	; 0x0
   134cc:	0a00000a 	beq	134fc <fat16_read_file+0x17c>
            }
        }

        fd->pos_cluster = cluster_num;

    }
    while(buffer_left > 0); /* check if we are done */
   134d0:	e3570000 	cmp	r7, #0	; 0x0
   134d4:	e1c653b4 	strh	r5, [r6, #52]
   134d8:	1affffd8 	bne	13440 <fat16_read_file+0xc0>

    return buffer_len;
   134dc:	e1a03808 	mov	r3, r8, lsl #16
   134e0:	ea000003 	b	134f4 <fat16_read_file+0x174>
   134e4:	e3e00000 	mvn	r0, #0	; 0x0
   134e8:	ea000009 	b	13514 <fat16_read_file+0x194>
   134ec:	e0673008 	rsb	r3, r7, r8
   134f0:	e1a03803 	mov	r3, r3, lsl #16
   134f4:	e1a00843 	mov	r0, r3, asr #16
   134f8:	ea000005 	b	13514 <fat16_read_file+0x194>
   134fc:	e0673008 	rsb	r3, r7, r8
   13500:	e1a03803 	mov	r3, r3, lsl #16
   13504:	e1a00843 	mov	r0, r3, asr #16
   13508:	e1c653b4 	strh	r5, [r6, #52]
   1350c:	ea000000 	b	13514 <fat16_read_file+0x194>
   13510:	e3a00000 	mov	r0, #0	; 0x0
}
   13514:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13518:	e12fff1e 	bx	lr

0001351c <fat16_reset_dir>:

/**
 * \ingroup fat16_file
 * Writes data to a file.
 *
 * The data is written to the current file location.
 *
 * \param[in] fd The file handle of the file to which to write.
 * \param[in] buffer The buffer from which to read the data to be written.
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat16_read_file
 */
int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
{
    #if FAT16_WRITE_SUPPORT
        /* check arguments */
        if(!fd || !buffer || buffer_len < 1)
            return -1;
        if(fd->pos > fd->dir_entry.file_size)
            return -1;
    
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint16_t cluster_num = fd->pos_cluster;
        uint16_t buffer_left = buffer_len;
        uint16_t first_cluster_offset = fd->pos % cluster_size;
    
        /* find cluster in which to start writing */
        if(!cluster_num)
        {
            cluster_num = fd->dir_entry.cluster;
    
            if(!cluster_num)
            {
                if(!fd->pos)
                {
                    /* empty file */
                    fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
                    if(!cluster_num)
                        return -1;
                }
                else
                {
                    return -1;
                }
            }
    
            if(fd->pos)
            {
                uint32_t pos = fd->pos;
                uint16_t cluster_num_next;
                while(pos >= cluster_size)
                {
                    pos -= cluster_size;
                    cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                    if(!cluster_num_next && pos == 0)
        /* the file exactly ends on a cluster boundary, and we append to it */
                        cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                    if(!cluster_num_next)
                        return -1;
    
                    cluster_num = cluster_num_next;
                }
            }
        }
    
        /* write data */
        do
        {
            /* calculate data size to write to cluster */
            uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
            (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
            uint16_t write_length = cluster_size - first_cluster_offset;
            if(write_length > buffer_left)
                write_length = buffer_left;
    
            /* write data which fits into the current cluster */
            if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
                break;
    
            /* calculate new file position */
            buffer += write_length;
            buffer_left -= write_length;
            fd->pos += write_length;
    
            if(first_cluster_offset + write_length >= cluster_size)
            {
                /* we are on a cluster boundary, so get the next cluster */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num_next && buffer_left > 0)
        /* we reached the last cluster, append a new one */
                    cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                if(!cluster_num_next)
                {
                    fd->pos_cluster = 0;
                    break;
                }
    
                cluster_num = cluster_num_next;
                first_cluster_offset = 0;
            }
    
            fd->pos_cluster = cluster_num;
    
        }
        while(buffer_left > 0); /* check if we are done */
    
        /* update directory entry */
        if(fd->pos > fd->dir_entry.file_size)
        {
            uint32_t size_old = fd->dir_entry.file_size;
    
            /* update file size */
            fd->dir_entry.file_size = fd->pos;
            /* write directory entry */
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
            {
                /* We do not return an error here since we actually wrote
                                                             * some data to disk. So we calculate the amount of data
                                                             * we wrote to disk and which lies within the old file size.
                                                             */
                buffer_left = fd->pos - size_old;
                fd->pos = size_old;
            }
        }
    
        return buffer_len - buffer_left;
    
    #else
        return -1;
    #endif
}

/**
 * \ingroup fat16_file
 * Repositions the read/write file offset.
 *
 * Changes the file offset where the next call to fat16_read_file()
 * or fat16_write_file() starts reading/writing.
 *
 * If the new offset is beyond the end of the file, fat16_resize_file()
 * is implicitly called, i.e. the file is expanded.
 *
 * The new offset can be given in different ways determined by
 * the \c whence parameter:
 * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
 * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
 * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
 *
 * The resulting absolute offset is written to the location the \c offset
 * parameter points to.
 *
 * \param[in] fd The file decriptor of the file on which to seek.
 * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
 *                   parameter. The function writes the new absolute offset
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
{
    if(!fd || !offset)
        return 0;

    uint32_t new_pos = fd->pos;
    switch(whence)
    {
        case FAT16_SEEK_SET:
            new_pos = *offset;
            break;
        case FAT16_SEEK_CUR:
            new_pos += *offset;
            break;
        case FAT16_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
        return 0;

    fd->pos = new_pos;
    fd->pos_cluster = 0;

    *offset = new_pos;
    return 1;
}

/**
 * \ingroup fat16_file
 * Resizes a file to have a specific size.
 *
 * Enlarges or shrinks the file pointed to by the file descriptor to have
 * exactly the specified size.
 *
 * If the file is truncated, all bytes having an equal or larger offset
 * than the given size are lost. If the file is expanded, the additional
 * bytes are allocated.
 *
 * \note Please be aware that this function just allocates or deallocates disk
 * space, it does not explicitely clear it. To avoid data leakage, this
 * must be done manually.
 *
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
{
    #if FAT16_WRITE_SUPPORT
        if(!fd)
            return 0;
    
        uint16_t cluster_num = fd->dir_entry.cluster;
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint32_t size_new = size;
    
        do
        {
            if(cluster_num == 0 && size_new == 0)
        /* the file stays empty */
                break;
    
            /* seek to the next cluster as long as we need the space */
            while(size_new > cluster_size)
            {
                /* get next cluster of file */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(cluster_num_next)
                {
                    cluster_num = cluster_num_next;
                    size_new -= cluster_size;
                }
                else
                {
                    break;
                }
            }
    
            if(size_new > cluster_size || cluster_num == 0)
            {
                /* Allocate new cluster chain and append
                                                             * it to the existing one, if available.
                                                             */
                uint16_t cluster_count = size_new / cluster_size;
                if((uint32_t) cluster_count * cluster_size < size_new)
                    ++cluster_count;
                uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_count);
                if(!cluster_new_chain)
                    return 0;
    
                if(!cluster_num)
                {
                    cluster_num = cluster_new_chain;
                    fd->dir_entry.cluster = cluster_num;
                }
            }
    
            /* write new directory entry */
            fd->dir_entry.file_size = size;
            if(size == 0)
                fd->dir_entry.cluster = 0;
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
                return 0;
    
            if(size == 0)
            {
                /* free all clusters of file */
                fat16_free_clusters(fd->fs, cluster_num);
            }
            else if(size_new <= cluster_size)
            {
                /* free all clusters no longer needed */
                fat16_terminate_clusters(fd->fs, cluster_num);
            }
    
        }
        while(0);
    
        /* correct file position */
        if(size < fd->pos)
        {
            fd->pos = size;
            fd->pos_cluster = 0;
        }
    
        return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_dir
 * Opens a directory.
 *
 * \param[in] fs The filesystem on which the directory to open resides.
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat16_close_dir
 */
struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_dir_struct* dd = malloc(sizeof(*dd));
    if(!dd)
        return 0;

    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    dd->fs = fs;
    dd->entry_next = 0;

    return dd;
}

/**
 * \ingroup fat16_dir
 * Closes a directory descriptor.
 *
 * This function destroys a directory descriptor which was
 * previously obtained by calling fat16_open_dir(). When this
 * function returns, the given descriptor will be invalid.
 *
 * \param[in] dd The directory descriptor to close.
 * \see fat16_open_dir
 */
void fat16_close_dir(struct fat16_dir_struct* dd)
{
    if(dd)
        free(dd);
}

/**
 * \ingroup fat16_dir
 * Reads the next directory entry contained within a parent directory.
 *
 * \param[in] dd The descriptor of the parent directory from which to read the entry.
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat16_reset_dir
 */
uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
{
    if(!dd || !dir_entry)
        return 0;

    if(dd->dir_entry.cluster == 0)
    {
        /* read entry from root directory */
        if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }
    else
    {
        /* read entry from a subdirectory */
        if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }

    /* restart reading */
    dd->entry_next = 0;

    return 0;
}

/**
 * \ingroup fat16_dir
 * Resets a directory handle.
 *
 * Resets the directory handle such that reading restarts
 * with the first directory entry.
 *
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
   1351c:	e3500000 	cmp	r0, #0	; 0x0
   13520:	e1a03000 	mov	r3, r0
        return 0;

    dd->entry_next = 0;
   13524:	13a03000 	movne	r3, #0	; 0x0
   13528:	11c033b0 	strneh	r3, [r0, #48]
   1352c:	13a03001 	movne	r3, #1	; 0x1
    return 1;
}
   13530:	e1a00003 	mov	r0, r3
   13534:	e12fff1e 	bx	lr

00013538 <fat16_delete_file>:

/**
 * \ingroup fat16_fs
 * Writes a directory entry to disk.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
            return 0;
    
        device_write_t device_write = fs->partition->device_write;
        uint32_t offset = dir_entry->entry_offset;
        uint8_t name_len = strlen(dir_entry->long_name);
        uint8_t lfn_entry_count = (name_len + 12) / 13;
        uint8_t buffer[32];
    
        /* write 8.3 entry */
    
        /* generate 8.3 file name */
        memset(&buffer[0], ' ', 11);
        char* name_ext = strrchr(dir_entry->long_name, '.');
        if(name_ext)
        {
            ++name_ext;
    
            uint8_t name_ext_len = strlen(name_ext);
            name_len -= name_ext_len + 1;
    
            if(name_ext_len > 3)
                name_ext_len = 3;
    
            memcpy(&buffer[8], name_ext, name_ext_len);
        }
    
        if(name_len <= 8)
        {
            memcpy(buffer, dir_entry->long_name, name_len);
        }
        else
        {
            memcpy(buffer, dir_entry->long_name, 8);
    
            /* Minimize 8.3 name clashes by appending
                                             * the lower byte of the cluster number.
                                             */
            uint8_t num = dir_entry->cluster & 0xff;
    
            buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
            num &= 0x0f;
            buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
        }
    
        /* fill directory entry buffer */
        memset(&buffer[11], 0, sizeof(buffer) - 11);
        buffer[0x0b] = dir_entry->attributes;

        //Not used in bootloader
		#ifdef MAIN_FIRMWARE
			//Added modified date/time 12-26-07
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			//*******************************************
			//char * current_time;
			//*******************************************
/*			current_time = GPS_get_time();
			char * current_date;
			current_date = GPS_get_date();
			
			uint16_t modified_time, modified_date;
			uint8_t c_hour, c_minute, c_second;
			uint8_t c_year, c_month, c_day;
			
			c_hour = (current_time[0] - '0') * 10;
			c_hour += (current_time[1] - '0');
			c_minute = (current_time[3] - '0') * 10;
			c_minute += (current_time[4] - '0');
			c_second = (current_time[6] - '0') * 10;
			c_second += (current_time[7] - '0');
			
			c_day = (current_date[0] - '0') * 10;
			c_day += (current_date[1] - '0');
			c_month = (current_date[3] - '0') * 10;
			c_month += (current_date[4] - '0');
			c_year = (current_date[6] - '0') * 10;
			c_year += (current_date[7] - '0');
			
			//Correct for 1980 = 0, 2000 = 20, year code
			c_year += 20;
			
			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);

			//Do a little error correction
			if (c_year < 26) //26 = 2006
			{
				modified_time = 0;
				modified_date = 0;
			}

			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
			//rprintf("mod_time=%x\n", modified_time);
			//rprintf("mod_date=%x\n", modified_date);
			
			buffer[0x16] = (modified_time >> 0) & 0xFF;
			buffer[0x17] = (modified_time >> 8) & 0xFF;
			buffer[0x18] = (modified_date >> 0) & 0xFF;
			buffer[0x19] = (modified_date >> 8) & 0xFF;
			*/
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
		#endif

        buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
        buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
        buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
        buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
        buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
        buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
    
        /* write to disk */
        if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
            return 0;
    
        /* calculate checksum of 8.3 name */
        uint8_t checksum = buffer[0];
        uint8_t i;
        for(i = 1; i < 11; ++i)
            checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
        /* write lfn entries */
        uint8_t lfn_entry;
        for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
        {
            memset(buffer, 0, sizeof(buffer));
            memset(&buffer[0x01], 0xff, 10);
            memset(&buffer[0x0e], 0xff, 12);
            memset(&buffer[0x1c], 0xff, 4);
    
            buffer[0x00] = lfn_entry;
            if(lfn_entry == lfn_entry_count)
                buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
    
            /* set file name */
            const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
            i = 1;
            while(i < 0x1f)
            {
                buffer[i++] = *long_name_curr;
                buffer[i++] = 0;
    
                switch(i)
                {
                    case 0x0b:
                        i = 0x0e;
                        break;
                    case 0x1a:
                        i = 0x1c;
                        break;
                }
    
                if(!*long_name_curr++)
                    break;
            }
    
            /* mark as lfn entry */
            buffer[0x0b] = 0x0f;
    
            /* set checksum */
            buffer[0x0d] = checksum;
    
            /* write entry */
            device_write(offset, buffer, sizeof(buffer));
    
            offset += sizeof(buffer);
        }
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Creates a file.
 *
 * Creates a file and obtains the directory entry of the
 * new file. If the file to create already exists, the
 * directory entry of the existing file will be returned
 * within the dir_entry parameter.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] parent The handle of the directory in which to create the file.
 * \param[in] file The name of the file to create.
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_file
 */
uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!parent || !file || !file[0])
            return 0;
    
        /* check if the file already exists */
        while(1)
        {
            if(!fat16_read_dir(parent, dir_entry))
                break;
    
            if(strcmp(file, dir_entry->long_name) == 0)
            {
                fat16_reset_dir(parent);
                return 1;
            }
        }
    
        memset(dir_entry, 0, sizeof(*dir_entry));
        strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    
        /* search for a place where to write the directory entry to disk */
        uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
        uint8_t free_dir_entries_found = 0;
        struct fat16_fs_struct* fs = parent->fs;
        uint16_t cluster_num = parent->dir_entry.cluster;
        uint32_t dir_entry_offset = 0;
        uint32_t offset = 0;
        uint32_t offset_to = 0;
    
        if(cluster_num == 0)
        {
            /* we read/write from the root directory entry */
            offset = fs->header.root_dir_offset;
            offset_to = fs->header.cluster_zero_offset;
            dir_entry_offset = offset;
        }
    
        while(1)
        {
            if(offset == offset_to)
            {
                if(cluster_num == 0)
				/* We iterated through the whole root directory entry
                * and could not find enough space for the directory entry.
                */
                return 0;
    
                if(offset)
                {
                    /* We reached a cluster boundary and have to
                    * switch to the next cluster.
                    */
    
                    uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
                    if(!cluster_next)
                    {
                        cluster_next = fat16_append_clusters(fs, cluster_num, 1);
                        if(!cluster_next)
                            return 0;
    
                        /* we appended a new cluster and know it is free */
                        dir_entry_offset = fs->header.cluster_zero_offset +
                        (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
    
                        /* TODO: This cluster has to be zeroed in an efficient way, or at least
                        *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
                        */
                        break;
                    }
                    cluster_num = cluster_next;
                }
    
                offset = fs->header.cluster_zero_offset +
                (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
                offset_to = offset + fs->header.cluster_size;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
    
            /* read next lfn or 8.3 entry */
            uint8_t first_char;
            if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
                return 0;
    
            /* check if we found a free directory entry */
            if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
            {
                /* check if we have the needed number of available entries */
                ++free_dir_entries_found;
                if(free_dir_entries_found >= free_dir_entries_needed)
                    break;
    
                offset += 32;
            }
            else
            {
                offset += 32;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
        }

        /* write directory entry to disk */
        dir_entry->entry_offset = dir_entry_offset;
        if(!fat16_write_dir_entry(fs, dir_entry))
            return 0;
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Deletes a file or directory.
 *
 * It is not checked if the file to delete is a directory.
 * If a directory is deleted without first deleting its
 * subdirectories and files, disk space occupied by these
 * files will get wasted as there is no chance to release
 * it and mark it as free.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat16_create_file
 */
uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
   13538:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
   1353c:	e3510000 	cmp	r1, #0	; 0x0
   13540:	13500000 	cmpne	r0, #0	; 0x0
   13544:	e24dd00c 	sub	sp, sp, #12	; 0xc
   13548:	e1a06000 	mov	r6, r0
   1354c:	e1a07001 	mov	r7, r1
   13550:	0a00001f 	beq	135d4 <fat16_delete_file+0x9c>
            return 0;
    
        /* get offset of the file's directory entry */
        uint32_t dir_entry_offset = dir_entry->entry_offset;
   13554:	e5915028 	ldr	r5, [r1, #40]
        if(!dir_entry_offset)
   13558:	e3550000 	cmp	r5, #0	; 0x0
   1355c:	0a00001c 	beq	135d4 <fat16_delete_file+0x9c>
            return 0;
    
        uint8_t buffer[12];
        while(1)
        {
            /* read directory entry */
            if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
   13560:	e1a0100d 	mov	r1, sp
   13564:	e1a00005 	mov	r0, r5
   13568:	e3a0200c 	mov	r2, #12	; 0xc
   1356c:	e5963000 	ldr	r3, [r6]
   13570:	e593c000 	ldr	ip, [r3]
   13574:	e1a0e00f 	mov	lr, pc
   13578:	e12fff1c 	bx	ip
   1357c:	e3500000 	cmp	r0, #0	; 0x0
   13580:	e1a0400d 	mov	r4, sp
                return 0;
    
            /* mark the directory entry as deleted */
            buffer[0] = FAT16_DIRENTRY_DELETED;
    
            /* write back entry */
            if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
   13584:	e1a00005 	mov	r0, r5
   13588:	e1a0100d 	mov	r1, sp
   1358c:	e3a0200c 	mov	r2, #12	; 0xc
                return 0;
    
            /* check if we deleted the whole entry */
            if(buffer[11] != 0x0f)
                break;
    
            dir_entry_offset += 32;
   13590:	e2855020 	add	r5, r5, #32	; 0x20
   13594:	0a00000e 	beq	135d4 <fat16_delete_file+0x9c>
   13598:	e3e0301a 	mvn	r3, #26	; 0x1a
   1359c:	e5cd3000 	strb	r3, [sp]
   135a0:	e5963000 	ldr	r3, [r6]
   135a4:	e593c008 	ldr	ip, [r3, #8]
   135a8:	e1a0e00f 	mov	lr, pc
   135ac:	e12fff1c 	bx	ip
   135b0:	e3500000 	cmp	r0, #0	; 0x0
   135b4:	0a000006 	beq	135d4 <fat16_delete_file+0x9c>
   135b8:	e5dd300b 	ldrb	r3, [sp, #11]
   135bc:	e353000f 	cmp	r3, #15	; 0xf
   135c0:	0affffe6 	beq	13560 <fat16_delete_file+0x28>
        }
    
        /* We deleted the directory entry. The next thing to do is
                             * marking all occupied clusters as free.
                             */
        return fat16_free_clusters(fs, dir_entry->cluster);
   135c4:	e1a00006 	mov	r0, r6
   135c8:	e1d712b2 	ldrh	r1, [r7, #34]
   135cc:	ebfffed9 	bl	13138 <fat16_free_clusters>
   135d0:	ea000000 	b	135d8 <fat16_delete_file+0xa0>
   135d4:	e3a00000 	mov	r0, #0	; 0x0
    #else
        return 0;
    #endif
}
   135d8:	e28dd00c 	add	sp, sp, #12	; 0xc
   135dc:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   135e0:	e12fff1e 	bx	lr

000135e4 <fat16_get_fs_size>:

/**
 * \ingroup fat16_fs
 * Returns the amount of total storage capacity of the filesystem in bytes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the filesystem size in bytes otherwise.
 */
uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
{
    if(!fs)
   135e4:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
   135e8:	1590300c 	ldrne	r3, [r0, #12]
   135ec:	e1a02000 	mov	r2, r0
   135f0:	11a030a3 	movne	r3, r3, lsr #1
   135f4:	11d021b2 	ldrneh	r2, [r0, #18]
   135f8:	12433002 	subne	r3, r3, #2	; 0x2
   135fc:	10020293 	mulne	r2, r3, r2
}
   13600:	e1a00002 	mov	r0, r2
   13604:	e12fff1e 	bx	lr

00013608 <fat16_get_fs_free>:

/**
 * \ingroup fat16_fs
 * Returns the amount of free storage capacity on the filesystem in bytes.
 *
 * \note As the FAT16 filesystem is cluster based, this function does not
 *       return continuous values but multiples of the cluster size.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the free filesystem space in bytes otherwise.
 */
uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
{
   13608:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    if(!fs)
   1360c:	e2506000 	subs	r6, r0, #0	; 0x0
   13610:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   13614:	0a000021 	beq	136a0 <fat16_get_fs_free+0x98>
        return 0;

    uint8_t fat[32];
    struct fat16_usage_count_callback_arg count_arg;
    count_arg.cluster_count = 0;
    count_arg.buffer_size = sizeof(fat);
   13618:	e3a03020 	mov	r3, #32	; 0x20
   1361c:	e5cd302a 	strb	r3, [sp, #42]

    uint32_t fat_offset = fs->header.fat_offset;
   13620:	e5967008 	ldr	r7, [r6, #8]
    uint32_t fat_size = fs->header.fat_size;
   13624:	e596500c 	ldr	r5, [r6, #12]
   13628:	e3a03000 	mov	r3, #0	; 0x0
   1362c:	e1cd32b8 	strh	r3, [sp, #40]
   13630:	ea000012 	b	13680 <fat16_get_fs_free+0x78>
    while(fat_size > 0)
    {
        uint16_t length = UINT16_MAX - 1;
        if(fat_size < length)
   13634:	e59f3074 	ldr	r3, [pc, #116]	; 136b0 <.text+0x36b0>
   13638:	e1550003 	cmp	r5, r3
            length = fat_size;

        if(!fs->partition->device_read_interval(fat_offset,
   1363c:	e59f3070 	ldr	r3, [pc, #112]	; 136b4 <.text+0x36b4>
   13640:	91a04822 	movls	r4, r2, lsr #16
   13644:	e596c000 	ldr	ip, [r6]
   13648:	e58d3000 	str	r3, [sp]
   1364c:	e28d3028 	add	r3, sp, #40	; 0x28
   13650:	e58d3004 	str	r3, [sp, #4]
   13654:	e1a00007 	mov	r0, r7
   13658:	e28d1008 	add	r1, sp, #8	; 0x8
   1365c:	e3a02020 	mov	r2, #32	; 0x20
   13660:	e1a03004 	mov	r3, r4
   13664:	e59cc004 	ldr	ip, [ip, #4]
   13668:	e1a0e00f 	mov	lr, pc
   1366c:	e12fff1c 	bx	ip
   13670:	e3500000 	cmp	r0, #0	; 0x0
   13674:	0a000009 	beq	136a0 <fat16_get_fs_free+0x98>
            fat,
           sizeof(fat),
           length,
           fat16_get_fs_free_callback,
           &count_arg
           )
           )
        return 0;

        fat_offset += length;
        fat_size -= length;
   13678:	e0645005 	rsb	r5, r4, r5
   1367c:	e0877004 	add	r7, r7, r4
   13680:	e3550000 	cmp	r5, #0	; 0x0
   13684:	e59f402c 	ldr	r4, [pc, #44]	; 136b8 <.text+0x36b8>
   13688:	e1a02805 	mov	r2, r5, lsl #16
   1368c:	1affffe8 	bne	13634 <fat16_get_fs_free+0x2c>
    }

    return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
   13690:	e1d621b2 	ldrh	r2, [r6, #18]
   13694:	e1dd32b8 	ldrh	r3, [sp, #40]
   13698:	e0000392 	mul	r0, r2, r3
   1369c:	ea000000 	b	136a4 <fat16_get_fs_free+0x9c>
   136a0:	e3a00000 	mov	r0, #0	; 0x0
}
   136a4:	e28dd02c 	add	sp, sp, #44	; 0x2c
   136a8:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   136ac:	e12fff1e 	bx	lr
   136b0:	0000fffd 	streqd	pc, [r0], -sp
   136b4:	000136bc 	streqh	r3, [r1], -ip
   136b8:	0000fffe 	streqd	pc, [r0], -lr

000136bc <fat16_get_fs_free_callback>:

/**
 * \ingroup fat16_fs
 * Callback function used for counting free clusters.
 */
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
   136bc:	e92d4010 	stmdb	sp!, {r4, lr}
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    uint8_t buffer_size = count_arg->buffer_size;
   136c0:	e5d24002 	ldrb	r4, [r2, #2]
   136c4:	e1a0c002 	mov	ip, r2
   136c8:	e1a01000 	mov	r1, r0
   136cc:	e3a0e000 	mov	lr, #0	; 0x0
   136d0:	ea000007 	b	136f4 <fat16_get_fs_free_callback+0x38>
    uint8_t i;
    for(i = 0; i < buffer_size; i += 2)
    {
        if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
   136d4:	e7de3000 	ldrb	r3, [lr, r0]
   136d8:	e5d12001 	ldrb	r2, [r1, #1]
   136dc:	e1932402 	orrs	r2, r3, r2, lsl #8
            ++(count_arg->cluster_count);
   136e0:	01dc30b0 	ldreqh	r3, [ip]
   136e4:	02833001 	addeq	r3, r3, #1	; 0x1
   136e8:	01cc30b0 	streqh	r3, [ip]

        buffer += 2;
   136ec:	e2811002 	add	r1, r1, #2	; 0x2
   136f0:	e28ee002 	add	lr, lr, #2	; 0x2
   136f4:	e20e30ff 	and	r3, lr, #255	; 0xff
   136f8:	e1530004 	cmp	r3, r4
   136fc:	3afffff4 	bcc	136d4 <fat16_get_fs_free_callback+0x18>
    }

    return 1;
}
   13700:	e3a00001 	mov	r0, #1	; 0x1
   13704:	e8bd4010 	ldmia	sp!, {r4, lr}
   13708:	e12fff1e 	bx	lr

0001370c <fat16_file_size>:

uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    while(fat16_read_dir(dd, dir_entry))
    {
        if(strcmp(dir_entry->long_name, name) == 0)
        {
            fat16_reset_dir(dd);
            return 1;
        }
    }

    return 0;
}

struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name)
{
    struct fat16_dir_entry_struct file_entry;
    if(!find_file_in_dir(fs, dd, name, &file_entry))
        return 0;

    return fat16_open_file(fs, &file_entry);
}

int fat16_file_size(struct fat16_file_struct * file)
{
    return(file->dir_entry.file_size);
}
   1370c:	e5900028 	ldr	r0, [r0, #40]
   13710:	e12fff1e 	bx	lr

00013714 <fat16_read_dir>:
   13714:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13718:	e1a0a001 	mov	sl, r1
   1371c:	e2711001 	rsbs	r1, r1, #1	; 0x1
   13720:	33a01000 	movcc	r1, #0	; 0x0
   13724:	e35a0000 	cmp	sl, #0	; 0x0
   13728:	13500000 	cmpne	r0, #0	; 0x0
   1372c:	e24dd038 	sub	sp, sp, #56	; 0x38
   13730:	e1a08000 	mov	r8, r0
   13734:	0a000076 	beq	13914 <fat16_read_dir+0x200>
   13738:	e1d032b6 	ldrh	r3, [r0, #38]
   1373c:	e3530000 	cmp	r3, #0	; 0x0
   13740:	e1d093b0 	ldrh	r9, [r0, #48]
   13744:	e5906000 	ldr	r6, [r0]
   13748:	1a00002c 	bne	13800 <fat16_read_dir+0xec>
   1374c:	e3560000 	cmp	r6, #0	; 0x0
   13750:	11a07001 	movne	r7, r1
   13754:	03817001 	orreq	r7, r1, #1	; 0x1
   13758:	e3570000 	cmp	r7, #0	; 0x0
   1375c:	1a00006a 	bne	1390c <fat16_read_dir+0x1f8>
   13760:	e5963000 	ldr	r3, [r6]
   13764:	e28d502c 	add	r5, sp, #44	; 0x2c
   13768:	e2864004 	add	r4, r6, #4	; 0x4
   1376c:	e1a01007 	mov	r1, r7
   13770:	e3a0200c 	mov	r2, #12	; 0xc
   13774:	e1a00005 	mov	r0, r5
   13778:	e5936004 	ldr	r6, [r3, #4]
   1377c:	eb001094 	bl	179d4 <memset>
   13780:	e2840010 	add	r0, r4, #16	; 0x10
   13784:	e8900009 	ldmia	r0, {r0, r3}
   13788:	e59f2194 	ldr	r2, [pc, #404]	; 13924 <.text+0x3924>
   1378c:	e0603003 	rsb	r3, r0, r3
   13790:	e1a03803 	mov	r3, r3, lsl #16
   13794:	e28d400c 	add	r4, sp, #12	; 0xc
   13798:	e58d2000 	str	r2, [sp]
   1379c:	e1cd92be 	strh	r9, [sp, #46]
   137a0:	e58d5004 	str	r5, [sp, #4]
   137a4:	e1a03823 	mov	r3, r3, lsr #16
   137a8:	e1a01004 	mov	r1, r4
   137ac:	e3a02020 	mov	r2, #32	; 0x20
   137b0:	e1a0e00f 	mov	lr, pc
   137b4:	e12fff16 	bx	r6
   137b8:	e3500000 	cmp	r0, #0	; 0x0
   137bc:	0a000052 	beq	1390c <fat16_read_dir+0x1f8>
   137c0:	e59d3030 	ldr	r3, [sp, #48]
   137c4:	e3530000 	cmp	r3, #0	; 0x0
   137c8:	0a00004f 	beq	1390c <fat16_read_dir+0x1f8>
   137cc:	e1a01007 	mov	r1, r7
   137d0:	e3a0202c 	mov	r2, #44	; 0x2c
   137d4:	e1a0000a 	mov	r0, sl
   137d8:	eb00107d 	bl	179d4 <memset>
   137dc:	e59f2144 	ldr	r2, [pc, #324]	; 13928 <.text+0x3928>
   137e0:	e5dd3034 	ldrb	r3, [sp, #52]
   137e4:	e88d0404 	stmia	sp, {r2, sl}
   137e8:	e1a01004 	mov	r1, r4
   137ec:	e59d0030 	ldr	r0, [sp, #48]
   137f0:	e3a02020 	mov	r2, #32	; 0x20
   137f4:	e1a0e00f 	mov	lr, pc
   137f8:	e12fff16 	bx	r6
   137fc:	ea000039 	b	138e8 <fat16_read_dir+0x1d4>
   13800:	e3560000 	cmp	r6, #0	; 0x0
   13804:	e58d9008 	str	r9, [sp, #8]
   13808:	0a00003f 	beq	1390c <fat16_read_dir+0x1f8>
   1380c:	e3510000 	cmp	r1, #0	; 0x0
   13810:	1a00003d 	bne	1390c <fat16_read_dir+0x1f8>
   13814:	e2800004 	add	r0, r0, #4	; 0x4
   13818:	e5d03020 	ldrb	r3, [r0, #32]
   1381c:	e3130010 	tst	r3, #16	; 0x10
   13820:	0a000039 	beq	1390c <fat16_read_dir+0x1f8>
   13824:	e1d072b2 	ldrh	r7, [r0, #34]
   13828:	e1d691b2 	ldrh	r9, [r6, #18]
   1382c:	e5962018 	ldr	r2, [r6, #24]
   13830:	e2473002 	sub	r3, r7, #2	; 0x2
   13834:	e0252399 	mla	r5, r9, r3, r2
   13838:	e28d402c 	add	r4, sp, #44	; 0x2c
   1383c:	e3a01000 	mov	r1, #0	; 0x0
   13840:	e3a0200c 	mov	r2, #12	; 0xc
   13844:	e1a00004 	mov	r0, r4
   13848:	eb001061 	bl	179d4 <memset>
   1384c:	e59d3008 	ldr	r3, [sp, #8]
   13850:	e1cd32be 	strh	r3, [sp, #46]
   13854:	e59f30c8 	ldr	r3, [pc, #200]	; 13924 <.text+0x3924>
   13858:	e28db00c 	add	fp, sp, #12	; 0xc
   1385c:	e596c000 	ldr	ip, [r6]
   13860:	e1a0100b 	mov	r1, fp
   13864:	e58d3000 	str	r3, [sp]
   13868:	e1a00005 	mov	r0, r5
   1386c:	e58d4004 	str	r4, [sp, #4]
   13870:	e3a02020 	mov	r2, #32	; 0x20
   13874:	e1a03009 	mov	r3, r9
   13878:	e59cc004 	ldr	ip, [ip, #4]
   1387c:	e1a0e00f 	mov	lr, pc
   13880:	e12fff1c 	bx	ip
   13884:	e3500000 	cmp	r0, #0	; 0x0
   13888:	e1a01007 	mov	r1, r7
   1388c:	e1a00006 	mov	r0, r6
   13890:	0a00001d 	beq	1390c <fat16_read_dir+0x1f8>
   13894:	e59d3030 	ldr	r3, [sp, #48]
   13898:	e3530000 	cmp	r3, #0	; 0x0
   1389c:	1a000003 	bne	138b0 <fat16_read_dir+0x19c>
   138a0:	ebfffdfa 	bl	13090 <fat16_get_next_cluster>
   138a4:	e2507000 	subs	r7, r0, #0	; 0x0
   138a8:	0a000017 	beq	1390c <fat16_read_dir+0x1f8>
   138ac:	eaffffde 	b	1382c <fat16_read_dir+0x118>
   138b0:	e3a01000 	mov	r1, #0	; 0x0
   138b4:	e3a0202c 	mov	r2, #44	; 0x2c
   138b8:	e1a0000a 	mov	r0, sl
   138bc:	eb001044 	bl	179d4 <memset>
   138c0:	e59f2060 	ldr	r2, [pc, #96]	; 13928 <.text+0x3928>
   138c4:	e596c000 	ldr	ip, [r6]
   138c8:	e5dd3034 	ldrb	r3, [sp, #52]
   138cc:	e88d0404 	stmia	sp, {r2, sl}
   138d0:	e1a0100b 	mov	r1, fp
   138d4:	e59d0030 	ldr	r0, [sp, #48]
   138d8:	e3a02020 	mov	r2, #32	; 0x20
   138dc:	e59cc004 	ldr	ip, [ip, #4]
   138e0:	e1a0e00f 	mov	lr, pc
   138e4:	e12fff1c 	bx	ip
   138e8:	e3500000 	cmp	r0, #0	; 0x0
   138ec:	0a000006 	beq	1390c <fat16_read_dir+0x1f8>
   138f0:	e5da3000 	ldrb	r3, [sl]
   138f4:	e3530000 	cmp	r3, #0	; 0x0
   138f8:	11d833b0 	ldrneh	r3, [r8, #48]
   138fc:	13a00001 	movne	r0, #1	; 0x1
   13900:	12833001 	addne	r3, r3, #1	; 0x1
   13904:	11c833b0 	strneh	r3, [r8, #48]
   13908:	1a000002 	bne	13918 <fat16_read_dir+0x204>
   1390c:	e3a03000 	mov	r3, #0	; 0x0
   13910:	e1c833b0 	strh	r3, [r8, #48]
   13914:	e3a00000 	mov	r0, #0	; 0x0
   13918:	e28dd038 	add	sp, sp, #56	; 0x38
   1391c:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13920:	e12fff1e 	bx	lr
   13924:	00012e70 	andeq	r2, r1, r0, ror lr
   13928:	00012ee0 	andeq	r2, r1, r0, ror #29

0001392c <find_file_in_dir>:
   1392c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   13930:	e1a04001 	mov	r4, r1
   13934:	e1a06002 	mov	r6, r2
   13938:	e1a05003 	mov	r5, r3
   1393c:	ea000007 	b	13960 <find_file_in_dir+0x34>
   13940:	eb001038 	bl	17a28 <strcmp>
   13944:	e3500000 	cmp	r0, #0	; 0x0
   13948:	1a000004 	bne	13960 <find_file_in_dir+0x34>
   1394c:	e3540000 	cmp	r4, #0	; 0x0
   13950:	03a03001 	moveq	r3, #1	; 0x1
   13954:	13a03001 	movne	r3, #1	; 0x1
   13958:	11c403b0 	strneh	r0, [r4, #48]
   1395c:	ea000006 	b	1397c <find_file_in_dir+0x50>
   13960:	e1a01005 	mov	r1, r5
   13964:	e1a00004 	mov	r0, r4
   13968:	ebffff69 	bl	13714 <fat16_read_dir>
   1396c:	e2503000 	subs	r3, r0, #0	; 0x0
   13970:	e1a01006 	mov	r1, r6
   13974:	e1a00005 	mov	r0, r5
   13978:	1afffff0 	bne	13940 <find_file_in_dir+0x14>
   1397c:	e1a00003 	mov	r0, r3
   13980:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   13984:	e12fff1e 	bx	lr

00013988 <fat16_write_dir_entry>:
   13988:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1398c:	e3510000 	cmp	r1, #0	; 0x0
   13990:	13500000 	cmpne	r0, #0	; 0x0
   13994:	e24dd020 	sub	sp, sp, #32	; 0x20
   13998:	e1a06001 	mov	r6, r1
   1399c:	0a000098 	beq	13c04 <fat16_write_dir_entry+0x27c>
   139a0:	e5903000 	ldr	r3, [r0]
   139a4:	e1a00001 	mov	r0, r1
   139a8:	e5939008 	ldr	r9, [r3, #8]
   139ac:	eb001029 	bl	17a58 <strlen>
   139b0:	e20050ff 	and	r5, r0, #255	; 0xff
   139b4:	e3a0100d 	mov	r1, #13	; 0xd
   139b8:	e285000c 	add	r0, r5, #12	; 0xc
   139bc:	eb001183 	bl	17fd0 <__aeabi_idiv>
   139c0:	e3a01020 	mov	r1, #32	; 0x20
   139c4:	e1a03000 	mov	r3, r0
   139c8:	e3a0200b 	mov	r2, #11	; 0xb
   139cc:	e1a0000d 	mov	r0, sp
   139d0:	e203a0ff 	and	sl, r3, #255	; 0xff
   139d4:	e5968028 	ldr	r8, [r6, #40]
   139d8:	eb000ffd 	bl	179d4 <memset>
   139dc:	e1a00006 	mov	r0, r6
   139e0:	e3a0102e 	mov	r1, #46	; 0x2e
   139e4:	eb00104a 	bl	17b14 <strrchr>
   139e8:	e3500000 	cmp	r0, #0	; 0x0
   139ec:	e1a0700d 	mov	r7, sp
   139f0:	0a00000b 	beq	13a24 <fat16_write_dir_entry+0x9c>
   139f4:	e2804001 	add	r4, r0, #1	; 0x1
   139f8:	e1a00004 	mov	r0, r4
   139fc:	eb001015 	bl	17a58 <strlen>
   13a00:	e20020ff 	and	r2, r0, #255	; 0xff
   13a04:	e0623005 	rsb	r3, r2, r5
   13a08:	e2433001 	sub	r3, r3, #1	; 0x1
   13a0c:	e3520003 	cmp	r2, #3	; 0x3
   13a10:	23a02003 	movcs	r2, #3	; 0x3
   13a14:	e1a01004 	mov	r1, r4
   13a18:	e28d0008 	add	r0, sp, #8	; 0x8
   13a1c:	e20350ff 	and	r5, r3, #255	; 0xff
   13a20:	eb000fe3 	bl	179b4 <memcpy>
   13a24:	e3550008 	cmp	r5, #8	; 0x8
   13a28:	8a000004 	bhi	13a40 <fat16_write_dir_entry+0xb8>
   13a2c:	e1a0000d 	mov	r0, sp
   13a30:	e1a02005 	mov	r2, r5
   13a34:	e1a01006 	mov	r1, r6
   13a38:	eb000fdd 	bl	179b4 <memcpy>
   13a3c:	ea00000e 	b	13a7c <fat16_write_dir_entry+0xf4>
   13a40:	e3a02008 	mov	r2, #8	; 0x8
   13a44:	e1a0000d 	mov	r0, sp
   13a48:	e1a01006 	mov	r1, r6
   13a4c:	eb000fd8 	bl	179b4 <memcpy>
   13a50:	e5d63022 	ldrb	r3, [r6, #34]
   13a54:	e353009f 	cmp	r3, #159	; 0x9f
   13a58:	e1a02223 	mov	r2, r3, lsr #4
   13a5c:	e203300f 	and	r3, r3, #15	; 0xf
   13a60:	92822030 	addls	r2, r2, #48	; 0x30
   13a64:	82822061 	addhi	r2, r2, #97	; 0x61
   13a68:	e3530009 	cmp	r3, #9	; 0x9
   13a6c:	92833030 	addls	r3, r3, #48	; 0x30
   13a70:	82833061 	addhi	r3, r3, #97	; 0x61
   13a74:	e5cd2006 	strb	r2, [sp, #6]
   13a78:	e5cd3007 	strb	r3, [sp, #7]
   13a7c:	e3a01000 	mov	r1, #0	; 0x0
   13a80:	e3a02015 	mov	r2, #21	; 0x15
   13a84:	e28d000b 	add	r0, sp, #11	; 0xb
   13a88:	eb000fd1 	bl	179d4 <memset>
   13a8c:	e5d63020 	ldrb	r3, [r6, #32]
   13a90:	e5cd300b 	strb	r3, [sp, #11]
   13a94:	e1d622b2 	ldrh	r2, [r6, #34]
   13a98:	e1a03422 	mov	r3, r2, lsr #8
   13a9c:	e5cd201a 	strb	r2, [sp, #26]
   13aa0:	e5cd301b 	strb	r3, [sp, #27]
   13aa4:	e5963024 	ldr	r3, [r6, #36]
   13aa8:	e1a00c23 	mov	r0, r3, lsr #24
   13aac:	e1a02423 	mov	r2, r3, lsr #8
   13ab0:	e1a01823 	mov	r1, r3, lsr #16
   13ab4:	e5cd201d 	strb	r2, [sp, #29]
   13ab8:	e5cd101e 	strb	r1, [sp, #30]
   13abc:	e5cd001f 	strb	r0, [sp, #31]
   13ac0:	e5cd301c 	strb	r3, [sp, #28]
   13ac4:	e088028a 	add	r0, r8, sl, lsl #5
   13ac8:	e1a0100d 	mov	r1, sp
   13acc:	e3a02020 	mov	r2, #32	; 0x20
   13ad0:	e1a0e00f 	mov	lr, pc
   13ad4:	e12fff19 	bx	r9
   13ad8:	e3500000 	cmp	r0, #0	; 0x0
   13adc:	e1a0400d 	mov	r4, sp
   13ae0:	0a000047 	beq	13c04 <fat16_write_dir_entry+0x27c>
   13ae4:	e5dd7000 	ldrb	r7, [sp]
   13ae8:	e1a0100d 	mov	r1, sp
   13aec:	e5f12001 	ldrb	r2, [r1, #1]!
   13af0:	e1a03387 	mov	r3, r7, lsl #7
   13af4:	e18330a7 	orr	r3, r3, r7, lsr #1
   13af8:	e0833002 	add	r3, r3, r2
   13afc:	e28d200a 	add	r2, sp, #10	; 0xa
   13b00:	e1510002 	cmp	r1, r2
   13b04:	e20370ff 	and	r7, r3, #255	; 0xff
   13b08:	1afffff7 	bne	13aec <fat16_write_dir_entry+0x164>
   13b0c:	e1a0500a 	mov	r5, sl
   13b10:	ea000037 	b	13bf4 <fat16_write_dir_entry+0x26c>
   13b14:	e3a01000 	mov	r1, #0	; 0x0
   13b18:	e3a02020 	mov	r2, #32	; 0x20
   13b1c:	e1a0000d 	mov	r0, sp
   13b20:	eb000fab 	bl	179d4 <memset>
   13b24:	e3a010ff 	mov	r1, #255	; 0xff
   13b28:	e3a0200a 	mov	r2, #10	; 0xa
   13b2c:	e28d0001 	add	r0, sp, #1	; 0x1
   13b30:	eb000fa7 	bl	179d4 <memset>
   13b34:	e3a010ff 	mov	r1, #255	; 0xff
   13b38:	e3a0200c 	mov	r2, #12	; 0xc
   13b3c:	e28d000e 	add	r0, sp, #14	; 0xe
   13b40:	eb000fa3 	bl	179d4 <memset>
   13b44:	e28d001c 	add	r0, sp, #28	; 0x1c
   13b48:	e3a010ff 	mov	r1, #255	; 0xff
   13b4c:	e3a02004 	mov	r2, #4	; 0x4
   13b50:	eb000f9f 	bl	179d4 <memset>
   13b54:	e155000a 	cmp	r5, sl
   13b58:	03853040 	orreq	r3, r5, #64	; 0x40
   13b5c:	e5cd5000 	strb	r5, [sp]
   13b60:	05cd3000 	streqb	r3, [sp]
   13b64:	e3a0300d 	mov	r3, #13	; 0xd
   13b68:	e02e6395 	mla	lr, r5, r3, r6
   13b6c:	e3a0c001 	mov	ip, #1	; 0x1
   13b70:	e28c3001 	add	r3, ip, #1	; 0x1
   13b74:	e20330ff 	and	r3, r3, #255	; 0xff
   13b78:	e2832001 	add	r2, r3, #1	; 0x1
   13b7c:	e28d4020 	add	r4, sp, #32	; 0x20
   13b80:	e55e000d 	ldrb	r0, [lr, #-13]
   13b84:	e084100c 	add	r1, r4, ip
   13b88:	e202c0ff 	and	ip, r2, #255	; 0xff
   13b8c:	e35c000b 	cmp	ip, #11	; 0xb
   13b90:	e0842003 	add	r2, r4, r3
   13b94:	e3a03000 	mov	r3, #0	; 0x0
   13b98:	e5410020 	strb	r0, [r1, #-32]
   13b9c:	03a0c00e 	moveq	ip, #14	; 0xe
   13ba0:	e5423020 	strb	r3, [r2, #-32]
   13ba4:	0a000001 	beq	13bb0 <fat16_write_dir_entry+0x228>
   13ba8:	e35c001a 	cmp	ip, #26	; 0x1a
   13bac:	028cc002 	addeq	ip, ip, #2	; 0x2
   13bb0:	e55e300d 	ldrb	r3, [lr, #-13]
   13bb4:	e3530000 	cmp	r3, #0	; 0x0
   13bb8:	e28ee001 	add	lr, lr, #1	; 0x1
   13bbc:	0a000001 	beq	13bc8 <fat16_write_dir_entry+0x240>
   13bc0:	e35c001e 	cmp	ip, #30	; 0x1e
   13bc4:	9affffe9 	bls	13b70 <fat16_write_dir_entry+0x1e8>
   13bc8:	e3a0300f 	mov	r3, #15	; 0xf
   13bcc:	e5cd300b 	strb	r3, [sp, #11]
   13bd0:	e1a00008 	mov	r0, r8
   13bd4:	e5cd700d 	strb	r7, [sp, #13]
   13bd8:	e1a0100d 	mov	r1, sp
   13bdc:	e3a02020 	mov	r2, #32	; 0x20
   13be0:	e1a0e00f 	mov	lr, pc
   13be4:	e12fff19 	bx	r9
   13be8:	e2453001 	sub	r3, r5, #1	; 0x1
   13bec:	e2888020 	add	r8, r8, #32	; 0x20
   13bf0:	e20350ff 	and	r5, r3, #255	; 0xff
   13bf4:	e3550000 	cmp	r5, #0	; 0x0
   13bf8:	1affffc5 	bne	13b14 <fat16_write_dir_entry+0x18c>
   13bfc:	e3a00001 	mov	r0, #1	; 0x1
   13c00:	ea000000 	b	13c08 <fat16_write_dir_entry+0x280>
   13c04:	e3a00000 	mov	r0, #0	; 0x0
   13c08:	e28dd020 	add	sp, sp, #32	; 0x20
   13c0c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13c10:	e12fff1e 	bx	lr

00013c14 <fat16_resize_file>:
   13c14:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13c18:	e2506000 	subs	r6, r0, #0	; 0x0
   13c1c:	e24dd004 	sub	sp, sp, #4	; 0x4
   13c20:	e1a0a001 	mov	sl, r1
   13c24:	0a00005b 	beq	13d98 <fat16_resize_file+0x184>
   13c28:	e1d642b6 	ldrh	r4, [r6, #38]
   13c2c:	e5963000 	ldr	r3, [r6]
   13c30:	e2719001 	rsbs	r9, r1, #1	; 0x1
   13c34:	33a09000 	movcc	r9, #0	; 0x0
   13c38:	e3540000 	cmp	r4, #0	; 0x0
   13c3c:	03510000 	cmpeq	r1, #0	; 0x0
   13c40:	e1d381b2 	ldrh	r8, [r3, #18]
   13c44:	11a07001 	movne	r7, r1
   13c48:	1a000006 	bne	13c68 <fat16_resize_file+0x54>
   13c4c:	ea000049 	b	13d78 <fat16_resize_file+0x164>
   13c50:	e5960000 	ldr	r0, [r6]
   13c54:	ebfffd0d 	bl	13090 <fat16_get_next_cluster>
   13c58:	e3500000 	cmp	r0, #0	; 0x0
   13c5c:	0a00004f 	beq	13da0 <fat16_resize_file+0x18c>
   13c60:	e0687007 	rsb	r7, r8, r7
   13c64:	e1a04000 	mov	r4, r0
   13c68:	e1570008 	cmp	r7, r8
   13c6c:	e1a01004 	mov	r1, r4
   13c70:	8afffff6 	bhi	13c50 <fat16_resize_file+0x3c>
   13c74:	e2745001 	rsbs	r5, r4, #1	; 0x1
   13c78:	33a05000 	movcc	r5, #0	; 0x0
   13c7c:	e3550000 	cmp	r5, #0	; 0x0
   13c80:	0a000011 	beq	13ccc <fat16_resize_file+0xb8>
   13c84:	e1a01008 	mov	r1, r8
   13c88:	e1a00007 	mov	r0, r7
   13c8c:	eb00108a 	bl	17ebc <__aeabi_uidiv>
   13c90:	e1a00800 	mov	r0, r0, lsl #16
   13c94:	e1a02820 	mov	r2, r0, lsr #16
   13c98:	e0030298 	mul	r3, r8, r2
   13c9c:	e1530007 	cmp	r3, r7
   13ca0:	32823001 	addcc	r3, r2, #1	; 0x1
   13ca4:	31a03803 	movcc	r3, r3, lsl #16
   13ca8:	31a02823 	movcc	r2, r3, lsr #16
   13cac:	e5960000 	ldr	r0, [r6]
   13cb0:	e1a01004 	mov	r1, r4
   13cb4:	ebfffd55 	bl	13210 <fat16_append_clusters>
   13cb8:	e3500000 	cmp	r0, #0	; 0x0
   13cbc:	0a000035 	beq	13d98 <fat16_resize_file+0x184>
   13cc0:	e3550000 	cmp	r5, #0	; 0x0
   13cc4:	11c602b6 	strneh	r0, [r6, #38]
   13cc8:	11a04000 	movne	r4, r0
   13ccc:	e3590000 	cmp	r9, #0	; 0x0
   13cd0:	13a03000 	movne	r3, #0	; 0x0
   13cd4:	11c632b6 	strneh	r3, [r6, #38]
   13cd8:	e586a028 	str	sl, [r6, #40]
   13cdc:	e5960000 	ldr	r0, [r6]
   13ce0:	e2861004 	add	r1, r6, #4	; 0x4
   13ce4:	ebffff27 	bl	13988 <fat16_write_dir_entry>
   13ce8:	e3500000 	cmp	r0, #0	; 0x0
   13cec:	0a000029 	beq	13d98 <fat16_resize_file+0x184>
   13cf0:	e3590000 	cmp	r9, #0	; 0x0
   13cf4:	11a01004 	movne	r1, r4
   13cf8:	15960000 	ldrne	r0, [r6]
   13cfc:	1a00001c 	bne	13d74 <fat16_resize_file+0x160>
   13d00:	e1570008 	cmp	r7, r8
   13d04:	8a00001b 	bhi	13d78 <fat16_resize_file+0x164>
   13d08:	e1a03804 	mov	r3, r4, lsl #16
   13d0c:	e5965000 	ldr	r5, [r6]
   13d10:	e1a04823 	mov	r4, r3, lsr #16
   13d14:	e3550000 	cmp	r5, #0	; 0x0
   13d18:	13540001 	cmpne	r4, #1	; 0x1
   13d1c:	9a000015 	bls	13d78 <fat16_resize_file+0x164>
   13d20:	e1a01004 	mov	r1, r4
   13d24:	e1a00005 	mov	r0, r5
   13d28:	ebfffcd8 	bl	13090 <fat16_get_next_cluster>
   13d2c:	e3e03000 	mvn	r3, #0	; 0x0
   13d30:	e5cd3003 	strb	r3, [sp, #3]
   13d34:	e5cd3002 	strb	r3, [sp, #2]
   13d38:	e1a07000 	mov	r7, r0
   13d3c:	e5950008 	ldr	r0, [r5, #8]
   13d40:	e5953000 	ldr	r3, [r5]
   13d44:	e0800084 	add	r0, r0, r4, lsl #1
   13d48:	e28d1002 	add	r1, sp, #2	; 0x2
   13d4c:	e3a02002 	mov	r2, #2	; 0x2
   13d50:	e593c008 	ldr	ip, [r3, #8]
   13d54:	e1a0e00f 	mov	lr, pc
   13d58:	e12fff1c 	bx	ip
   13d5c:	e3500000 	cmp	r0, #0	; 0x0
   13d60:	0a000004 	beq	13d78 <fat16_resize_file+0x164>
   13d64:	e3570000 	cmp	r7, #0	; 0x0
   13d68:	0a000002 	beq	13d78 <fat16_resize_file+0x164>
   13d6c:	e1a00005 	mov	r0, r5
   13d70:	e1a01007 	mov	r1, r7
   13d74:	ebfffcef 	bl	13138 <fat16_free_clusters>
   13d78:	e5963030 	ldr	r3, [r6, #48]
   13d7c:	e15a0003 	cmp	sl, r3
   13d80:	33a03000 	movcc	r3, #0	; 0x0
   13d84:	23a00001 	movcs	r0, #1	; 0x1
   13d88:	33a00001 	movcc	r0, #1	; 0x1
   13d8c:	3586a030 	strcc	sl, [r6, #48]
   13d90:	31c633b4 	strcch	r3, [r6, #52]
   13d94:	ea000004 	b	13dac <fat16_resize_file+0x198>
   13d98:	e3a00000 	mov	r0, #0	; 0x0
   13d9c:	ea000002 	b	13dac <fat16_resize_file+0x198>
   13da0:	e2745001 	rsbs	r5, r4, #1	; 0x1
   13da4:	33a05000 	movcc	r5, #0	; 0x0
   13da8:	eaffffb5 	b	13c84 <fat16_resize_file+0x70>
   13dac:	e28dd004 	add	sp, sp, #4	; 0x4
   13db0:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13db4:	e12fff1e 	bx	lr

00013db8 <fat16_seek_file>:
   13db8:	e3510000 	cmp	r1, #0	; 0x0
   13dbc:	13500000 	cmpne	r0, #0	; 0x0
   13dc0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   13dc4:	e20220ff 	and	r2, r2, #255	; 0xff
   13dc8:	e1a05000 	mov	r5, r0
   13dcc:	e1a06001 	mov	r6, r1
   13dd0:	0a00001b 	beq	13e44 <fat16_seek_file+0x8c>
   13dd4:	e3520001 	cmp	r2, #1	; 0x1
   13dd8:	e5901030 	ldr	r1, [r0, #48]
   13ddc:	0a000004 	beq	13df4 <fat16_seek_file+0x3c>
   13de0:	35964000 	ldrcc	r4, [r6]
   13de4:	3a000008 	bcc	13e0c <fat16_seek_file+0x54>
   13de8:	e3520002 	cmp	r2, #2	; 0x2
   13dec:	1a000014 	bne	13e44 <fat16_seek_file+0x8c>
   13df0:	ea000002 	b	13e00 <fat16_seek_file+0x48>
   13df4:	e5963000 	ldr	r3, [r6]
   13df8:	e0814003 	add	r4, r1, r3
   13dfc:	ea000002 	b	13e0c <fat16_seek_file+0x54>
   13e00:	e5902028 	ldr	r2, [r0, #40]
   13e04:	e5963000 	ldr	r3, [r6]
   13e08:	e0824003 	add	r4, r2, r3
   13e0c:	e5953028 	ldr	r3, [r5, #40]
   13e10:	e1540003 	cmp	r4, r3
   13e14:	9a000004 	bls	13e2c <fat16_seek_file+0x74>
   13e18:	e1a00005 	mov	r0, r5
   13e1c:	e1a01004 	mov	r1, r4
   13e20:	ebffff7b 	bl	13c14 <fat16_resize_file>
   13e24:	e3500000 	cmp	r0, #0	; 0x0
   13e28:	0a000005 	beq	13e44 <fat16_seek_file+0x8c>
   13e2c:	e3a03000 	mov	r3, #0	; 0x0
   13e30:	e3a00001 	mov	r0, #1	; 0x1
   13e34:	e5854030 	str	r4, [r5, #48]
   13e38:	e1c533b4 	strh	r3, [r5, #52]
   13e3c:	e5864000 	str	r4, [r6]
   13e40:	ea000000 	b	13e48 <fat16_seek_file+0x90>
   13e44:	e3a00000 	mov	r0, #0	; 0x0
   13e48:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   13e4c:	e12fff1e 	bx	lr

00013e50 <fat16_write_file>:
   13e50:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13e54:	e1a02802 	mov	r2, r2, lsl #16
   13e58:	e24dd004 	sub	sp, sp, #4	; 0x4
   13e5c:	e1a02822 	mov	r2, r2, lsr #16
   13e60:	e3510000 	cmp	r1, #0	; 0x0
   13e64:	13500000 	cmpne	r0, #0	; 0x0
   13e68:	e1a04000 	mov	r4, r0
   13e6c:	e1a0b001 	mov	fp, r1
   13e70:	e58d2000 	str	r2, [sp]
   13e74:	0a000077 	beq	14058 <fat16_write_file+0x208>
   13e78:	e3520000 	cmp	r2, #0	; 0x0
   13e7c:	0a000075 	beq	14058 <fat16_write_file+0x208>
   13e80:	e590a030 	ldr	sl, [r0, #48]
   13e84:	e5903028 	ldr	r3, [r0, #40]
   13e88:	e15a0003 	cmp	sl, r3
   13e8c:	8a000071 	bhi	14058 <fat16_write_file+0x208>
   13e90:	e1d053b4 	ldrh	r5, [r0, #52]
   13e94:	e5900000 	ldr	r0, [r0]
   13e98:	e3550000 	cmp	r5, #0	; 0x0
   13e9c:	e1d081b2 	ldrh	r8, [r0, #18]
   13ea0:	1a000020 	bne	13f28 <fat16_write_file+0xd8>
   13ea4:	e1d452b6 	ldrh	r5, [r4, #38]
   13ea8:	e3550000 	cmp	r5, #0	; 0x0
   13eac:	1a000008 	bne	13ed4 <fat16_write_file+0x84>
   13eb0:	e35a0000 	cmp	sl, #0	; 0x0
   13eb4:	1a000067 	bne	14058 <fat16_write_file+0x208>
   13eb8:	e1a01005 	mov	r1, r5
   13ebc:	e3a02001 	mov	r2, #1	; 0x1
   13ec0:	ebfffcd2 	bl	13210 <fat16_append_clusters>
   13ec4:	e3500000 	cmp	r0, #0	; 0x0
   13ec8:	e1a05000 	mov	r5, r0
   13ecc:	e1c402b6 	strh	r0, [r4, #38]
   13ed0:	0a000060 	beq	14058 <fat16_write_file+0x208>
   13ed4:	e5946030 	ldr	r6, [r4, #48]
   13ed8:	e3560000 	cmp	r6, #0	; 0x0
   13edc:	12689000 	rsbne	r9, r8, #0	; 0x0
   13ee0:	10687006 	rsbne	r7, r8, r6
   13ee4:	1a00000c 	bne	13f1c <fat16_write_file+0xcc>
   13ee8:	ea00000e 	b	13f28 <fat16_write_file+0xd8>
   13eec:	e5940000 	ldr	r0, [r4]
   13ef0:	ebfffc66 	bl	13090 <fat16_get_next_cluster>
   13ef4:	e3500000 	cmp	r0, #0	; 0x0
   13ef8:	03570000 	cmpeq	r7, #0	; 0x0
   13efc:	e0866009 	add	r6, r6, r9
   13f00:	e0877009 	add	r7, r7, r9
   13f04:	e1a01005 	mov	r1, r5
   13f08:	e3a02001 	mov	r2, #1	; 0x1
   13f0c:	05940000 	ldreq	r0, [r4]
   13f10:	0bfffcbe 	bleq	13210 <fat16_append_clusters>
   13f14:	e2505000 	subs	r5, r0, #0	; 0x0
   13f18:	0a00004e 	beq	14058 <fat16_write_file+0x208>
   13f1c:	e1560008 	cmp	r6, r8
   13f20:	e1a01005 	mov	r1, r5
   13f24:	2afffff0 	bcs	13eec <fat16_write_file+0x9c>
   13f28:	e1a0000a 	mov	r0, sl
   13f2c:	e1a01008 	mov	r1, r8
   13f30:	eb001077 	bl	18114 <__umodsi3>
   13f34:	e59d7000 	ldr	r7, [sp]
   13f38:	e1a00800 	mov	r0, r0, lsl #16
   13f3c:	e1a0a820 	mov	sl, r0, lsr #16
   13f40:	e594c000 	ldr	ip, [r4]
   13f44:	e06a3008 	rsb	r3, sl, r8
   13f48:	e59c2018 	ldr	r2, [ip, #24]
   13f4c:	e1a03803 	mov	r3, r3, lsl #16
   13f50:	e1a03823 	mov	r3, r3, lsr #16
   13f54:	e1570003 	cmp	r7, r3
   13f58:	31a06007 	movcc	r6, r7
   13f5c:	21a06003 	movcs	r6, r3
   13f60:	e08a2002 	add	r2, sl, r2
   13f64:	e2453002 	sub	r3, r5, #2	; 0x2
   13f68:	e0202398 	mla	r0, r8, r3, r2
   13f6c:	e1a0100b 	mov	r1, fp
   13f70:	e1a02006 	mov	r2, r6
   13f74:	e59c3000 	ldr	r3, [ip]
   13f78:	e593c008 	ldr	ip, [r3, #8]
   13f7c:	e1a0e00f 	mov	lr, pc
   13f80:	e12fff1c 	bx	ip
   13f84:	e0663007 	rsb	r3, r6, r7
   13f88:	e3500000 	cmp	r0, #0	; 0x0
   13f8c:	e1a01005 	mov	r1, r5
   13f90:	e08bb006 	add	fp, fp, r6
   13f94:	e08a2006 	add	r2, sl, r6
   13f98:	e1a00803 	mov	r0, r3, lsl #16
   13f9c:	0a000018 	beq	14004 <fat16_write_file+0x1b4>
   13fa0:	e5943030 	ldr	r3, [r4, #48]
   13fa4:	e1520008 	cmp	r2, r8
   13fa8:	e0833006 	add	r3, r3, r6
   13fac:	e5843030 	str	r3, [r4, #48]
   13fb0:	e1a07820 	mov	r7, r0, lsr #16
   13fb4:	ba00000f 	blt	13ff8 <fat16_write_file+0x1a8>
   13fb8:	e5940000 	ldr	r0, [r4]
   13fbc:	ebfffc33 	bl	13090 <fat16_get_next_cluster>
   13fc0:	e3a0a000 	mov	sl, #0	; 0x0
   13fc4:	e150000a 	cmp	r0, sl
   13fc8:	13a03000 	movne	r3, #0	; 0x0
   13fcc:	03a03001 	moveq	r3, #1	; 0x1
   13fd0:	e157000a 	cmp	r7, sl
   13fd4:	03a03000 	moveq	r3, #0	; 0x0
   13fd8:	e153000a 	cmp	r3, sl
   13fdc:	e1a01005 	mov	r1, r5
   13fe0:	e3a02001 	mov	r2, #1	; 0x1
   13fe4:	15940000 	ldrne	r0, [r4]
   13fe8:	1bfffc88 	blne	13210 <fat16_append_clusters>
   13fec:	e3500000 	cmp	r0, #0	; 0x0
   13ff0:	e1a05000 	mov	r5, r0
   13ff4:	0a000015 	beq	14050 <fat16_write_file+0x200>
   13ff8:	e3570000 	cmp	r7, #0	; 0x0
   13ffc:	e1c453b4 	strh	r5, [r4, #52]
   14000:	1affffce 	bne	13f40 <fat16_write_file+0xf0>
   14004:	e5943030 	ldr	r3, [r4, #48]
   14008:	e5945028 	ldr	r5, [r4, #40]
   1400c:	e1530005 	cmp	r3, r5
   14010:	9a000009 	bls	1403c <fat16_write_file+0x1ec>
   14014:	e5843028 	str	r3, [r4, #40]
   14018:	e5940000 	ldr	r0, [r4]
   1401c:	e2841004 	add	r1, r4, #4	; 0x4
   14020:	ebfffe58 	bl	13988 <fat16_write_dir_entry>
   14024:	e3500000 	cmp	r0, #0	; 0x0
   14028:	05943030 	ldreq	r3, [r4, #48]
   1402c:	00653003 	rsbeq	r3, r5, r3
   14030:	01a03803 	moveq	r3, r3, lsl #16
   14034:	05845030 	streq	r5, [r4, #48]
   14038:	01a07823 	moveq	r7, r3, lsr #16
   1403c:	e59d2000 	ldr	r2, [sp]
   14040:	e0673002 	rsb	r3, r7, r2
   14044:	e1a03803 	mov	r3, r3, lsl #16
   14048:	e1a00843 	mov	r0, r3, asr #16
   1404c:	ea000002 	b	1405c <fat16_write_file+0x20c>
   14050:	e1c403b4 	strh	r0, [r4, #52]
   14054:	eaffffea 	b	14004 <fat16_write_file+0x1b4>
   14058:	e3e00000 	mvn	r0, #0	; 0x0
   1405c:	e28dd004 	add	sp, sp, #4	; 0x4
   14060:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14064:	e12fff1e 	bx	lr

00014068 <fat16_close_dir>:
   14068:	e3500000 	cmp	r0, #0	; 0x0
   1406c:	e52de004 	str	lr, [sp, #-4]!
   14070:	1b000c9d 	blne	172ec <free>
   14074:	e49de004 	ldr	lr, [sp], #4
   14078:	e12fff1e 	bx	lr

0001407c <fat16_close_file>:
   1407c:	e3500000 	cmp	r0, #0	; 0x0
   14080:	e52de004 	str	lr, [sp, #-4]!
   14084:	1b000c98 	blne	172ec <free>
   14088:	e49de004 	ldr	lr, [sp], #4
   1408c:	e12fff1e 	bx	lr

00014090 <fat16_close>:
   14090:	e3500000 	cmp	r0, #0	; 0x0
   14094:	e52de004 	str	lr, [sp, #-4]!
   14098:	1b000c93 	blne	172ec <free>
   1409c:	e49de004 	ldr	lr, [sp], #4
   140a0:	e12fff1e 	bx	lr

000140a4 <fat16_open_dir>:
   140a4:	e3510000 	cmp	r1, #0	; 0x0
   140a8:	13500000 	cmpne	r0, #0	; 0x0
   140ac:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   140b0:	e1a07000 	mov	r7, r0
   140b4:	e1a05001 	mov	r5, r1
   140b8:	13a08000 	movne	r8, #0	; 0x0
   140bc:	03a08001 	moveq	r8, #1	; 0x1
   140c0:	0a000013 	beq	14114 <fat16_open_dir+0x70>
   140c4:	e5d13020 	ldrb	r3, [r1, #32]
   140c8:	e3130010 	tst	r3, #16	; 0x10
   140cc:	e3a00034 	mov	r0, #52	; 0x34
   140d0:	0a00000f 	beq	14114 <fat16_open_dir+0x70>
   140d4:	eb000c8c 	bl	1730c <malloc>
   140d8:	e3500000 	cmp	r0, #0	; 0x0
   140dc:	e1a06000 	mov	r6, r0
   140e0:	e2804004 	add	r4, r0, #4	; 0x4
   140e4:	0a00000a 	beq	14114 <fat16_open_dir+0x70>
   140e8:	e1a0c005 	mov	ip, r5
   140ec:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   140f0:	e1a0e004 	mov	lr, r4
   140f4:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   140f8:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   140fc:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14100:	e89c0007 	ldmia	ip, {r0, r1, r2}
   14104:	e5867000 	str	r7, [r6]
   14108:	e88e0007 	stmia	lr, {r0, r1, r2}
   1410c:	e1c683b0 	strh	r8, [r6, #48]
   14110:	ea000000 	b	14118 <fat16_open_dir+0x74>
   14114:	e3a06000 	mov	r6, #0	; 0x0
   14118:	e1a00006 	mov	r0, r6
   1411c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14120:	e12fff1e 	bx	lr

00014124 <fat16_open_file>:
   14124:	e3510000 	cmp	r1, #0	; 0x0
   14128:	13500000 	cmpne	r0, #0	; 0x0
   1412c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14130:	e1a05001 	mov	r5, r1
   14134:	e1a07000 	mov	r7, r0
   14138:	0a000015 	beq	14194 <fat16_open_file+0x70>
   1413c:	e5d13020 	ldrb	r3, [r1, #32]
   14140:	e2138010 	ands	r8, r3, #16	; 0x10
   14144:	e3a00038 	mov	r0, #56	; 0x38
   14148:	1a000011 	bne	14194 <fat16_open_file+0x70>
   1414c:	eb000c6e 	bl	1730c <malloc>
   14150:	e3500000 	cmp	r0, #0	; 0x0
   14154:	e1a06000 	mov	r6, r0
   14158:	e2804004 	add	r4, r0, #4	; 0x4
   1415c:	0a00000c 	beq	14194 <fat16_open_file+0x70>
   14160:	e1a0c005 	mov	ip, r5
   14164:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   14168:	e1a0e004 	mov	lr, r4
   1416c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14170:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   14174:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14178:	e89c0007 	ldmia	ip, {r0, r1, r2}
   1417c:	e88e0007 	stmia	lr, {r0, r1, r2}
   14180:	e1d552b2 	ldrh	r5, [r5, #34]
   14184:	e5867000 	str	r7, [r6]
   14188:	e5868030 	str	r8, [r6, #48]
   1418c:	e1c653b4 	strh	r5, [r6, #52]
   14190:	ea000000 	b	14198 <fat16_open_file+0x74>
   14194:	e3a06000 	mov	r6, #0	; 0x0
   14198:	e1a00006 	mov	r0, r6
   1419c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   141a0:	e12fff1e 	bx	lr

000141a4 <open_file_in_dir>:
   141a4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   141a8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   141ac:	e1a0300d 	mov	r3, sp
   141b0:	e1a04000 	mov	r4, r0
   141b4:	ebfffddc 	bl	1392c <find_file_in_dir>
   141b8:	e3500000 	cmp	r0, #0	; 0x0
   141bc:	e1a03000 	mov	r3, r0
   141c0:	e1a0500d 	mov	r5, sp
   141c4:	e1a00004 	mov	r0, r4
   141c8:	e1a0100d 	mov	r1, sp
   141cc:	0a000001 	beq	141d8 <open_file_in_dir+0x34>
   141d0:	ebffffd3 	bl	14124 <fat16_open_file>
   141d4:	e1a03000 	mov	r3, r0
   141d8:	e1a00003 	mov	r0, r3
   141dc:	e28dd02c 	add	sp, sp, #44	; 0x2c
   141e0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   141e4:	e12fff1e 	bx	lr

000141e8 <fat16_get_dir_entry_of_path>:
   141e8:	e3510000 	cmp	r1, #0	; 0x0
   141ec:	13500000 	cmpne	r0, #0	; 0x0
   141f0:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   141f4:	e1a09000 	mov	r9, r0
   141f8:	e1a04001 	mov	r4, r1
   141fc:	e1a05002 	mov	r5, r2
   14200:	0a00003c 	beq	142f8 <fat16_get_dir_entry_of_path+0x110>
   14204:	e5d13000 	ldrb	r3, [r1]
   14208:	e3520000 	cmp	r2, #0	; 0x0
   1420c:	13530000 	cmpne	r3, #0	; 0x0
   14210:	13a01000 	movne	r1, #0	; 0x0
   14214:	03a01001 	moveq	r1, #1	; 0x1
   14218:	0a000036 	beq	142f8 <fat16_get_dir_entry_of_path+0x110>
   1421c:	e353002f 	cmp	r3, #47	; 0x2f
   14220:	e1a00002 	mov	r0, r2
   14224:	e3a0202c 	mov	r2, #44	; 0x2c
   14228:	02844001 	addeq	r4, r4, #1	; 0x1
   1422c:	eb000de8 	bl	179d4 <memset>
   14230:	e3a03010 	mov	r3, #16	; 0x10
   14234:	e5c53020 	strb	r3, [r5, #32]
   14238:	e5d43000 	ldrb	r3, [r4]
   1423c:	e3530000 	cmp	r3, #0	; 0x0
   14240:	0a00002e 	beq	14300 <fat16_get_dir_entry_of_path+0x118>
   14244:	e1a00009 	mov	r0, r9
   14248:	e1a01005 	mov	r1, r5
   1424c:	ebffff94 	bl	140a4 <fat16_open_dir>
   14250:	e2507000 	subs	r7, r0, #0	; 0x0
   14254:	0a000027 	beq	142f8 <fat16_get_dir_entry_of_path+0x110>
   14258:	e1a00004 	mov	r0, r4
   1425c:	e3a0102f 	mov	r1, #47	; 0x2f
   14260:	eb000de4 	bl	179f8 <strchr>
   14264:	e2508000 	subs	r8, r0, #0	; 0x0
   14268:	1a000002 	bne	14278 <fat16_get_dir_entry_of_path+0x90>
   1426c:	e1a00004 	mov	r0, r4
   14270:	eb000df8 	bl	17a58 <strlen>
   14274:	e0848000 	add	r8, r4, r0
   14278:	e0643008 	rsb	r3, r4, r8
   1427c:	e20360ff 	and	r6, r3, #255	; 0xff
   14280:	ea000013 	b	142d4 <fat16_get_dir_entry_of_path+0xec>
   14284:	eb000df3 	bl	17a58 <strlen>
   14288:	e1500006 	cmp	r0, r6
   1428c:	e1a01005 	mov	r1, r5
   14290:	e1a02006 	mov	r2, r6
   14294:	e1a00004 	mov	r0, r4
   14298:	1a00000d 	bne	142d4 <fat16_get_dir_entry_of_path+0xec>
   1429c:	eb000df5 	bl	17a78 <strncmp>
   142a0:	e250a000 	subs	sl, r0, #0	; 0x0
   142a4:	1a00000a 	bne	142d4 <fat16_get_dir_entry_of_path+0xec>
   142a8:	e1a00007 	mov	r0, r7
   142ac:	ebffff6d 	bl	14068 <fat16_close_dir>
   142b0:	e7d43006 	ldrb	r3, [r4, r6]
   142b4:	e3530000 	cmp	r3, #0	; 0x0
   142b8:	0a000010 	beq	14300 <fat16_get_dir_entry_of_path+0x118>
   142bc:	e5d53020 	ldrb	r3, [r5, #32]
   142c0:	e3130010 	tst	r3, #16	; 0x10
   142c4:	0a00000b 	beq	142f8 <fat16_get_dir_entry_of_path+0x110>
   142c8:	e2884001 	add	r4, r8, #1	; 0x1
   142cc:	e1a0700a 	mov	r7, sl
   142d0:	ea000005 	b	142ec <fat16_get_dir_entry_of_path+0x104>
   142d4:	e1a01005 	mov	r1, r5
   142d8:	e1a00007 	mov	r0, r7
   142dc:	ebfffd0c 	bl	13714 <fat16_read_dir>
   142e0:	e3500000 	cmp	r0, #0	; 0x0
   142e4:	e1a00005 	mov	r0, r5
   142e8:	1affffe5 	bne	14284 <fat16_get_dir_entry_of_path+0x9c>
   142ec:	e1a00007 	mov	r0, r7
   142f0:	ebffff5c 	bl	14068 <fat16_close_dir>
   142f4:	eaffffd2 	b	14244 <fat16_get_dir_entry_of_path+0x5c>
   142f8:	e3a00000 	mov	r0, #0	; 0x0
   142fc:	ea000000 	b	14304 <fat16_get_dir_entry_of_path+0x11c>
   14300:	e3a00001 	mov	r0, #1	; 0x1
   14304:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14308:	e12fff1e 	bx	lr

0001430c <fat16_open>:
   1430c:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14310:	e2508000 	subs	r8, r0, #0	; 0x0
   14314:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   14318:	0a000071 	beq	144e4 <fat16_open+0x1d8>
   1431c:	e5983008 	ldr	r3, [r8, #8]
   14320:	e3530000 	cmp	r3, #0	; 0x0
   14324:	0a00006e 	beq	144e4 <fat16_open+0x1d8>
   14328:	e3a0001c 	mov	r0, #28	; 0x1c
   1432c:	eb000bf6 	bl	1730c <malloc>
   14330:	e250b000 	subs	fp, r0, #0	; 0x0
   14334:	1a000003 	bne	14348 <fat16_open+0x3c>
   14338:	e59f01b8 	ldr	r0, [pc, #440]	; 144f8 <.text+0x44f8>
   1433c:	ebfff597 	bl	119a0 <rprintf>
   14340:	e1a0a00b 	mov	sl, fp
   14344:	ea000067 	b	144e8 <fat16_open+0x1dc>
   14348:	e3a01000 	mov	r1, #0	; 0x0
   1434c:	e3a0201c 	mov	r2, #28	; 0x1c
   14350:	eb000d9f 	bl	179d4 <memset>
   14354:	e5983010 	ldr	r3, [r8, #16]
   14358:	e1a03483 	mov	r3, r3, lsl #9
   1435c:	e58d3008 	str	r3, [sp, #8]
   14360:	e58b8000 	str	r8, [fp]
   14364:	e283000b 	add	r0, r3, #11	; 0xb
   14368:	e28d1023 	add	r1, sp, #35	; 0x23
   1436c:	e3a02019 	mov	r2, #25	; 0x19
   14370:	e598c000 	ldr	ip, [r8]
   14374:	e1a0e00f 	mov	lr, pc
   14378:	e12fff1c 	bx	ip
   1437c:	e3500000 	cmp	r0, #0	; 0x0
   14380:	e1a0a00b 	mov	sl, fp
   14384:	0a000052 	beq	144d4 <fat16_open+0x1c8>
   14388:	e5dd202e 	ldrb	r2, [sp, #46]
   1438c:	e5dd302f 	ldrb	r3, [sp, #47]
   14390:	e1923403 	orrs	r3, r2, r3, lsl #8
   14394:	e5dd0023 	ldrb	r0, [sp, #35]
   14398:	e5dd2024 	ldrb	r2, [sp, #36]
   1439c:	e58d3010 	str	r3, [sp, #16]
   143a0:	e5dd6026 	ldrb	r6, [sp, #38]
   143a4:	e5dd3025 	ldrb	r3, [sp, #37]
   143a8:	e58d001c 	str	r0, [sp, #28]
   143ac:	e58d2018 	str	r2, [sp, #24]
   143b0:	e58d3004 	str	r3, [sp, #4]
   143b4:	e58d6014 	str	r6, [sp, #20]
   143b8:	e5dd1027 	ldrb	r1, [sp, #39]
   143bc:	e5dd9028 	ldrb	r9, [sp, #40]
   143c0:	e5dd7029 	ldrb	r7, [sp, #41]
   143c4:	e5dd502a 	ldrb	r5, [sp, #42]
   143c8:	e5dd402b 	ldrb	r4, [sp, #43]
   143cc:	e5dde02c 	ldrb	lr, [sp, #44]
   143d0:	e5ddc038 	ldrb	ip, [sp, #56]
   143d4:	e5dd2039 	ldrb	r2, [sp, #57]
   143d8:	e5dd303a 	ldrb	r3, [sp, #58]
   143dc:	e5dd003b 	ldrb	r0, [sp, #59]
   143e0:	0a00003b 	beq	144d4 <fat16_open+0x1c8>
   143e4:	e1a03803 	mov	r3, r3, lsl #16
   143e8:	e18c2402 	orr	r2, ip, r2, lsl #8
   143ec:	e1833c00 	orr	r3, r3, r0, lsl #24
   143f0:	e1926003 	orrs	r6, r2, r3
   143f4:	1a000002 	bne	14404 <fat16_open+0xf8>
   143f8:	e194240e 	orrs	r2, r4, lr, lsl #8
   143fc:	0a000034 	beq	144d4 <fat16_open+0x1c8>
   14400:	e1a06002 	mov	r6, r2
   14404:	e59d0010 	ldr	r0, [sp, #16]
   14408:	e0000099 	mul	r0, r9, r0
   1440c:	e59d201c 	ldr	r2, [sp, #28]
   14410:	e58d000c 	str	r0, [sp, #12]
   14414:	e59d0018 	ldr	r0, [sp, #24]
   14418:	e1873405 	orr	r3, r7, r5, lsl #8
   1441c:	e1825400 	orr	r5, r2, r0, lsl #8
   14420:	e59d2014 	ldr	r2, [sp, #20]
   14424:	e1a03283 	mov	r3, r3, lsl #5
   14428:	e1829401 	orr	r9, r2, r1, lsl #8
   1442c:	e58d3000 	str	r3, [sp]
   14430:	e0830005 	add	r0, r3, r5
   14434:	e59d300c 	ldr	r3, [sp, #12]
   14438:	e1a01005 	mov	r1, r5
   1443c:	e2400001 	sub	r0, r0, #1	; 0x1
   14440:	e0694006 	rsb	r4, r9, r6
   14444:	e0634004 	rsb	r4, r3, r4
   14448:	eb000ee0 	bl	17fd0 <__aeabi_idiv>
   1444c:	e59d1004 	ldr	r1, [sp, #4]
   14450:	e0600004 	rsb	r0, r0, r4
   14454:	eb000e98 	bl	17ebc <__aeabi_uidiv>
   14458:	e2403eff 	sub	r3, r0, #4080	; 0xff0
   1445c:	e2433005 	sub	r3, r3, #5	; 0x5
   14460:	e3530a0f 	cmp	r3, #61440	; 0xf000
   14464:	e1a07000 	mov	r7, r0
   14468:	2a000019 	bcs	144d4 <fat16_open+0x1c8>
   1446c:	e28a4004 	add	r4, sl, #4	; 0x4
   14470:	e3a03006 	mov	r3, #6	; 0x6
   14474:	e5c8300c 	strb	r3, [r8, #12]
   14478:	e3a01000 	mov	r1, #0	; 0x0
   1447c:	e3a02018 	mov	r2, #24	; 0x18
   14480:	e1a00004 	mov	r0, r4
   14484:	eb000d52 	bl	179d4 <memset>
   14488:	e59dc008 	ldr	ip, [sp, #8]
   1448c:	e02cc995 	mla	ip, r5, r9, ip
   14490:	e59de00c 	ldr	lr, [sp, #12]
   14494:	e59d0004 	ldr	r0, [sp, #4]
   14498:	e02ece95 	mla	lr, r5, lr, ip
   1449c:	e0010695 	mul	r1, r5, r6
   144a0:	e0000095 	mul	r0, r5, r0
   144a4:	e59d6000 	ldr	r6, [sp]
   144a8:	e1a03087 	mov	r3, r7, lsl #1
   144ac:	e08e2006 	add	r2, lr, r6
   144b0:	e2833004 	add	r3, r3, #4	; 0x4
   144b4:	e5842014 	str	r2, [r4, #20]
   144b8:	e58a1004 	str	r1, [sl, #4]
   144bc:	e5843008 	str	r3, [r4, #8]
   144c0:	e1c400be 	strh	r0, [r4, #14]
   144c4:	e584c004 	str	ip, [r4, #4]
   144c8:	e1c450bc 	strh	r5, [r4, #12]
   144cc:	e584e010 	str	lr, [r4, #16]
   144d0:	ea000004 	b	144e8 <fat16_open+0x1dc>
   144d4:	e59f0020 	ldr	r0, [pc, #32]	; 144fc <.text+0x44fc>
   144d8:	ebfff530 	bl	119a0 <rprintf>
   144dc:	e1a0000b 	mov	r0, fp
   144e0:	eb000b81 	bl	172ec <free>
   144e4:	e3a0a000 	mov	sl, #0	; 0x0
   144e8:	e1a0000a 	mov	r0, sl
   144ec:	e28dd03c 	add	sp, sp, #60	; 0x3c
   144f0:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   144f4:	e12fff1e 	bx	lr
   144f8:	00018b88 	andeq	r8, r1, r8, lsl #23
   144fc:	00018b98 	muleq	r1, r8, fp

00014500 <fat16_create_file>:
   14500:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14504:	e2706001 	rsbs	r6, r0, #1	; 0x1
   14508:	33a06000 	movcc	r6, #0	; 0x0
   1450c:	e3500000 	cmp	r0, #0	; 0x0
   14510:	13510000 	cmpne	r1, #0	; 0x0
   14514:	e24dd004 	sub	sp, sp, #4	; 0x4
   14518:	e1a05000 	mov	r5, r0
   1451c:	e1a04001 	mov	r4, r1
   14520:	e1a08002 	mov	r8, r2
   14524:	0a000065 	beq	146c0 <fat16_create_file+0x1c0>
   14528:	e5d13000 	ldrb	r3, [r1]
   1452c:	e3530000 	cmp	r3, #0	; 0x0
   14530:	0a000062 	beq	146c0 <fat16_create_file+0x1c0>
   14534:	e1a01008 	mov	r1, r8
   14538:	e1a00005 	mov	r0, r5
   1453c:	ebfffc74 	bl	13714 <fat16_read_dir>
   14540:	e250a000 	subs	sl, r0, #0	; 0x0
   14544:	e1a01008 	mov	r1, r8
   14548:	e1a00004 	mov	r0, r4
   1454c:	0a000007 	beq	14570 <fat16_create_file+0x70>
   14550:	eb000d34 	bl	17a28 <strcmp>
   14554:	e3500000 	cmp	r0, #0	; 0x0
   14558:	1afffff5 	bne	14534 <fat16_create_file+0x34>
   1455c:	e3560000 	cmp	r6, #0	; 0x0
   14560:	12800001 	addne	r0, r0, #1	; 0x1
   14564:	03a00001 	moveq	r0, #1	; 0x1
   14568:	01c563b0 	streqh	r6, [r5, #48]
   1456c:	ea000054 	b	146c4 <fat16_create_file+0x1c4>
   14570:	e1a0100a 	mov	r1, sl
   14574:	e3a0202c 	mov	r2, #44	; 0x2c
   14578:	e1a00008 	mov	r0, r8
   1457c:	eb000d14 	bl	179d4 <memset>
   14580:	e1a01004 	mov	r1, r4
   14584:	e3a0201f 	mov	r2, #31	; 0x1f
   14588:	e1a00008 	mov	r0, r8
   1458c:	eb000d4d 	bl	17ac8 <strncpy>
   14590:	e1a00004 	mov	r0, r4
   14594:	eb000d2f 	bl	17a58 <strlen>
   14598:	e3a0100d 	mov	r1, #13	; 0xd
   1459c:	eb000e46 	bl	17ebc <__aeabi_uidiv>
   145a0:	e1d572b6 	ldrh	r7, [r5, #38]
   145a4:	e5955000 	ldr	r5, [r5]
   145a8:	e3570000 	cmp	r7, #0	; 0x0
   145ac:	05954014 	ldreq	r4, [r5, #20]
   145b0:	11a0600a 	movne	r6, sl
   145b4:	e2800002 	add	r0, r0, #2	; 0x2
   145b8:	0595a018 	ldreq	sl, [r5, #24]
   145bc:	e200b0ff 	and	fp, r0, #255	; 0xff
   145c0:	11a04006 	movne	r4, r6
   145c4:	11a0a006 	movne	sl, r6
   145c8:	01a06004 	moveq	r6, r4
   145cc:	e3a09000 	mov	r9, #0	; 0x0
   145d0:	e154000a 	cmp	r4, sl
   145d4:	1a00001b 	bne	14648 <fat16_create_file+0x148>
   145d8:	e3570000 	cmp	r7, #0	; 0x0
   145dc:	0a000037 	beq	146c0 <fat16_create_file+0x1c0>
   145e0:	e3540000 	cmp	r4, #0	; 0x0
   145e4:	0a000010 	beq	1462c <fat16_create_file+0x12c>
   145e8:	e1a00005 	mov	r0, r5
   145ec:	e1a01007 	mov	r1, r7
   145f0:	ebfffaa6 	bl	13090 <fat16_get_next_cluster>
   145f4:	e3500000 	cmp	r0, #0	; 0x0
   145f8:	1a00000a 	bne	14628 <fat16_create_file+0x128>
   145fc:	e1a01007 	mov	r1, r7
   14600:	e1a00005 	mov	r0, r5
   14604:	e3a02001 	mov	r2, #1	; 0x1
   14608:	ebfffb00 	bl	13210 <fat16_append_clusters>
   1460c:	e3500000 	cmp	r0, #0	; 0x0
   14610:	0a00002a 	beq	146c0 <fat16_create_file+0x1c0>
   14614:	e1d511b2 	ldrh	r1, [r5, #18]
   14618:	e5952018 	ldr	r2, [r5, #24]
   1461c:	e2403002 	sub	r3, r0, #2	; 0x2
   14620:	e0262391 	mla	r6, r1, r3, r2
   14624:	ea00001e 	b	146a4 <fat16_create_file+0x1a4>
   14628:	e1a07000 	mov	r7, r0
   1462c:	e1d511b2 	ldrh	r1, [r5, #18]
   14630:	e5952018 	ldr	r2, [r5, #24]
   14634:	e2473002 	sub	r3, r7, #2	; 0x2
   14638:	e0242391 	mla	r4, r1, r3, r2
   1463c:	e3a09000 	mov	r9, #0	; 0x0
   14640:	e084a001 	add	sl, r4, r1
   14644:	e1a06004 	mov	r6, r4
   14648:	e5953000 	ldr	r3, [r5]
   1464c:	e1a00004 	mov	r0, r4
   14650:	e28d1003 	add	r1, sp, #3	; 0x3
   14654:	e3a02001 	mov	r2, #1	; 0x1
   14658:	e593c000 	ldr	ip, [r3]
   1465c:	e1a0e00f 	mov	lr, pc
   14660:	e12fff1c 	bx	ip
   14664:	e3500000 	cmp	r0, #0	; 0x0
   14668:	0a000014 	beq	146c0 <fat16_create_file+0x1c0>
   1466c:	e5dd3003 	ldrb	r3, [sp, #3]
   14670:	e3530000 	cmp	r3, #0	; 0x0
   14674:	135300e5 	cmpne	r3, #229	; 0xe5
   14678:	13a03000 	movne	r3, #0	; 0x0
   1467c:	03a03001 	moveq	r3, #1	; 0x1
   14680:	12846020 	addne	r6, r4, #32	; 0x20
   14684:	11a09003 	movne	r9, r3
   14688:	11a04006 	movne	r4, r6
   1468c:	1affffcf 	bne	145d0 <fat16_create_file+0xd0>
   14690:	e2893001 	add	r3, r9, #1	; 0x1
   14694:	e20390ff 	and	r9, r3, #255	; 0xff
   14698:	e159000b 	cmp	r9, fp
   1469c:	32844020 	addcc	r4, r4, #32	; 0x20
   146a0:	3affffca 	bcc	145d0 <fat16_create_file+0xd0>
   146a4:	e5886028 	str	r6, [r8, #40]
   146a8:	e1a00005 	mov	r0, r5
   146ac:	e1a01008 	mov	r1, r8
   146b0:	ebfffcb4 	bl	13988 <fat16_write_dir_entry>
   146b4:	e2500000 	subs	r0, r0, #0	; 0x0
   146b8:	13a00001 	movne	r0, #1	; 0x1
   146bc:	ea000000 	b	146c4 <fat16_create_file+0x1c4>
   146c0:	e3a00000 	mov	r0, #0	; 0x0
   146c4:	e28dd004 	add	sp, sp, #4	; 0x4
   146c8:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   146cc:	e12fff1e 	bx	lr

000146d0 <partition_close>:
 * \see partition_open
 */
uint8_t partition_close(struct partition_struct* partition)
{
    if(!partition)
   146d0:	e2503000 	subs	r3, r0, #0	; 0x0
   146d4:	e52de004 	str	lr, [sp, #-4]!
   146d8:	0a000001 	beq	146e4 <partition_close+0x14>
        return 0;

    /* destroy partition descriptor */
    free(partition);
   146dc:	eb000b02 	bl	172ec <free>
   146e0:	e3a03001 	mov	r3, #1	; 0x1

    return 1;
}
   146e4:	e1a00003 	mov	r0, r3
   146e8:	e49de004 	ldr	lr, [sp], #4
   146ec:	e12fff1e 	bx	lr

000146f0 <partition_open>:
   146f0:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   146f4:	e3510000 	cmp	r1, #0	; 0x0
   146f8:	13500000 	cmpne	r0, #0	; 0x0
   146fc:	e24dd010 	sub	sp, sp, #16	; 0x10
   14700:	e1a06000 	mov	r6, r0
   14704:	e1a07001 	mov	r7, r1
   14708:	13a04000 	movne	r4, #0	; 0x0
   1470c:	03a04001 	moveq	r4, #1	; 0x1
   14710:	e1a08002 	mov	r8, r2
   14714:	e20330ff 	and	r3, r3, #255	; 0xff
   14718:	0a000033 	beq	147ec <partition_open+0xfc>
   1471c:	e1a03c03 	mov	r3, r3, lsl #24
   14720:	e1a05c43 	mov	r5, r3, asr #24
   14724:	e3550003 	cmp	r5, #3	; 0x3
   14728:	ca00002f 	bgt	147ec <partition_open+0xfc>
   1472c:	e3550000 	cmp	r5, #0	; 0x0
   14730:	ba00000b 	blt	14764 <partition_open+0x74>
   14734:	e1a00205 	mov	r0, r5, lsl #4
   14738:	e2800f6f 	add	r0, r0, #444	; 0x1bc
   1473c:	e2800002 	add	r0, r0, #2	; 0x2
   14740:	e1a0100d 	mov	r1, sp
   14744:	e3a02010 	mov	r2, #16	; 0x10
   14748:	e1a0e00f 	mov	lr, pc
   1474c:	e12fff16 	bx	r6
   14750:	e3500000 	cmp	r0, #0	; 0x0
   14754:	0a000024 	beq	147ec <partition_open+0xfc>
   14758:	e5dd3004 	ldrb	r3, [sp, #4]
   1475c:	e3530000 	cmp	r3, #0	; 0x0
   14760:	0a000021 	beq	147ec <partition_open+0xfc>
   14764:	e3a00018 	mov	r0, #24	; 0x18
   14768:	eb000ae7 	bl	1730c <malloc>
   1476c:	e2503000 	subs	r3, r0, #0	; 0x0
   14770:	0a00001d 	beq	147ec <partition_open+0xfc>
   14774:	e1a01004 	mov	r1, r4
   14778:	e3a02018 	mov	r2, #24	; 0x18
   1477c:	e1a04003 	mov	r4, r3
   14780:	eb000c93 	bl	179d4 <memset>
   14784:	e3550000 	cmp	r5, #0	; 0x0
   14788:	b3e03000 	mvnlt	r3, #0	; 0x0
   1478c:	e88401c0 	stmia	r4, {r6, r7, r8}
   14790:	b5c4300c 	strltb	r3, [r4, #12]
   14794:	ba000015 	blt	147f0 <partition_open+0x100>
   14798:	e5dd3004 	ldrb	r3, [sp, #4]
   1479c:	e5c4300c 	strb	r3, [r4, #12]
   147a0:	e5dd300a 	ldrb	r3, [sp, #10]
   147a4:	e5dd1009 	ldrb	r1, [sp, #9]
   147a8:	e5dd000b 	ldrb	r0, [sp, #11]
   147ac:	e5dd2008 	ldrb	r2, [sp, #8]
   147b0:	e1a03803 	mov	r3, r3, lsl #16
   147b4:	e1833c00 	orr	r3, r3, r0, lsl #24
   147b8:	e1822401 	orr	r2, r2, r1, lsl #8
   147bc:	e1822003 	orr	r2, r2, r3
   147c0:	e5842010 	str	r2, [r4, #16]
   147c4:	e5dd300e 	ldrb	r3, [sp, #14]
   147c8:	e5dd200c 	ldrb	r2, [sp, #12]
   147cc:	e5dd100d 	ldrb	r1, [sp, #13]
   147d0:	e5dd000f 	ldrb	r0, [sp, #15]
   147d4:	e1a03803 	mov	r3, r3, lsl #16
   147d8:	e1822401 	orr	r2, r2, r1, lsl #8
   147dc:	e1833c00 	orr	r3, r3, r0, lsl #24
   147e0:	e1822003 	orr	r2, r2, r3
   147e4:	e5842014 	str	r2, [r4, #20]
   147e8:	ea000000 	b	147f0 <partition_open+0x100>
   147ec:	e3a04000 	mov	r4, #0	; 0x0
   147f0:	e1a00004 	mov	r0, r4
   147f4:	e28dd010 	add	sp, sp, #16	; 0x10
   147f8:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   147fc:	e12fff1e 	bx	lr

00014800 <get_adc_1>:
//         and can only be used within this file!
static int get_adc_1(int channel)
{
    int val;
    AD1CR = 0;
   14800:	e59f2040 	ldr	r2, [pc, #64]	; 14848 <.text+0x4848>
    AD1GDR = 0;

    AD1CR = 0x00200600 | channel;
   14804:	e3800602 	orr	r0, r0, #2097152	; 0x200000
   14808:	e3a03000 	mov	r3, #0	; 0x0
   1480c:	e3800c06 	orr	r0, r0, #1536	; 0x600
   14810:	e5823000 	str	r3, [r2]
   14814:	e5823004 	str	r3, [r2, #4]
   14818:	e5820000 	str	r0, [r2]
    AD1CR |= 0x01000000;
   1481c:	e5923000 	ldr	r3, [r2]
   14820:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   14824:	e5823000 	str	r3, [r2]
    do
    {
        val = AD1GDR;                   // Read A/D Data Register
   14828:	e59f3018 	ldr	r3, [pc, #24]	; 14848 <.text+0x4848>
   1482c:	e5930004 	ldr	r0, [r3, #4]
    }
    while ((val & 0x80000000) == 0);  //Wait for the conversion to complete
   14830:	e3500000 	cmp	r0, #0	; 0x0
   14834:	aafffffb 	bge	14828 <get_adc_1+0x28>
   14838:	e1a00340 	mov	r0, r0, asr #6
    val = ((val >> 6) & 0x03FF);  //Extract the A/D result

    return val;
}
   1483c:	e1a00b00 	mov	r0, r0, lsl #22
   14840:	e1a00b20 	mov	r0, r0, lsr #22
   14844:	e12fff1e 	bx	lr
   14848:	e0060000 	and	r0, r6, r0

0001484c <MMA_get_z>:
   1484c:	e3a00020 	mov	r0, #32	; 0x20
   14850:	eaffffea 	b	14800 <get_adc_1>

00014854 <MMA_get_y>:
   14854:	e3a00010 	mov	r0, #16	; 0x10
   14858:	eaffffe8 	b	14800 <get_adc_1>

0001485c <MMA_get_x>:
   1485c:	e3a00008 	mov	r0, #8	; 0x8
   14860:	eaffffe6 	b	14800 <get_adc_1>

00014864 <MMA_change_mode>:

//Usage: MMA_change_mode(RANGE_2G);
//Inputs: char mode - The mode to be set (Modes are defined in MMA7260.h)
//Outputs: None
//Description: Sets the sensitivity of the MMA7260 accelerometer based on
//             the input "mode" value.
void MMA_change_mode(char mode){

    /*
	Setup the MMA g-select
	GS1/GS2
	0/0 = 1.5g
	1/0 = 2g
	0/1 = 4g
	1/1 = 6g
	*/
	IODIR0|=(GS1 | GS2);
   14864:	e59f205c 	ldr	r2, [pc, #92]	; 148c8 <.text+0x48c8>
   14868:	e5923008 	ldr	r3, [r2, #8]
   1486c:	e20000ff 	and	r0, r0, #255	; 0xff
   14870:	e3833b03 	orr	r3, r3, #3072	; 0xc00
	if(mode==RANGE_15G)	IOCLR0=(GS1 | GS2);
   14874:	e3500031 	cmp	r0, #49	; 0x31
   14878:	e5823008 	str	r3, [r2, #8]
   1487c:	03a03b03 	moveq	r3, #3072	; 0xc00
   14880:	0a000004 	beq	14898 <MMA_change_mode+0x34>
	else if(mode==RANGE_2G){
   14884:	e3500032 	cmp	r0, #50	; 0x32
   14888:	1a000004 	bne	148a0 <MMA_change_mode+0x3c>
		IOSET0=GS1;
   1488c:	e3a03b02 	mov	r3, #2048	; 0x800
   14890:	e5823004 	str	r3, [r2, #4]
		IOCLR0=GS2;
   14894:	e2433b01 	sub	r3, r3, #1024	; 0x400
   14898:	e582300c 	str	r3, [r2, #12]
   1489c:	e12fff1e 	bx	lr
	}
	else if(mode==RANGE_4G){
   148a0:	e3500033 	cmp	r0, #51	; 0x33
		IOCLR0=GS1;
   148a4:	03a03b02 	moveq	r3, #2048	; 0x800
   148a8:	0582300c 	streq	r3, [r2, #12]
		IOSET0=GS2;
   148ac:	02433b01 	subeq	r3, r3, #1024	; 0x400
   148b0:	0a000002 	beq	148c0 <MMA_change_mode+0x5c>
	}
	else if(mode==RANGE_6G)IOSET0=(GS1 | GS2);
   148b4:	e3500034 	cmp	r0, #52	; 0x34
   148b8:	112fff1e 	bxne	lr
   148bc:	e3a03b03 	mov	r3, #3072	; 0xc00
   148c0:	e5823004 	str	r3, [r2, #4]
   148c4:	e12fff1e 	bx	lr
   148c8:	e0028000 	and	r8, r2, r0

000148cc <LCDCommand>:
//         and can only be used within this file!
static void LCDCommand(unsigned char data)
{

	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
   148cc:	e59f2080 	ldr	r2, [pc, #128]	; 14954 <.text+0x4954>
   148d0:	e5923008 	ldr	r3, [r2, #8]
   148d4:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   148d8:	e3833050 	orr	r3, r3, #80	; 0x50
   148dc:	e5823008 	str	r3, [r2, #8]
	
	IOCLR0 = LCD_CS;      // enable chip, p0.20 goes low
   148e0:	e3a03702 	mov	r3, #524288	; 0x80000
   148e4:	e582300c 	str	r3, [r2, #12]
    IOCLR0 = LCD_DIO;     // output low on data out (9th bit low = command), p0.19

    IOCLR0 = LCD_SCK;      // send clock pulse
   148e8:	e3a01010 	mov	r1, #16	; 0x10
   148ec:	e3a03040 	mov	r3, #64	; 0x40
   148f0:	e582300c 	str	r3, [r2, #12]
   148f4:	e582100c 	str	r1, [r2, #12]
    IOSET0 = LCD_SCK;
   148f8:	e5821004 	str	r1, [r2, #4]
   148fc:	e20000ff 	and	r0, r0, #255	; 0xff
   14900:	e3a0c000 	mov	ip, #0	; 0x0

    for (char j = 0; j < 8; j++)
    {
        if ((data & 0x80) == 0x80) IOSET0 = LCD_DIO;
   14904:	e3100080 	tst	r0, #128	; 0x80
   14908:	159f3044 	ldrne	r3, [pc, #68]	; 14954 <.text+0x4954>
        else IOCLR0 = LCD_DIO;
   1490c:	059f3040 	ldreq	r3, [pc, #64]	; 14954 <.text+0x4954>
   14910:	13a02040 	movne	r2, #64	; 0x40
   14914:	03a02040 	moveq	r2, #64	; 0x40
   14918:	15832004 	strne	r2, [r3, #4]
   1491c:	0583200c 	streq	r2, [r3, #12]
   14920:	e28c3001 	add	r3, ip, #1	; 0x1

        IOCLR0 = LCD_SCK;   // send clock pulse
   14924:	e59f1028 	ldr	r1, [pc, #40]	; 14954 <.text+0x4954>
   14928:	e203c0ff 	and	ip, r3, #255	; 0xff
        IOSET0 = LCD_SCK;

        data <<= 1;
   1492c:	e1a02080 	mov	r2, r0, lsl #1
   14930:	e3a03010 	mov	r3, #16	; 0x10
   14934:	e35c0008 	cmp	ip, #8	; 0x8
   14938:	e581300c 	str	r3, [r1, #12]
   1493c:	e20200ff 	and	r0, r2, #255	; 0xff
   14940:	e5813004 	str	r3, [r1, #4]
   14944:	1affffee 	bne	14904 <LCDCommand+0x38>
    }

    IOSET0 = LCD_CS;    		// disable
   14948:	e3a03702 	mov	r3, #524288	; 0x80000
   1494c:	e5813004 	str	r3, [r1, #4]

}
   14950:	e12fff1e 	bx	lr
   14954:	e0028000 	and	r8, r2, r0

00014958 <LCDData>:

//Usage: LCDData(RAMWR);
//Inputs: char data - character data to be sent to the LCD
//Outputs: None
//Description: Sends a 9 bit command over SPI to the LCD with
//			   the first bit LOW indicating "data" mode.
//**NOTE** Because this function is static, it is essentially a "private" function
//         and can only be used within this file!
static void LCDData(unsigned char data)
{
	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
   14958:	e59f208c 	ldr	r2, [pc, #140]	; 149ec <.text+0x49ec>
   1495c:	e5923008 	ldr	r3, [r2, #8]
   14960:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   14964:	e3833050 	orr	r3, r3, #80	; 0x50
   14968:	e5823008 	str	r3, [r2, #8]
	
	IOCLR0 = LCD_SCK;      // send clock pulse
   1496c:	e3a01010 	mov	r1, #16	; 0x10
	IOCLR0 = LCD_CS;      // enable chip, p0.20 goes low    
   14970:	e3a03702 	mov	r3, #524288	; 0x80000
   14974:	e582100c 	str	r1, [r2, #12]
   14978:	e20000ff 	and	r0, r0, #255	; 0xff
   1497c:	e582300c 	str	r3, [r2, #12]
	#ifdef	PHILLIPS
		for (char i = 0; i < 1; i++) asm volatile ("nop");
   14980:	e1a00000 	nop			(mov r0,r0)
	#endif
	IOSET0 = LCD_DIO;    // output high on data out (9th bit high = data), p0.19
   14984:	e3a03040 	mov	r3, #64	; 0x40
   14988:	e5823004 	str	r3, [r2, #4]
    IOCLR0 = LCD_SCK;    // send clock pulse
   1498c:	e582100c 	str	r1, [r2, #12]
	#ifdef	PHILLIPS
		for (char i = 0; i < 1; i++) asm volatile ("nop");
   14990:	e1a00000 	nop			(mov r0,r0)
	#endif
    IOSET0 = LCD_SCK;
   14994:	e5821004 	str	r1, [r2, #4]
   14998:	e3a0c000 	mov	ip, #0	; 0x0
	for (char j = 0; j < 8; j++)
    {
        if ((data & 0x80) == 0x80) IOSET0 = LCD_DIO;
   1499c:	e3100080 	tst	r0, #128	; 0x80
   149a0:	159f3044 	ldrne	r3, [pc, #68]	; 149ec <.text+0x49ec>
        else IOCLR0 = LCD_DIO;
   149a4:	059f3040 	ldreq	r3, [pc, #64]	; 149ec <.text+0x49ec>
   149a8:	13a02040 	movne	r2, #64	; 0x40
   149ac:	03a02040 	moveq	r2, #64	; 0x40
   149b0:	15832004 	strne	r2, [r3, #4]
   149b4:	0583200c 	streq	r2, [r3, #12]
   149b8:	e28c3001 	add	r3, ip, #1	; 0x1
        IOCLR0 = LCD_SCK;   // send clock pulse
   149bc:	e59f1028 	ldr	r1, [pc, #40]	; 149ec <.text+0x49ec>
   149c0:	e203c0ff 	and	ip, r3, #255	; 0xff
		//#ifdef	PHILLIPS
			//for (char i = 0; i < delay; i++) asm volatile ("nop");
		//#endif
        IOSET0 = LCD_SCK;
		//#ifdef	PHILLIPS
			//for (char i = 0; i < delay; i++) asm volatile ("nop");
		//#endif
        data <<= 1;
   149c4:	e1a02080 	mov	r2, r0, lsl #1
   149c8:	e3a03010 	mov	r3, #16	; 0x10
   149cc:	e35c0008 	cmp	ip, #8	; 0x8
   149d0:	e581300c 	str	r3, [r1, #12]
   149d4:	e20200ff 	and	r0, r2, #255	; 0xff
   149d8:	e5813004 	str	r3, [r1, #4]
   149dc:	1affffee 	bne	1499c <LCDData+0x44>
    }

    IOSET0 = LCD_CS;     		// disable
   149e0:	e3a03702 	mov	r3, #524288	; 0x80000
   149e4:	e5813004 	str	r3, [r1, #4]
}
   149e8:	e12fff1e 	bx	lr
   149ec:	e0028000 	and	r8, r2, r0

000149f0 <LCDClear>:
   149f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   149f4:	e1a03000 	mov	r3, r0
   149f8:	e3a0002b 	mov	r0, #43	; 0x2b
   149fc:	e20350ff 	and	r5, r3, #255	; 0xff
   14a00:	ebffffb1 	bl	148cc <LCDCommand>
   14a04:	e3a00000 	mov	r0, #0	; 0x0
   14a08:	ebffffd2 	bl	14958 <LCDData>
   14a0c:	e3a00083 	mov	r0, #131	; 0x83
   14a10:	ebffffd0 	bl	14958 <LCDData>
   14a14:	e3a0002a 	mov	r0, #42	; 0x2a
   14a18:	ebffffab 	bl	148cc <LCDCommand>
   14a1c:	e3a00000 	mov	r0, #0	; 0x0
   14a20:	ebffffcc 	bl	14958 <LCDData>
   14a24:	e3a00083 	mov	r0, #131	; 0x83
   14a28:	ebffffca 	bl	14958 <LCDData>
   14a2c:	e3a0002c 	mov	r0, #44	; 0x2c
   14a30:	ebffffa5 	bl	148cc <LCDCommand>
   14a34:	e3a04001 	mov	r4, #1	; 0x1
   14a38:	e1a00005 	mov	r0, r5
   14a3c:	ebffffc5 	bl	14958 <LCDData>
   14a40:	e59f3024 	ldr	r3, [pc, #36]	; 14a6c <.text+0x4a6c>
   14a44:	e2844001 	add	r4, r4, #1	; 0x1
   14a48:	e1540003 	cmp	r4, r3
   14a4c:	1afffff9 	bne	14a38 <LCDClear+0x48>
   14a50:	e59f2018 	ldr	r2, [pc, #24]	; 14a70 <.text+0x4a70>
   14a54:	e3a03000 	mov	r3, #0	; 0x0
   14a58:	e5c23000 	strb	r3, [r2]
   14a5c:	e59f2010 	ldr	r2, [pc, #16]	; 14a74 <.text+0x4a74>
   14a60:	e5c23000 	strb	r3, [r2]
   14a64:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   14a68:	e12fff1e 	bx	lr
   14a6c:	00004410 	andeq	r4, r0, r0, lsl r4
   14a70:	40000f2a 	andmi	r0, r0, sl, lsr #30
   14a74:	40000f29 	andmi	r0, r0, r9, lsr #30

00014a78 <LCDSetPixel>:

//Usage: LCDInit();
//Inputs: None
//Outputs: None
//Description:  Initializes the LCD regardless of if the controlller is an EPSON or PHILLIPS.
void LCDInit(void)
{
    int j;

	delay_ms(200);
	
    // reset display
	IODIR0 |= (LCD_DIO | LCD_SCK | LCD_CS | LCD_RES);		//Assign LCD pins as Outputs
		
    IOCLR0 = (LCD_SCK | LCD_DIO);							//output_low (SPI_CLK);//output_low (SPI_DO);
    IOSET0 = LCD_CS;				//output_high (LCD_CS);
    for (j = 0; j < 16; j++);
    IOCLR0 = LCD_RES;				//output_low (LCD_RESET);
    for (j = 0; j < 300000; j++);
    IOSET0 = LCD_RES;				//output_high (LCD_RESET);
    IOSET0 = (LCD_SCK | LCD_DIO);
    for (j = 0; j < 300000; j++);	//delay_ms(100);
	
    LCDCommand(DISCTL);  	// display control(EPSON)
    LCDData(0x0C);   		// 12 = 1100 - CL dividing ratio [don't divide] switching period 8H (default)
    LCDData(0x20);
    LCDData(0x02);
	
    LCDCommand(COMSCN);  	// common scanning direction(EPSON)
    LCDData(0x01);
    
    LCDCommand(OSCON);  	// internal oscialltor ON(EPSON)
    
    LCDCommand(SLPOUT);  	// sleep out(EPSON)
	LCDCommand(SLEEPOUT);	//sleep out(PHILLIPS)
    
    LCDCommand(VOLCTR);  	// electronic volume, this is the contrast/brightness(EPSON)
    LCDData(0x18);   		// volume (contrast) setting - fine tuning, original
    LCDData(0x03);   		// internal resistor ratio - coarse adjustment
	LCDCommand(SETCON);		//Set Contrast(PHILLIPS)
	LCDData(0x30);	
	
    
    LCDCommand(PWRCTR); 	// power ctrl(EPSON)
    LCDData(0x0F);    		//everything on, no external reference resistors
    LCDCommand(BSTRON);		//Booset On(PHILLIPS)
	
    LCDCommand(DISINV);  	// invert display mode(EPSON)
	LCDCommand(INVON);		// invert display mode(PHILLIPS)
    
    LCDCommand(DATCTL);  	// data control(EPSON)
    LCDData(0x03);			//correct for normal sin7
    LCDData(0x00);   		// normal RGB arrangement
    LCDData(0x01);   		// 8-bit grayscale
	LCDCommand(MADCTL);		//Memory Access Control(PHILLIPS)
	LCDData(0xC8);
	
	LCDCommand(COLMOD);		//Set Color Mode(PHILLIPS)
	LCDData(0x02);	
	
    
    LCDCommand(RGBSET8);   // setup 8-bit color lookup table  [RRRGGGBB](EPSON)
    //RED
    LCDData(0);
    LCDData(2);
    LCDData(4);
    LCDData(6);
    LCDData(8);
    LCDData(10);
    LCDData(12);
    LCDData(15);
    // GREEN
    LCDData(0);
    LCDData(2);
    LCDData(4);
    LCDData(6);
    LCDData(8);
    LCDData(10);
    LCDData(12);
    LCDData(15);
    //BLUE
    LCDData(0);
    LCDData(4);
    LCDData(9);
    LCDData(15);
    
    LCDCommand(NOP);  	// nop(EPSON)
	LCDCommand(NOPP);		// nop(PHILLIPS)

    LCDCommand(DISON);   	// display on(EPSON)
	LCDCommand(DISPON);	// display on(PHILLIPS)
}

//Usage: LCDPrintChar('1', white,&x_offset, &y_offset, inverted)
//Inputs: char txt - character to be printed
//		  char text_color - desired color
//	 	  char *x_pos - pointer to the row position of the character
//		  char *y_pos - pointer to the column position of the character
//		  char inverted - indicates if the character should be positioned normally, or oriented to the right side of the screen
//Outputs: char *x_pos - Now holds the next available row position for a character on the screen
//		   char *y_pos - Now holds the next available column position for a character on the screen
//Description: Prints a character in the desired color at the given x and y position.  If the character is to be inverted,
//			   then the right side of the LCD becomes the "top" so the text will be viewed at a different orientation.
//**NOTE** Because this function is static, it is essentially a "private" function
//         and can only be used within this file!
static unsigned char LCDPrintChar(char txt, char text_color, char *x_pos, char *y_pos, char inverted)
{
    short text_array_offset = (txt - 32)*5, j;
    char k, temp;
	
    
    if (txt == 10)
    {
        y_pos += 8;
        return(0);
    }

    else if (txt == 13)
    {
        x_pos = 0;
        return(0);
    }

    for (j = text_array_offset; j < text_array_offset+5; j++)
    {
        temp = text_array[j];
        
        for (k = 0; k < 8; k++)
        {
			if(inverted==0){
				if ((temp & 0x80) == 0x80) LCDSetPixel(text_color, *y_pos + k, *x_pos + j + 2 - text_array_offset);
				temp <<= 1;
			}
			else if(inverted==1){
				if ((temp & 0x01) == 0x01) LCDSetPixel(text_color, *y_pos + j + 2 - text_array_offset, *x_pos + k);
				temp >>= 1;	
			}
        }

    }

	if(inverted==0){
		if ((*x_pos + 12) > 132) *x_pos = 0, *y_pos += 8;
		else *x_pos += 6;
	}
	else if(inverted==1){
		if ((*y_pos + 12) > 132) *y_pos = 0, *x_pos += 8;
		else *y_pos += 6;	
	}

    if ((*y_pos + 8) > 132)
    {
        //clear_screen();
        return 1;
    }
    else return 0;

}

//Usage: LCDPrintLogo();
//Inputs: None
//Outputs: None
//Description: Prints the logo_spark array to the LCD.
void LCDPrintLogo(void)
{
    int x = 4, y = 25, logo_ix = 0, z;
    char logo;
    
    for (logo_ix = 0; logo_ix < 1120; logo_ix++)
    {
        logo = logo_spark[logo_ix];
		for (z = 0; z < 8; z++)
        {
            if ((logo & 0x80) == 0x80) LCDSetPixel(red, y, x);
            x++;
            if (x == 132)
            {
                x = 4;
                y++;
            }
            
            logo <<= 1;
        }
    }

}

//Usage: LCDPrintString("Hello %d", 5, black, 0, 0, 1);
//Inputs: const char *txt - string of characters to be printed
//		  int variable - if a variable is to be printed in the string it should be placed here, else put a 0
//		  text_color - desired color of the string
//		  char row - desired row for the string
//		  char column - desired column for the string
//		  char inverterted - indication of desired orientation
//Outputs: None
//Description: Prints a string, including variables, in the desired color at the given row and column.  If inverterted,
//			   the right side of the LCD will become the "top."
void LCDPrintString(const char *txt, int variable, char text_color, char row, char column, char inverted)
{
	if(inverted==0){
		x_offset=column*6;
		y_offset=row*8;
	}
	else if(inverted==1){
		x_offset=(15-row)*8+3;
		y_offset=(column*6);
	}
    int	  temp;
    short i, k, l, m;
    short temp2;
    
    short decimal_output[9];
    
    for(i = 0 ; i < 22; i++)		//Only print the length of the screen
    {
        //delay_ms(3);
        
        k = txt[i];

        if (k == '\0') break;
        
        else if (k == '%') //Print var
        {
            i++;
            k = txt[i];

            if (k == '\0') break;
        	
            else if (k == '\\') //Print special characters
            {
                i++;
                k = txt[i];
                
                LCDPrintChar(k, white, &x_offset, &y_offset, inverted);
                

            } //End Special Characters
            else if (k == 'b') //Print Binary
            {
                for( m = 0 ; m < 32 ; m++ )
                {
                    if ((variable & 0x80000000) == 0x80000000) LCDPrintChar('1', white,&x_offset, &y_offset, inverted);
                    if ((variable & 0x80000000) == 0) LCDPrintChar('0', white,&x_offset, &y_offset, inverted);
                    if (((m+1) % 4) == 0) LCDPrintChar(' ', white,&x_offset, &y_offset, inverted);
                    
                    variable = variable << 1;
                }
            } //End Binary               
            else if (k == 'd') //Print Decimal
            {
                //Print negative sign and take 2's compliment
                
                if(variable < 0)
                {
                    LCDPrintChar('-', text_color,&x_offset, &y_offset, inverted);
                    variable *= -1;
                }
                
                
                if (variable == 0)
                    LCDPrintChar('0', text_color,&x_offset, &y_offset, inverted);
                else
                {
                    //Divide number by a series of 10s
                    for(m = 9 ; variable > 0 ; m--)
                    {
                        temp = variable % 10;
                        decimal_output[m] = temp+48;
                        variable = variable / 10;               
                    }
                
                    for(m++ ; m < 10 ; m++)
                    {
                        LCDPrintChar(decimal_output[m], text_color,&x_offset, &y_offset, inverted);
                    }
                }
    
            } //End Decimal
            else if (k == 'h') //Print Hex
            {
                //New trick 3-15-04
                LCDPrintChar('0', white,&x_offset, &y_offset, inverted);
                LCDPrintChar('x', white,&x_offset, &y_offset, inverted);
                
                for (m = 0; m < 8; m++)
                {
                	temp = variable & 0xF0000000;
                	temp2 = temp >>= 28;
                	//LCDPrintChar(bin2Hex(temp2));
                	variable <<= 4;
                }
            } //End Hex
            else if (k == 'f') //Print Float
            {
                LCDPrintChar('!', white,&x_offset, &y_offset, inverted);
            } //End Float
            else if (k == 'u') //Print Direct Character
            {
                //All ascii characters below 20 are special and screwy characters
                //if(my_byte > 20) 
                    LCDPrintChar(variable, text_color,&x_offset, &y_offset, inverted);
            } //End Direct
                        
        } //End Special Chars           
        
        else if (k == '/')
        {
            l = txt[i+1];
            if (l == 'r') LCDPrintChar(13, white,&x_offset, &y_offset, inverted);
            else if (l == 'n') LCDPrintChar(10, white,&x_offset, &y_offset, inverted);
            i += 1;
        }

        else LCDPrintChar(k, text_color,&x_offset, &y_offset, inverted);
    }    
}

//Usage: LCDSetPixel(white, 0, 0);
//Inputs: unsigned char color - desired color of the pixel
//		  unsigned char x - Page address of pixel to be colored
//		  unsigned char y - column address of pixel to be colored
//Outputs: None
//Description: Sets the starting page(row) and column (x & y) coordinates in ram,
//  		   then writes the colour to display memory.  The ending x & y are left
//  		   maxed out so one can continue sending colour data bytes to the 'open'
//  		   RAMWR command to fill further memory.  issuing any red command
//  		   finishes RAMWR.
//**NOTE** Because this function is static, it is essentially a "private" function
//         and can only be used within this file!
static void LCDSetPixel(unsigned char color, unsigned char x, unsigned char y)
{
   14a78:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	unsigned int temp_register;
	
	temp_register = VICIntEnable;
	VICIntEnClr = 0x20;
   14a7c:	e3a03020 	mov	r3, #32	; 0x20
   14a80:	e3e07000 	mvn	r7, #0	; 0x0
   14a84:	e20140ff 	and	r4, r1, #255	; 0xff
   14a88:	e5178fef 	ldr	r8, [r7, #-4079]
   14a8c:	e1a06000 	mov	r6, r0
   14a90:	e5073feb 	str	r3, [r7, #-4075]
	#ifdef EPSON
		LCDCommand(PASET);   // page start/end ram
		LCDData(x);
		LCDData(ENDPAGE);
  
		LCDCommand(CASET);   // column start/end ram
		LCDData(y);
		LCDData(ENDCOL);
  
		LCDCommand(RAMWR);    // write
		LCDData(color);
	#endif
	#ifdef	PHILLIPS
		LCDCommand(PASETP);   // page start/end ram
   14a94:	e3a0002b 	mov	r0, #43	; 0x2b
   14a98:	e20250ff 	and	r5, r2, #255	; 0xff
   14a9c:	ebffff8a 	bl	148cc <LCDCommand>
		LCDData(x);
   14aa0:	e1a00004 	mov	r0, r4
   14aa4:	ebffffab 	bl	14958 <LCDData>
		LCDData(ENDPAGE);
   14aa8:	e3a00084 	mov	r0, #132	; 0x84
   14aac:	ebffffa9 	bl	14958 <LCDData>
  
		LCDCommand(CASETP);   // column start/end ram
   14ab0:	e3a0002a 	mov	r0, #42	; 0x2a
   14ab4:	ebffff84 	bl	148cc <LCDCommand>
		LCDData(y);
   14ab8:	e1a00005 	mov	r0, r5
   14abc:	ebffffa5 	bl	14958 <LCDData>
		LCDData(ENDCOL);
   14ac0:	e3a00082 	mov	r0, #130	; 0x82
   14ac4:	ebffffa3 	bl	14958 <LCDData>
   14ac8:	e20660ff 	and	r6, r6, #255	; 0xff
  
		LCDCommand(RAMWRP);    // write
   14acc:	e3a0002c 	mov	r0, #44	; 0x2c
   14ad0:	ebffff7d 	bl	148cc <LCDCommand>
		LCDData(color);
   14ad4:	e1a00006 	mov	r0, r6
   14ad8:	ebffff9e 	bl	14958 <LCDData>
	#endif
	VICIntEnable = temp_register;
   14adc:	e5078fef 	str	r8, [r7, #-4079]
}
   14ae0:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14ae4:	e12fff1e 	bx	lr

00014ae8 <LCDPrintLogo>:
   14ae8:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14aec:	e59f7060 	ldr	r7, [pc, #96]	; 14b54 <.text+0x4b54>
   14af0:	e3a05004 	mov	r5, #4	; 0x4
   14af4:	e3a08019 	mov	r8, #25	; 0x19
   14af8:	e5d74000 	ldrb	r4, [r7]
   14afc:	e3a06000 	mov	r6, #0	; 0x0
   14b00:	e3140080 	tst	r4, #128	; 0x80
   14b04:	e20520ff 	and	r2, r5, #255	; 0xff
   14b08:	e2866001 	add	r6, r6, #1	; 0x1
   14b0c:	e20810ff 	and	r1, r8, #255	; 0xff
   14b10:	e2855001 	add	r5, r5, #1	; 0x1
   14b14:	159f303c 	ldrne	r3, [pc, #60]	; 14b58 <.text+0x4b58>
   14b18:	15d30000 	ldrneb	r0, [r3]
   14b1c:	1bffffd5 	blne	14a78 <LCDSetPixel>
   14b20:	e3550084 	cmp	r5, #132	; 0x84
   14b24:	e1a03084 	mov	r3, r4, lsl #1
   14b28:	02888001 	addeq	r8, r8, #1	; 0x1
   14b2c:	03a05004 	moveq	r5, #4	; 0x4
   14b30:	e3560008 	cmp	r6, #8	; 0x8
   14b34:	e20340ff 	and	r4, r3, #255	; 0xff
   14b38:	1afffff0 	bne	14b00 <LCDPrintLogo+0x18>
   14b3c:	e59f3018 	ldr	r3, [pc, #24]	; 14b5c <.text+0x4b5c>
   14b40:	e2877001 	add	r7, r7, #1	; 0x1
   14b44:	e1570003 	cmp	r7, r3
   14b48:	1affffea 	bne	14af8 <LCDPrintLogo+0x10>
   14b4c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14b50:	e12fff1e 	bx	lr
   14b54:	00018523 	andeq	r8, r1, r3, lsr #10
   14b58:	40000008 	andmi	r0, r0, r8
   14b5c:	00018983 	andeq	r8, r1, r3, lsl #19

00014b60 <LCDPrintChar>:
   14b60:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14b64:	e20000ff 	and	r0, r0, #255	; 0xff
   14b68:	e350000a 	cmp	r0, #10	; 0xa
   14b6c:	e1a06002 	mov	r6, r2
   14b70:	e1a05003 	mov	r5, r3
   14b74:	e201b0ff 	and	fp, r1, #255	; 0xff
   14b78:	e5dda024 	ldrb	sl, [sp, #36]
   14b7c:	0a000055 	beq	14cd8 <LCDPrintChar+0x178>
   14b80:	e350000d 	cmp	r0, #13	; 0xd
   14b84:	0a000053 	beq	14cd8 <LCDPrintChar+0x178>
   14b88:	e3a03005 	mov	r3, #5	; 0x5
   14b8c:	e0030390 	mul	r3, r0, r3
   14b90:	e24330a0 	sub	r3, r3, #160	; 0xa0
   14b94:	e1a03803 	mov	r3, r3, lsl #16
   14b98:	e1a08823 	mov	r8, r3, lsr #16
   14b9c:	e1a07008 	mov	r7, r8
   14ba0:	ea000029 	b	14c4c <LCDPrintChar+0xec>
   14ba4:	e59f3138 	ldr	r3, [pc, #312]	; 14ce4 <.text+0x4ce4>
   14ba8:	e7d34002 	ldrb	r4, [r3, r2]
   14bac:	e3a09000 	mov	r9, #0	; 0x0
   14bb0:	e35a0000 	cmp	sl, #0	; 0x0
   14bb4:	e20930ff 	and	r3, r9, #255	; 0xff
   14bb8:	1a00000e 	bne	14bf8 <LCDPrintChar+0x98>
   14bbc:	e3140080 	tst	r4, #128	; 0x80
   14bc0:	e1a0000b 	mov	r0, fp
   14bc4:	0a000008 	beq	14bec <LCDPrintChar+0x8c>
   14bc8:	e5d62000 	ldrb	r2, [r6]
   14bcc:	e5d51000 	ldrb	r1, [r5]
   14bd0:	e0872002 	add	r2, r7, r2
   14bd4:	e0682002 	rsb	r2, r8, r2
   14bd8:	e0831001 	add	r1, r3, r1
   14bdc:	e2822002 	add	r2, r2, #2	; 0x2
   14be0:	e20110ff 	and	r1, r1, #255	; 0xff
   14be4:	e20220ff 	and	r2, r2, #255	; 0xff
   14be8:	ebffffa2 	bl	14a78 <LCDSetPixel>
   14bec:	e1a03084 	mov	r3, r4, lsl #1
   14bf0:	e20340ff 	and	r4, r3, #255	; 0xff
   14bf4:	ea00000e 	b	14c34 <LCDPrintChar+0xd4>
   14bf8:	e35a0001 	cmp	sl, #1	; 0x1
   14bfc:	1a00000c 	bne	14c34 <LCDPrintChar+0xd4>
   14c00:	e3140001 	tst	r4, #1	; 0x1
   14c04:	e1a0000b 	mov	r0, fp
   14c08:	e1a040a4 	mov	r4, r4, lsr #1
   14c0c:	0a000008 	beq	14c34 <LCDPrintChar+0xd4>
   14c10:	e5d51000 	ldrb	r1, [r5]
   14c14:	e5d62000 	ldrb	r2, [r6]
   14c18:	e0871001 	add	r1, r7, r1
   14c1c:	e0681001 	rsb	r1, r8, r1
   14c20:	e0832002 	add	r2, r3, r2
   14c24:	e2811002 	add	r1, r1, #2	; 0x2
   14c28:	e20110ff 	and	r1, r1, #255	; 0xff
   14c2c:	e20220ff 	and	r2, r2, #255	; 0xff
   14c30:	ebffff90 	bl	14a78 <LCDSetPixel>
   14c34:	e2899001 	add	r9, r9, #1	; 0x1
   14c38:	e3590008 	cmp	r9, #8	; 0x8
   14c3c:	1affffdb 	bne	14bb0 <LCDPrintChar+0x50>
   14c40:	e2873001 	add	r3, r7, #1	; 0x1
   14c44:	e1a03803 	mov	r3, r3, lsl #16
   14c48:	e1a07823 	mov	r7, r3, lsr #16
   14c4c:	e1a03808 	mov	r3, r8, lsl #16
   14c50:	e1a03843 	mov	r3, r3, asr #16
   14c54:	e1a02807 	mov	r2, r7, lsl #16
   14c58:	e1a02842 	mov	r2, r2, asr #16
   14c5c:	e2833005 	add	r3, r3, #5	; 0x5
   14c60:	e1520003 	cmp	r2, r3
   14c64:	baffffce 	blt	14ba4 <LCDPrintChar+0x44>
   14c68:	e35a0000 	cmp	sl, #0	; 0x0
   14c6c:	1a000007 	bne	14c90 <LCDPrintChar+0x130>
   14c70:	e5d63000 	ldrb	r3, [r6]
   14c74:	e3530078 	cmp	r3, #120	; 0x78
   14c78:	c5c6a000 	strgtb	sl, [r6]
   14c7c:	c5d53000 	ldrgtb	r3, [r5]
   14c80:	d2833006 	addle	r3, r3, #6	; 0x6
   14c84:	c2833008 	addgt	r3, r3, #8	; 0x8
   14c88:	da00000a 	ble	14cb8 <LCDPrintChar+0x158>
   14c8c:	ea00000b 	b	14cc0 <LCDPrintChar+0x160>
   14c90:	e35a0001 	cmp	sl, #1	; 0x1
   14c94:	1a00000a 	bne	14cc4 <LCDPrintChar+0x164>
   14c98:	e5d53000 	ldrb	r3, [r5]
   14c9c:	e3530078 	cmp	r3, #120	; 0x78
   14ca0:	d2833006 	addle	r3, r3, #6	; 0x6
   14ca4:	da000005 	ble	14cc0 <LCDPrintChar+0x160>
   14ca8:	e3a03000 	mov	r3, #0	; 0x0
   14cac:	e5c53000 	strb	r3, [r5]
   14cb0:	e5d63000 	ldrb	r3, [r6]
   14cb4:	e2833008 	add	r3, r3, #8	; 0x8
   14cb8:	e5c63000 	strb	r3, [r6]
   14cbc:	ea000000 	b	14cc4 <LCDPrintChar+0x164>
   14cc0:	e5c53000 	strb	r3, [r5]
   14cc4:	e5d53000 	ldrb	r3, [r5]
   14cc8:	e353007c 	cmp	r3, #124	; 0x7c
   14ccc:	d3a00000 	movle	r0, #0	; 0x0
   14cd0:	c3a00001 	movgt	r0, #1	; 0x1
   14cd4:	ea000000 	b	14cdc <LCDPrintChar+0x17c>
   14cd8:	e3a00000 	mov	r0, #0	; 0x0
   14cdc:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14ce0:	e12fff1e 	bx	lr
   14ce4:	00018348 	andeq	r8, r1, r8, asr #6

00014ce8 <LCDPrintString>:
   14ce8:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14cec:	e24dd018 	sub	sp, sp, #24	; 0x18
   14cf0:	e5dd503c 	ldrb	r5, [sp, #60]
   14cf4:	e3550000 	cmp	r5, #0	; 0x0
   14cf8:	e1a09000 	mov	r9, r0
   14cfc:	e1a07001 	mov	r7, r1
   14d00:	e202a0ff 	and	sl, r2, #255	; 0xff
   14d04:	e20300ff 	and	r0, r3, #255	; 0xff
   14d08:	e5dd1038 	ldrb	r1, [sp, #56]
   14d0c:	1a000005 	bne	14d28 <LCDPrintString+0x40>
   14d10:	e3a03006 	mov	r3, #6	; 0x6
   14d14:	e0020391 	mul	r2, r1, r3
   14d18:	e59f3304 	ldr	r3, [pc, #772]	; 15024 <.text+0x5024>
   14d1c:	e1a01180 	mov	r1, r0, lsl #3
   14d20:	e5c32000 	strb	r2, [r3]
   14d24:	ea000008 	b	14d4c <LCDPrintString+0x64>
   14d28:	e3550001 	cmp	r5, #1	; 0x1
   14d2c:	1a000008 	bne	14d54 <LCDPrintString+0x6c>
   14d30:	e3a03006 	mov	r3, #6	; 0x6
   14d34:	e0010193 	mul	r1, r3, r1
   14d38:	e260300f 	rsb	r3, r0, #15	; 0xf
   14d3c:	e1a03183 	mov	r3, r3, lsl #3
   14d40:	e59f22dc 	ldr	r2, [pc, #732]	; 15024 <.text+0x5024>
   14d44:	e2833003 	add	r3, r3, #3	; 0x3
   14d48:	e5c23000 	strb	r3, [r2]
   14d4c:	e59f32d4 	ldr	r3, [pc, #724]	; 15028 <.text+0x5028>
   14d50:	e5c31000 	strb	r1, [r3]
   14d54:	e3a08000 	mov	r8, #0	; 0x0
   14d58:	e1a03808 	mov	r3, r8, lsl #16
   14d5c:	e1a03843 	mov	r3, r3, asr #16
   14d60:	e7d90003 	ldrb	r0, [r9, r3]
   14d64:	e3500000 	cmp	r0, #0	; 0x0
   14d68:	0a0000aa 	beq	15018 <LCDPrintString+0x330>
   14d6c:	e3500025 	cmp	r0, #37	; 0x25
   14d70:	1a000085 	bne	14f8c <LCDPrintString+0x2a4>
   14d74:	e2883001 	add	r3, r8, #1	; 0x1
   14d78:	e1a03803 	mov	r3, r3, lsl #16
   14d7c:	e7d92843 	ldrb	r2, [r9, r3, asr #16]
   14d80:	e3520000 	cmp	r2, #0	; 0x0
   14d84:	e1a08823 	mov	r8, r3, lsr #16
   14d88:	0a0000a2 	beq	15018 <LCDPrintString+0x330>
   14d8c:	e352005c 	cmp	r2, #92	; 0x5c
   14d90:	1a000009 	bne	14dbc <LCDPrintString+0xd4>
   14d94:	e288c001 	add	ip, r8, #1	; 0x1
   14d98:	e59f328c 	ldr	r3, [pc, #652]	; 1502c <.text+0x502c>
   14d9c:	e1a0c80c 	mov	ip, ip, lsl #16
   14da0:	e5d31000 	ldrb	r1, [r3]
   14da4:	e7d9084c 	ldrb	r0, [r9, ip, asr #16]
   14da8:	e59f2274 	ldr	r2, [pc, #628]	; 15024 <.text+0x5024>
   14dac:	e59f3274 	ldr	r3, [pc, #628]	; 15028 <.text+0x5028>
   14db0:	e1a0882c 	mov	r8, ip, lsr #16
   14db4:	e58d5000 	str	r5, [sp]
   14db8:	ea000090 	b	15000 <LCDPrintString+0x318>
   14dbc:	e3520062 	cmp	r2, #98	; 0x62
   14dc0:	1a000019 	bne	14e2c <LCDPrintString+0x144>
   14dc4:	e3a04001 	mov	r4, #1	; 0x1
   14dc8:	e59f125c 	ldr	r1, [pc, #604]	; 1502c <.text+0x502c>
   14dcc:	e3570000 	cmp	r7, #0	; 0x0
   14dd0:	e59f224c 	ldr	r2, [pc, #588]	; 15024 <.text+0x5024>
   14dd4:	e59f324c 	ldr	r3, [pc, #588]	; 15028 <.text+0x5028>
   14dd8:	b5d11000 	ldrltb	r1, [r1]
   14ddc:	a5d11000 	ldrgeb	r1, [r1]
   14de0:	a59f223c 	ldrge	r2, [pc, #572]	; 15024 <.text+0x5024>
   14de4:	a59f323c 	ldrge	r3, [pc, #572]	; 15028 <.text+0x5028>
   14de8:	e3a00031 	mov	r0, #49	; 0x31
   14dec:	a3a00030 	movge	r0, #48	; 0x30
   14df0:	e58d5000 	str	r5, [sp]
   14df4:	ebffff59 	bl	14b60 <LCDPrintChar>
   14df8:	e3140003 	tst	r4, #3	; 0x3
   14dfc:	e59f2220 	ldr	r2, [pc, #544]	; 15024 <.text+0x5024>
   14e00:	e59f3220 	ldr	r3, [pc, #544]	; 15028 <.text+0x5028>
   14e04:	e3a00020 	mov	r0, #32	; 0x20
   14e08:	e1a07087 	mov	r7, r7, lsl #1
   14e0c:	e2844001 	add	r4, r4, #1	; 0x1
   14e10:	059f1214 	ldreq	r1, [pc, #532]	; 1502c <.text+0x502c>
   14e14:	05d11000 	ldreqb	r1, [r1]
   14e18:	058d5000 	streq	r5, [sp]
   14e1c:	0bffff4f 	bleq	14b60 <LCDPrintChar>
   14e20:	e3540021 	cmp	r4, #33	; 0x21
   14e24:	0a000076 	beq	15004 <LCDPrintString+0x31c>
   14e28:	eaffffe6 	b	14dc8 <LCDPrintString+0xe0>
   14e2c:	e3520064 	cmp	r2, #100	; 0x64
   14e30:	1a000032 	bne	14f00 <LCDPrintString+0x218>
   14e34:	e3570000 	cmp	r7, #0	; 0x0
   14e38:	aa000006 	bge	14e58 <LCDPrintString+0x170>
   14e3c:	e3a0002d 	mov	r0, #45	; 0x2d
   14e40:	e1a0100a 	mov	r1, sl
   14e44:	e59f21d8 	ldr	r2, [pc, #472]	; 15024 <.text+0x5024>
   14e48:	e59f31d8 	ldr	r3, [pc, #472]	; 15028 <.text+0x5028>
   14e4c:	e58d5000 	str	r5, [sp]
   14e50:	ebffff42 	bl	14b60 <LCDPrintChar>
   14e54:	e2677000 	rsb	r7, r7, #0	; 0x0
   14e58:	e3570000 	cmp	r7, #0	; 0x0
   14e5c:	13a06009 	movne	r6, #9	; 0x9
   14e60:	128d4018 	addne	r4, sp, #24	; 0x18
   14e64:	1a00000e 	bne	14ea4 <LCDPrintString+0x1bc>
   14e68:	e59f21b4 	ldr	r2, [pc, #436]	; 15024 <.text+0x5024>
   14e6c:	e59f31b4 	ldr	r3, [pc, #436]	; 15028 <.text+0x5028>
   14e70:	e1a0100a 	mov	r1, sl
   14e74:	e3a00030 	mov	r0, #48	; 0x30
   14e78:	ea00005f 	b	14ffc <LCDPrintString+0x314>
   14e7c:	eb000cd8 	bl	181e4 <__modsi3>
   14e80:	e2803030 	add	r3, r0, #48	; 0x30
   14e84:	e1c430b2 	strh	r3, [r4, #2]
   14e88:	e1a00007 	mov	r0, r7
   14e8c:	e3a0100a 	mov	r1, #10	; 0xa
   14e90:	eb000c4e 	bl	17fd0 <__aeabi_idiv>
   14e94:	e2463001 	sub	r3, r6, #1	; 0x1
   14e98:	e1a03803 	mov	r3, r3, lsl #16
   14e9c:	e1a07000 	mov	r7, r0
   14ea0:	e1a06823 	mov	r6, r3, lsr #16
   14ea4:	e3570000 	cmp	r7, #0	; 0x0
   14ea8:	e1a00007 	mov	r0, r7
   14eac:	e3a0100a 	mov	r1, #10	; 0xa
   14eb0:	e2444002 	sub	r4, r4, #2	; 0x2
   14eb4:	cafffff0 	bgt	14e7c <LCDPrintString+0x194>
   14eb8:	e2863001 	add	r3, r6, #1	; 0x1
   14ebc:	ea000003 	b	14ed0 <LCDPrintString+0x1e8>
   14ec0:	e55c0012 	ldrb	r0, [ip, #-18]
   14ec4:	e58d5000 	str	r5, [sp]
   14ec8:	ebffff24 	bl	14b60 <LCDPrintChar>
   14ecc:	e2843001 	add	r3, r4, #1	; 0x1
   14ed0:	e1a03803 	mov	r3, r3, lsl #16
   14ed4:	e1a04823 	mov	r4, r3, lsr #16
   14ed8:	e1a00804 	mov	r0, r4, lsl #16
   14edc:	e1a00840 	mov	r0, r0, asr #16
   14ee0:	e28de018 	add	lr, sp, #24	; 0x18
   14ee4:	e3500009 	cmp	r0, #9	; 0x9
   14ee8:	e1a0100a 	mov	r1, sl
   14eec:	e59f2130 	ldr	r2, [pc, #304]	; 15024 <.text+0x5024>
   14ef0:	e59f3130 	ldr	r3, [pc, #304]	; 15028 <.text+0x5028>
   14ef4:	e08ec080 	add	ip, lr, r0, lsl #1
   14ef8:	dafffff0 	ble	14ec0 <LCDPrintString+0x1d8>
   14efc:	ea000040 	b	15004 <LCDPrintString+0x31c>
   14f00:	e3520068 	cmp	r2, #104	; 0x68
   14f04:	1a000014 	bne	14f5c <LCDPrintString+0x274>
   14f08:	e59f411c 	ldr	r4, [pc, #284]	; 1502c <.text+0x502c>
   14f0c:	e59f2110 	ldr	r2, [pc, #272]	; 15024 <.text+0x5024>
   14f10:	e5d41000 	ldrb	r1, [r4]
   14f14:	e59f310c 	ldr	r3, [pc, #268]	; 15028 <.text+0x5028>
   14f18:	e3a00030 	mov	r0, #48	; 0x30
   14f1c:	e58d5000 	str	r5, [sp]
   14f20:	ebffff0e 	bl	14b60 <LCDPrintChar>
   14f24:	e5d41000 	ldrb	r1, [r4]
   14f28:	e59f30f8 	ldr	r3, [pc, #248]	; 15028 <.text+0x5028>
   14f2c:	e3a00078 	mov	r0, #120	; 0x78
   14f30:	e59f20ec 	ldr	r2, [pc, #236]	; 15024 <.text+0x5024>
   14f34:	e58d5000 	str	r5, [sp]
   14f38:	ebffff08 	bl	14b60 <LCDPrintChar>
   14f3c:	e3a03000 	mov	r3, #0	; 0x0
   14f40:	e2833001 	add	r3, r3, #1	; 0x1
   14f44:	e1a03803 	mov	r3, r3, lsl #16
   14f48:	e3530702 	cmp	r3, #524288	; 0x80000
   14f4c:	e1a07207 	mov	r7, r7, lsl #4
   14f50:	e1a03823 	mov	r3, r3, lsr #16
   14f54:	0a00002a 	beq	15004 <LCDPrintString+0x31c>
   14f58:	eafffff8 	b	14f40 <LCDPrintString+0x258>
   14f5c:	e3520066 	cmp	r2, #102	; 0x66
   14f60:	1a000005 	bne	14f7c <LCDPrintString+0x294>
   14f64:	e59f30c0 	ldr	r3, [pc, #192]	; 1502c <.text+0x502c>
   14f68:	e59f20b4 	ldr	r2, [pc, #180]	; 15024 <.text+0x5024>
   14f6c:	e5d31000 	ldrb	r1, [r3]
   14f70:	e59f30b0 	ldr	r3, [pc, #176]	; 15028 <.text+0x5028>
   14f74:	e3a00021 	mov	r0, #33	; 0x21
   14f78:	ea00001f 	b	14ffc <LCDPrintString+0x314>
   14f7c:	e3520075 	cmp	r2, #117	; 0x75
   14f80:	020700ff 	andeq	r0, r7, #255	; 0xff
   14f84:	0a000019 	beq	14ff0 <LCDPrintString+0x308>
   14f88:	ea00001d 	b	15004 <LCDPrintString+0x31c>
   14f8c:	e350002f 	cmp	r0, #47	; 0x2f
   14f90:	1a000016 	bne	14ff0 <LCDPrintString+0x308>
   14f94:	e0893003 	add	r3, r9, r3
   14f98:	e5d33001 	ldrb	r3, [r3, #1]
   14f9c:	e3530072 	cmp	r3, #114	; 0x72
   14fa0:	1a000005 	bne	14fbc <LCDPrintString+0x2d4>
   14fa4:	e59f3080 	ldr	r3, [pc, #128]	; 1502c <.text+0x502c>
   14fa8:	e59f2074 	ldr	r2, [pc, #116]	; 15024 <.text+0x5024>
   14fac:	e5d31000 	ldrb	r1, [r3]
   14fb0:	e59f3070 	ldr	r3, [pc, #112]	; 15028 <.text+0x5028>
   14fb4:	e3a0000d 	mov	r0, #13	; 0xd
   14fb8:	ea000006 	b	14fd8 <LCDPrintString+0x2f0>
   14fbc:	e353006e 	cmp	r3, #110	; 0x6e
   14fc0:	1a000006 	bne	14fe0 <LCDPrintString+0x2f8>
   14fc4:	e59f3060 	ldr	r3, [pc, #96]	; 1502c <.text+0x502c>
   14fc8:	e59f2054 	ldr	r2, [pc, #84]	; 15024 <.text+0x5024>
   14fcc:	e5d31000 	ldrb	r1, [r3]
   14fd0:	e59f3050 	ldr	r3, [pc, #80]	; 15028 <.text+0x5028>
   14fd4:	e3a0000a 	mov	r0, #10	; 0xa
   14fd8:	e58d5000 	str	r5, [sp]
   14fdc:	ebfffedf 	bl	14b60 <LCDPrintChar>
   14fe0:	e2883001 	add	r3, r8, #1	; 0x1
   14fe4:	e1a03803 	mov	r3, r3, lsl #16
   14fe8:	e1a08823 	mov	r8, r3, lsr #16
   14fec:	ea000004 	b	15004 <LCDPrintString+0x31c>
   14ff0:	e59f202c 	ldr	r2, [pc, #44]	; 15024 <.text+0x5024>
   14ff4:	e59f302c 	ldr	r3, [pc, #44]	; 15028 <.text+0x5028>
   14ff8:	e1a0100a 	mov	r1, sl
   14ffc:	e58d5000 	str	r5, [sp]
   15000:	ebfffed6 	bl	14b60 <LCDPrintChar>
   15004:	e2883001 	add	r3, r8, #1	; 0x1
   15008:	e1a03803 	mov	r3, r3, lsl #16
   1500c:	e3530815 	cmp	r3, #1376256	; 0x150000
   15010:	e1a08823 	mov	r8, r3, lsr #16
   15014:	daffff4f 	ble	14d58 <LCDPrintString+0x70>
   15018:	e28dd018 	add	sp, sp, #24	; 0x18
   1501c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15020:	e12fff1e 	bx	lr
   15024:	40000f29 	andmi	r0, r0, r9, lsr #30
   15028:	40000f2a 	andmi	r0, r0, sl, lsr #30
   1502c:	40000f28 	andmi	r0, r0, r8, lsr #30

00015030 <LCDSetRowColor>:

//Usage: LCDSetRowColor(0,0,white, 0);
//Inputs: unsigned char row - row to be set
//		  unsigned char column - this indicates where to start coloring the row
//		  char color - desired color to change the row to
//		  char inverted - indicates if row goes from left to right, or top to bottom
//Outputs: None
//Description:  Changes the color or a row starting at the position indicated in column.
void LCDSetRowColor(unsigned char row, unsigned char column, char color, char inverted){
   15030:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if(inverted==ORIENTUP){
   15034:	e213a0ff 	ands	sl, r3, #255	; 0xff
		row *= 8;
		column *=6;
   15038:	03a03006 	moveq	r3, #6	; 0x6
   1503c:	e20070ff 	and	r7, r0, #255	; 0xff
   15040:	e20160ff 	and	r6, r1, #255	; 0xff
   15044:	e202b0ff 	and	fp, r2, #255	; 0xff
   15048:	00020396 	muleq	r2, r6, r3
   1504c:	01a03187 	moveq	r3, r7, lsl #3
   15050:	0a000006 	beq	15070 <LCDSetRowColor+0x40>
	}
	else if(inverted==ORIENTLEFT){
   15054:	e35a0001 	cmp	sl, #1	; 0x1
   15058:	1a000006 	bne	15078 <LCDSetRowColor+0x48>
		row=(15-row)*8+3;
		column = (column*6);
   1505c:	e3a03006 	mov	r3, #6	; 0x6
   15060:	e0020396 	mul	r2, r6, r3
   15064:	e267300f 	rsb	r3, r7, #15	; 0xf
   15068:	e1a03183 	mov	r3, r3, lsl #3
   1506c:	e2833003 	add	r3, r3, #3	; 0x3
   15070:	e20370ff 	and	r7, r3, #255	; 0xff
   15074:	e20260ff 	and	r6, r2, #255	; 0xff
   15078:	e1a05006 	mov	r5, r6
   1507c:	e3a09000 	mov	r9, #0	; 0x0
   15080:	ea000014 	b	150d8 <LCDSetRowColor+0xa8>
	}
	for (int j = column; j < ROW_LENGTH; j++)
   15084:	e1a04007 	mov	r4, r7
   15088:	e3a08000 	mov	r8, #0	; 0x0
	{
		for (int k = 0; k < 8; k++)
		{
			if(inverted==ORIENTUP){
   1508c:	e35a0000 	cmp	sl, #0	; 0x0
				LCDSetPixel(color, row + k, j);
   15090:	e1a0000b 	mov	r0, fp
   15094:	e1a01004 	mov	r1, r4
   15098:	e1a02005 	mov	r2, r5
   1509c:	0a000004 	beq	150b4 <LCDSetRowColor+0x84>
			}
			else if(inverted==ORIENTLEFT){
   150a0:	e35a0001 	cmp	sl, #1	; 0x1
				LCDSetPixel(color, j, row+k);
   150a4:	e1a02004 	mov	r2, r4
   150a8:	e1a0000b 	mov	r0, fp
   150ac:	e1a01005 	mov	r1, r5
   150b0:	1a000000 	bne	150b8 <LCDSetRowColor+0x88>
   150b4:	ebfffe6f 	bl	14a78 <LCDSetPixel>
   150b8:	e2888001 	add	r8, r8, #1	; 0x1
   150bc:	e2843001 	add	r3, r4, #1	; 0x1
   150c0:	e3580008 	cmp	r8, #8	; 0x8
   150c4:	e20340ff 	and	r4, r3, #255	; 0xff
   150c8:	1affffef 	bne	1508c <LCDSetRowColor+0x5c>
   150cc:	e2853001 	add	r3, r5, #1	; 0x1
   150d0:	e2899001 	add	r9, r9, #1	; 0x1
   150d4:	e20350ff 	and	r5, r3, #255	; 0xff
   150d8:	e0863009 	add	r3, r6, r9
   150dc:	e3530083 	cmp	r3, #131	; 0x83
   150e0:	daffffe7 	ble	15084 <LCDSetRowColor+0x54>
			}
		}
	}
}
   150e4:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   150e8:	e12fff1e 	bx	lr

000150ec <LCDContrast>:

//Usage: LCDContrast(0x03);
//Inputs: char setting - character representing desired contrast
//Outputs: None
//Description: Sets the LCD contrast to "setting"
void LCDContrast(char setting){
   150ec:	e92d4010 	stmdb	sp!, {r4, lr}
   150f0:	e20040ff 	and	r4, r0, #255	; 0xff
	#ifdef	EPSON
		LCDCommand(VOLCTR);	// electronic volume, this is the contrast/brightness
		LCDData(0x18);		// volume (contrast) setting - fine tuning, original
		LCDData(setting);	// internal resistor ratio - coarse adjustment
	#endif
	#ifdef	PHILLIPS
		LCDCommand(SETCON);	//Sets contrast for phillips screen
   150f4:	e3a00025 	mov	r0, #37	; 0x25
   150f8:	ebfffdf3 	bl	148cc <LCDCommand>
		LCDCommand(setting);
   150fc:	e1a00004 	mov	r0, r4
	#endif
}
   15100:	e8bd4010 	ldmia	sp!, {r4, lr}
   15104:	eafffdf0 	b	148cc <LCDCommand>

00015108 <LCDInit>:
   15108:	e52de004 	str	lr, [sp, #-4]!
   1510c:	e3a000c8 	mov	r0, #200	; 0xc8
   15110:	ebffec1f 	bl	10194 <delay_ms>
   15114:	e59f21d0 	ldr	r2, [pc, #464]	; 152ec <.text+0x52ec>
   15118:	e5923008 	ldr	r3, [r2, #8]
   1511c:	e3833703 	orr	r3, r3, #786432	; 0xc0000
   15120:	e3833050 	orr	r3, r3, #80	; 0x50
   15124:	e5823008 	str	r3, [r2, #8]
   15128:	e3a0c050 	mov	ip, #80	; 0x50
   1512c:	e3a01701 	mov	r1, #262144	; 0x40000
   15130:	e3a03702 	mov	r3, #524288	; 0x80000
   15134:	e582c00c 	str	ip, [r2, #12]
   15138:	e3a000ca 	mov	r0, #202	; 0xca
   1513c:	e5823004 	str	r3, [r2, #4]
   15140:	e582100c 	str	r1, [r2, #12]
   15144:	e5821004 	str	r1, [r2, #4]
   15148:	e582c004 	str	ip, [r2, #4]
   1514c:	ebfffdde 	bl	148cc <LCDCommand>
   15150:	e3a0000c 	mov	r0, #12	; 0xc
   15154:	ebfffdff 	bl	14958 <LCDData>
   15158:	e3a00020 	mov	r0, #32	; 0x20
   1515c:	ebfffdfd 	bl	14958 <LCDData>
   15160:	e3a00002 	mov	r0, #2	; 0x2
   15164:	ebfffdfb 	bl	14958 <LCDData>
   15168:	e3a000bb 	mov	r0, #187	; 0xbb
   1516c:	ebfffdd6 	bl	148cc <LCDCommand>
   15170:	e3a00001 	mov	r0, #1	; 0x1
   15174:	ebfffdf7 	bl	14958 <LCDData>
   15178:	e3a000d1 	mov	r0, #209	; 0xd1
   1517c:	ebfffdd2 	bl	148cc <LCDCommand>
   15180:	e3a00094 	mov	r0, #148	; 0x94
   15184:	ebfffdd0 	bl	148cc <LCDCommand>
   15188:	e3a00011 	mov	r0, #17	; 0x11
   1518c:	ebfffdce 	bl	148cc <LCDCommand>
   15190:	e3a00081 	mov	r0, #129	; 0x81
   15194:	ebfffdcc 	bl	148cc <LCDCommand>
   15198:	e3a00018 	mov	r0, #24	; 0x18
   1519c:	ebfffded 	bl	14958 <LCDData>
   151a0:	e3a00003 	mov	r0, #3	; 0x3
   151a4:	ebfffdeb 	bl	14958 <LCDData>
   151a8:	e3a00025 	mov	r0, #37	; 0x25
   151ac:	ebfffdc6 	bl	148cc <LCDCommand>
   151b0:	e3a00030 	mov	r0, #48	; 0x30
   151b4:	ebfffde7 	bl	14958 <LCDData>
   151b8:	e3a00020 	mov	r0, #32	; 0x20
   151bc:	ebfffdc2 	bl	148cc <LCDCommand>
   151c0:	e3a0000f 	mov	r0, #15	; 0xf
   151c4:	ebfffde3 	bl	14958 <LCDData>
   151c8:	e3a00003 	mov	r0, #3	; 0x3
   151cc:	ebfffdbe 	bl	148cc <LCDCommand>
   151d0:	e3a000a7 	mov	r0, #167	; 0xa7
   151d4:	ebfffdbc 	bl	148cc <LCDCommand>
   151d8:	e3a00021 	mov	r0, #33	; 0x21
   151dc:	ebfffdba 	bl	148cc <LCDCommand>
   151e0:	e3a000bc 	mov	r0, #188	; 0xbc
   151e4:	ebfffdb8 	bl	148cc <LCDCommand>
   151e8:	e3a00003 	mov	r0, #3	; 0x3
   151ec:	ebfffdd9 	bl	14958 <LCDData>
   151f0:	e3a00000 	mov	r0, #0	; 0x0
   151f4:	ebfffdd7 	bl	14958 <LCDData>
   151f8:	e3a00001 	mov	r0, #1	; 0x1
   151fc:	ebfffdd5 	bl	14958 <LCDData>
   15200:	e3a00036 	mov	r0, #54	; 0x36
   15204:	ebfffdb0 	bl	148cc <LCDCommand>
   15208:	e3a000c8 	mov	r0, #200	; 0xc8
   1520c:	ebfffdd1 	bl	14958 <LCDData>
   15210:	e3a0003a 	mov	r0, #58	; 0x3a
   15214:	ebfffdac 	bl	148cc <LCDCommand>
   15218:	e3a00002 	mov	r0, #2	; 0x2
   1521c:	ebfffdcd 	bl	14958 <LCDData>
   15220:	e3a000ce 	mov	r0, #206	; 0xce
   15224:	ebfffda8 	bl	148cc <LCDCommand>
   15228:	e3a00000 	mov	r0, #0	; 0x0
   1522c:	ebfffdc9 	bl	14958 <LCDData>
   15230:	e3a00002 	mov	r0, #2	; 0x2
   15234:	ebfffdc7 	bl	14958 <LCDData>
   15238:	e3a00004 	mov	r0, #4	; 0x4
   1523c:	ebfffdc5 	bl	14958 <LCDData>
   15240:	e3a00006 	mov	r0, #6	; 0x6
   15244:	ebfffdc3 	bl	14958 <LCDData>
   15248:	e3a00008 	mov	r0, #8	; 0x8
   1524c:	ebfffdc1 	bl	14958 <LCDData>
   15250:	e3a0000a 	mov	r0, #10	; 0xa
   15254:	ebfffdbf 	bl	14958 <LCDData>
   15258:	e3a0000c 	mov	r0, #12	; 0xc
   1525c:	ebfffdbd 	bl	14958 <LCDData>
   15260:	e3a0000f 	mov	r0, #15	; 0xf
   15264:	ebfffdbb 	bl	14958 <LCDData>
   15268:	e3a00000 	mov	r0, #0	; 0x0
   1526c:	ebfffdb9 	bl	14958 <LCDData>
   15270:	e3a00002 	mov	r0, #2	; 0x2
   15274:	ebfffdb7 	bl	14958 <LCDData>
   15278:	e3a00004 	mov	r0, #4	; 0x4
   1527c:	ebfffdb5 	bl	14958 <LCDData>
   15280:	e3a00006 	mov	r0, #6	; 0x6
   15284:	ebfffdb3 	bl	14958 <LCDData>
   15288:	e3a00008 	mov	r0, #8	; 0x8
   1528c:	ebfffdb1 	bl	14958 <LCDData>
   15290:	e3a0000a 	mov	r0, #10	; 0xa
   15294:	ebfffdaf 	bl	14958 <LCDData>
   15298:	e3a0000c 	mov	r0, #12	; 0xc
   1529c:	ebfffdad 	bl	14958 <LCDData>
   152a0:	e3a0000f 	mov	r0, #15	; 0xf
   152a4:	ebfffdab 	bl	14958 <LCDData>
   152a8:	e3a00000 	mov	r0, #0	; 0x0
   152ac:	ebfffda9 	bl	14958 <LCDData>
   152b0:	e3a00004 	mov	r0, #4	; 0x4
   152b4:	ebfffda7 	bl	14958 <LCDData>
   152b8:	e3a00009 	mov	r0, #9	; 0x9
   152bc:	ebfffda5 	bl	14958 <LCDData>
   152c0:	e3a0000f 	mov	r0, #15	; 0xf
   152c4:	ebfffda3 	bl	14958 <LCDData>
   152c8:	e3a00025 	mov	r0, #37	; 0x25
   152cc:	ebfffd7e 	bl	148cc <LCDCommand>
   152d0:	e3a00000 	mov	r0, #0	; 0x0
   152d4:	ebfffd7c 	bl	148cc <LCDCommand>
   152d8:	e3a000af 	mov	r0, #175	; 0xaf
   152dc:	ebfffd7a 	bl	148cc <LCDCommand>
   152e0:	e3a00029 	mov	r0, #41	; 0x29
   152e4:	e49de004 	ldr	lr, [sp], #4
   152e8:	eafffd77 	b	148cc <LCDCommand>
   152ec:	e0028000 	and	r8, r2, r0

000152f0 <vs1002Config>:
//Description: Configures the LPC2148 for communication with the mp3 player
void vs1002Config(void){
	
	//Setup I/O Ports
	PINSEL0	|= (SCLK_PINSEL | MISO_PINSEL | MOSI_PINSEL);	// SPI pin connections
   152f0:	e59f301c 	ldr	r3, [pc, #28]	; 15314 <.text+0x5314>
   152f4:	e5932000 	ldr	r2, [r3]
   152f8:	e3822c15 	orr	r2, r2, #5376	; 0x1500
   152fc:	e5832000 	str	r2, [r3]
	PINSEL0 &= 0x0FFFFF0F;									
   15300:	e5932000 	ldr	r2, [r3]
   15304:	e3c2220f 	bic	r2, r2, #-268435456	; 0xf0000000
   15308:	e3c220f0 	bic	r2, r2, #240	; 0xf0
   1530c:	e5832000 	str	r2, [r3]
	
}
   15310:	e12fff1e 	bx	lr
   15314:	e002c000 	and	ip, r2, r0

00015318 <vs1002Finish>:

//Usage: vs1002Finish();
//Inputs: None
//Outputs: None
//Description: Relinquishes control of the SPI lines to the MP3 player
void vs1002Finish(void){
	PINSEL0 &= 0xFFFFC00F;		// Relinquish SPI pin connections
   15318:	e59f2010 	ldr	r2, [pc, #16]	; 15330 <.text+0x5330>
   1531c:	e5923000 	ldr	r3, [r2]
   15320:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
   15324:	e3c33030 	bic	r3, r3, #48	; 0x30
   15328:	e5823000 	str	r3, [r2]
}
   1532c:	e12fff1e 	bx	lr
   15330:	e002c000 	and	ip, r2, r0

00015334 <vs1002Reset>:

//Usage: register_value = vs1002SCIRead(SCI_MODE);
//Inputs: unsigned char address - Address of the register to be read
//Ouputs: None
//Description: Returns the value of the vs1002 register defined by "address"
unsigned short int vs1002SCIRead(unsigned char address)
{
	unsigned short int temp;
	SELECT_MP3_SCI();
	
	//delay_ms(1);
	SPI0_send(READ_COMMAND);
	SPI0_send(address);
   	temp = 	SPI0_recv();					
   	temp <<= 8;							
   	temp |= SPI0_recv();				
	//delay_ms(1);
	UNSELECT_MP3_SCI();
	
	delay_ms(1);
	return temp;
}

//Usage: vs1002SCIWrite(SCI_MODE, SM_SDINEW);
//Inputs: unsigned char address - Adress of the register to be written to
//		  unsigned short int data - Data to write to the register
//Outputs: None
//Description: Writes "data" to the register defined in "address"
void vs1002SCIWrite(unsigned char address, unsigned short int data)
{	
	SELECT_MP3_SCI();

	SPI0_send(WRITE_COMMAND);
	SPI0_send(address);
	SPI0_send(data >> 8);						// Send High Byte of data
	SPI0_send(data & 0x00ff);					// Send Low Byte of data

	UNSELECT_MP3_SCI();
	delay_ms(1);
}

//Usage: vs1002SineTest(126);
//Inputs: unsigned char pitch - pitch of the sine wave to be produced
//Outputs: None
//Description: Runs the Sine Test defined in the vs1002 datasheet
//**NOTE: ** for a sine wave test @ 5168 hz, send sequence: 0x53, 0xEF, 0x6E, 126, 0, 0, 0, 0
void vs1002SineTest(unsigned char pitch)
{
	SELECT_MP3_SDI();
	
   	SPI0_send(0x53);
	SPI0_send(0xEF);
	SPI0_send(0x6E);
   	SPI0_send(pitch);						//Send the Pitch	
	SPI0_send(0);
	SPI0_send(0);
	SPI0_send(0);
	SPI0_send(0);
	
   	UNSELECT_MP3_SDI();
}

//Usage: vs1002Mute();
//Inputs: None
//Outputs: None
//Description: Mutes the output of the vs1002 MP3 player
void vs1002Mute(void){
	vs1002SCIWrite(SCI_VOL, SV_MUTE);
}


//Usage: vs1002SetVolume(INCREASE);
//Inputs: char setting - either INCREASE(1) or DECREASE(0)
//Outputs: None
//Description: Increases or decreases the volume of the MP3 player based on the value of "setting"
void vs1002SetVolume(char setting){
	unsigned short int currentVolume=0;
	
	currentVolume = vs1002SCIRead(SCI_VOL);
	if(setting == INCREASE){
		if(currentVolume == SV_MAX_VOLUME);	//Don't Change the current volume
		else currentVolume -= 0x0808;		//Increment both channels equally
	}
	else{
		if(currentVolume == SV_MUTE);			//Don't change the current volume
		else currentVolume += 0x0808;
	}
	vs1002SCIWrite(SCI_VOL, currentVolume);
}

//Usage: vs1002SendMusic(bufferedSongData, BUFFERSIZE);
//Inputs: unsigned char* songData - pointer to MP3 data that is to be sent to mp3 player
//		  int buffer_size - size of song data in bytes
//Outputs: None
//Description: Sends the data in the songData buffer to the MP3 player
void vs1002SendMusic(unsigned char* songData, int buffer_size){
	SELECT_MP3_SDI();
	for(int i=0; i<buffer_size; i++){
		SPI0_send(*songData++);			//Send the buffered byte of data, then increment the buffer position
	}
	UNSELECT_MP3_SDI();
}

//Usage: vs1002Reset();
//Inputs: None
//Outputs: None
//Description: Resets the mp3 player
void vs1002Reset(void){
   15334:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	//Reset the MP3 Player and make sure the mp3 player doesn't try to boot from SPI
	IOCLR0 = MP3_GPIO0;		//Pull GPIO0 low
   15338:	e59f4020 	ldr	r4, [pc, #32]	; 15360 <.text+0x5360>
	IOCLR1 = MP3_XRES;		//Reset the vs1002
   1533c:	e3a05401 	mov	r5, #16777216	; 0x1000000
   15340:	e3a03802 	mov	r3, #131072	; 0x20000
   15344:	e584300c 	str	r3, [r4, #12]
	delay_ms(10);			//Hold Reset
   15348:	e3a0000a 	mov	r0, #10	; 0xa
   1534c:	e584501c 	str	r5, [r4, #28]
   15350:	ebffeb8f 	bl	10194 <delay_ms>
	IOSET1 = MP3_XRES;		//Bring vs1002 out of reset
   15354:	e5845014 	str	r5, [r4, #20]
}
   15358:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1535c:	e12fff1e 	bx	lr
   15360:	e0028000 	and	r8, r2, r0

00015364 <vs1002SendMusic>:
   15364:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15368:	e59f303c 	ldr	r3, [pc, #60]	; 153ac <.text+0x53ac>
   1536c:	e3a02801 	mov	r2, #65536	; 0x10000
   15370:	e1a06000 	mov	r6, r0
   15374:	e1a05001 	mov	r5, r1
   15378:	e3a04000 	mov	r4, #0	; 0x0
   1537c:	e583201c 	str	r2, [r3, #28]
   15380:	ea000002 	b	15390 <vs1002SendMusic+0x2c>
   15384:	e7d40006 	ldrb	r0, [r4, r6]
   15388:	ebfff278 	bl	11d70 <SPI0_send>
   1538c:	e2844001 	add	r4, r4, #1	; 0x1
   15390:	e1540005 	cmp	r4, r5
   15394:	bafffffa 	blt	15384 <vs1002SendMusic+0x20>
   15398:	e59f300c 	ldr	r3, [pc, #12]	; 153ac <.text+0x53ac>
   1539c:	e3a02801 	mov	r2, #65536	; 0x10000
   153a0:	e5832014 	str	r2, [r3, #20]
   153a4:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   153a8:	e12fff1e 	bx	lr
   153ac:	e0028000 	and	r8, r2, r0

000153b0 <vs1002SineTest>:
   153b0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   153b4:	e59f4058 	ldr	r4, [pc, #88]	; 15414 <.text+0x5414>
   153b8:	e3a06801 	mov	r6, #65536	; 0x10000
   153bc:	e1a05000 	mov	r5, r0
   153c0:	e584601c 	str	r6, [r4, #28]
   153c4:	e3a00053 	mov	r0, #83	; 0x53
   153c8:	ebfff268 	bl	11d70 <SPI0_send>
   153cc:	e3a000ef 	mov	r0, #239	; 0xef
   153d0:	ebfff266 	bl	11d70 <SPI0_send>
   153d4:	e20550ff 	and	r5, r5, #255	; 0xff
   153d8:	e3a0006e 	mov	r0, #110	; 0x6e
   153dc:	ebfff263 	bl	11d70 <SPI0_send>
   153e0:	e1a00005 	mov	r0, r5
   153e4:	ebfff261 	bl	11d70 <SPI0_send>
   153e8:	e3a00000 	mov	r0, #0	; 0x0
   153ec:	ebfff25f 	bl	11d70 <SPI0_send>
   153f0:	e3a00000 	mov	r0, #0	; 0x0
   153f4:	ebfff25d 	bl	11d70 <SPI0_send>
   153f8:	e3a00000 	mov	r0, #0	; 0x0
   153fc:	ebfff25b 	bl	11d70 <SPI0_send>
   15400:	e3a00000 	mov	r0, #0	; 0x0
   15404:	ebfff259 	bl	11d70 <SPI0_send>
   15408:	e5846014 	str	r6, [r4, #20]
   1540c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15410:	e12fff1e 	bx	lr
   15414:	e0028000 	and	r8, r2, r0

00015418 <vs1002SCIWrite>:
   15418:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   1541c:	e59f7048 	ldr	r7, [pc, #72]	; 1546c <.text+0x546c>
   15420:	e3a06601 	mov	r6, #1048576	; 0x100000
   15424:	e20050ff 	and	r5, r0, #255	; 0xff
   15428:	e587600c 	str	r6, [r7, #12]
   1542c:	e3a00002 	mov	r0, #2	; 0x2
   15430:	e1a04801 	mov	r4, r1, lsl #16
   15434:	ebfff24d 	bl	11d70 <SPI0_send>
   15438:	e1a00005 	mov	r0, r5
   1543c:	ebfff24b 	bl	11d70 <SPI0_send>
   15440:	e1a00c24 	mov	r0, r4, lsr #24
   15444:	e1a04824 	mov	r4, r4, lsr #16
   15448:	e20440ff 	and	r4, r4, #255	; 0xff
   1544c:	ebfff247 	bl	11d70 <SPI0_send>
   15450:	e1a00004 	mov	r0, r4
   15454:	ebfff245 	bl	11d70 <SPI0_send>
   15458:	e3a00001 	mov	r0, #1	; 0x1
   1545c:	e5876004 	str	r6, [r7, #4]
   15460:	ebffeb4b 	bl	10194 <delay_ms>
   15464:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15468:	e12fff1e 	bx	lr
   1546c:	e0028000 	and	r8, r2, r0

00015470 <vs1002Mute>:
   15470:	e59f1004 	ldr	r1, [pc, #4]	; 1547c <.text+0x547c>
   15474:	e3a0000b 	mov	r0, #11	; 0xb
   15478:	eaffffe6 	b	15418 <vs1002SCIWrite>
   1547c:	0000ffff 	streqd	pc, [r0], -pc

00015480 <vs1002Init>:
   15480:	e52de004 	str	lr, [sp, #-4]!
   15484:	e3a01b02 	mov	r1, #2048	; 0x800
   15488:	e3a00000 	mov	r0, #0	; 0x0
   1548c:	ebffffe1 	bl	15418 <vs1002SCIWrite>
   15490:	e3a00001 	mov	r0, #1	; 0x1
   15494:	ebffeb3e 	bl	10194 <delay_ms>
   15498:	e59f1008 	ldr	r1, [pc, #8]	; 154a8 <.text+0x54a8>
   1549c:	e3a00003 	mov	r0, #3	; 0x3
   154a0:	e49de004 	ldr	lr, [sp], #4
   154a4:	eaffffdb 	b	15418 <vs1002SCIWrite>
   154a8:	00009964 	andeq	r9, r0, r4, ror #18

000154ac <vs1002SCIRead>:
   154ac:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   154b0:	e59f704c 	ldr	r7, [pc, #76]	; 15504 <.text+0x5504>
   154b4:	e3a06601 	mov	r6, #1048576	; 0x100000
   154b8:	e20040ff 	and	r4, r0, #255	; 0xff
   154bc:	e587600c 	str	r6, [r7, #12]
   154c0:	e3a00003 	mov	r0, #3	; 0x3
   154c4:	ebfff229 	bl	11d70 <SPI0_send>
   154c8:	e1a00004 	mov	r0, r4
   154cc:	ebfff227 	bl	11d70 <SPI0_send>
   154d0:	ebfff221 	bl	11d5c <SPI0_recv>
   154d4:	e1a04c00 	mov	r4, r0, lsl #24
   154d8:	ebfff21f 	bl	11d5c <SPI0_recv>
   154dc:	e5876004 	str	r6, [r7, #4]
   154e0:	e1a05000 	mov	r5, r0
   154e4:	e3a00001 	mov	r0, #1	; 0x1
   154e8:	ebffeb29 	bl	10194 <delay_ms>
   154ec:	e1a04824 	mov	r4, r4, lsr #16
   154f0:	e1844005 	orr	r4, r4, r5
   154f4:	e1a04804 	mov	r4, r4, lsl #16
   154f8:	e1a00824 	mov	r0, r4, lsr #16
   154fc:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15500:	e12fff1e 	bx	lr
   15504:	e0028000 	and	r8, r2, r0

00015508 <vs1002SetVolume>:
   15508:	e92d4010 	stmdb	sp!, {r4, lr}
   1550c:	e20040ff 	and	r4, r0, #255	; 0xff
   15510:	e3a0000b 	mov	r0, #11	; 0xb
   15514:	ebffffe4 	bl	154ac <vs1002SCIRead>
   15518:	e3540031 	cmp	r4, #49	; 0x31
   1551c:	1a000004 	bne	15534 <vs1002SetVolume+0x2c>
   15520:	e2403b02 	sub	r3, r0, #2048	; 0x800
   15524:	e2433008 	sub	r3, r3, #8	; 0x8
   15528:	e1a03803 	mov	r3, r3, lsl #16
   1552c:	e3500000 	cmp	r0, #0	; 0x0
   15530:	ea000004 	b	15548 <vs1002SetVolume+0x40>
   15534:	e2803b02 	add	r3, r0, #2048	; 0x800
   15538:	e59f201c 	ldr	r2, [pc, #28]	; 1555c <.text+0x555c>
   1553c:	e2833008 	add	r3, r3, #8	; 0x8
   15540:	e1500002 	cmp	r0, r2
   15544:	e1a03803 	mov	r3, r3, lsl #16
   15548:	11a00823 	movne	r0, r3, lsr #16
   1554c:	e1a01000 	mov	r1, r0
   15550:	e3a0000b 	mov	r0, #11	; 0xb
   15554:	e8bd4010 	ldmia	sp!, {r4, lr}
   15558:	eaffffae 	b	15418 <vs1002SCIWrite>
   1555c:	0000ffff 	streqd	pc, [r0], -pc

00015560 <ns73SerialReset>:
//Usage: ns73SerialReset()
//Inputs: None
//Outputs: None
//Description:  Resets the ns73 module
void ns73SerialReset(void){
   15560:	e92d4030 	stmdb	sp!, {r4, r5, lr}
		delay_ms(10);
		IOCLR1 |= FM_DIO;
   15564:	e59f40ec 	ldr	r4, [pc, #236]	; 15658 <.text+0x5658>
   15568:	e3a0000a 	mov	r0, #10	; 0xa
   1556c:	ebffeb08 	bl	10194 <delay_ms>
   15570:	e594301c 	ldr	r3, [r4, #28]
   15574:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
		delay_ms(10);
   15578:	e3a0000a 	mov	r0, #10	; 0xa
   1557c:	e584301c 	str	r3, [r4, #28]
   15580:	ebffeb03 	bl	10194 <delay_ms>
		IOCLR1 |= FM_SCLK;
   15584:	e594301c 	ldr	r3, [r4, #28]
   15588:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   1558c:	e584301c 	str	r3, [r4, #28]
		delay_ms(10);
   15590:	e3a0000a 	mov	r0, #10	; 0xa
   15594:	ebffeafe 	bl	10194 <delay_ms>
		IOSET1 |= FM_DIO;
   15598:	e5943014 	ldr	r3, [r4, #20]
   1559c:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
   155a0:	e5843014 	str	r3, [r4, #20]
   155a4:	e3a05000 	mov	r5, #0	; 0x0
		for(int i=0; i<26; i++){
			IOSET1 |= FM_SCLK;
   155a8:	e59f40a8 	ldr	r4, [pc, #168]	; 15658 <.text+0x5658>
   155ac:	e5943014 	ldr	r3, [r4, #20]
   155b0:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
			delay_ms(10);
   155b4:	e3a0000a 	mov	r0, #10	; 0xa
   155b8:	e5843014 	str	r3, [r4, #20]
   155bc:	ebffeaf4 	bl	10194 <delay_ms>
			IOCLR1 |= FM_SCLK;
   155c0:	e594301c 	ldr	r3, [r4, #28]
   155c4:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   155c8:	e2855001 	add	r5, r5, #1	; 0x1
			delay_ms(10);
   155cc:	e3a0000a 	mov	r0, #10	; 0xa
   155d0:	e584301c 	str	r3, [r4, #28]
   155d4:	ebffeaee 	bl	10194 <delay_ms>
   155d8:	e355001a 	cmp	r5, #26	; 0x1a
   155dc:	1afffff1 	bne	155a8 <ns73SerialReset+0x48>
		}
		IOSET1 |= FM_SCLK;
   155e0:	e5943014 	ldr	r3, [r4, #20]
   155e4:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
		delay_ms(10);
   155e8:	e3a0000a 	mov	r0, #10	; 0xa
   155ec:	e5843014 	str	r3, [r4, #20]
   155f0:	ebffeae7 	bl	10194 <delay_ms>
		IOCLR1 |= FM_DIO;
   155f4:	e594301c 	ldr	r3, [r4, #28]
   155f8:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
		delay_ms(10);
   155fc:	e3a0000a 	mov	r0, #10	; 0xa
   15600:	e584301c 	str	r3, [r4, #28]
   15604:	ebffeae2 	bl	10194 <delay_ms>
		IOCLR1 |= FM_SCLK;
   15608:	e594301c 	ldr	r3, [r4, #28]
   1560c:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
		delay_ms(10);
   15610:	e3a0000a 	mov	r0, #10	; 0xa
   15614:	e584301c 	str	r3, [r4, #28]
   15618:	ebffeadd 	bl	10194 <delay_ms>
		IOSET1 |= FM_SCLK;
   1561c:	e5943014 	ldr	r3, [r4, #20]
   15620:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
		delay_ms(10);
   15624:	e3a0000a 	mov	r0, #10	; 0xa
   15628:	e5843014 	str	r3, [r4, #20]
   1562c:	ebffead8 	bl	10194 <delay_ms>
		IOSET1 |= FM_DIO;
   15630:	e5943014 	ldr	r3, [r4, #20]
   15634:	e3833301 	orr	r3, r3, #67108864	; 0x4000000
   15638:	e5843014 	str	r3, [r4, #20]
		delay_ms(10);
   1563c:	e3a0000a 	mov	r0, #10	; 0xa
   15640:	ebffead3 	bl	10194 <delay_ms>
		IOCLR1 |= FM_SCLK;
   15644:	e594301c 	ldr	r3, [r4, #28]
   15648:	e3833302 	orr	r3, r3, #134217728	; 0x8000000
   1564c:	e584301c 	str	r3, [r4, #28]
}
   15650:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15654:	e12fff1e 	bx	lr
   15658:	e0028000 	and	r8, r2, r0

0001565c <ns73Send>:
   1565c:	e59f3100 	ldr	r3, [pc, #256]	; 15764 <.text+0x5764>
   15660:	e3a02402 	mov	r2, #33554432	; 0x2000000
   15664:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   15668:	e1a0c000 	mov	ip, r0
   1566c:	e583201c 	str	r2, [r3, #28]
   15670:	e3a0000a 	mov	r0, #10	; 0xa
   15674:	e20c40ff 	and	r4, ip, #255	; 0xff
   15678:	e20160ff 	and	r6, r1, #255	; 0xff
   1567c:	ebffeac4 	bl	10194 <delay_ms>
   15680:	e3a05000 	mov	r5, #0	; 0x0
   15684:	e59f20d8 	ldr	r2, [pc, #216]	; 15764 <.text+0x5764>
   15688:	e3a03302 	mov	r3, #134217728	; 0x8000000
   1568c:	e582301c 	str	r3, [r2, #28]
   15690:	e3140001 	tst	r4, #1	; 0x1
   15694:	15923014 	ldrne	r3, [r2, #20]
   15698:	0592301c 	ldreq	r3, [r2, #28]
   1569c:	13833301 	orrne	r3, r3, #67108864	; 0x4000000
   156a0:	03833301 	orreq	r3, r3, #67108864	; 0x4000000
   156a4:	15823014 	strne	r3, [r2, #20]
   156a8:	0582301c 	streq	r3, [r2, #28]
   156ac:	e3a00001 	mov	r0, #1	; 0x1
   156b0:	e1a04034 	mov	r4, r4, lsr r0
   156b4:	ebffeab6 	bl	10194 <delay_ms>
   156b8:	e59f20a4 	ldr	r2, [pc, #164]	; 15764 <.text+0x5764>
   156bc:	e3a03302 	mov	r3, #134217728	; 0x8000000
   156c0:	e5823014 	str	r3, [r2, #20]
   156c4:	e3a00001 	mov	r0, #1	; 0x1
   156c8:	ebffeab1 	bl	10194 <delay_ms>
   156cc:	e2853001 	add	r3, r5, #1	; 0x1
   156d0:	e20350ff 	and	r5, r3, #255	; 0xff
   156d4:	e3550004 	cmp	r5, #4	; 0x4
   156d8:	1affffe9 	bne	15684 <ns73Send+0x28>
   156dc:	e3a04000 	mov	r4, #0	; 0x0
   156e0:	e59f207c 	ldr	r2, [pc, #124]	; 15764 <.text+0x5764>
   156e4:	e3a03302 	mov	r3, #134217728	; 0x8000000
   156e8:	e582301c 	str	r3, [r2, #28]
   156ec:	e283330e 	add	r3, r3, #939524096	; 0x38000000
   156f0:	e582300c 	str	r3, [r2, #12]
   156f4:	e3160001 	tst	r6, #1	; 0x1
   156f8:	15923014 	ldrne	r3, [r2, #20]
   156fc:	0592301c 	ldreq	r3, [r2, #28]
   15700:	13833301 	orrne	r3, r3, #67108864	; 0x4000000
   15704:	03833301 	orreq	r3, r3, #67108864	; 0x4000000
   15708:	e59f5054 	ldr	r5, [pc, #84]	; 15764 <.text+0x5764>
   1570c:	15823014 	strne	r3, [r2, #20]
   15710:	0582301c 	streq	r3, [r2, #28]
   15714:	e3a00001 	mov	r0, #1	; 0x1
   15718:	e3a07302 	mov	r7, #134217728	; 0x8000000
   1571c:	e1a06036 	mov	r6, r6, lsr r0
   15720:	ebffea9b 	bl	10194 <delay_ms>
   15724:	e3a00001 	mov	r0, #1	; 0x1
   15728:	e5857014 	str	r7, [r5, #20]
   1572c:	ebffea98 	bl	10194 <delay_ms>
   15730:	e2843001 	add	r3, r4, #1	; 0x1
   15734:	e20340ff 	and	r4, r3, #255	; 0xff
   15738:	e3540008 	cmp	r4, #8	; 0x8
   1573c:	1affffe7 	bne	156e0 <ns73Send+0x84>
   15740:	e3a04402 	mov	r4, #33554432	; 0x2000000
   15744:	e3a0000a 	mov	r0, #10	; 0xa
   15748:	e5854014 	str	r4, [r5, #20]
   1574c:	ebffea90 	bl	10194 <delay_ms>
   15750:	e3a00000 	mov	r0, #0	; 0x0
   15754:	e585401c 	str	r4, [r5, #28]
   15758:	e585701c 	str	r7, [r5, #28]
   1575c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15760:	e12fff1e 	bx	lr
   15764:	e0028000 	and	r8, r2, r0

00015768 <ns73SetChannel>:

//Usage: ns73SetChannel(973);
//Inputs: int radio_channel - Desired Radio Channel (should be input in MHz*10 so 97.3FM becomes 973)
//Outputs: None
//Description: Tunes the ns73 module to "radio_channel."
void ns73SetChannel(int radio_channel){
	long int channel=radio_channel*100000;
	unsigned char low_byte, high_byte;
	
	channel += 304000;
   15768:	e59f203c 	ldr	r2, [pc, #60]	; 157ac <.text+0x57ac>
   1576c:	e59f303c 	ldr	r3, [pc, #60]	; 157b0 <.text+0x57b0>
   15770:	e92d4010 	stmdb	sp!, {r4, lr}
   15774:	e0243290 	mla	r4, r0, r2, r3
	channel /= 8192;
   15778:	e2843d7f 	add	r3, r4, #8128	; 0x1fc0
   1577c:	e3540000 	cmp	r4, #0	; 0x0
   15780:	e283303f 	add	r3, r3, #63	; 0x3f
   15784:	b1a04003 	movlt	r4, r3
	low_byte = channel & 0xFF;
	high_byte = (channel >> 8) & 0xFF;
	
	ns73Send(R3, low_byte);
   15788:	e1a016a4 	mov	r1, r4, lsr #13
   1578c:	e20110ff 	and	r1, r1, #255	; 0xff
   15790:	e3a00003 	mov	r0, #3	; 0x3
   15794:	ebffffb0 	bl	1565c <ns73Send>
	ns73Send(R4, high_byte);
   15798:	e1a04aa4 	mov	r4, r4, lsr #21
   1579c:	e20410ff 	and	r1, r4, #255	; 0xff
   157a0:	e3a00004 	mov	r0, #4	; 0x4
}
   157a4:	e8bd4010 	ldmia	sp!, {r4, lr}
   157a8:	eaffffab 	b	1565c <ns73Send>
   157ac:	000186a0 	andeq	r8, r1, r0, lsr #13
   157b0:	0004a380 	andeq	sl, r4, r0, lsl #7

000157b4 <ns73Init>:
   157b4:	e52de004 	str	lr, [sp, #-4]!
   157b8:	e3a01005 	mov	r1, #5	; 0x5
   157bc:	e3a0000e 	mov	r0, #14	; 0xe
   157c0:	ebffffa5 	bl	1565c <ns73Send>
   157c4:	e3a00001 	mov	r0, #1	; 0x1
   157c8:	ebffea71 	bl	10194 <delay_ms>
   157cc:	e3a010b4 	mov	r1, #180	; 0xb4
   157d0:	e3a00001 	mov	r0, #1	; 0x1
   157d4:	ebffffa0 	bl	1565c <ns73Send>
   157d8:	e3a01006 	mov	r1, #6	; 0x6
   157dc:	e3a00002 	mov	r0, #2	; 0x2
   157e0:	ebffff9d 	bl	1565c <ns73Send>
   157e4:	e3a0108a 	mov	r1, #138	; 0x8a
   157e8:	e3a00003 	mov	r0, #3	; 0x3
   157ec:	ebffff9a 	bl	1565c <ns73Send>
   157f0:	e3a0102e 	mov	r1, #46	; 0x2e
   157f4:	e3a00004 	mov	r0, #4	; 0x4
   157f8:	ebffff97 	bl	1565c <ns73Send>
   157fc:	e3a0101a 	mov	r1, #26	; 0x1a
   15800:	e3a00008 	mov	r0, #8	; 0x8
   15804:	ebffff94 	bl	1565c <ns73Send>
   15808:	e3a01004 	mov	r1, #4	; 0x4
   1580c:	e3a00000 	mov	r0, #0	; 0x0
   15810:	ebffff91 	bl	1565c <ns73Send>
   15814:	e3a01005 	mov	r1, #5	; 0x5
   15818:	e3a0000e 	mov	r0, #14	; 0xe
   1581c:	ebffff8e 	bl	1565c <ns73Send>
   15820:	e3a00006 	mov	r0, #6	; 0x6
   15824:	e3a0101e 	mov	r1, #30	; 0x1e
   15828:	e49de004 	ldr	lr, [sp], #4
   1582c:	eaffff8a 	b	1565c <ns73Send>

00015830 <ns73Config>:
   15830:	e59f2040 	ldr	r2, [pc, #64]	; 15878 <.text+0x5878>
   15834:	e5923018 	ldr	r3, [r2, #24]
   15838:	e3833303 	orr	r3, r3, #201326592	; 0xc000000
   1583c:	e5823018 	str	r3, [r2, #24]
   15840:	e5923018 	ldr	r3, [r2, #24]
   15844:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
   15848:	e5823018 	str	r3, [r2, #24]
   1584c:	e5923008 	ldr	r3, [r2, #8]
   15850:	e3c33801 	bic	r3, r3, #65536	; 0x10000
   15854:	e5823008 	str	r3, [r2, #8]
   15858:	e5923014 	ldr	r3, [r2, #20]
   1585c:	e3833303 	orr	r3, r3, #201326592	; 0xc000000
   15860:	e52de004 	str	lr, [sp, #-4]!
   15864:	e3a00001 	mov	r0, #1	; 0x1
   15868:	e5823014 	str	r3, [r2, #20]
   1586c:	ebffea48 	bl	10194 <delay_ms>
   15870:	e49de004 	ldr	lr, [sp], #4
   15874:	e12fff1e 	bx	lr
   15878:	e0028000 	and	r8, r2, r0

0001587c <main_msc>:
    msc_main
    ====
**************************************************************************/
int main_msc(void)
{
   1587c:	e52de004 	str	lr, [sp, #-4]!
    // initialise the SD card
    BlockDevInit();
   15880:	eb0002e9 	bl	1642c <BlockDevInit>

    rprintf("Initialising USB stack\n");
   15884:	e59f006c 	ldr	r0, [pc, #108]	; 158f8 <.text+0x58f8>
   15888:	ebfff044 	bl	119a0 <rprintf>

    // initialise stack
    USBInit();
   1588c:	eb0003d9 	bl	167f8 <USBInit>

    // enable bulk-in interrupts on NAKs
    // these are required to get the BOT protocol going again after a STALL
    USBHwNakIntEnable(INACK_BI);
   15890:	e3a00020 	mov	r0, #32	; 0x20
   15894:	eb00046b 	bl	16a48 <USBHwNakIntEnable>

    // register descriptors
    USBRegisterDescriptors(abDescriptors);
   15898:	e59f005c 	ldr	r0, [pc, #92]	; 158fc <.text+0x58fc>
   1589c:	eb0005cb 	bl	16fd0 <USBRegisterDescriptors>

    // register class request handler
    USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
   158a0:	e59f2058 	ldr	r2, [pc, #88]	; 15900 <.text+0x5900>
   158a4:	e3a00001 	mov	r0, #1	; 0x1
   158a8:	e59f1054 	ldr	r1, [pc, #84]	; 15904 <.text+0x5904>
   158ac:	eb000553 	bl	16e00 <USBRegisterRequestHandler>

    // register endpoint handlers
    USBHwRegisterEPIntHandler(MSC_BULK_IN_EP, MSCBotBulkIn);
   158b0:	e3a00085 	mov	r0, #133	; 0x85
   158b4:	e59f104c 	ldr	r1, [pc, #76]	; 15908 <.text+0x5908>
   158b8:	eb000435 	bl	16994 <USBHwRegisterEPIntHandler>
    USBHwRegisterEPIntHandler(MSC_BULK_OUT_EP, MSCBotBulkOut);
   158bc:	e59f1048 	ldr	r1, [pc, #72]	; 1590c <.text+0x590c>
   158c0:	e3a00002 	mov	r0, #2	; 0x2
   158c4:	eb000432 	bl	16994 <USBHwRegisterEPIntHandler>

    rprintf("Starting USB communication\n");
   158c8:	e59f0040 	ldr	r0, [pc, #64]	; 15910 <.text+0x5910>
   158cc:	ebfff033 	bl	119a0 <rprintf>
	
    // connect to bus
    USBHwConnect(TRUE);
   158d0:	e3a00001 	mov	r0, #1	; 0x1
   158d4:	eb000457 	bl	16a38 <USBHwConnect>
   158d8:	ea000000 	b	158e0 <main_msc+0x64>

    // call USB interrupt handler continuously
    while (IOPIN0 & (1<<23))
	{
		USBHwISR();
   158dc:	eb0004bc 	bl	16bd4 <USBHwISR>
   158e0:	e59f302c 	ldr	r3, [pc, #44]	; 15914 <.text+0x5914>
   158e4:	e5933000 	ldr	r3, [r3]
   158e8:	e2130502 	ands	r0, r3, #8388608	; 0x800000
   158ec:	1afffffa 	bne	158dc <main_msc+0x60>
    }

    return 0;
}
   158f0:	e49de004 	ldr	lr, [sp], #4
   158f4:	e12fff1e 	bx	lr
   158f8:	00018bb0 	streqh	r8, [r1], -r0
   158fc:	4000000a 	andmi	r0, r0, sl
   15900:	40000f2b 	andmi	r0, r0, fp, lsr #30
   15904:	00015918 	andeq	r5, r1, r8, lsl r9
   15908:	00015ad8 	ldreqd	r5, [r1], -r8
   1590c:	00015b3c 	andeq	r5, r1, ip, lsr fp
   15910:	00018bc8 	andeq	r8, r1, r8, asr #23
   15914:	e0028000 	and	r8, r2, r0

00015918 <HandleClassRequest>:
   15918:	e1d030b4 	ldrh	r3, [r0, #4]
   1591c:	e3530000 	cmp	r3, #0	; 0x0
   15920:	e92d4010 	stmdb	sp!, {r4, lr}
   15924:	e1a03002 	mov	r3, r2
   15928:	e1a04001 	mov	r4, r1
   1592c:	1a000012 	bne	1597c <HandleClassRequest+0x64>
   15930:	e1d0e0b2 	ldrh	lr, [r0, #2]
   15934:	e35e0000 	cmp	lr, #0	; 0x0
   15938:	1a00000f 	bne	1597c <HandleClassRequest+0x64>
   1593c:	e5d0c001 	ldrb	ip, [r0, #1]
   15940:	e35c00fe 	cmp	ip, #254	; 0xfe
   15944:	05933000 	ldreq	r3, [r3]
   15948:	e3a02001 	mov	r2, #1	; 0x1
   1594c:	05c3e000 	streqb	lr, [r3]
   15950:	e1a01002 	mov	r1, r2
   15954:	05842000 	streq	r2, [r4]
   15958:	0a000008 	beq	15980 <HandleClassRequest+0x68>
   1595c:	e35c00ff 	cmp	ip, #255	; 0xff
   15960:	1a000005 	bne	1597c <HandleClassRequest+0x64>
   15964:	e1d030b6 	ldrh	r3, [r0, #6]
   15968:	e3530000 	cmp	r3, #0	; 0x0
   1596c:	1a000002 	bne	1597c <HandleClassRequest+0x64>
   15970:	eb000103 	bl	15d84 <MSCBotReset>
   15974:	e3a01001 	mov	r1, #1	; 0x1
   15978:	ea000000 	b	15980 <HandleClassRequest+0x68>
   1597c:	e3a01000 	mov	r1, #0	; 0x0
   15980:	e1a00001 	mov	r0, r1
   15984:	e8bd4010 	ldmia	sp!, {r4, lr}
   15988:	e12fff1e 	bx	lr

0001598c <SendCSW>:
static void SendCSW(U8 bStatus)
{
    int iResidue;

    iResidue = CBW.dwCBWDataTransferLength - dwTransferSize;
   1598c:	e59f203c 	ldr	r2, [pc, #60]	; 159d0 <.text+0x59d0>
   15990:	e59f303c 	ldr	r3, [pc, #60]	; 159d4 <.text+0x59d4>
   15994:	e5921008 	ldr	r1, [r2, #8]
   15998:	e5933000 	ldr	r3, [r3]

    // construct CSW
    CSW.dwCSWSignature      = CSW_SIGNATURE;
    CSW.dwCSWTag            = CBW.dwCBWTag;
   1599c:	e592c004 	ldr	ip, [r2, #4]
   159a0:	e59f2030 	ldr	r2, [pc, #48]	; 159d8 <.text+0x59d8>
   159a4:	e0631001 	rsb	r1, r3, r1
    CSW.dwCSWDataResidue    = MAX(iResidue, 0);
    CSW.bmCSWStatus         = bStatus;

    DBG("CSW: status=%x, residue=%d\n", bStatus, CSW.dwCSWDataResidue);

    // next state
    eState = eCSW;
   159a8:	e59f302c 	ldr	r3, [pc, #44]	; 159dc <.text+0x59dc>
   159ac:	e5c2000c 	strb	r0, [r2, #12]
   159b0:	e3a00003 	mov	r0, #3	; 0x3
   159b4:	e5830000 	str	r0, [r3]
   159b8:	e59f3020 	ldr	r3, [pc, #32]	; 159e0 <.text+0x59e0>
   159bc:	e3510000 	cmp	r1, #0	; 0x0
   159c0:	b3a01000 	movlt	r1, #0	; 0x0
   159c4:	e8821008 	stmia	r2, {r3, ip}
   159c8:	e5821008 	str	r1, [r2, #8]
}
   159cc:	e12fff1e 	bx	lr
   159d0:	40000f38 	andmi	r0, r0, r8, lsr pc
   159d4:	40000f30 	andmi	r0, r0, r0, lsr pc
   159d8:	40000f58 	andmi	r0, r0, r8, asr pc
   159dc:	40000f68 	andmi	r0, r0, r8, ror #30
   159e0:	53425355 	movtpl	r5, #9045	; 0x2355

000159e4 <BOTStall>:


/*************************************************************************
    CheckCBW
    ========
        Checks if CBW is valid and meaningful

    IN      pCBW    Command block wrapper
            iLen    Length of CBW

    Returns TRUE if valid and meaningful
**************************************************************************/
static BOOL CheckCBW(TCBW *pCBW, int iLen)
{
    // CBW valid?
    if (iLen != 31)
    {
        DBG("Invalid length (%d)\n", iLen);
        return FALSE;
    }
    if (pCBW->dwCBWSignature != CBW_SIGNATURE)
    {
        DBG("Invalid signature %x\n", pCBW->dwCBWSignature);
        return FALSE;
    }

    // CBW meaningful?
    if (pCBW->bCBWLun != 0)
    {
        DBG("Invalid LUN %d\n", pCBW->bCBWLun);
        return FALSE;
    }
    if ((pCBW->bCBWCBLength < 1) || (pCBW->bCBWCBLength > 16))
    {
        DBG("Invalid CB len %d\n", pCBW->bCBWCBLength);
        return FALSE;
    }
    return TRUE;
}


/*************************************************************************
    BOTStall
    ========
        Local function to stall ongoing transfer

    Which endpoint to stall is determined by looking at the transfer
    direction intended by the host.

**************************************************************************/
static void BOTStall(void)
{
   159e4:	e52de004 	str	lr, [sp, #-4]!
    if ((CBW.bmCBWFlags & 0x80) || (CBW.dwCBWDataTransferLength == 0))
   159e8:	e59f202c 	ldr	r2, [pc, #44]	; 15a1c <.text+0x5a1c>
   159ec:	e1d230dc 	ldrsb	r3, [r2, #12]
   159f0:	e3530000 	cmp	r3, #0	; 0x0
    {
        // stall data-in or CSW
        USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   159f4:	e3a00085 	mov	r0, #133	; 0x85
   159f8:	e3a01001 	mov	r1, #1	; 0x1
   159fc:	ba000003 	blt	15a10 <BOTStall+0x2c>
   15a00:	e5923008 	ldr	r3, [r2, #8]
   15a04:	e3530000 	cmp	r3, #0	; 0x0
    }
    else
    {
        // stall data-out
        USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
   15a08:	13a00002 	movne	r0, #2	; 0x2
   15a0c:	13a01001 	movne	r1, #1	; 0x1
   15a10:	eb000418 	bl	16a78 <USBHwEPStall>
    }
}
   15a14:	e49de004 	ldr	lr, [sp], #4
   15a18:	e12fff1e 	bx	lr
   15a1c:	40000f38 	andmi	r0, r0, r8, lsr pc

00015a20 <HandleDataIn>:


/*************************************************************************
    HandleDataIn
    ============
        Handles data from device-to-host

**************************************************************************/
static void HandleDataIn(void)
{
   15a20:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    int iChunk;

    // process data for host in SCSI layer
    pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
   15a24:	e59f609c 	ldr	r6, [pc, #156]	; 15ac8 <.text+0x5ac8>
   15a28:	e59f409c 	ldr	r4, [pc, #156]	; 15acc <.text+0x5acc>
   15a2c:	e59f509c 	ldr	r5, [pc, #156]	; 15ad0 <.text+0x5ad0>
   15a30:	e5d6100e 	ldrb	r1, [r6, #14]
   15a34:	e5942000 	ldr	r2, [r4]
   15a38:	e5953000 	ldr	r3, [r5]
   15a3c:	e286000f 	add	r0, r6, #15	; 0xf
   15a40:	eb000129 	bl	15eec <SCSIHandleData>
    if (pbData == NULL)
   15a44:	e3500000 	cmp	r0, #0	; 0x0
    {
        BOTStall();
        SendCSW(STATUS_FAILED);
        return;
    }

    // send data to host?
    if (dwOffset < dwTransferSize)
   15a48:	e59f7084 	ldr	r7, [pc, #132]	; 15ad4 <.text+0x5ad4>
   15a4c:	e5840000 	str	r0, [r4]
   15a50:	1a000002 	bne	15a60 <HandleDataIn+0x40>
   15a54:	ebffffe2 	bl	159e4 <BOTStall>
   15a58:	e3a00001 	mov	r0, #1	; 0x1
   15a5c:	ea000015 	b	15ab8 <HandleDataIn+0x98>
   15a60:	e5952000 	ldr	r2, [r5]
   15a64:	e5973000 	ldr	r3, [r7]
   15a68:	e1520003 	cmp	r2, r3
    {
        iChunk = MIN(64, dwTransferSize - dwOffset);
        USBHwEPWrite(MSC_BULK_IN_EP, pbData, iChunk);
   15a6c:	e1a01000 	mov	r1, r0
   15a70:	e0624003 	rsb	r4, r2, r3
   15a74:	e3a00085 	mov	r0, #133	; 0x85
   15a78:	2a000006 	bcs	15a98 <HandleDataIn+0x78>
   15a7c:	e3540040 	cmp	r4, #64	; 0x40
   15a80:	23a04040 	movcs	r4, #64	; 0x40
   15a84:	e1a02004 	mov	r2, r4
   15a88:	eb000402 	bl	16a98 <USBHwEPWrite>
        dwOffset += iChunk;
   15a8c:	e5953000 	ldr	r3, [r5]
   15a90:	e0833004 	add	r3, r3, r4
   15a94:	e5853000 	str	r3, [r5]
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
   15a98:	e5952000 	ldr	r2, [r5]
   15a9c:	e5973000 	ldr	r3, [r7]
   15aa0:	e1520003 	cmp	r2, r3
   15aa4:	1a000005 	bne	15ac0 <HandleDataIn+0xa0>
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
   15aa8:	e5963008 	ldr	r3, [r6, #8]
   15aac:	e1520003 	cmp	r2, r3
        {
            // stall pipe
            DBG("stalling DIN");
            BOTStall();
   15ab0:	1bffffcb 	blne	159e4 <BOTStall>
        }
        // done
        SendCSW(STATUS_PASSED);
   15ab4:	e3a00000 	mov	r0, #0	; 0x0
    }
}
   15ab8:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15abc:	eaffffb2 	b	1598c <SendCSW>
   15ac0:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15ac4:	e12fff1e 	bx	lr
   15ac8:	40000f38 	andmi	r0, r0, r8, lsr pc
   15acc:	40000f6c 	andmi	r0, r0, ip, ror #30
   15ad0:	40000f34 	andmi	r0, r0, r4, lsr pc
   15ad4:	40000f30 	andmi	r0, r0, r0, lsr pc

00015ad8 <MSCBotBulkIn>:


/*************************************************************************
    HandleDataOut
    =============
        Handles data from host-to-device

**************************************************************************/
static void HandleDataOut(void)
{
    int iChunk;

    if (dwOffset < dwTransferSize)
    {
        // get data from host
        iChunk = USBHwEPRead(MSC_BULK_OUT_EP, pbData, dwTransferSize - dwOffset);
        // process data in SCSI layer
        pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
        if (pbData == NULL)
        {
            BOTStall();
            SendCSW(STATUS_FAILED);
            return;
        }
        dwOffset += iChunk;
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
        {
            // stall pipe
            DBG("stalling DOUT");
            BOTStall();
        }
        SendCSW(STATUS_PASSED);
    }
}


/*************************************************************************
    MSCBotBulkOut
    ===============
        Handles the BOT bulk OUT endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkOut(U8 bEP, U8 bEPStatus)
{
    int     iLen, iChunk;
    BOOL    fHostIn, fDevIn;

    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
    {
        return;
    }

    switch (eState)
    {

        case eCBW:
            iLen = USBHwEPRead(bEP, (U8 *)&CBW, sizeof(CBW));

            // check if we got a good CBW
            if (!CheckCBW(&CBW, iLen))
            {
                // see 6.6.1
                USBHwEPStall(MSC_BULK_IN_EP, TRUE);
                USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
                eState = eStalled;
                break;
            }

            DBG("CBW: len=%d, flags=%x, cmd=%x, cmdlen=%d\n",
                    CBW.dwCBWDataTransferLength, CBW.bmCBWFlags, CBW.CBWCB[0], CBW.bCBWCBLength);

            dwOffset = 0;
            dwTransferSize = 0;
            fHostIn = ((CBW.bmCBWFlags & 0x80) != 0);

            // verify request
            pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
            if (pbData == NULL)
            {
                // unknown command
                BOTStall();
                SendCSW(STATUS_FAILED);
                break;
            }

            // rule: if device and host disagree on direction, send CSW with status 2
            if ((iLen > 0) &&
                ((fHostIn && !fDevIn) ||
                (!fHostIn && fDevIn)))
            {
                DBG("Host and device disagree on direction\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            // rule: if D > H, send CSW with status 2
            if (iLen > CBW.dwCBWDataTransferLength)
            {
                DBG("Negative residue\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            dwTransferSize = iLen;
            if ((dwTransferSize == 0) || fDevIn)
            {
                // data from device-to-host
                eState = eDataIn;
                HandleDataIn();
            }
            else
            {
                // data from host-to-device
                eState = eDataOut;
            }
            break;

        case eDataOut:
            HandleDataOut();
            break;

        case eDataIn:
        case eCSW:
            iChunk = USBHwEPRead(bEP, NULL, 0);
            DBG("Phase error in state %d, %d bytes\n", eState, iChunk);
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}


/*************************************************************************
    MSCBotBulkIn
    ============
        Handles the BOT bulk IN endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkIn(U8 bEP, U8 bEPStatus)
{
   15ad8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
   15adc:	e2114002 	ands	r4, r1, #2	; 0x2
    {
        return;
    }

    switch (eState)
   15ae0:	e59f504c 	ldr	r5, [pc, #76]	; 15b34 <.text+0x5b34>
   15ae4:	1a000010 	bne	15b2c <MSCBotBulkIn+0x54>
   15ae8:	e5953000 	ldr	r3, [r5]
   15aec:	e3530003 	cmp	r3, #3	; 0x3
    {

        case eCBW:
        case eDataOut:
        // ignore possibly old ACKs
            break;

        case eDataIn:
            HandleDataIn();
            break;

        case eCSW:
        // wait for an IN token, then send the CSW
            USBHwEPWrite(MSC_BULK_IN_EP, (U8 *)&CSW, 13);
   15af0:	e3a00085 	mov	r0, #133	; 0x85
   15af4:	e59f103c 	ldr	r1, [pc, #60]	; 15b38 <.text+0x5b38>
   15af8:	e3a0200d 	mov	r2, #13	; 0xd
   15afc:	0a000006 	beq	15b1c <MSCBotBulkIn+0x44>
   15b00:	e3530004 	cmp	r3, #4	; 0x4
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   15b04:	e3a01001 	mov	r1, #1	; 0x1
   15b08:	0a000006 	beq	15b28 <MSCBotBulkIn+0x50>
   15b0c:	e3530002 	cmp	r3, #2	; 0x2
   15b10:	1a000005 	bne	15b2c <MSCBotBulkIn+0x54>
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}
   15b14:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15b18:	eaffffc0 	b	15a20 <HandleDataIn>
   15b1c:	eb0003dd 	bl	16a98 <USBHwEPWrite>
   15b20:	e5854000 	str	r4, [r5]
   15b24:	ea000000 	b	15b2c <MSCBotBulkIn+0x54>
   15b28:	eb0003d2 	bl	16a78 <USBHwEPStall>
   15b2c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15b30:	e12fff1e 	bx	lr
   15b34:	40000f68 	andmi	r0, r0, r8, ror #30
   15b38:	40000f58 	andmi	r0, r0, r8, asr pc

00015b3c <MSCBotBulkOut>:
   15b3c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15b40:	e3110002 	tst	r1, #2	; 0x2
   15b44:	e24dd008 	sub	sp, sp, #8	; 0x8
   15b48:	e20000ff 	and	r0, r0, #255	; 0xff
   15b4c:	1a000083 	bne	15d60 <.text+0x5d60>
   15b50:	e59f3214 	ldr	r3, [pc, #532]	; 15d6c <.text+0x5d6c>
   15b54:	e5933000 	ldr	r3, [r3]
   15b58:	e3530004 	cmp	r3, #4	; 0x4
   15b5c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   15b60:	ea00007e 	b	15d60 <.text+0x5d60>
   15b64:	00015b78 	andeq	r5, r1, r8, ror fp
   15b68:	00015c60 	andeq	r5, r1, r0, ror #24
   15b6c:	00015cfc 	streqd	r5, [r1], -ip
   15b70:	00015cfc 	streqd	r5, [r1], -ip
   15b74:	00015d18 	andeq	r5, r1, r8, lsl sp
   15b78:	e59f41f0 	ldr	r4, [pc, #496]	; 15d70 <.text+0x5d70>
   15b7c:	e3a02020 	mov	r2, #32	; 0x20
   15b80:	e1a01004 	mov	r1, r4
   15b84:	eb0003e5 	bl	16b20 <USBHwEPRead>
   15b88:	e350001f 	cmp	r0, #31	; 0x1f
   15b8c:	e58d0000 	str	r0, [sp]
   15b90:	1a00000a 	bne	15bc0 <.text+0x5bc0>
   15b94:	e5942000 	ldr	r2, [r4]
   15b98:	e59f31d4 	ldr	r3, [pc, #468]	; 15d74 <.text+0x5d74>
   15b9c:	e1520003 	cmp	r2, r3
   15ba0:	1a000006 	bne	15bc0 <.text+0x5bc0>
   15ba4:	e5d4e00d 	ldrb	lr, [r4, #13]
   15ba8:	e35e0000 	cmp	lr, #0	; 0x0
   15bac:	1a000003 	bne	15bc0 <.text+0x5bc0>
   15bb0:	e5d4100e 	ldrb	r1, [r4, #14]
   15bb4:	e2413001 	sub	r3, r1, #1	; 0x1
   15bb8:	e353000f 	cmp	r3, #15	; 0xf
   15bbc:	9a000059 	bls	15d28 <.text+0x5d28>
   15bc0:	e3a00085 	mov	r0, #133	; 0x85
   15bc4:	e3a01001 	mov	r1, #1	; 0x1
   15bc8:	eb0003aa 	bl	16a78 <USBHwEPStall>
   15bcc:	e3a00002 	mov	r0, #2	; 0x2
   15bd0:	e3a01001 	mov	r1, #1	; 0x1
   15bd4:	eb0003a7 	bl	16a78 <USBHwEPStall>
   15bd8:	e3a02004 	mov	r2, #4	; 0x4
   15bdc:	ea00004a 	b	15d0c <.text+0x5d0c>
   15be0:	e59d2000 	ldr	r2, [sp]
   15be4:	e3520000 	cmp	r2, #0	; 0x0
   15be8:	da00000b 	ble	15c1c <.text+0x5c1c>
   15bec:	e3140080 	tst	r4, #128	; 0x80
   15bf0:	e59d3004 	ldr	r3, [sp, #4]
   15bf4:	0a000002 	beq	15c04 <.text+0x5c04>
   15bf8:	e3530000 	cmp	r3, #0	; 0x0
   15bfc:	0a000002 	beq	15c0c <.text+0x5c0c>
   15c00:	ea000005 	b	15c1c <.text+0x5c1c>
   15c04:	e3530000 	cmp	r3, #0	; 0x0
   15c08:	0a000003 	beq	15c1c <.text+0x5c1c>
   15c0c:	ebffff74 	bl	159e4 <BOTStall>
   15c10:	e3a00002 	mov	r0, #2	; 0x2
   15c14:	ebffff5c 	bl	1598c <SendCSW>
   15c18:	ea000050 	b	15d60 <.text+0x5d60>
   15c1c:	e59f314c 	ldr	r3, [pc, #332]	; 15d70 <.text+0x5d70>
   15c20:	e5933008 	ldr	r3, [r3, #8]
   15c24:	e1520003 	cmp	r2, r3
   15c28:	8afffff7 	bhi	15c0c <.text+0x5c0c>
   15c2c:	e59f3144 	ldr	r3, [pc, #324]	; 15d78 <.text+0x5d78>
   15c30:	e3520000 	cmp	r2, #0	; 0x0
   15c34:	e5832000 	str	r2, [r3]
   15c38:	0a000003 	beq	15c4c <.text+0x5c4c>
   15c3c:	e59d3004 	ldr	r3, [sp, #4]
   15c40:	e3530000 	cmp	r3, #0	; 0x0
   15c44:	03a02001 	moveq	r2, #1	; 0x1
   15c48:	0a00002f 	beq	15d0c <.text+0x5d0c>
   15c4c:	e59f3118 	ldr	r3, [pc, #280]	; 15d6c <.text+0x5d6c>
   15c50:	e3a02002 	mov	r2, #2	; 0x2
   15c54:	e5832000 	str	r2, [r3]
   15c58:	ebffff70 	bl	15a20 <HandleDataIn>
   15c5c:	ea00003f 	b	15d60 <.text+0x5d60>
   15c60:	e59f5114 	ldr	r5, [pc, #276]	; 15d7c <.text+0x5d7c>
   15c64:	e59f310c 	ldr	r3, [pc, #268]	; 15d78 <.text+0x5d78>
   15c68:	e5951000 	ldr	r1, [r5]
   15c6c:	e5932000 	ldr	r2, [r3]
   15c70:	e1510002 	cmp	r1, r2
   15c74:	2a000014 	bcs	15ccc <.text+0x5ccc>
   15c78:	e59f4100 	ldr	r4, [pc, #256]	; 15d80 <.text+0x5d80>
   15c7c:	e0612002 	rsb	r2, r1, r2
   15c80:	e3a00002 	mov	r0, #2	; 0x2
   15c84:	e5941000 	ldr	r1, [r4]
   15c88:	eb0003a4 	bl	16b20 <USBHwEPRead>
   15c8c:	e1a06000 	mov	r6, r0
   15c90:	e59f00d8 	ldr	r0, [pc, #216]	; 15d70 <.text+0x5d70>
   15c94:	e5953000 	ldr	r3, [r5]
   15c98:	e5d0100e 	ldrb	r1, [r0, #14]
   15c9c:	e5942000 	ldr	r2, [r4]
   15ca0:	e280000f 	add	r0, r0, #15	; 0xf
   15ca4:	eb000090 	bl	15eec <SCSIHandleData>
   15ca8:	e3500000 	cmp	r0, #0	; 0x0
   15cac:	15953000 	ldrne	r3, [r5]
   15cb0:	10833006 	addne	r3, r3, r6
   15cb4:	e5840000 	str	r0, [r4]
   15cb8:	15853000 	strne	r3, [r5]
   15cbc:	1a000002 	bne	15ccc <.text+0x5ccc>
   15cc0:	ebffff47 	bl	159e4 <BOTStall>
   15cc4:	e3a00001 	mov	r0, #1	; 0x1
   15cc8:	eaffffd1 	b	15c14 <.text+0x5c14>
   15ccc:	e59f30a8 	ldr	r3, [pc, #168]	; 15d7c <.text+0x5d7c>
   15cd0:	e5932000 	ldr	r2, [r3]
   15cd4:	e59f309c 	ldr	r3, [pc, #156]	; 15d78 <.text+0x5d78>
   15cd8:	e5933000 	ldr	r3, [r3]
   15cdc:	e1520003 	cmp	r2, r3
   15ce0:	1a00001e 	bne	15d60 <.text+0x5d60>
   15ce4:	e59f3084 	ldr	r3, [pc, #132]	; 15d70 <.text+0x5d70>
   15ce8:	e5933008 	ldr	r3, [r3, #8]
   15cec:	e1520003 	cmp	r2, r3
   15cf0:	1bffff3b 	blne	159e4 <BOTStall>
   15cf4:	e3a00000 	mov	r0, #0	; 0x0
   15cf8:	eaffffc5 	b	15c14 <.text+0x5c14>
   15cfc:	e3a01000 	mov	r1, #0	; 0x0
   15d00:	e1a02001 	mov	r2, r1
   15d04:	eb000385 	bl	16b20 <USBHwEPRead>
   15d08:	e3a02000 	mov	r2, #0	; 0x0
   15d0c:	e59f3058 	ldr	r3, [pc, #88]	; 15d6c <.text+0x5d6c>
   15d10:	e5832000 	str	r2, [r3]
   15d14:	ea000011 	b	15d60 <.text+0x5d60>
   15d18:	e3a00002 	mov	r0, #2	; 0x2
   15d1c:	e3a01001 	mov	r1, #1	; 0x1
   15d20:	eb000354 	bl	16a78 <USBHwEPStall>
   15d24:	ea00000d 	b	15d60 <.text+0x5d60>
   15d28:	e59fc048 	ldr	ip, [pc, #72]	; 15d78 <.text+0x5d78>
   15d2c:	e58ce000 	str	lr, [ip]
   15d30:	e59fc044 	ldr	ip, [pc, #68]	; 15d7c <.text+0x5d7c>
   15d34:	e284000f 	add	r0, r4, #15	; 0xf
   15d38:	e28d3004 	add	r3, sp, #4	; 0x4
   15d3c:	e1a0200d 	mov	r2, sp
   15d40:	e58ce000 	str	lr, [ip]
   15d44:	e5d4400c 	ldrb	r4, [r4, #12]
   15d48:	eb00001a 	bl	15db8 <SCSIHandleCmd>
   15d4c:	e59f302c 	ldr	r3, [pc, #44]	; 15d80 <.text+0x5d80>
   15d50:	e3500000 	cmp	r0, #0	; 0x0
   15d54:	e5830000 	str	r0, [r3]
   15d58:	1affffa0 	bne	15be0 <.text+0x5be0>
   15d5c:	eaffffd7 	b	15cc0 <.text+0x5cc0>
   15d60:	e28dd008 	add	sp, sp, #8	; 0x8
   15d64:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15d68:	e12fff1e 	bx	lr
   15d6c:	40000f68 	andmi	r0, r0, r8, ror #30
   15d70:	40000f38 	andmi	r0, r0, r8, lsr pc
   15d74:	43425355 	movtmi	r5, #9045	; 0x2355
   15d78:	40000f30 	andmi	r0, r0, r0, lsr pc
   15d7c:	40000f34 	andmi	r0, r0, r4, lsr pc
   15d80:	40000f6c 	andmi	r0, r0, ip, ror #30

00015d84 <MSCBotReset>:
   15d84:	e59f3014 	ldr	r3, [pc, #20]	; 15da0 <.text+0x5da0>
   15d88:	e3a02000 	mov	r2, #0	; 0x0
   15d8c:	e52de004 	str	lr, [sp, #-4]!
   15d90:	e5832000 	str	r2, [r3]
   15d94:	eb000002 	bl	15da4 <SCSIReset>
   15d98:	e49de004 	ldr	lr, [sp], #4
   15d9c:	e12fff1e 	bx	lr
   15da0:	40000f68 	andmi	r0, r0, r8, ror #30

00015da4 <SCSIReset>:

**************************************************************************/
void SCSIReset(void)
{
    dwSense = 0;
   15da4:	e59f3008 	ldr	r3, [pc, #8]	; 15db4 <.text+0x5db4>
   15da8:	e3a02000 	mov	r2, #0	; 0x0
   15dac:	e5832000 	str	r2, [r3]
}
   15db0:	e12fff1e 	bx	lr
   15db4:	40000f70 	andmi	r0, r0, r0, ror pc

00015db8 <SCSIHandleCmd>:


/*************************************************************************
    SCSIHandleCmd
    =============
        Verifies a SCSI CDB and indicates the direction and amount of data
        that the device wants to transfer.

    If this call fails, a sense code is set in dwSense.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    OUT     *piRspLen   Length of intended response data:
            *pfDevIn    TRUE if data is transferred from device-to-host

    Returns a pointer to the data exchange buffer if successful,
    return NULL otherwise.
**************************************************************************/
U8 * SCSIHandleCmd(U8 *pbCDB, int iCDBLen, int *piRspLen, BOOL *pfDevIn)
{
   15db8:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15dbc:	e1a04000 	mov	r4, r0
   15dc0:	e24dd008 	sub	sp, sp, #8	; 0x8
    int     i;
    TCDB6   *pCDB;
    U32     dwLen, dwLBA;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
   15dc4:	e3a08008 	mov	r8, #8	; 0x8
   15dc8:	e1a06001 	mov	r6, r1
   15dcc:	e1a05002 	mov	r5, r2
   15dd0:	e1a0000d 	mov	r0, sp
   15dd4:	e1a02008 	mov	r2, r8
   15dd8:	e1a01004 	mov	r1, r4
   15ddc:	e1a07003 	mov	r7, r3
   15de0:	eb0006f3 	bl	179b4 <memcpy>
	
    // default direction is from device to host
    *pfDevIn = TRUE;

    switch (pCDB->bOperationCode)
   15de4:	e5dd2000 	ldrb	r2, [sp]
   15de8:	e3a03001 	mov	r3, #1	; 0x1
   15dec:	e3520012 	cmp	r2, #18	; 0x12
   15df0:	e5873000 	str	r3, [r7]
   15df4:	0a000013 	beq	15e48 <SCSIHandleCmd+0x90>
   15df8:	8a000006 	bhi	15e18 <SCSIHandleCmd+0x60>
   15dfc:	e3520000 	cmp	r2, #0	; 0x0
    {

        // test unit ready (6)
        case SCSI_CMD_TEST_UNIT_READY:
            DBG("TEST UNIT READY\n");
            *piRspLen = 0;
   15e00:	059f00dc 	ldreq	r0, [pc, #220]	; 15ee4 <.text+0x5ee4>
   15e04:	05852000 	streq	r2, [r5]
   15e08:	0a000032 	beq	15ed8 <SCSIHandleCmd+0x120>
   15e0c:	e3520003 	cmp	r2, #3	; 0x3
   15e10:	1a000028 	bne	15eb8 <SCSIHandleCmd+0x100>
   15e14:	ea000006 	b	15e34 <SCSIHandleCmd+0x7c>
   15e18:	e3520028 	cmp	r2, #40	; 0x28
   15e1c:	0a000012 	beq	15e6c <SCSIHandleCmd+0xb4>
   15e20:	e352002a 	cmp	r2, #42	; 0x2a
   15e24:	0a000018 	beq	15e8c <SCSIHandleCmd+0xd4>
   15e28:	e3520025 	cmp	r2, #37	; 0x25
   15e2c:	1a000021 	bne	15eb8 <SCSIHandleCmd+0x100>
   15e30:	ea00000a 	b	15e60 <SCSIHandleCmd+0xa8>
            break;

        // request sense (6)
        case SCSI_CMD_REQUEST_SENSE:
            DBG("REQUEST SENSE (%06X)\n", dwSense);
            // check params
            *piRspLen = MIN(18, pCDB->bLength);
   15e34:	e5dd3004 	ldrb	r3, [sp, #4]
   15e38:	e59f00a4 	ldr	r0, [pc, #164]	; 15ee4 <.text+0x5ee4>
   15e3c:	e3530012 	cmp	r3, #18	; 0x12
   15e40:	23a03012 	movcs	r3, #18	; 0x12
   15e44:	ea000003 	b	15e58 <SCSIHandleCmd+0xa0>
            break;

        // inquiry (6)
        case SCSI_CMD_INQUIRY:
            DBG("INQUIRY\n");
            // see SPC20r20, 4.3.4.6
            *piRspLen = MIN(36, pCDB->bLength);
   15e48:	e5dd3004 	ldrb	r3, [sp, #4]
   15e4c:	e59f0090 	ldr	r0, [pc, #144]	; 15ee4 <.text+0x5ee4>
   15e50:	e3530024 	cmp	r3, #36	; 0x24
   15e54:	23a03024 	movcs	r3, #36	; 0x24
   15e58:	e5853000 	str	r3, [r5]
   15e5c:	ea00001d 	b	15ed8 <SCSIHandleCmd+0x120>
            break;

        // read capacity (10)
        case SCSI_CMD_READ_CAPACITY:
            DBG("READ CAPACITY\n");
            *piRspLen = 8;
   15e60:	e59f007c 	ldr	r0, [pc, #124]	; 15ee4 <.text+0x5ee4>
   15e64:	e5858000 	str	r8, [r5]
   15e68:	ea00001a 	b	15ed8 <SCSIHandleCmd+0x120>
            break;

        // read (10)
        case SCSI_CMD_READ_10:
            if (iCDBLen != 10)
   15e6c:	e356000a 	cmp	r6, #10	; 0xa
   15e70:	1a000017 	bne	15ed4 <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("READ10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
   15e74:	e5d43008 	ldrb	r3, [r4, #8]
   15e78:	e5d42007 	ldrb	r2, [r4, #7]
   15e7c:	e59f0060 	ldr	r0, [pc, #96]	; 15ee4 <.text+0x5ee4>
   15e80:	e1833402 	orr	r3, r3, r2, lsl #8
   15e84:	e1a03483 	mov	r3, r3, lsl #9
   15e88:	eafffff2 	b	15e58 <SCSIHandleCmd+0xa0>
            break;

        // write (10)
        case SCSI_CMD_WRITE_10:
            if (iCDBLen != 10)
   15e8c:	e356000a 	cmp	r6, #10	; 0xa
   15e90:	1a00000f 	bne	15ed4 <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("WRITE10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
   15e94:	e5d43008 	ldrb	r3, [r4, #8]
   15e98:	e5d42007 	ldrb	r2, [r4, #7]
   15e9c:	e1833402 	orr	r3, r3, r2, lsl #8
   15ea0:	e1a03483 	mov	r3, r3, lsl #9
            *pfDevIn = FALSE;
   15ea4:	e59f0038 	ldr	r0, [pc, #56]	; 15ee4 <.text+0x5ee4>
   15ea8:	e5853000 	str	r3, [r5]
   15eac:	e3a03000 	mov	r3, #0	; 0x0
   15eb0:	e5873000 	str	r3, [r7]
   15eb4:	ea000007 	b	15ed8 <SCSIHandleCmd+0x120>
            break;

        default:
            DBG("Unhandled SCSI: ");
            for (i = 0; i < iCDBLen; i++)
            {
                DBG(" %02X", pbCDB[i]);
            }
            DBG("\n");
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
            *piRspLen = 0;
   15eb8:	e3a01000 	mov	r1, #0	; 0x0
   15ebc:	e59f3024 	ldr	r3, [pc, #36]	; 15ee8 <.text+0x5ee8>
   15ec0:	e3a02a52 	mov	r2, #335872	; 0x52000
   15ec4:	e1a00001 	mov	r0, r1
   15ec8:	e5832000 	str	r2, [r3]
   15ecc:	e5851000 	str	r1, [r5]
   15ed0:	ea000000 	b	15ed8 <SCSIHandleCmd+0x120>
            return NULL;
   15ed4:	e3a00000 	mov	r0, #0	; 0x0
        }


    return abBlockBuf;
}
   15ed8:	e28dd008 	add	sp, sp, #8	; 0x8
   15edc:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   15ee0:	e12fff1e 	bx	lr
   15ee4:	40000f74 	andmi	r0, r0, r4, ror pc
   15ee8:	40000f70 	andmi	r0, r0, r0, ror pc

00015eec <SCSIHandleData>:


/*************************************************************************
    SCSIHandleData
    ==============
        Handles a block of SCSI data.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    IN/OUT  pbData      Data buffer
    IN      dwOffset    Offset in data

    Returns a pointer to the next data to be exchanged if successful,
    returns NULL otherwise.
**************************************************************************/
U8 * SCSIHandleData(U8 *pbCDB, int iCDBLen, U8 *pbData, U32 dwOffset)
{
   15eec:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15ef0:	e1a04000 	mov	r4, r0
   15ef4:	e24dd00c 	sub	sp, sp, #12	; 0xc
   15ef8:	e1a05002 	mov	r5, r2
    TCDB6   *pCDB;
    U32     dwLBA;
    U32     dwBufPos, dwBlockNr;
    U32     dwNumBlocks, dwMaxBlock;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
   15efc:	e1a0000d 	mov	r0, sp
   15f00:	e1a01004 	mov	r1, r4
   15f04:	e3a02008 	mov	r2, #8	; 0x8
   15f08:	e1a06003 	mov	r6, r3
   15f0c:	eb0006a8 	bl	179b4 <memcpy>
	
    switch (pCDB->bOperationCode)
   15f10:	e5dd3000 	ldrb	r3, [sp]
   15f14:	e3530012 	cmp	r3, #18	; 0x12
   15f18:	0a000022 	beq	15fa8 <SCSIHandleData+0xbc>
   15f1c:	8a000004 	bhi	15f34 <SCSIHandleData+0x48>
   15f20:	e3530000 	cmp	r3, #0	; 0x0
   15f24:	0a000009 	beq	15f50 <SCSIHandleData+0x64>
   15f28:	e3530003 	cmp	r3, #3	; 0x3
   15f2c:	1a000065 	bne	160c8 <SCSIHandleData+0x1dc>
   15f30:	ea00000d 	b	15f6c <SCSIHandleData+0x80>
   15f34:	e3530028 	cmp	r3, #40	; 0x28
   15f38:	0a000034 	beq	16010 <SCSIHandleData+0x124>
   15f3c:	e353002a 	cmp	r3, #42	; 0x2a
   15f40:	0a000046 	beq	16060 <SCSIHandleData+0x174>
   15f44:	e3530025 	cmp	r3, #37	; 0x25
   15f48:	1a00005e 	bne	160c8 <SCSIHandleData+0x1dc>
   15f4c:	ea00001b 	b	15fc0 <SCSIHandleData+0xd4>
    {

        // test unit ready
        case 0x00:
            if (dwSense != 0)
   15f50:	e59f3190 	ldr	r3, [pc, #400]	; 160e8 <.text+0x60e8>
   15f54:	e5932000 	ldr	r2, [r3]
   15f58:	e59f318c 	ldr	r3, [pc, #396]	; 160ec <.text+0x60ec>
   15f5c:	e3520000 	cmp	r2, #0	; 0x0
   15f60:	01a0e003 	moveq	lr, r3
   15f64:	13a0e000 	movne	lr, #0	; 0x0
   15f68:	ea00005a 	b	160d8 <SCSIHandleData+0x1ec>
            {
                return NULL;
            }
            break;

        // request sense
        case SCSI_CMD_REQUEST_SENSE:
            memcpy(pbData, abSense, 18);
   15f6c:	e59f117c 	ldr	r1, [pc, #380]	; 160f0 <.text+0x60f0>
   15f70:	e3a02012 	mov	r2, #18	; 0x12
   15f74:	e1a00005 	mov	r0, r5
   15f78:	eb00068d 	bl	179b4 <memcpy>
            // fill in KEY/ASC/ASCQ
            pbData[2] = (dwSense >> 16) & 0xFF;
   15f7c:	e59f0164 	ldr	r0, [pc, #356]	; 160e8 <.text+0x60e8>
   15f80:	e5903000 	ldr	r3, [r0]
            pbData[12] = (dwSense >> 8) & 0xFF;
            pbData[13] = (dwSense >> 0) & 0xFF;
            // reset sense data
            dwSense = 0;
   15f84:	e59fe160 	ldr	lr, [pc, #352]	; 160ec <.text+0x60ec>
   15f88:	e1a02823 	mov	r2, r3, lsr #16
   15f8c:	e1a01423 	mov	r1, r3, lsr #8
   15f90:	e5c5300d 	strb	r3, [r5, #13]
   15f94:	e3a03000 	mov	r3, #0	; 0x0
   15f98:	e5c52002 	strb	r2, [r5, #2]
   15f9c:	e5c5100c 	strb	r1, [r5, #12]
   15fa0:	e5803000 	str	r3, [r0]
   15fa4:	ea00004b 	b	160d8 <SCSIHandleData+0x1ec>
            break;

        // inquiry
        case SCSI_CMD_INQUIRY:
            memcpy(pbData, abInquiry, sizeof(abInquiry));
   15fa8:	e1a00005 	mov	r0, r5
   15fac:	e59f1140 	ldr	r1, [pc, #320]	; 160f4 <.text+0x60f4>
   15fb0:	e3a02024 	mov	r2, #36	; 0x24
   15fb4:	eb00067e 	bl	179b4 <memcpy>
   15fb8:	e59fe12c 	ldr	lr, [pc, #300]	; 160ec <.text+0x60ec>
   15fbc:	ea000045 	b	160d8 <SCSIHandleData+0x1ec>
            break;

        // read capacity
        case SCSI_CMD_READ_CAPACITY:
        // get size of drive (bytes)
            BlockDevGetSize(&dwNumBlocks);
   15fc0:	e28d0008 	add	r0, sp, #8	; 0x8
   15fc4:	eb000088 	bl	161ec <BlockDevGetSize>
            // calculate highest LBA
            dwMaxBlock = (dwNumBlocks - 1) / 512;
   15fc8:	e59d3008 	ldr	r3, [sp, #8]
   15fcc:	e2433001 	sub	r3, r3, #1	; 0x1
   15fd0:	e1a004a3 	mov	r0, r3, lsr #9

            pbData[0] = (dwMaxBlock >> 24) & 0xFF;
            pbData[1] = (dwMaxBlock >> 16) & 0xFF;
            pbData[2] = (dwMaxBlock >> 8) & 0xFF;
   15fd4:	e1a0c8a3 	mov	ip, r3, lsr #17
            pbData[3] = (dwMaxBlock >> 0) & 0xFF;
            pbData[4] = (BLOCKSIZE >> 24) & 0xFF;
            pbData[5] = (BLOCKSIZE >> 16) & 0xFF;
            pbData[6] = (BLOCKSIZE >> 8) & 0xFF;
            pbData[7] = (BLOCKSIZE >> 0) & 0xFF;
   15fd8:	e59fe10c 	ldr	lr, [pc, #268]	; 160ec <.text+0x60ec>
   15fdc:	e1a03ca3 	mov	r3, r3, lsr #25
   15fe0:	e3a02000 	mov	r2, #0	; 0x0
   15fe4:	e1a01c20 	mov	r1, r0, lsr #24
   15fe8:	e5c53001 	strb	r3, [r5, #1]
   15fec:	e3a03002 	mov	r3, #2	; 0x2
   15ff0:	e5c52007 	strb	r2, [r5, #7]
   15ff4:	e5c51000 	strb	r1, [r5]
   15ff8:	e5c5c002 	strb	ip, [r5, #2]
   15ffc:	e5c50003 	strb	r0, [r5, #3]
   16000:	e5c53006 	strb	r3, [r5, #6]
   16004:	e5c52004 	strb	r2, [r5, #4]
   16008:	e5c52005 	strb	r2, [r5, #5]
   1600c:	ea000031 	b	160d8 <SCSIHandleData+0x1ec>
            break;

        // read10
        case SCSI_CMD_READ_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data from block buffer
            dwBufPos = (dwOffset & (BLOCKSIZE - 1));
   16010:	e1a05b86 	mov	r5, r6, lsl #23
   16014:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
   16018:	e3550000 	cmp	r5, #0	; 0x0
   1601c:	e5d42005 	ldrb	r2, [r4, #5]
   16020:	e5d43002 	ldrb	r3, [r4, #2]
   16024:	e5d40003 	ldrb	r0, [r4, #3]
   16028:	e5d41004 	ldrb	r1, [r4, #4]
   1602c:	1a000022 	bne	160bc <SCSIHandleData+0x1d0>
            {
                // read new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("R");
                if (BlockDevRead(dwBlockNr, abBlockBuf) < 0)
   16030:	e1a00800 	mov	r0, r0, lsl #16
   16034:	e1800c03 	orr	r0, r0, r3, lsl #24
   16038:	e1800002 	orr	r0, r0, r2
   1603c:	e1800401 	orr	r0, r0, r1, lsl #8
   16040:	e08004a6 	add	r0, r0, r6, lsr #9
   16044:	e59f10a0 	ldr	r1, [pc, #160]	; 160ec <.text+0x60ec>
   16048:	eb0000d2 	bl	16398 <BlockDevRead>
   1604c:	e3500000 	cmp	r0, #0	; 0x0
                {
                    dwSense = READ_ERROR;
   16050:	b1a0e005 	movlt	lr, r5
   16054:	b59f209c 	ldrlt	r2, [pc, #156]	; 160f8 <.text+0x60f8>
   16058:	ba000014 	blt	160b0 <SCSIHandleData+0x1c4>
   1605c:	ea000016 	b	160bc <SCSIHandleData+0x1d0>
                    DBG("BlockDevRead failed\n");
                    return NULL;
                }
            }
            // return pointer to data
            return abBlockBuf + dwBufPos;

            // write10
            case SCSI_CMD_WRITE_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data to block buffer
            dwBufPos = ((dwOffset + 64) & (BLOCKSIZE - 1));
   16060:	e2863040 	add	r3, r6, #64	; 0x40
   16064:	e1a05b83 	mov	r5, r3, lsl #23
   16068:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
   1606c:	e3550000 	cmp	r5, #0	; 0x0
   16070:	e5d42005 	ldrb	r2, [r4, #5]
   16074:	e5d43002 	ldrb	r3, [r4, #2]
   16078:	e5d40003 	ldrb	r0, [r4, #3]
   1607c:	e5d41004 	ldrb	r1, [r4, #4]
   16080:	1a00000d 	bne	160bc <SCSIHandleData+0x1d0>
            {
                // write new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("W");
                if (BlockDevWrite(dwBlockNr, abBlockBuf) < 0)
   16084:	e1a00800 	mov	r0, r0, lsl #16
   16088:	e1800c03 	orr	r0, r0, r3, lsl #24
   1608c:	e1800002 	orr	r0, r0, r2
   16090:	e1800401 	orr	r0, r0, r1, lsl #8
   16094:	e08004a6 	add	r0, r0, r6, lsr #9
   16098:	e59f104c 	ldr	r1, [pc, #76]	; 160ec <.text+0x60ec>
   1609c:	eb000039 	bl	16188 <BlockDevWrite>
   160a0:	e3500000 	cmp	r0, #0	; 0x0
   160a4:	aa000004 	bge	160bc <SCSIHandleData+0x1d0>
                {
                    dwSense = WRITE_ERROR;
   160a8:	e1a0e005 	mov	lr, r5
   160ac:	e3a02bc3 	mov	r2, #199680	; 0x30c00
   160b0:	e59f3030 	ldr	r3, [pc, #48]	; 160e8 <.text+0x60e8>
   160b4:	e5832000 	str	r2, [r3]
   160b8:	ea000006 	b	160d8 <SCSIHandleData+0x1ec>
                    DBG("BlockDevWrite failed\n");
                    return NULL;
                }
            }
            // return pointer to next data
            return abBlockBuf + dwBufPos;
   160bc:	e59f3028 	ldr	r3, [pc, #40]	; 160ec <.text+0x60ec>
   160c0:	e085e003 	add	lr, r5, r3
   160c4:	ea000003 	b	160d8 <SCSIHandleData+0x1ec>

            default:
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
   160c8:	e59f3018 	ldr	r3, [pc, #24]	; 160e8 <.text+0x60e8>
   160cc:	e3a02a52 	mov	r2, #335872	; 0x52000
   160d0:	e5832000 	str	r2, [r3]
   160d4:	e3a0e000 	mov	lr, #0	; 0x0
            return NULL;
        }

    // default: return pointer to start of block buffer
    return abBlockBuf;
}
   160d8:	e1a0000e 	mov	r0, lr
   160dc:	e28dd00c 	add	sp, sp, #12	; 0xc
   160e0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   160e4:	e12fff1e 	bx	lr
   160e8:	40000f70 	andmi	r0, r0, r0, ror pc
   160ec:	40000f74 	andmi	r0, r0, r4, ror pc
   160f0:	00018983 	andeq	r8, r1, r3, lsl #19
   160f4:	00018995 	muleq	r1, r5, r9
   160f8:	00031100 	andeq	r1, r3, r0, lsl #2

000160fc <Resp8b>:

/*****************************************************************************/

static U8 Resp8b(void)
{
   160fc:	e92d4010 	stmdb	sp!, {r4, lr}
   16100:	e3a04000 	mov	r4, #0	; 0x0
    U8 i;
    U8 resp;

    /* Respone will come after 1 - 8 pings */
    for (i = 0; i < 8; i++)
    {
        resp = SPISend(0xff);
   16104:	e3a000ff 	mov	r0, #255	; 0xff
   16108:	eb000146 	bl	16628 <SPISend>
   1610c:	e2843001 	add	r3, r4, #1	; 0x1
        if (resp != 0xff)
   16110:	e35000ff 	cmp	r0, #255	; 0xff
   16114:	e20340ff 	and	r4, r3, #255	; 0xff
   16118:	1a000001 	bne	16124 <Resp8b+0x28>
   1611c:	e3540008 	cmp	r4, #8	; 0x8
   16120:	1afffff7 	bne	16104 <Resp8b+0x8>
        {
            return resp;
        }
    }

    return resp;
}
   16124:	e8bd4010 	ldmia	sp!, {r4, lr}
   16128:	e12fff1e 	bx	lr

0001612c <Command>:
   1612c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   16130:	e1a03001 	mov	r3, r1
   16134:	e24dd008 	sub	sp, sp, #8	; 0x8
   16138:	e3804040 	orr	r4, r0, #64	; 0x40
   1613c:	e3e05000 	mvn	r5, #0	; 0x0
   16140:	e1a02c21 	mov	r2, r1, lsr #24
   16144:	e1a0c821 	mov	ip, r1, lsr #16
   16148:	e1a0e421 	mov	lr, r1, lsr #8
   1614c:	e5cd3005 	strb	r3, [sp, #5]
   16150:	e1a0000d 	mov	r0, sp
   16154:	e3e0306a 	mvn	r3, #106	; 0x6a
   16158:	e3a01008 	mov	r1, #8	; 0x8
   1615c:	e5cd4001 	strb	r4, [sp, #1]
   16160:	e5cd2002 	strb	r2, [sp, #2]
   16164:	e5cdc003 	strb	ip, [sp, #3]
   16168:	e5cde004 	strb	lr, [sp, #4]
   1616c:	e5cd3006 	strb	r3, [sp, #6]
   16170:	e5cd5007 	strb	r5, [sp, #7]
   16174:	e5cd5000 	strb	r5, [sp]
   16178:	eb00013d 	bl	16674 <SPISendN>
   1617c:	e28dd008 	add	sp, sp, #8	; 0x8
   16180:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16184:	e12fff1e 	bx	lr

00016188 <BlockDevWrite>:

/*****************************************************************************/

static void Resp8bError(U8 value)
{
    switch (value)
    {
        case 0x40:  rprintf("Argument out of bounds.\n");               break;
        case 0x20:  rprintf("Address out of bounds.\n");                break;
        case 0x10:  rprintf("Error during erase sequence.\n");          break;
        case 0x08:  rprintf("CRC failed.\n");                           break;
        case 0x04:  rprintf("Illegal command.\n");                      break;
        case 0x02:  rprintf("Erase reset (see SanDisk docs p5-13).\n"); break;
//        case 0x01:  rprintf("Card is initialising.\n");                 break;
        case 0x01:  rprintf(".");                 break;
            default:
            rprintf("Unknown error 0x%x (see SanDisk docs p5-13).\n", value);
            break;
    }
}


/* ****************************************************************************
 calculates size of card from CSD
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
int BlockDevGetSize(U32 *pdwDriveSize)
{
    U8 cardresp, i, by;
    U8 iob[16];
    U16 c_size, c_size_mult, read_bl_len;

    Command(CMD_READCSD, 0);
    do
    {
        cardresp = Resp8b();
    }
    while (cardresp != 0xFE);

    rprintf("CSD:");
    for (i = 0; i < 16; i++)
    {
        iob[i] = SPISend(0xFF);
        rprintf(" %02x", iob[i]);
    }
    rprintf("\n");

    SPISend(0xff);
    SPISend(0xff);

    c_size = iob[6] & 0x03;     // bits 1..0
    c_size <<= 10;
    c_size += (U16) iob[7] << 2;
    c_size += iob[8] >> 6;

    by = iob[5] & 0x0F;
    read_bl_len = 1 << by;

    by = iob[9] & 0x03;
    by <<= 1;
    by += iob[10] >> 7;

    c_size_mult = 1 << (2 + by);

    *pdwDriveSize = (U32) (c_size + 1) * (U32) c_size_mult *(U32) read_bl_len;

    return 0;
}

/*****************************************************************************/

static U16 Resp16b(void)
{
    U16 resp;

    resp = (Resp8b() << 8) & 0xff00;
    resp |= SPISend(0xff);

    return resp;
}

/*****************************************************************************/

static int State(void)
{
    U16 value;

    Command(CMD_SENDSTATUS, 0);
    value = Resp16b();

    switch (value)
    {
        case 0x0000: return 1;
        case 0x0001: rprintf("Card is Locked.\n");                                                  break;
        case 0x0002: rprintf("WP Erase Skip, Lock/Unlock Cmd Failed.\n");                           break;
        case 0x0004: rprintf("General / Unknown error -- card broken?.\n");                         break;
        case 0x0008: rprintf("Internal card controller error.\n");                                  break;
        case 0x0010: rprintf("Card internal ECC was applied, but failed to correct the data.\n");   break;
        case 0x0020: rprintf("Write protect violation.\n");                                         break;
        case 0x0040: rprintf("An invalid selection, sectors for erase.\n");                         break;
        case 0x0080: rprintf("Out of Range, CSD_Overwrite.\n");                                     break;
            default:
            if (value > 0x00FF)
            {
                Resp8bError((U8) (value >> 8));
            }
            else
            {
                rprintf("Unknown error: 0x%x (see SanDisk docs p5-14).\n", value);
            }
            break;
    }
    return -1;
}

/*****************************************************************************/


int BlockDevInit(void)
{
    int i;
    U8 resp;

    SPIInit();              /* init at low speed */

    /* Try to send reset command up to 100 times */
    i = 100;
    do
    {
        Command(CMD_GOIDLESTATE, 0);
        resp = Resp8b();
    }
    while (resp != 1 && i--);

    if (resp != 1)
    {
        if (resp == 0xff)
        {
            rprintf("resp=0xff\n");
            return -1;
        }
        else
        {
            Resp8bError(resp);
            rprintf("resp!=0xff\n");
            return -2;
        }
    }

    /* Wait till card is ready initialising (returns 0 on CMD_1) */
    /* Try up to 32000 times. */
    i = 32000;
    do
    {
        Command(CMD_SENDOPCOND, 0);

        resp = Resp8b();
        if (resp != 0)
        {
            Resp8bError(resp);
        }
    }
    while (resp == 1 && i--);

    if (resp != 0)
    {
        Resp8bError(resp);
        return -3;
    }

    /* increase speed after init */
    SPISetSpeed(SPI_PRESCALE_MIN);

    if (State() < 0)
    {
        rprintf("Card didn't return the ready state, breaking up...\n");
        return -2;
    }

    rprintf("SD Init done...\n");

    return 0;
}

/*****************************************************************************/



/*****************************************************************************/


/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_WRITE
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK OUT
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 * BUSY...
 */

int BlockDevWrite(U32 dwAddress, U8 * pbBuf)
{
    U32 place;
    U16 t = 0;

    place = 512 * dwAddress;
    Command(CMD_WRITE, place);
   16188:	e1a00480 	mov	r0, r0, lsl #9
   1618c:	e92d4010 	stmdb	sp!, {r4, lr}
   16190:	e1a04001 	mov	r4, r1
   16194:	e1a01000 	mov	r1, r0
   16198:	e3a00018 	mov	r0, #24	; 0x18
   1619c:	ebffffe2 	bl	1612c <Command>

    Resp8b();               /* Card response */
   161a0:	ebffffd5 	bl	160fc <Resp8b>

    SPISend(0xfe);          /* Start block */
   161a4:	e3a000fe 	mov	r0, #254	; 0xfe
   161a8:	eb00011e 	bl	16628 <SPISend>
    SPISendN(pbBuf, 512);
   161ac:	e3a01c02 	mov	r1, #512	; 0x200
   161b0:	e1a00004 	mov	r0, r4
   161b4:	eb00012e 	bl	16674 <SPISendN>
    SPISend(0xff);          /* Checksum part 1 */
   161b8:	e3a000ff 	mov	r0, #255	; 0xff
   161bc:	eb000119 	bl	16628 <SPISend>
    SPISend(0xff);          /* Checksum part 2 */
   161c0:	e3a000ff 	mov	r0, #255	; 0xff
   161c4:	eb000117 	bl	16628 <SPISend>

    SPISend(0xff);
   161c8:	e3a000ff 	mov	r0, #255	; 0xff
   161cc:	eb000115 	bl	16628 <SPISend>

    while (SPISend(0xff) != 0xff)
   161d0:	e3a000ff 	mov	r0, #255	; 0xff
   161d4:	eb000113 	bl	16628 <SPISend>
   161d8:	e35000ff 	cmp	r0, #255	; 0xff
   161dc:	1afffffb 	bne	161d0 <BlockDevWrite+0x48>
    {
        t++;
    }

    return 0;
}
   161e0:	e3a00000 	mov	r0, #0	; 0x0
   161e4:	e8bd4010 	ldmia	sp!, {r4, lr}
   161e8:	e12fff1e 	bx	lr

000161ec <BlockDevGetSize>:
   161ec:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   161f0:	e3a01000 	mov	r1, #0	; 0x0
   161f4:	e1a05000 	mov	r5, r0
   161f8:	e24dd010 	sub	sp, sp, #16	; 0x10
   161fc:	e3a00009 	mov	r0, #9	; 0x9
   16200:	ebffffc9 	bl	1612c <Command>
   16204:	ebffffbc 	bl	160fc <Resp8b>
   16208:	e35000fe 	cmp	r0, #254	; 0xfe
   1620c:	1afffffc 	bne	16204 <BlockDevGetSize+0x18>
   16210:	e59f00bc 	ldr	r0, [pc, #188]	; 162d4 <.text+0x62d4>
   16214:	ebffede1 	bl	119a0 <rprintf>
   16218:	e3a04000 	mov	r4, #0	; 0x0
   1621c:	e3a000ff 	mov	r0, #255	; 0xff
   16220:	eb000100 	bl	16628 <SPISend>
   16224:	e1a0300d 	mov	r3, sp
   16228:	e7c40003 	strb	r0, [r4, r3]
   1622c:	e1a01000 	mov	r1, r0
   16230:	e2844001 	add	r4, r4, #1	; 0x1
   16234:	e59f009c 	ldr	r0, [pc, #156]	; 162d8 <.text+0x62d8>
   16238:	ebffedd8 	bl	119a0 <rprintf>
   1623c:	e3540010 	cmp	r4, #16	; 0x10
   16240:	1afffff5 	bne	1621c <BlockDevGetSize+0x30>
   16244:	e59f0090 	ldr	r0, [pc, #144]	; 162dc <.text+0x62dc>
   16248:	ebffedd4 	bl	119a0 <rprintf>
   1624c:	e3a000ff 	mov	r0, #255	; 0xff
   16250:	eb0000f4 	bl	16628 <SPISend>
   16254:	e3a000ff 	mov	r0, #255	; 0xff
   16258:	eb0000f2 	bl	16628 <SPISend>
   1625c:	e5dd1005 	ldrb	r1, [sp, #5]
   16260:	e3a00001 	mov	r0, #1	; 0x1
   16264:	e201100f 	and	r1, r1, #15	; 0xf
   16268:	e1a01110 	mov	r1, r0, lsl r1
   1626c:	e5dd2009 	ldrb	r2, [sp, #9]
   16270:	e5dd300a 	ldrb	r3, [sp, #10]
   16274:	e2022003 	and	r2, r2, #3	; 0x3
   16278:	e1a033a3 	mov	r3, r3, lsr #7
   1627c:	e0833082 	add	r3, r3, r2, lsl #1
   16280:	e2833002 	add	r3, r3, #2	; 0x2
   16284:	e1a00310 	mov	r0, r0, lsl r3
   16288:	e5dd3007 	ldrb	r3, [sp, #7]
   1628c:	e5dd2006 	ldrb	r2, [sp, #6]
   16290:	e5ddc008 	ldrb	ip, [sp, #8]
   16294:	e1a03103 	mov	r3, r3, lsl #2
   16298:	e083332c 	add	r3, r3, ip, lsr #6
   1629c:	e2022003 	and	r2, r2, #3	; 0x3
   162a0:	e0833502 	add	r3, r3, r2, lsl #10
   162a4:	e1a01801 	mov	r1, r1, lsl #16
   162a8:	e1a01821 	mov	r1, r1, lsr #16
   162ac:	e2833001 	add	r3, r3, #1	; 0x1
   162b0:	e0030391 	mul	r3, r1, r3
   162b4:	e1a00800 	mov	r0, r0, lsl #16
   162b8:	e1a00820 	mov	r0, r0, lsr #16
   162bc:	e0030390 	mul	r3, r0, r3
   162c0:	e3a00000 	mov	r0, #0	; 0x0
   162c4:	e5853000 	str	r3, [r5]
   162c8:	e28dd010 	add	sp, sp, #16	; 0x10
   162cc:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   162d0:	e12fff1e 	bx	lr
   162d4:	00018be4 	andeq	r8, r1, r4, ror #23
   162d8:	00018bec 	andeq	r8, r1, ip, ror #23
   162dc:	00018cc4 	andeq	r8, r1, r4, asr #25

000162e0 <Resp8bError>:
   162e0:	e20010ff 	and	r1, r0, #255	; 0xff
   162e4:	e3510008 	cmp	r1, #8	; 0x8
   162e8:	e52de004 	str	lr, [sp, #-4]!
   162ec:	0a000015 	beq	16348 <Resp8bError+0x68>
   162f0:	8a000006 	bhi	16310 <Resp8bError+0x30>
   162f4:	e3510002 	cmp	r1, #2	; 0x2
   162f8:	0a000016 	beq	16358 <Resp8bError+0x78>
   162fc:	e3510004 	cmp	r1, #4	; 0x4
   16300:	0a000012 	beq	16350 <Resp8bError+0x70>
   16304:	e3510001 	cmp	r1, #1	; 0x1
   16308:	1a000016 	bne	16368 <Resp8bError+0x88>
   1630c:	ea000013 	b	16360 <Resp8bError+0x80>
   16310:	e3510020 	cmp	r1, #32	; 0x20
   16314:	0a000006 	beq	16334 <Resp8bError+0x54>
   16318:	e3510040 	cmp	r1, #64	; 0x40
   1631c:	0a000002 	beq	1632c <Resp8bError+0x4c>
   16320:	e3510010 	cmp	r1, #16	; 0x10
   16324:	1a00000f 	bne	16368 <Resp8bError+0x88>
   16328:	ea000004 	b	16340 <Resp8bError+0x60>
   1632c:	e59f0044 	ldr	r0, [pc, #68]	; 16378 <.text+0x6378>
   16330:	ea000000 	b	16338 <Resp8bError+0x58>
   16334:	e59f0040 	ldr	r0, [pc, #64]	; 1637c <.text+0x637c>
   16338:	ebffed98 	bl	119a0 <rprintf>
   1633c:	ea00000b 	b	16370 <Resp8bError+0x90>
   16340:	e59f0038 	ldr	r0, [pc, #56]	; 16380 <.text+0x6380>
   16344:	eafffffb 	b	16338 <Resp8bError+0x58>
   16348:	e59f0034 	ldr	r0, [pc, #52]	; 16384 <.text+0x6384>
   1634c:	eafffff9 	b	16338 <Resp8bError+0x58>
   16350:	e59f0030 	ldr	r0, [pc, #48]	; 16388 <.text+0x6388>
   16354:	eafffff7 	b	16338 <Resp8bError+0x58>
   16358:	e59f002c 	ldr	r0, [pc, #44]	; 1638c <.text+0x638c>
   1635c:	eafffff5 	b	16338 <Resp8bError+0x58>
   16360:	e59f0028 	ldr	r0, [pc, #40]	; 16390 <.text+0x6390>
   16364:	eafffff3 	b	16338 <Resp8bError+0x58>
   16368:	e59f0024 	ldr	r0, [pc, #36]	; 16394 <.text+0x6394>
   1636c:	ebffed8b 	bl	119a0 <rprintf>
   16370:	e49de004 	ldr	lr, [sp], #4
   16374:	e12fff1e 	bx	lr
   16378:	00018bf4 	streqd	r8, [r1], -r4
   1637c:	00018c10 	andeq	r8, r1, r0, lsl ip
   16380:	00018c28 	andeq	r8, r1, r8, lsr #24
   16384:	00018c48 	andeq	r8, r1, r8, asr #24
   16388:	00018c58 	andeq	r8, r1, r8, asr ip
   1638c:	00018c6c 	andeq	r8, r1, ip, ror #24
   16390:	00018c94 	muleq	r1, r4, ip
   16394:	00018c98 	muleq	r1, r8, ip

00016398 <BlockDevRead>:

/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_CMD_
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK IN
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 */

int BlockDevRead(U32 dwAddress, U8 * pbBuf)
{
    U8 cardresp;
    U8 firstblock;
    U16 fb_timeout = 0xffff;
    U32 place;

    place = 512 * dwAddress;
    Command(CMD_READSINGLEBLOCK, place);
   16398:	e1a00480 	mov	r0, r0, lsl #9
   1639c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   163a0:	e1a06001 	mov	r6, r1
   163a4:	e1a01000 	mov	r1, r0
   163a8:	e3a00011 	mov	r0, #17	; 0x11
   163ac:	ebffff5e 	bl	1612c <Command>

    cardresp = Resp8b();        /* Card response */
   163b0:	ebffff51 	bl	160fc <Resp8b>
   163b4:	e59f506c 	ldr	r5, [pc, #108]	; 16428 <.text+0x6428>
   163b8:	e1a04000 	mov	r4, r0

    /* Wait for startblock */
    do
    {
        firstblock = Resp8b();
   163bc:	ebffff4e 	bl	160fc <Resp8b>
    }
    while (firstblock == 0xff && fb_timeout--);
   163c0:	e2453001 	sub	r3, r5, #1	; 0x1
   163c4:	e35000ff 	cmp	r0, #255	; 0xff
   163c8:	e1a03803 	mov	r3, r3, lsl #16
   163cc:	1a000003 	bne	163e0 <BlockDevRead+0x48>
   163d0:	e3730801 	cmn	r3, #65536	; 0x10000
   163d4:	e1a05823 	mov	r5, r3, lsr #16
   163d8:	0a000005 	beq	163f4 <BlockDevRead+0x5c>
   163dc:	eafffff6 	b	163bc <BlockDevRead+0x24>

    if (cardresp != 0x00 || firstblock != 0xfe)
   163e0:	e35000fe 	cmp	r0, #254	; 0xfe
   163e4:	03540000 	cmpeq	r4, #0	; 0x0
   163e8:	03a04000 	moveq	r4, #0	; 0x0
   163ec:	13a04001 	movne	r4, #1	; 0x1
   163f0:	0a000002 	beq	16400 <BlockDevRead+0x68>
    {
        Resp8bError(firstblock);
   163f4:	ebffffb9 	bl	162e0 <Resp8bError>
   163f8:	e3e00000 	mvn	r0, #0	; 0x0
   163fc:	ea000007 	b	16420 <BlockDevRead+0x88>
        return -1;
    }

    SPIRecvN(pbBuf, 512);
   16400:	e3a01c02 	mov	r1, #512	; 0x200
   16404:	e1a00006 	mov	r0, r6
   16408:	eb0000b0 	bl	166d0 <SPIRecvN>

    /* Checksum (2 byte) - ignore for now */
    SPISend(0xff);
   1640c:	e3a000ff 	mov	r0, #255	; 0xff
   16410:	eb000084 	bl	16628 <SPISend>
    SPISend(0xff);
   16414:	e3a000ff 	mov	r0, #255	; 0xff
   16418:	eb000082 	bl	16628 <SPISend>
   1641c:	e1a00004 	mov	r0, r4

    return 0;
}
   16420:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   16424:	e12fff1e 	bx	lr
   16428:	0000ffff 	streqd	pc, [r0], -pc

0001642c <BlockDevInit>:
   1642c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   16430:	eb0000bf 	bl	16734 <SPIInit>
   16434:	e3a04064 	mov	r4, #100	; 0x64
   16438:	e3a00000 	mov	r0, #0	; 0x0
   1643c:	e1a01000 	mov	r1, r0
   16440:	ebffff39 	bl	1612c <Command>
   16444:	ebffff2c 	bl	160fc <Resp8b>
   16448:	e3500001 	cmp	r0, #1	; 0x1
   1644c:	e2444001 	sub	r4, r4, #1	; 0x1
   16450:	0a00000a 	beq	16480 <BlockDevInit+0x54>
   16454:	e3740001 	cmn	r4, #1	; 0x1
   16458:	1afffff6 	bne	16438 <BlockDevInit+0xc>
   1645c:	e35000ff 	cmp	r0, #255	; 0xff
   16460:	1a000003 	bne	16474 <BlockDevInit+0x48>
   16464:	e59f016c 	ldr	r0, [pc, #364]	; 165d8 <.text+0x65d8>
   16468:	ebffed4c 	bl	119a0 <rprintf>
   1646c:	e1a00004 	mov	r0, r4
   16470:	ea000056 	b	165d0 <BlockDevInit+0x1a4>
   16474:	ebffff99 	bl	162e0 <Resp8bError>
   16478:	e59f015c 	ldr	r0, [pc, #348]	; 165dc <.text+0x65dc>
   1647c:	ea000051 	b	165c8 <BlockDevInit+0x19c>
   16480:	e3a04c7d 	mov	r4, #32000	; 0x7d00
   16484:	e3a01000 	mov	r1, #0	; 0x0
   16488:	e3a00001 	mov	r0, #1	; 0x1
   1648c:	ebffff26 	bl	1612c <Command>
   16490:	ebffff19 	bl	160fc <Resp8b>
   16494:	e2505000 	subs	r5, r0, #0	; 0x0
   16498:	e2444001 	sub	r4, r4, #1	; 0x1
   1649c:	0a000008 	beq	164c4 <BlockDevInit+0x98>
   164a0:	ebffff8e 	bl	162e0 <Resp8bError>
   164a4:	e3550001 	cmp	r5, #1	; 0x1
   164a8:	1a000001 	bne	164b4 <BlockDevInit+0x88>
   164ac:	e3740001 	cmn	r4, #1	; 0x1
   164b0:	1afffff3 	bne	16484 <BlockDevInit+0x58>
   164b4:	e1a00005 	mov	r0, r5
   164b8:	ebffff88 	bl	162e0 <Resp8bError>
   164bc:	e3e00002 	mvn	r0, #2	; 0x2
   164c0:	ea000042 	b	165d0 <BlockDevInit+0x1a4>
   164c4:	e3a00008 	mov	r0, #8	; 0x8
   164c8:	eb00004f 	bl	1660c <SPISetSpeed>
   164cc:	e1a01005 	mov	r1, r5
   164d0:	e3a0000d 	mov	r0, #13	; 0xd
   164d4:	ebffff14 	bl	1612c <Command>
   164d8:	ebffff07 	bl	160fc <Resp8b>
   164dc:	e1a04c00 	mov	r4, r0, lsl #24
   164e0:	e3a000ff 	mov	r0, #255	; 0xff
   164e4:	eb00004f 	bl	16628 <SPISend>
   164e8:	e1a04824 	mov	r4, r4, lsr #16
   164ec:	e1844000 	orr	r4, r4, r0
   164f0:	e1a04804 	mov	r4, r4, lsl #16
   164f4:	e1a01824 	mov	r1, r4, lsr #16
   164f8:	e3510008 	cmp	r1, #8	; 0x8
   164fc:	0a00001a 	beq	1656c <BlockDevInit+0x140>
   16500:	8a000007 	bhi	16524 <BlockDevInit+0xf8>
   16504:	e3510001 	cmp	r1, #1	; 0x1
   16508:	0a000010 	beq	16550 <BlockDevInit+0x124>
   1650c:	3a000028 	bcc	165b4 <BlockDevInit+0x188>
   16510:	e3510002 	cmp	r1, #2	; 0x2
   16514:	0a00000f 	beq	16558 <BlockDevInit+0x12c>
   16518:	e3510004 	cmp	r1, #4	; 0x4
   1651c:	1a00001c 	bne	16594 <BlockDevInit+0x168>
   16520:	ea00000f 	b	16564 <BlockDevInit+0x138>
   16524:	e3510020 	cmp	r1, #32	; 0x20
   16528:	0a000013 	beq	1657c <BlockDevInit+0x150>
   1652c:	8a000002 	bhi	1653c <BlockDevInit+0x110>
   16530:	e3510010 	cmp	r1, #16	; 0x10
   16534:	1a000016 	bne	16594 <BlockDevInit+0x168>
   16538:	ea00000d 	b	16574 <BlockDevInit+0x148>
   1653c:	e3510040 	cmp	r1, #64	; 0x40
   16540:	0a00000f 	beq	16584 <BlockDevInit+0x158>
   16544:	e3510080 	cmp	r1, #128	; 0x80
   16548:	1a000011 	bne	16594 <BlockDevInit+0x168>
   1654c:	ea00000e 	b	1658c <BlockDevInit+0x160>
   16550:	e59f0088 	ldr	r0, [pc, #136]	; 165e0 <.text+0x65e0>
   16554:	ea000000 	b	1655c <BlockDevInit+0x130>
   16558:	e59f0084 	ldr	r0, [pc, #132]	; 165e4 <.text+0x65e4>
   1655c:	ebffed0f 	bl	119a0 <rprintf>
   16560:	ea000017 	b	165c4 <BlockDevInit+0x198>
   16564:	e59f007c 	ldr	r0, [pc, #124]	; 165e8 <.text+0x65e8>
   16568:	eafffffb 	b	1655c <BlockDevInit+0x130>
   1656c:	e59f0078 	ldr	r0, [pc, #120]	; 165ec <.text+0x65ec>
   16570:	eafffff9 	b	1655c <BlockDevInit+0x130>
   16574:	e59f0074 	ldr	r0, [pc, #116]	; 165f0 <.text+0x65f0>
   16578:	eafffff7 	b	1655c <BlockDevInit+0x130>
   1657c:	e59f0070 	ldr	r0, [pc, #112]	; 165f4 <.text+0x65f4>
   16580:	eafffff5 	b	1655c <BlockDevInit+0x130>
   16584:	e59f006c 	ldr	r0, [pc, #108]	; 165f8 <.text+0x65f8>
   16588:	eafffff3 	b	1655c <BlockDevInit+0x130>
   1658c:	e59f0068 	ldr	r0, [pc, #104]	; 165fc <.text+0x65fc>
   16590:	eafffff1 	b	1655c <BlockDevInit+0x130>
   16594:	e35100ff 	cmp	r1, #255	; 0xff
   16598:	9a000002 	bls	165a8 <BlockDevInit+0x17c>
   1659c:	e1a00421 	mov	r0, r1, lsr #8
   165a0:	ebffff4e 	bl	162e0 <Resp8bError>
   165a4:	ea000006 	b	165c4 <BlockDevInit+0x198>
   165a8:	e59f0050 	ldr	r0, [pc, #80]	; 16600 <.text+0x6600>
   165ac:	ebffecfb 	bl	119a0 <rprintf>
   165b0:	ea000003 	b	165c4 <BlockDevInit+0x198>
   165b4:	e59f0048 	ldr	r0, [pc, #72]	; 16604 <.text+0x6604>
   165b8:	ebffecf8 	bl	119a0 <rprintf>
   165bc:	e1a00005 	mov	r0, r5
   165c0:	ea000002 	b	165d0 <BlockDevInit+0x1a4>
   165c4:	e59f003c 	ldr	r0, [pc, #60]	; 16608 <.text+0x6608>
   165c8:	ebffecf4 	bl	119a0 <rprintf>
   165cc:	e3e00001 	mvn	r0, #1	; 0x1
   165d0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   165d4:	e12fff1e 	bx	lr
   165d8:	00018cc8 	andeq	r8, r1, r8, asr #25
   165dc:	00018cd4 	ldreqd	r8, [r1], -r4
   165e0:	00018ce0 	andeq	r8, r1, r0, ror #25
   165e4:	00018cf4 	streqd	r8, [r1], -r4
   165e8:	00018d1c 	andeq	r8, r1, ip, lsl sp
   165ec:	00018d48 	andeq	r8, r1, r8, asr #26
   165f0:	00018d6c 	andeq	r8, r1, ip, ror #26
   165f4:	00018dac 	andeq	r8, r1, ip, lsr #27
   165f8:	00018dc8 	andeq	r8, r1, r8, asr #27
   165fc:	00018df4 	streqd	r8, [r1], -r4
   16600:	00018e14 	andeq	r8, r1, r4, lsl lr
   16604:	00018e44 	andeq	r8, r1, r4, asr #28
   16608:	00018e58 	andeq	r8, r1, r8, asr lr

0001660c <SPISetSpeed>:
/*****************************************************************************/

void SPISetSpeed(U8 speed)
{
    speed &= 0xFE;
   1660c:	e20000fe 	and	r0, r0, #254	; 0xfe
    if (speed < SPI_PRESCALE_MIN)
   16610:	e3500007 	cmp	r0, #7	; 0x7
    {
        speed = SPI_PRESCALE_MIN;
    }
    SPI_PRESCALE_REG = speed;
   16614:	e59f3008 	ldr	r3, [pc, #8]	; 16624 <.text+0x6624>
   16618:	93a00008 	movls	r0, #8	; 0x8
   1661c:	e5c3000c 	strb	r0, [r3, #12]
}
   16620:	e12fff1e 	bx	lr
   16624:	e0020000 	and	r0, r2, r0

00016628 <SPISend>:


void SPIInit(void)
{
    U8 i;
    //U32 j;

    rprintf("spiInit for SPI(0)\n");

    // setup GPIO
    PINSEL2 = 0;

	SPI_IODIR |= (1 << SPI_SCK_PIN) | (1 << SPI_MOSI_PIN);
    IODIR0 |= (1 << SPI_SS_PIN);			//Changed to Port0 for MP3 Player
    SPI_IODIR &= ~(1 << SPI_MISO_PIN);

    // reset Pin-Functions
    SPI_PINSEL &= ~((3 << SPI_SCK_FUNCBIT) | (3 << SPI_MISO_FUNCBIT) | (3 << SPI_MOSI_FUNCBIT));
    SPI_PINSEL |= ((1 << SPI_SCK_FUNCBIT) | (1 << SPI_MISO_FUNCBIT) | (1 << SPI_MOSI_FUNCBIT));

    /*        PINSEL0 &= ~(3 << (SPI_SS_FUNCBIT));*/
    /*        PINSEL0 |= (0 << (SPI_SS_FUNCBIT));*/

    // set Chip-Select high - unselect card
    UNSELECT_CARD();

    // enable SPI-Master
    S0SPCR = (1 << MSTR) | (0 << CPOL);   // TODO: check CPOL

    // low speed during init
    SPISetSpeed(254);

    /* Send 20 spi commands with card not selected */
    for (i = 0; i < 21; i++)
    {
        my_SPISend(0xff);
    }
}

/*****************************************************************************/

/*****************************************************************************/

U8 SPISend(U8 outgoing)
{
    U8 incoming;

    SELECT_CARD();
   16628:	e59f203c 	ldr	r2, [pc, #60]	; 1666c <.text+0x666c>
   1662c:	e592300c 	ldr	r3, [r2, #12]
   16630:	e3833080 	orr	r3, r3, #128	; 0x80
   16634:	e582300c 	str	r3, [r2, #12]
    S0SPDR = outgoing;
   16638:	e59f3030 	ldr	r3, [pc, #48]	; 16670 <.text+0x6670>
   1663c:	e20000ff 	and	r0, r0, #255	; 0xff
   16640:	e5c30008 	strb	r0, [r3, #8]
    while (!(S0SPSR & (1 << SPIF)));
   16644:	e59f2024 	ldr	r2, [pc, #36]	; 16670 <.text+0x6670>
   16648:	e5d23004 	ldrb	r3, [r2, #4]
   1664c:	e3130080 	tst	r3, #128	; 0x80
   16650:	0afffffb 	beq	16644 <SPISend+0x1c>
    incoming = S0SPDR;
    UNSELECT_CARD();
   16654:	e59f3010 	ldr	r3, [pc, #16]	; 1666c <.text+0x666c>
   16658:	e5d20008 	ldrb	r0, [r2, #8]
   1665c:	e5932004 	ldr	r2, [r3, #4]
   16660:	e3822080 	orr	r2, r2, #128	; 0x80
   16664:	e5832004 	str	r2, [r3, #4]

    return incoming;
}
   16668:	e12fff1e 	bx	lr
   1666c:	e0028000 	and	r8, r2, r0
   16670:	e0020000 	and	r0, r2, r0

00016674 <SPISendN>:

void SPISendN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
   16674:	e59f204c 	ldr	r2, [pc, #76]	; 166c8 <.text+0x66c8>
   16678:	e592300c 	ldr	r3, [r2, #12]
   1667c:	e3a0c000 	mov	ip, #0	; 0x0
   16680:	e3833080 	orr	r3, r3, #128	; 0x80
   16684:	e582300c 	str	r3, [r2, #12]
   16688:	ea000007 	b	166ac <SPISendN+0x38>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = pbBuf[i];
   1668c:	e7d0200c 	ldrb	r2, [r0, ip]
   16690:	e59f3034 	ldr	r3, [pc, #52]	; 166cc <.text+0x66cc>
   16694:	e5c32008 	strb	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
   16698:	e59f302c 	ldr	r3, [pc, #44]	; 166cc <.text+0x66cc>
   1669c:	e5d33004 	ldrb	r3, [r3, #4]
   166a0:	e3130080 	tst	r3, #128	; 0x80
   166a4:	0afffffb 	beq	16698 <SPISendN+0x24>
   166a8:	e28cc001 	add	ip, ip, #1	; 0x1
   166ac:	e15c0001 	cmp	ip, r1
   166b0:	bafffff5 	blt	1668c <SPISendN+0x18>
    }
    UNSELECT_CARD();
   166b4:	e59f200c 	ldr	r2, [pc, #12]	; 166c8 <.text+0x66c8>
   166b8:	e5923004 	ldr	r3, [r2, #4]
   166bc:	e3833080 	orr	r3, r3, #128	; 0x80
   166c0:	e5823004 	str	r3, [r2, #4]
}
   166c4:	e12fff1e 	bx	lr
   166c8:	e0028000 	and	r8, r2, r0
   166cc:	e0020000 	and	r0, r2, r0

000166d0 <SPIRecvN>:

void SPIRecvN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
   166d0:	e59f2054 	ldr	r2, [pc, #84]	; 1672c <.text+0x672c>
   166d4:	e592300c 	ldr	r3, [r2, #12]
   166d8:	e3a0c000 	mov	ip, #0	; 0x0
   166dc:	e3833080 	orr	r3, r3, #128	; 0x80
   166e0:	e582300c 	str	r3, [r2, #12]
   166e4:	ea000009 	b	16710 <SPIRecvN+0x40>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = 0xFF;
   166e8:	e59f3040 	ldr	r3, [pc, #64]	; 16730 <.text+0x6730>
   166ec:	e3e02000 	mvn	r2, #0	; 0x0
   166f0:	e5c32008 	strb	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
   166f4:	e59f2034 	ldr	r2, [pc, #52]	; 16730 <.text+0x6730>
   166f8:	e5d23004 	ldrb	r3, [r2, #4]
   166fc:	e3130080 	tst	r3, #128	; 0x80
   16700:	0afffffb 	beq	166f4 <SPIRecvN+0x24>
        pbBuf[i] = S0SPDR;
   16704:	e5d23008 	ldrb	r3, [r2, #8]
   16708:	e7c0300c 	strb	r3, [r0, ip]
   1670c:	e28cc001 	add	ip, ip, #1	; 0x1
   16710:	e15c0001 	cmp	ip, r1
   16714:	bafffff3 	blt	166e8 <SPIRecvN+0x18>
    }
    UNSELECT_CARD();
   16718:	e59f200c 	ldr	r2, [pc, #12]	; 1672c <.text+0x672c>
   1671c:	e5923004 	ldr	r3, [r2, #4]
   16720:	e3833080 	orr	r3, r3, #128	; 0x80
   16724:	e5823004 	str	r3, [r2, #4]
}
   16728:	e12fff1e 	bx	lr
   1672c:	e0028000 	and	r8, r2, r0
   16730:	e0020000 	and	r0, r2, r0

00016734 <SPIInit>:
   16734:	e59f00a8 	ldr	r0, [pc, #168]	; 167e4 <.text+0x67e4>
   16738:	e52de004 	str	lr, [sp, #-4]!
   1673c:	ebffec97 	bl	119a0 <rprintf>
   16740:	e59f10a0 	ldr	r1, [pc, #160]	; 167e8 <.text+0x67e8>
   16744:	e3a00000 	mov	r0, #0	; 0x0
   16748:	e5810014 	str	r0, [r1, #20]
   1674c:	e59f2098 	ldr	r2, [pc, #152]	; 167ec <.text+0x67ec>
   16750:	e5923008 	ldr	r3, [r2, #8]
   16754:	e3833050 	orr	r3, r3, #80	; 0x50
   16758:	e5823008 	str	r3, [r2, #8]
   1675c:	e5923008 	ldr	r3, [r2, #8]
   16760:	e3833080 	orr	r3, r3, #128	; 0x80
   16764:	e5823008 	str	r3, [r2, #8]
   16768:	e5923008 	ldr	r3, [r2, #8]
   1676c:	e3c33020 	bic	r3, r3, #32	; 0x20
   16770:	e5823008 	str	r3, [r2, #8]
   16774:	e5913000 	ldr	r3, [r1]
   16778:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
   1677c:	e5813000 	str	r3, [r1]
   16780:	e5913000 	ldr	r3, [r1]
   16784:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   16788:	e5813000 	str	r3, [r1]
   1678c:	e5923004 	ldr	r3, [r2, #4]
   16790:	e3833080 	orr	r3, r3, #128	; 0x80
   16794:	e5823004 	str	r3, [r2, #4]
   16798:	e2411903 	sub	r1, r1, #49152	; 0xc000
   1679c:	e3a03020 	mov	r3, #32	; 0x20
   167a0:	e5c13000 	strb	r3, [r1]
   167a4:	e3e03001 	mvn	r3, #1	; 0x1
   167a8:	e5c1300c 	strb	r3, [r1, #12]
   167ac:	e59f303c 	ldr	r3, [pc, #60]	; 167f0 <.text+0x67f0>
   167b0:	e3e02000 	mvn	r2, #0	; 0x0
   167b4:	e5c32008 	strb	r2, [r3, #8]
   167b8:	e59f2030 	ldr	r2, [pc, #48]	; 167f0 <.text+0x67f0>
   167bc:	e5d23004 	ldrb	r3, [r2, #4]
   167c0:	e3130080 	tst	r3, #128	; 0x80
   167c4:	0afffffb 	beq	167b8 <SPIInit+0x84>
   167c8:	e2803001 	add	r3, r0, #1	; 0x1
   167cc:	e20300ff 	and	r0, r3, #255	; 0xff
   167d0:	e3500015 	cmp	r0, #21	; 0x15
   167d4:	e5d23008 	ldrb	r3, [r2, #8]
   167d8:	1afffff3 	bne	167ac <SPIInit+0x78>
   167dc:	e49de004 	ldr	lr, [sp], #4
   167e0:	e12fff1e 	bx	lr
   167e4:	00018e8c 	andeq	r8, r1, ip, lsl #29
   167e8:	e002c000 	and	ip, r2, r0
   167ec:	e0028000 	and	r8, r2, r0
   167f0:	e0020000 	and	r0, r2, r0

000167f4 <HandleUsbReset>:
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
   167f4:	e12fff1e 	bx	lr

000167f8 <USBInit>:


/**
	Initialises the USB hardware and sets up the USB stack by
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
   167f8:	e92d4010 	stmdb	sp!, {r4, lr}
	// init hardware
	USBHwInit();
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
   167fc:	e59f4054 	ldr	r4, [pc, #84]	; 16858 <.text+0x6858>
   16800:	eb00013d 	bl	16cfc <USBHwInit>
   16804:	e59f0050 	ldr	r0, [pc, #80]	; 1685c <.text+0x685c>
   16808:	eb000074 	bl	169e0 <USBHwRegisterDevIntHandler>
   1680c:	e1a01004 	mov	r1, r4
   16810:	e3a00000 	mov	r0, #0	; 0x0
   16814:	eb00005e 	bl	16994 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
   16818:	e1a01004 	mov	r1, r4
   1681c:	e3a00080 	mov	r0, #128	; 0x80
   16820:	eb00005b 	bl	16994 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
   16824:	e3a00000 	mov	r0, #0	; 0x0
   16828:	e3a01040 	mov	r1, #64	; 0x40
   1682c:	eb000041 	bl	16938 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
   16830:	e3a00080 	mov	r0, #128	; 0x80
   16834:	e3a01040 	mov	r1, #64	; 0x40
   16838:	eb00003e 	bl	16938 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
   1683c:	e3a00000 	mov	r0, #0	; 0x0
   16840:	e59f1018 	ldr	r1, [pc, #24]	; 16860 <.text+0x6860>
   16844:	e59f2018 	ldr	r2, [pc, #24]	; 16864 <.text+0x6864>
   16848:	eb00016c 	bl	16e00 <USBRegisterRequestHandler>

	return TRUE;
}
   1684c:	e3a00001 	mov	r0, #1	; 0x1
   16850:	e8bd4010 	ldmia	sp!, {r4, lr}
   16854:	e12fff1e 	bx	lr
   16858:	00016e84 	andeq	r6, r1, r4, lsl #29
   1685c:	000167f4 	streqd	r6, [r1], -r4
   16860:	00017074 	andeq	r7, r1, r4, ror r0
   16864:	40001174 	andmi	r1, r0, r4, ror r1

00016868 <USBHwCmd>:
		
	@param [in]	bCmd		Command to send
 */
static void USBHwCmd(U8 bCmd)
{
   16868:	e1a00800 	mov	r0, r0, lsl #16
	// clear CDFULL/CCEMTY
	USBDevIntClr = CDFULL | CCEMTY;
   1686c:	e59f202c 	ldr	r2, [pc, #44]	; 168a0 <.text+0x68a0>
	// write command code
	USBCmdCode = 0x00000500 | (bCmd << 16);
   16870:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
   16874:	e3800c05 	orr	r0, r0, #1280	; 0x500
   16878:	e3a03030 	mov	r3, #48	; 0x30
   1687c:	e5823008 	str	r3, [r2, #8]
   16880:	e5820010 	str	r0, [r2, #16]
   16884:	e59f2014 	ldr	r2, [pc, #20]	; 168a0 <.text+0x68a0>
   16888:	e5923000 	ldr	r3, [r2]
   1688c:	e2033010 	and	r3, r3, #16	; 0x10
   16890:	e3530010 	cmp	r3, #16	; 0x10
   16894:	1afffffa 	bne	16884 <USBHwCmd+0x1c>
   16898:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
   1689c:	e12fff1e 	bx	lr
   168a0:	e0090000 	and	r0, r9, r0

000168a4 <USBHwCmdWrite>:


/**
	Local function to send a command + data to the USB protocol engine
		
	@param [in]	bCmd		Command to send
	@param [in]	bData		Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
   168a4:	e92d4010 	stmdb	sp!, {r4, lr}
   168a8:	e1a04801 	mov	r4, r1, lsl #16
   168ac:	e20000ff 	and	r0, r0, #255	; 0xff
   168b0:	e1a04824 	mov	r4, r4, lsr #16
	// write command code
	USBHwCmd(bCmd);
   168b4:	ebffffeb 	bl	16868 <USBHwCmd>

	// write command data
	USBCmdCode = 0x00000100 | (bData << 16);
   168b8:	e1a04804 	mov	r4, r4, lsl #16
   168bc:	e59f3024 	ldr	r3, [pc, #36]	; 168e8 <.text+0x68e8>
   168c0:	e3844c01 	orr	r4, r4, #256	; 0x100
   168c4:	e5834010 	str	r4, [r3, #16]
   168c8:	e59f2018 	ldr	r2, [pc, #24]	; 168e8 <.text+0x68e8>
   168cc:	e5923000 	ldr	r3, [r2]
   168d0:	e2033010 	and	r3, r3, #16	; 0x10
   168d4:	e3530010 	cmp	r3, #16	; 0x10
   168d8:	1afffffa 	bne	168c8 <USBHwCmdWrite+0x24>
   168dc:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
   168e0:	e8bd4010 	ldmia	sp!, {r4, lr}
   168e4:	e12fff1e 	bx	lr
   168e8:	e0090000 	and	r0, r9, r0

000168ec <USBHwCmdRead>:


/**
	Local function to send a command to the USB protocol engine and read data
		
	@param [in]	bCmd		Command to send

	@return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
   168ec:	e92d4010 	stmdb	sp!, {r4, lr}
   168f0:	e20040ff 	and	r4, r0, #255	; 0xff
	// write command code
	USBHwCmd(bCmd);
   168f4:	e1a00004 	mov	r0, r4
   168f8:	ebffffda 	bl	16868 <USBHwCmd>
	
	// get data
	USBCmdCode = 0x00000200 | (bCmd << 16);
   168fc:	e1a04804 	mov	r4, r4, lsl #16
   16900:	e59f302c 	ldr	r3, [pc, #44]	; 16934 <.text+0x6934>
   16904:	e3844c02 	orr	r4, r4, #512	; 0x200
   16908:	e5834010 	str	r4, [r3, #16]
   1690c:	e59f2020 	ldr	r2, [pc, #32]	; 16934 <.text+0x6934>
   16910:	e5923000 	ldr	r3, [r2]
   16914:	e2033020 	and	r3, r3, #32	; 0x20
   16918:	e3530020 	cmp	r3, #32	; 0x20
   1691c:	1afffffa 	bne	1690c <USBHwCmdRead+0x20>
   16920:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CDFULL);
	return USBCmdData;
   16924:	e5920014 	ldr	r0, [r2, #20]
   16928:	e20000ff 	and	r0, r0, #255	; 0xff
}
   1692c:	e8bd4010 	ldmia	sp!, {r4, lr}
   16930:	e12fff1e 	bx	lr
   16934:	e0090000 	and	r0, r9, r0

00016938 <USBHwEPConfig>:


/**
	'Realizes' an endpoint, meaning that buffer space is reserved for
	it. An endpoint needs to be realised before it can be used.
		
	From experiments, it appears that a USB reset causes USBReEP to
	re-initialise to 3 (= just the control endpoints).
	However, a USB bus reset does not disturb the USBMaxPSize settings.
		
	@param [in]	idx			Endpoint index
	@param [in] wMaxPSize	Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
	USBReEP |= (1 << idx);
   16938:	e59fc050 	ldr	ip, [pc, #80]	; 16990 <.text+0x6990>
	USBEpInd = idx;
	USBMaxPSize = wMaxPSize;
	Wait4DevInt(EP_RLZED);
}


/**
	Enables or disables an endpoint
		
	@param [in]	idx		Endpoint index
	@param [in]	fEnable	TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
}


/**
	Configures an endpoint and enables it
		
	@param [in]	bEP				Endpoint number
	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
	int idx;
	
	idx = EP2IDX(bEP);
   1693c:	e2003080 	and	r3, r0, #128	; 0x80
   16940:	e59c2044 	ldr	r2, [ip, #68]
   16944:	e1a033c3 	mov	r3, r3, asr #7
   16948:	e200000f 	and	r0, r0, #15	; 0xf
   1694c:	e1830080 	orr	r0, r3, r0, lsl #1
   16950:	e3a03001 	mov	r3, #1	; 0x1
   16954:	e1822013 	orr	r2, r2, r3, lsl r0
   16958:	e1a01801 	mov	r1, r1, lsl #16
   1695c:	e1a01821 	mov	r1, r1, lsr #16
   16960:	e58c2044 	str	r2, [ip, #68]
   16964:	e58c0048 	str	r0, [ip, #72]
   16968:	e58c104c 	str	r1, [ip, #76]
   1696c:	e59f201c 	ldr	r2, [pc, #28]	; 16990 <.text+0x6990>
   16970:	e5923000 	ldr	r3, [r2]
   16974:	e2033c01 	and	r3, r3, #256	; 0x100
   16978:	e3530c01 	cmp	r3, #256	; 0x100
   1697c:	1afffffa 	bne	1696c <USBHwEPConfig+0x34>
   16980:	e3800040 	orr	r0, r0, #64	; 0x40
   16984:	e3a01000 	mov	r1, #0	; 0x0
   16988:	e5823008 	str	r3, [r2, #8]
   1698c:	eaffffc4 	b	168a4 <USBHwCmdWrite>
   16990:	e0090000 	and	r0, r9, r0

00016994 <USBHwRegisterEPIntHandler>:
	
	// realise EP
	USBHwEPRealize(idx, wMaxPacketSize);

	// enable EP
	USBHwEPEnable(idx, TRUE);
}


/**
	Registers an endpoint event callback
		
	@param [in]	bEP				Endpoint number
	@param [in]	pfnHandler		Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
   16994:	e52de004 	str	lr, [sp, #-4]!
	int idx;
	
	idx = EP2IDX(bEP);

	ASSERT(idx<32);

	/* add handler to list of EP handlers */
	_apfnEPIntHandlers[idx / 2] = pfnHandler;
	
	/* enable EP interrupt */
	USBEpIntEn |= (1 << idx);
   16998:	e59fe038 	ldr	lr, [pc, #56]	; 169d8 <.text+0x69d8>
   1699c:	e2003080 	and	r3, r0, #128	; 0x80
   169a0:	e59ec034 	ldr	ip, [lr, #52]
   169a4:	e200000f 	and	r0, r0, #15	; 0xf
   169a8:	e1a033c3 	mov	r3, r3, asr #7
   169ac:	e1833080 	orr	r3, r3, r0, lsl #1
   169b0:	e3a02001 	mov	r2, #1	; 0x1
   169b4:	e18cc312 	orr	ip, ip, r2, lsl r3
   169b8:	e58ec034 	str	ip, [lr, #52]
	USBDevIntEn |= EP_SLOW;
   169bc:	e59e3004 	ldr	r3, [lr, #4]
   169c0:	e59f2014 	ldr	r2, [pc, #20]	; 169dc <.text+0x69dc>
   169c4:	e3833004 	orr	r3, r3, #4	; 0x4
   169c8:	e7821100 	str	r1, [r2, r0, lsl #2]
   169cc:	e58e3004 	str	r3, [lr, #4]
	
	DBG("Registered handler for EP 0x%x\n", bEP);
}
   169d0:	e49de004 	ldr	lr, [sp], #4
   169d4:	e12fff1e 	bx	lr
   169d8:	e0090000 	and	r0, r9, r0
   169dc:	40001184 	andmi	r1, r0, r4, lsl #3

000169e0 <USBHwRegisterDevIntHandler>:


/**
	Registers an device status callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
	_pfnDevIntHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= DEV_STAT;
   169e0:	e59f3014 	ldr	r3, [pc, #20]	; 169fc <.text+0x69fc>
   169e4:	e5932004 	ldr	r2, [r3, #4]
   169e8:	e59f1010 	ldr	r1, [pc, #16]	; 16a00 <.text+0x6a00>
   169ec:	e3822008 	orr	r2, r2, #8	; 0x8
   169f0:	e5810000 	str	r0, [r1]
   169f4:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for device status\n");
}
   169f8:	e12fff1e 	bx	lr
   169fc:	e0090000 	and	r0, r9, r0
   16a00:	40001180 	andmi	r1, r0, r0, lsl #3

00016a04 <USBHwRegisterFrameHandler>:


/**
	Registers the frame callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
	_pfnFrameHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= FRAME;
   16a04:	e59f3014 	ldr	r3, [pc, #20]	; 16a20 <.text+0x6a20>
   16a08:	e5932004 	ldr	r2, [r3, #4]
   16a0c:	e59f1010 	ldr	r1, [pc, #16]	; 16a24 <.text+0x6a24>
   16a10:	e3822001 	orr	r2, r2, #1	; 0x1
   16a14:	e5810000 	str	r0, [r1]
   16a18:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for frame\n");
}
   16a1c:	e12fff1e 	bx	lr
   16a20:	e0090000 	and	r0, r9, r0
   16a24:	4000117c 	andmi	r1, r0, ip, ror r1

00016a28 <USBHwSetAddress>:


/**
	Sets the USB address.
		
	@param [in]	bAddr		Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
   16a28:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
   16a2c:	e3811080 	orr	r1, r1, #128	; 0x80
   16a30:	e3a000d0 	mov	r0, #208	; 0xd0
   16a34:	eaffff9a 	b	168a4 <USBHwCmdWrite>

00016a38 <USBHwConnect>:
}


/**
	Connects or disconnects from the USB bus
		
	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
   16a38:	e2501000 	subs	r1, r0, #0	; 0x0
   16a3c:	13a01001 	movne	r1, #1	; 0x1
   16a40:	e3a000fe 	mov	r0, #254	; 0xfe
   16a44:	eaffff96 	b	168a4 <USBHwCmdWrite>

00016a48 <USBHwNakIntEnable>:

}


/**
	Enables interrupt on NAK condition
		
	For IN endpoints a NAK is generated when the host wants to read data
	from the device, but none is available in the endpoint buffer.
	For OUT endpoints a NAK is generated when the host wants to write data
	to the device, but the endpoint buffer is still full.
	
	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
	from NAK interrupt by checking the bits in their bEPStatus argument.
	
	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
   16a48:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
   16a4c:	e3a000f3 	mov	r0, #243	; 0xf3
   16a50:	eaffff93 	b	168a4 <USBHwCmdWrite>

00016a54 <USBHwEPGetStatus>:
}


/**
	Gets the status from a specific endpoint.
		
	@param [in]	bEP		Endpoint number
	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8	USBHwEPGetStatus(U8 bEP)
{
   16a54:	e1a03000 	mov	r3, r0
	int idx = EP2IDX(bEP);

	return USBHwCmdRead(CMD_EP_SELECT | idx);
   16a58:	e2000080 	and	r0, r0, #128	; 0x80
   16a5c:	e203300f 	and	r3, r3, #15	; 0xf
   16a60:	e1a003c0 	mov	r0, r0, asr #7
   16a64:	e52de004 	str	lr, [sp, #-4]!
   16a68:	e1800083 	orr	r0, r0, r3, lsl #1
   16a6c:	ebffff9e 	bl	168ec <USBHwCmdRead>
}
   16a70:	e49de004 	ldr	lr, [sp], #4
   16a74:	e12fff1e 	bx	lr

00016a78 <USBHwEPStall>:


/**
	Sets the stalled property of an endpoint
		
	@param [in]	bEP		Endpoint number
	@param [in]	fStall	TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
	int idx = EP2IDX(bEP);

	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
   16a78:	e2003080 	and	r3, r0, #128	; 0x80
   16a7c:	e1a033c3 	mov	r3, r3, asr #7
   16a80:	e200000f 	and	r0, r0, #15	; 0xf
   16a84:	e1833080 	orr	r3, r3, r0, lsl #1
   16a88:	e2511000 	subs	r1, r1, #0	; 0x0
   16a8c:	13a01001 	movne	r1, #1	; 0x1
   16a90:	e3830040 	orr	r0, r3, #64	; 0x40
   16a94:	eaffff82 	b	168a4 <USBHwCmdWrite>

00016a98 <USBHwEPWrite>:
}


/**
	Writes data to an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iLen	Number of bytes to write
			
	@return TRUE if the data was successfully written or <0 in case of error.
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
{
   16a98:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	int idx;
	
	idx = EP2IDX(bEP);
   16a9c:	e200400f 	and	r4, r0, #15	; 0xf
	
	// set write enable for specific endpoint
	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
   16aa0:	e59fc074 	ldr	ip, [pc, #116]	; 16b1c <.text+0x6b1c>
   16aa4:	e1a03104 	mov	r3, r4, lsl #2
   16aa8:	e3833002 	orr	r3, r3, #2	; 0x2
   16aac:	e1a05002 	mov	r5, r2
	
	// set packet length
	USBTxPLen = iLen;
   16ab0:	e1a0e001 	mov	lr, r1
   16ab4:	e20000ff 	and	r0, r0, #255	; 0xff
   16ab8:	e58c3028 	str	r3, [ip, #40]
   16abc:	e58c2024 	str	r2, [ip, #36]
   16ac0:	ea000008 	b	16ae8 <USBHwEPWrite+0x50>
	
	// write data
	while (USBCtrl & WR_EN) {
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
   16ac4:	e55e3002 	ldrb	r3, [lr, #-2]
   16ac8:	e55e2001 	ldrb	r2, [lr, #-1]
   16acc:	e55e1004 	ldrb	r1, [lr, #-4]
   16ad0:	e1a03803 	mov	r3, r3, lsl #16
   16ad4:	e1833c02 	orr	r3, r3, r2, lsl #24
   16ad8:	e55e2003 	ldrb	r2, [lr, #-3]
   16adc:	e1833001 	orr	r3, r3, r1
   16ae0:	e1833402 	orr	r3, r3, r2, lsl #8
   16ae4:	e58c301c 	str	r3, [ip, #28]
   16ae8:	e59fc02c 	ldr	ip, [pc, #44]	; 16b1c <.text+0x6b1c>
   16aec:	e59c3028 	ldr	r3, [ip, #40]
   16af0:	e3130002 	tst	r3, #2	; 0x2
   16af4:	e28ee004 	add	lr, lr, #4	; 0x4
   16af8:	1afffff1 	bne	16ac4 <USBHwEPWrite+0x2c>
		pbBuf += 4;
	}

	// select endpoint and validate buffer
	USBHwCmd(CMD_EP_SELECT | idx);
   16afc:	e1a003a0 	mov	r0, r0, lsr #7
   16b00:	e1800084 	orr	r0, r0, r4, lsl #1
   16b04:	ebffff57 	bl	16868 <USBHwCmd>
	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
   16b08:	e3a000fa 	mov	r0, #250	; 0xfa
   16b0c:	ebffff55 	bl	16868 <USBHwCmd>
	
	return iLen;
}
   16b10:	e1a00005 	mov	r0, r5
   16b14:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16b18:	e12fff1e 	bx	lr
   16b1c:	e0090000 	and	r0, r9, r0

00016b20 <USBHwEPRead>:


/**
	Reads data from an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iMaxLen	Maximum number of bytes to read
			
	@return the number of bytes available in the EP (possibly more than iMaxLen),
	or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
{
   16b20:	e92d4010 	stmdb	sp!, {r4, lr}
	int i, idx;
	U32	dwData, dwLen;
	
	idx = EP2IDX(bEP);
   16b24:	e200e00f 	and	lr, r0, #15	; 0xf
	
	// set read enable bit for specific endpoint
	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
   16b28:	e1a0310e 	mov	r3, lr, lsl #2
   16b2c:	e59fc08c 	ldr	ip, [pc, #140]	; 16bc0 <.text+0x6bc0>
   16b30:	e3833001 	orr	r3, r3, #1	; 0x1
   16b34:	e58c3028 	str	r3, [ip, #40]
   16b38:	e20000ff 	and	r0, r0, #255	; 0xff
	
	// wait for PKT_RDY
	do {
		dwLen = USBRxPLen;
   16b3c:	e59f307c 	ldr	r3, [pc, #124]	; 16bc0 <.text+0x6bc0>
   16b40:	e5933020 	ldr	r3, [r3, #32]
	} while ((dwLen & PKT_RDY) == 0);
   16b44:	e3130b02 	tst	r3, #2048	; 0x800
   16b48:	0afffffb 	beq	16b3c <USBHwEPRead+0x1c>
	
	// packet valid?
	if ((dwLen & DV) == 0) {
   16b4c:	e3130b01 	tst	r3, #1024	; 0x400
   16b50:	03e04000 	mvneq	r4, #0	; 0x0
   16b54:	0a000016 	beq	16bb4 <USBHwEPRead+0x94>
		return -1;
	}
	
	// get length
	dwLen &= PKT_LNGTH_MASK;
   16b58:	e1a0cb03 	mov	ip, r3, lsl #22
   16b5c:	e3a04000 	mov	r4, #0	; 0x0
   16b60:	e1a0cb2c 	mov	ip, ip, lsr #22
   16b64:	e1a03004 	mov	r3, r4
   16b68:	ea000007 	b	16b8c <USBHwEPRead+0x6c>
	
	// get data
	dwData = 0;
	for (i = 0; i < dwLen; i++) {
		if ((i % 4) == 0) {
   16b6c:	e3140003 	tst	r4, #3	; 0x3
			dwData = USBRxData;
   16b70:	059f3048 	ldreq	r3, [pc, #72]	; 16bc0 <.text+0x6bc0>
   16b74:	05933018 	ldreq	r3, [r3, #24]
		}
		if ((pbBuf != NULL) && (i < iMaxLen)) {
   16b78:	e3510000 	cmp	r1, #0	; 0x0
   16b7c:	11540002 	cmpne	r4, r2
			pbBuf[i] = dwData & 0xFF;
   16b80:	b7c43001 	strltb	r3, [r4, r1]
		}
		dwData >>= 8;
   16b84:	e1a03423 	mov	r3, r3, lsr #8
   16b88:	e2844001 	add	r4, r4, #1	; 0x1
   16b8c:	e154000c 	cmp	r4, ip
   16b90:	1afffff5 	bne	16b6c <USBHwEPRead+0x4c>
	}

	// make sure RD_EN is clear
	USBCtrl = 0;
   16b94:	e59f3024 	ldr	r3, [pc, #36]	; 16bc0 <.text+0x6bc0>
   16b98:	e3a02000 	mov	r2, #0	; 0x0

	// select endpoint and clear buffer
	USBHwCmd(CMD_EP_SELECT | idx);
   16b9c:	e1a003a0 	mov	r0, r0, lsr #7
   16ba0:	e180008e 	orr	r0, r0, lr, lsl #1
   16ba4:	e5832028 	str	r2, [r3, #40]
   16ba8:	ebffff2e 	bl	16868 <USBHwCmd>
	USBHwCmd(CMD_EP_CLEAR_BUFFER);
   16bac:	e3a000f2 	mov	r0, #242	; 0xf2
   16bb0:	ebffff2c 	bl	16868 <USBHwCmd>
	
	return dwLen;
}
   16bb4:	e1a00004 	mov	r0, r4
   16bb8:	e8bd4010 	ldmia	sp!, {r4, lr}
   16bbc:	e12fff1e 	bx	lr
   16bc0:	e0090000 	and	r0, r9, r0

00016bc4 <USBHwConfigDevice>:


/**
	Sets the 'configured' state.
		
	All registered endpoints are 'realised' and enabled, and the
	'configured' bit is set in the device status register.
		
	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
	// set configured bit
	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
   16bc4:	e2501000 	subs	r1, r0, #0	; 0x0
   16bc8:	13a01001 	movne	r1, #1	; 0x1
   16bcc:	e3a000d8 	mov	r0, #216	; 0xd8
   16bd0:	eaffff33 	b	168a4 <USBHwCmdWrite>

00016bd4 <USBHwISR>:
}


/**
	USB interrupt handler
		
	@todo Get all 11 bits of frame number instead of just 8

	Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
	U32	dwStatus;
	U32 dwIntBit;
	U8	bEPStat, bDevStat, bStat;
	int i;
	U16	wFrame;

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

	// handle device interrupts
	dwStatus = USBDevIntSt;
   16bd4:	e59f2110 	ldr	r2, [pc, #272]	; 16cec <.text+0x6cec>
   16bd8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   16bdc:	e5925000 	ldr	r5, [r2]
	
	// frame interrupt
	if (dwStatus & FRAME) {
   16be0:	e3150001 	tst	r5, #1	; 0x1
   16be4:	0a00000b 	beq	16c18 <USBHwISR+0x44>
		// clear int
		USBDevIntClr = FRAME;
		// call handler
		if (_pfnFrameHandler != NULL) {
   16be8:	e59f3100 	ldr	r3, [pc, #256]	; 16cf0 <.text+0x6cf0>
   16bec:	e5934000 	ldr	r4, [r3]
   16bf0:	e3a03001 	mov	r3, #1	; 0x1
   16bf4:	e3540000 	cmp	r4, #0	; 0x0
   16bf8:	e5823008 	str	r3, [r2, #8]
   16bfc:	0a000005 	beq	16c18 <USBHwISR+0x44>
			wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
   16c00:	e3a000f5 	mov	r0, #245	; 0xf5
   16c04:	ebffff38 	bl	168ec <USBHwCmdRead>
			_pfnFrameHandler(wFrame);
   16c08:	e1a00800 	mov	r0, r0, lsl #16
   16c0c:	e1a00820 	mov	r0, r0, lsr #16
   16c10:	e1a0e00f 	mov	lr, pc
   16c14:	e12fff14 	bx	r4
		}
	}
	
	// device status interrupt
	if (dwStatus & DEV_STAT) {
   16c18:	e3150008 	tst	r5, #8	; 0x8
   16c1c:	0a00000c 	beq	16c54 <USBHwISR+0x80>
		/*	Clear DEV_STAT interrupt before reading DEV_STAT register.
			This prevents corrupted device status reads, see
			LPC2148 User manual revision 2, 25 july 2006.
		*/
		USBDevIntClr = DEV_STAT;
   16c20:	e59f30c4 	ldr	r3, [pc, #196]	; 16cec <.text+0x6cec>
   16c24:	e3a02008 	mov	r2, #8	; 0x8
		bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
   16c28:	e3a000fe 	mov	r0, #254	; 0xfe
   16c2c:	e5832008 	str	r2, [r3, #8]
   16c30:	ebffff2d 	bl	168ec <USBHwCmdRead>
		if (bDevStat & (CON_CH | SUS_CH | RST)) {
   16c34:	e310001a 	tst	r0, #26	; 0x1a
   16c38:	0a000005 	beq	16c54 <USBHwISR+0x80>
			// convert device status into something HW independent
			bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
					((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
					((bDevStat & RST) ? DEV_STATUS_RESET : 0);
			// call handler
			if (_pfnDevIntHandler != NULL) {
   16c3c:	e59f30b0 	ldr	r3, [pc, #176]	; 16cf4 <.text+0x6cf4>
   16c40:	e5933000 	ldr	r3, [r3]
   16c44:	e3530000 	cmp	r3, #0	; 0x0
DEBUG_LED_ON(8);		
				_pfnDevIntHandler(bStat);
   16c48:	12000015 	andne	r0, r0, #21	; 0x15
   16c4c:	11a0e00f 	movne	lr, pc
   16c50:	112fff13 	bxne	r3
DEBUG_LED_OFF(8);		
			}
		}
	}
	
	// endpoint interrupt
	if (dwStatus & EP_SLOW) {
   16c54:	e3150004 	tst	r5, #4	; 0x4
   16c58:	0a000021 	beq	16ce4 <USBHwISR+0x110>
		// clear EP_SLOW
		USBDevIntClr = EP_SLOW;
   16c5c:	e59f3088 	ldr	r3, [pc, #136]	; 16cec <.text+0x6cec>
   16c60:	e3a02004 	mov	r2, #4	; 0x4
   16c64:	e5832008 	str	r2, [r3, #8]
   16c68:	e3a04000 	mov	r4, #0	; 0x0
		// check all endpoints
		for (i = 0; i < 32; i++) {
			dwIntBit = (1 << i);
   16c6c:	e3a03001 	mov	r3, #1	; 0x1
   16c70:	e1a02413 	mov	r2, r3, lsl r4
			if (USBEpIntSt & dwIntBit) {
   16c74:	e59f1070 	ldr	r1, [pc, #112]	; 16cec <.text+0x6cec>
   16c78:	e5913030 	ldr	r3, [r1, #48]
   16c7c:	e1130002 	tst	r3, r2
   16c80:	0a000014 	beq	16cd8 <USBHwISR+0x104>
				// clear int (and retrieve status)
				USBEpIntClr = dwIntBit;
   16c84:	e5812038 	str	r2, [r1, #56]
   16c88:	e59f105c 	ldr	r1, [pc, #92]	; 16cec <.text+0x6cec>
   16c8c:	e5913000 	ldr	r3, [r1]
   16c90:	e2030020 	and	r0, r3, #32	; 0x20
   16c94:	e3500020 	cmp	r0, #32	; 0x20
   16c98:	1afffffa 	bne	16c88 <USBHwISR+0xb4>
				Wait4DevInt(CDFULL);
				bEPStat = USBCmdData;
				// convert EP pipe stat into something HW independent
				bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
						((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
						((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
						((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
						((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
				// call handler
				if (_apfnEPIntHandlers[i / 2] != NULL) {
   16c9c:	e0843fa4 	add	r3, r4, r4, lsr #31
   16ca0:	e59f2050 	ldr	r2, [pc, #80]	; 16cf8 <.text+0x6cf8>
   16ca4:	e1a030c3 	mov	r3, r3, asr #1
   16ca8:	e7923103 	ldr	r3, [r2, r3, lsl #2]
   16cac:	e5810008 	str	r0, [r1, #8]
   16cb0:	e3530000 	cmp	r3, #0	; 0x0
   16cb4:	e5911014 	ldr	r1, [r1, #20]
   16cb8:	0a000006 	beq	16cd8 <USBHwISR+0x104>
DEBUG_LED_ON(10);		
					_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
   16cbc:	e1a000c4 	mov	r0, r4, asr #1
   16cc0:	e200000f 	and	r0, r0, #15	; 0xf
   16cc4:	e1800384 	orr	r0, r0, r4, lsl #7
   16cc8:	e200008f 	and	r0, r0, #143	; 0x8f
   16ccc:	e201101f 	and	r1, r1, #31	; 0x1f
   16cd0:	e1a0e00f 	mov	lr, pc
   16cd4:	e12fff13 	bx	r3
   16cd8:	e2844001 	add	r4, r4, #1	; 0x1
   16cdc:	e3540020 	cmp	r4, #32	; 0x20
   16ce0:	1affffe1 	bne	16c6c <USBHwISR+0x98>
DEBUG_LED_OFF(10);
				}
			}
		}
	}
	
DEBUG_LED_OFF(9);		
}
   16ce4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16ce8:	e12fff1e 	bx	lr
   16cec:	e0090000 	and	r0, r9, r0
   16cf0:	4000117c 	andmi	r1, r0, ip, ror r1
   16cf4:	40001180 	andmi	r1, r0, r0, lsl #3
   16cf8:	40001184 	andmi	r1, r0, r4, lsl #3

00016cfc <USBHwInit>:



/**
	Initialises the USB hardware
		
	This function assumes that the hardware is connected as shown in
	section 10.1 of the LPC2148 data sheet:
	* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
	* P0.23 is connected to USB VCC.
	
	Embedded artists board: make sure to disconnect P0.23 LED as it
	acts as a pull-up and so prevents detection of USB disconnect.
		
	@return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
	// configure P0.23 for Vbus sense
	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
   16cfc:	e59f20b0 	ldr	r2, [pc, #176]	; 16db4 <.text+0x6db4>
   16d00:	e5923004 	ldr	r3, [r2, #4]
   16d04:	e3c33903 	bic	r3, r3, #49152	; 0xc000
   16d08:	e3833901 	orr	r3, r3, #16384	; 0x4000
   16d0c:	e5823004 	str	r3, [r2, #4]
	// configure P0.31 for CONNECT
	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
   16d10:	e5923004 	ldr	r3, [r2, #4]
   16d14:	e3c33103 	bic	r3, r3, #-1073741824	; 0xc0000000
   16d18:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   16d1c:	e5823004 	str	r3, [r2, #4]

	// enable PUSB
	PCONP |= (1 << 31);		
   16d20:	e282281d 	add	r2, r2, #1900544	; 0x1d0000
   16d24:	e59230c4 	ldr	r3, [r2, #196]
   16d28:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   16d2c:	e58230c4 	str	r3, [r2, #196]
	
	// initialise PLL
	PLL1CON = 1;			// enable PLL
   16d30:	e3a03001 	mov	r3, #1	; 0x1
   16d34:	e58230a0 	str	r3, [r2, #160]
   16d38:	e52de004 	str	lr, [sp, #-4]!
	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
   16d3c:	e2833022 	add	r3, r3, #34	; 0x22
   16d40:	e58230a4 	str	r3, [r2, #164]
	PLL1FEED = 0xAA;
   16d44:	e2833087 	add	r3, r3, #135	; 0x87
   16d48:	e58230ac 	str	r3, [r2, #172]
	PLL1FEED = 0x55;
   16d4c:	e3a03055 	mov	r3, #85	; 0x55
   16d50:	e58230ac 	str	r3, [r2, #172]
	while ((PLL1STAT & (1 << 10)) == 0);
   16d54:	e59fe05c 	ldr	lr, [pc, #92]	; 16db8 <.text+0x6db8>
   16d58:	e59e30a8 	ldr	r3, [lr, #168]
   16d5c:	e3130b01 	tst	r3, #1024	; 0x400
   16d60:	0afffffb 	beq	16d54 <USBHwInit+0x58>

	PLL1CON = 3;			// enable and connect
   16d64:	e3a03003 	mov	r3, #3	; 0x3
   16d68:	e58e30a0 	str	r3, [lr, #160]
	PLL1FEED = 0xAA;
	PLL1FEED = 0x55;
	
	// disable/clear all interrupts for now
	USBDevIntEn = 0;
   16d6c:	e59f2048 	ldr	r2, [pc, #72]	; 16dbc <.text+0x6dbc>
   16d70:	e28330a7 	add	r3, r3, #167	; 0xa7
   16d74:	e58e30ac 	str	r3, [lr, #172]
   16d78:	e3a01000 	mov	r1, #0	; 0x0
	USBDevIntClr = 0xFFFFFFFF;
   16d7c:	e3e0c000 	mvn	ip, #0	; 0x0
   16d80:	e3a03055 	mov	r3, #85	; 0x55
   16d84:	e58e30ac 	str	r3, [lr, #172]
	USBDevIntPri = 0;

	USBEpIntEn = 0;
	USBEpIntClr = 0xFFFFFFFF;
	USBEpIntPri = 0;

	// by default, only ACKs generate interrupts
	USBHwNakIntEnable(0);
   16d88:	e1a00001 	mov	r0, r1
   16d8c:	e5821004 	str	r1, [r2, #4]
   16d90:	e582c008 	str	ip, [r2, #8]
   16d94:	e582102c 	str	r1, [r2, #44]
   16d98:	e5821034 	str	r1, [r2, #52]
   16d9c:	e582c038 	str	ip, [r2, #56]
   16da0:	e5821040 	str	r1, [r2, #64]
   16da4:	ebffff27 	bl	16a48 <USBHwNakIntEnable>
	
	// init debug leds
	DEBUG_LED_INIT(8);
	DEBUG_LED_INIT(9);
	DEBUG_LED_INIT(10);

	return TRUE;
}
   16da8:	e3a00001 	mov	r0, #1	; 0x1
   16dac:	e49de004 	ldr	lr, [sp], #4
   16db0:	e12fff1e 	bx	lr
   16db4:	e002c000 	and	ip, r2, r0
   16db8:	e01fc000 	ands	ip, pc, r0
   16dbc:	e0090000 	and	r0, r9, r0

00016dc0 <_HandleRequest>:

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
   16dc0:	e52de004 	str	lr, [sp, #-4]!
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
	pfnHandler = apfnReqHandlers[iType];
   16dc4:	e5d03000 	ldrb	r3, [r0]
   16dc8:	e59fc02c 	ldr	ip, [pc, #44]	; 16dfc <.text+0x6dfc>
   16dcc:	e1a032a3 	mov	r3, r3, lsr #5
   16dd0:	e2033003 	and	r3, r3, #3	; 0x3
   16dd4:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
	if (pfnHandler == NULL) {
   16dd8:	e3530000 	cmp	r3, #0	; 0x0
   16ddc:	e1a0c003 	mov	ip, r3
   16de0:	0a000002 	beq	16df0 <_HandleRequest+0x30>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
	}

	return pfnHandler(pSetup, piLen, ppbData);
   16de4:	e1a0e00f 	mov	lr, pc
   16de8:	e12fff13 	bx	r3
   16dec:	e1a0c000 	mov	ip, r0
}
   16df0:	e1a0000c 	mov	r0, ip
   16df4:	e49de004 	ldr	lr, [sp], #4
   16df8:	e12fff1e 	bx	lr
   16dfc:	400011c4 	andmi	r1, r0, r4, asr #3

00016e00 <USBRegisterRequestHandler>:


/**
	Local function to stall the control endpoint
	
	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);

// dump setup packet
	DBG("STALL on [");
	pb = (U8 *)&Setup;
	for (i = 0; i < 8; i++) {
		DBG(" %02x", *pb++);
	}
	DBG("] stat=%x\n", bEPStat);
}


/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
	USBHwEPWrite(0x80, pbData, iChunk);
	pbData += iChunk;
	iResidue -= iChunk;
}


/**
 *	Handles IN/OUT transfers on EP0
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
	int iChunk, iType;

	if (bEP == 0x00) {
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
			pbData = apbDataStore[iType];
			iResidue = Setup.wLength;
			iLen = Setup.wLength;

			if ((Setup.wLength == 0) ||
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
					return;
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
				// send first part (possibly a zero-length status message)
				DataIn();
			}
		}
		else {		
			if (iResidue > 0) {
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
				if (iChunk < 0) {
					StallControlPipe(bEPStat);
					return;
				}
				pbData += iChunk;
				iResidue -= iChunk;
				if (iResidue == 0) {
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
					pbData = apbDataStore[iType];
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
						return;
					}
					// send status to host
					DataIn();
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}


/**
	Registers a callback for handling requests
		
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
	apbDataStore[iType] = pbDataStore;
   16e00:	e59f300c 	ldr	r3, [pc, #12]	; 16e14 <.text+0x6e14>
   16e04:	e7832100 	str	r2, [r3, r0, lsl #2]
   16e08:	e59f3008 	ldr	r3, [pc, #8]	; 16e18 <.text+0x6e18>
   16e0c:	e7831100 	str	r1, [r3, r0, lsl #2]
}
   16e10:	e12fff1e 	bx	lr
   16e14:	400011d4 	ldrmid	r1, [r0], -r4
   16e18:	400011c4 	andmi	r1, r0, r4, asr #3

00016e1c <StallControlPipe>:
   16e1c:	e52de004 	str	lr, [sp, #-4]!
   16e20:	e3a00080 	mov	r0, #128	; 0x80
   16e24:	e3a01001 	mov	r1, #1	; 0x1
   16e28:	ebffff12 	bl	16a78 <USBHwEPStall>
   16e2c:	e49de004 	ldr	lr, [sp], #4
   16e30:	e12fff1e 	bx	lr

00016e34 <DataIn>:
   16e34:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   16e38:	e59f603c 	ldr	r6, [pc, #60]	; 16e7c <.text+0x6e7c>
   16e3c:	e5964000 	ldr	r4, [r6]
   16e40:	e59f5038 	ldr	r5, [pc, #56]	; 16e80 <.text+0x6e80>
   16e44:	e3540040 	cmp	r4, #64	; 0x40
   16e48:	a3a04040 	movge	r4, #64	; 0x40
   16e4c:	e1a02004 	mov	r2, r4
   16e50:	e3a00080 	mov	r0, #128	; 0x80
   16e54:	e5951000 	ldr	r1, [r5]
   16e58:	ebffff0e 	bl	16a98 <USBHwEPWrite>
   16e5c:	e5953000 	ldr	r3, [r5]
   16e60:	e5962000 	ldr	r2, [r6]
   16e64:	e0833004 	add	r3, r3, r4
   16e68:	e0642002 	rsb	r2, r4, r2
   16e6c:	e5853000 	str	r3, [r5]
   16e70:	e5862000 	str	r2, [r6]
   16e74:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   16e78:	e12fff1e 	bx	lr
   16e7c:	400011f0 	strmid	r1, [r0], -r0
   16e80:	400011ec 	andmi	r1, r0, ip, ror #3

00016e84 <USBHandleControlTransfer>:
   16e84:	e21000ff 	ands	r0, r0, #255	; 0xff
   16e88:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   16e8c:	e20170ff 	and	r7, r1, #255	; 0xff
   16e90:	1a000043 	bne	16fa4 <USBHandleControlTransfer+0x120>
   16e94:	e3110004 	tst	r1, #4	; 0x4
   16e98:	e59f611c 	ldr	r6, [pc, #284]	; 16fbc <.text+0x6fbc>
   16e9c:	0a00001d 	beq	16f18 <USBHandleControlTransfer+0x94>
   16ea0:	e59f5118 	ldr	r5, [pc, #280]	; 16fc0 <.text+0x6fc0>
   16ea4:	e3a02008 	mov	r2, #8	; 0x8
   16ea8:	e1a01005 	mov	r1, r5
   16eac:	ebffff1b 	bl	16b20 <USBHwEPRead>
   16eb0:	e5d50000 	ldrb	r0, [r5]
   16eb4:	e59f2108 	ldr	r2, [pc, #264]	; 16fc4 <.text+0x6fc4>
   16eb8:	e1a032a0 	mov	r3, r0, lsr #5
   16ebc:	e1d510b6 	ldrh	r1, [r5, #6]
   16ec0:	e2033003 	and	r3, r3, #3	; 0x3
   16ec4:	e7923103 	ldr	r3, [r2, r3, lsl #2]
   16ec8:	e59f40f8 	ldr	r4, [pc, #248]	; 16fc8 <.text+0x6fc8>
   16ecc:	e59f20f8 	ldr	r2, [pc, #248]	; 16fcc <.text+0x6fcc>
   16ed0:	e3510000 	cmp	r1, #0	; 0x0
   16ed4:	e5823000 	str	r3, [r2]
   16ed8:	e5861000 	str	r1, [r6]
   16edc:	e5841000 	str	r1, [r4]
   16ee0:	0a000001 	beq	16eec <USBHandleControlTransfer+0x68>
   16ee4:	e1b003a0 	movs	r0, r0, lsr #7
   16ee8:	0a000031 	beq	16fb4 <USBHandleControlTransfer+0x130>
   16eec:	e1a00005 	mov	r0, r5
   16ef0:	e1a01004 	mov	r1, r4
   16ef4:	ebffffb1 	bl	16dc0 <_HandleRequest>
   16ef8:	e3500000 	cmp	r0, #0	; 0x0
   16efc:	0a000021 	beq	16f88 <USBHandleControlTransfer+0x104>
   16f00:	e1d520b6 	ldrh	r2, [r5, #6]
   16f04:	e5943000 	ldr	r3, [r4]
   16f08:	e1520003 	cmp	r2, r3
   16f0c:	d5862000 	strle	r2, [r6]
   16f10:	c5863000 	strgt	r3, [r6]
   16f14:	ea000024 	b	16fac <USBHandleControlTransfer+0x128>
   16f18:	e5962000 	ldr	r2, [r6]
   16f1c:	e3520000 	cmp	r2, #0	; 0x0
   16f20:	da00001b 	ble	16f94 <USBHandleControlTransfer+0x110>
   16f24:	e59f40a0 	ldr	r4, [pc, #160]	; 16fcc <.text+0x6fcc>
   16f28:	e5941000 	ldr	r1, [r4]
   16f2c:	ebfffefb 	bl	16b20 <USBHwEPRead>
   16f30:	e3500000 	cmp	r0, #0	; 0x0
   16f34:	ba000013 	blt	16f88 <USBHandleControlTransfer+0x104>
   16f38:	e5962000 	ldr	r2, [r6]
   16f3c:	e5943000 	ldr	r3, [r4]
   16f40:	e0602002 	rsb	r2, r0, r2
   16f44:	e0833000 	add	r3, r3, r0
   16f48:	e3520000 	cmp	r2, #0	; 0x0
   16f4c:	e5843000 	str	r3, [r4]
   16f50:	e5862000 	str	r2, [r6]
   16f54:	1a000016 	bne	16fb4 <USBHandleControlTransfer+0x130>
   16f58:	e59f0060 	ldr	r0, [pc, #96]	; 16fc0 <.text+0x6fc0>
   16f5c:	e5d03000 	ldrb	r3, [r0]
   16f60:	e59f205c 	ldr	r2, [pc, #92]	; 16fc4 <.text+0x6fc4>
   16f64:	e1a032a3 	mov	r3, r3, lsr #5
   16f68:	e2033003 	and	r3, r3, #3	; 0x3
   16f6c:	e7923103 	ldr	r3, [r2, r3, lsl #2]
   16f70:	e59f1050 	ldr	r1, [pc, #80]	; 16fc8 <.text+0x6fc8>
   16f74:	e1a02004 	mov	r2, r4
   16f78:	e5843000 	str	r3, [r4]
   16f7c:	ebffff8f 	bl	16dc0 <_HandleRequest>
   16f80:	e3500000 	cmp	r0, #0	; 0x0
   16f84:	1a000008 	bne	16fac <USBHandleControlTransfer+0x128>
   16f88:	e1a00007 	mov	r0, r7
   16f8c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   16f90:	eaffffa1 	b	16e1c <StallControlPipe>
   16f94:	e1a01000 	mov	r1, r0
   16f98:	e1a02000 	mov	r2, r0
   16f9c:	ebfffedf 	bl	16b20 <USBHwEPRead>
   16fa0:	ea000003 	b	16fb4 <USBHandleControlTransfer+0x130>
   16fa4:	e3500080 	cmp	r0, #128	; 0x80
   16fa8:	1a000001 	bne	16fb4 <USBHandleControlTransfer+0x130>
   16fac:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   16fb0:	eaffff9f 	b	16e34 <DataIn>
   16fb4:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   16fb8:	e12fff1e 	bx	lr
   16fbc:	400011f0 	strmid	r1, [r0], -r0
   16fc0:	400011e4 	andmi	r1, r0, r4, ror #3
   16fc4:	400011d4 	ldrmid	r1, [r0], -r4
   16fc8:	400011f4 	strmid	r1, [r0], -r4
   16fcc:	400011ec 	andmi	r1, r0, ip, ror #3

00016fd0 <USBRegisterDescriptors>:
 */
//void USBRegisterDescriptors(const U8 *pabDescriptors)
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
   16fd0:	e59f3004 	ldr	r3, [pc, #4]	; 16fdc <.text+0x6fdc>
   16fd4:	e5830000 	str	r0, [r3]
}
   16fd8:	e12fff1e 	bx	lr
   16fdc:	40001200 	andmi	r1, r0, r0, lsl #4

00016fe0 <USBGetDescriptor>:


/**
	Parses the list of installed USB descriptors and attempts to find
	the specified USB descriptor.
		
	@param [in]		wTypeIndex	Type and index of the descriptor
	@param [in]		wLangID		Language ID of the descriptor (currently unused)
	@param [out]	*piLen		Descriptor length
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
   16fe0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	U8	bType, bIndex;
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
	pab = (U8 *)pabDescrip;
   16fe4:	e59f1074 	ldr	r1, [pc, #116]	; 17060 <.text+0x7060>
   16fe8:	e1a00800 	mov	r0, r0, lsl #16
   16fec:	e591c000 	ldr	ip, [r1]
   16ff0:	e1a01820 	mov	r1, r0, lsr #16
   16ff4:	e1a05002 	mov	r5, r2
   16ff8:	e1a04003 	mov	r4, r3
   16ffc:	e1a0ec20 	mov	lr, r0, lsr #24
   17000:	e20110ff 	and	r1, r1, #255	; 0xff
   17004:	e3a02000 	mov	r2, #0	; 0x0
   17008:	ea00000f 	b	1704c <USBGetDescriptor+0x6c>
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
		if (pab[DESC_bDescriptorType] == bType) {
   1700c:	e5dc3001 	ldrb	r3, [ip, #1]
   17010:	e153000e 	cmp	r3, lr
   17014:	1a00000b 	bne	17048 <USBGetDescriptor+0x68>
			if (iCurIndex == bIndex) {
   17018:	e1520001 	cmp	r2, r1
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
			}
			iCurIndex++;
   1701c:	e2822001 	add	r2, r2, #1	; 0x1
   17020:	1a000008 	bne	17048 <USBGetDescriptor+0x68>
   17024:	e584c000 	str	ip, [r4]
   17028:	e35e0002 	cmp	lr, #2	; 0x2
   1702c:	05dc2003 	ldreqb	r2, [ip, #3]
   17030:	05dc3002 	ldreqb	r3, [ip, #2]
   17034:	15dc3000 	ldrneb	r3, [ip]
   17038:	01833402 	orreq	r3, r3, r2, lsl #8
   1703c:	e3a00001 	mov	r0, #1	; 0x1
   17040:	e5853000 	str	r3, [r5]
   17044:	ea000003 	b	17058 <USBGetDescriptor+0x78>
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
   17048:	e08cc000 	add	ip, ip, r0
   1704c:	e5dc0000 	ldrb	r0, [ip]
   17050:	e3500000 	cmp	r0, #0	; 0x0
   17054:	1affffec 	bne	1700c <USBGetDescriptor+0x2c>
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
   17058:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1705c:	e12fff1e 	bx	lr
   17060:	40001200 	andmi	r1, r0, r0, lsl #4

00017064 <USBRegisterCustomReqHandler>:


/**
	Configures the device according to the specified configuration index and
	alternate setting by parsing the installed USB descriptor list.
	A configuration index of 0 unconfigures the device.
		
	@param [in]		bConfigIndex	Configuration index
	@param [in]		bAltSetting		Alternate setting number
	
	@todo function always returns TRUE, add stricter checking?
	
	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
	U8	*pab;
	U8	bCurConfig, bCurAltSetting;
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
		// unconfigure device
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {

			switch (pab[DESC_bDescriptorType]) {

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
				break;

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
				break;

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
	}

	return TRUE;
}


/**
	Local function to handle a standard device request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
		*piLen = 1;
		break;

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_REMOTE_WAKEUP) {
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;

	case REQ_SET_DESCRIPTOR:
		DBG("Device req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Local function to handle a standard interface request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
		*piLen = 1;
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
			return FALSE;
		}
		*piLen = 0;
		break;

	default:
		DBG("Illegal interface req %d\n", pSetup->bRequest);
		return FALSE;
	}

	return TRUE;
}


/**
	Local function to handle a standard endpoint request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;

	case REQ_SYNCH_FRAME:
		DBG("EP req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal EP req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Default handler for standard ('chapter 9') requests
	
	If a custom request handler was installed, this handler is called first.
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}


/**
	Registers a callback for custom device requests
	
	In USBHandleStandardRequest, the custom request handler gets a first
	chance at handling the request before it is handed over to the 'chapter 9'
	request handler.
	
	This can be used for example in HID devices, where a REQ_GET_DESCRIPTOR
	request is sent to an interface, which is not covered by the 'chapter 9'
	specification.
		
	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
	pfnHandleCustomReq = pfnHandler;
   17064:	e59f3004 	ldr	r3, [pc, #4]	; 17070 <.text+0x7070>
   17068:	e5830000 	str	r0, [r3]
}
   1706c:	e12fff1e 	bx	lr
   17070:	400011f8 	strmid	r1, [r0], -r8

00017074 <USBHandleStandardRequest>:
   17074:	e59f3264 	ldr	r3, [pc, #612]	; 172e0 <.text+0x72e0>
   17078:	e5933000 	ldr	r3, [r3]
   1707c:	e3530000 	cmp	r3, #0	; 0x0
   17080:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17084:	e1a05000 	mov	r5, r0
   17088:	e1a08001 	mov	r8, r1
   1708c:	e1a07002 	mov	r7, r2
   17090:	0a000003 	beq	170a4 <USBHandleStandardRequest+0x30>
   17094:	e1a0e00f 	mov	lr, pc
   17098:	e12fff13 	bx	r3
   1709c:	e3500000 	cmp	r0, #0	; 0x0
   170a0:	1a00001e 	bne	17120 <.text+0x7120>
   170a4:	e5d53000 	ldrb	r3, [r5]
   170a8:	e203401f 	and	r4, r3, #31	; 0x1f
   170ac:	e3540001 	cmp	r4, #1	; 0x1
   170b0:	0a00004e 	beq	171f0 <.text+0x71f0>
   170b4:	e3540002 	cmp	r4, #2	; 0x2
   170b8:	0a000064 	beq	17250 <.text+0x7250>
   170bc:	e3540000 	cmp	r4, #0	; 0x0
   170c0:	1a000082 	bne	172d0 <.text+0x72d0>
   170c4:	e5d53001 	ldrb	r3, [r5, #1]
   170c8:	e5971000 	ldr	r1, [r7]
   170cc:	e3530009 	cmp	r3, #9	; 0x9
   170d0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   170d4:	ea00007d 	b	172d0 <.text+0x72d0>
   170d8:	00017100 	andeq	r7, r1, r0, lsl #2
   170dc:	000172d0 	ldreqd	r7, [r1], -r0
   170e0:	000172d0 	ldreqd	r7, [r1], -r0
   170e4:	000172d0 	ldreqd	r7, [r1], -r0
   170e8:	000172d0 	ldreqd	r7, [r1], -r0
   170ec:	00017118 	andeq	r7, r1, r8, lsl r1
   170f0:	00017128 	andeq	r7, r1, r8, lsr #2
   170f4:	000172d0 	ldreqd	r7, [r1], -r0
   170f8:	00017140 	andeq	r7, r1, r0, asr #2
   170fc:	0001715c 	andeq	r7, r1, ip, asr r1
   17100:	e3a03000 	mov	r3, #0	; 0x0
   17104:	e5c13001 	strb	r3, [r1, #1]
   17108:	e5c13000 	strb	r3, [r1]
   1710c:	e3a0c001 	mov	ip, #1	; 0x1
   17110:	e2833002 	add	r3, r3, #2	; 0x2
   17114:	ea00000e 	b	17154 <.text+0x7154>
   17118:	e5d50002 	ldrb	r0, [r5, #2]
   1711c:	ebfffe41 	bl	16a28 <USBHwSetAddress>
   17120:	e3a0c001 	mov	ip, #1	; 0x1
   17124:	ea00006a 	b	172d4 <.text+0x72d4>
   17128:	e1d510b4 	ldrh	r1, [r5, #4]
   1712c:	e1d500b2 	ldrh	r0, [r5, #2]
   17130:	e1a02008 	mov	r2, r8
   17134:	e1a03007 	mov	r3, r7
   17138:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   1713c:	eaffffa7 	b	16fe0 <USBGetDescriptor>
   17140:	e59f319c 	ldr	r3, [pc, #412]	; 172e4 <.text+0x72e4>
   17144:	e5d32000 	ldrb	r2, [r3]
   17148:	e3a03001 	mov	r3, #1	; 0x1
   1714c:	e5c12000 	strb	r2, [r1]
   17150:	e1a0c003 	mov	ip, r3
   17154:	e5883000 	str	r3, [r8]
   17158:	ea00005d 	b	172d4 <.text+0x72d4>
   1715c:	e5d56002 	ldrb	r6, [r5, #2]
   17160:	e3560000 	cmp	r6, #0	; 0x0
   17164:	01a00006 	moveq	r0, r6
   17168:	0a00001a 	beq	171d8 <.text+0x71d8>
   1716c:	e59f3174 	ldr	r3, [pc, #372]	; 172e8 <.text+0x72e8>
   17170:	e3a070ff 	mov	r7, #255	; 0xff
   17174:	e5934000 	ldr	r4, [r3]
   17178:	e1a08007 	mov	r8, r7
   1717c:	ea000011 	b	171c8 <.text+0x71c8>
   17180:	e5d43001 	ldrb	r3, [r4, #1]
   17184:	e3530004 	cmp	r3, #4	; 0x4
   17188:	05d47003 	ldreqb	r7, [r4, #3]
   1718c:	0a00000b 	beq	171c0 <.text+0x71c0>
   17190:	e3530005 	cmp	r3, #5	; 0x5
   17194:	0a000002 	beq	171a4 <.text+0x71a4>
   17198:	e3530002 	cmp	r3, #2	; 0x2
   1719c:	05d48005 	ldreqb	r8, [r4, #5]
   171a0:	ea000006 	b	171c0 <.text+0x71c0>
   171a4:	e1580006 	cmp	r8, r6
   171a8:	03570000 	cmpeq	r7, #0	; 0x0
   171ac:	05d43004 	ldreqb	r3, [r4, #4]
   171b0:	05d41005 	ldreqb	r1, [r4, #5]
   171b4:	05d40002 	ldreqb	r0, [r4, #2]
   171b8:	01831401 	orreq	r1, r3, r1, lsl #8
   171bc:	0bfffddd 	bleq	16938 <USBHwEPConfig>
   171c0:	e5d43000 	ldrb	r3, [r4]
   171c4:	e0844003 	add	r4, r4, r3
   171c8:	e5d43000 	ldrb	r3, [r4]
   171cc:	e3530000 	cmp	r3, #0	; 0x0
   171d0:	1affffea 	bne	17180 <.text+0x7180>
   171d4:	e3a00001 	mov	r0, #1	; 0x1
   171d8:	ebfffe79 	bl	16bc4 <USBHwConfigDevice>
   171dc:	e1d520b2 	ldrh	r2, [r5, #2]
   171e0:	e59f30fc 	ldr	r3, [pc, #252]	; 172e4 <.text+0x72e4>
   171e4:	e3a0c001 	mov	ip, #1	; 0x1
   171e8:	e5c32000 	strb	r2, [r3]
   171ec:	ea000038 	b	172d4 <.text+0x72d4>
   171f0:	e5d53001 	ldrb	r3, [r5, #1]
   171f4:	e3530000 	cmp	r3, #0	; 0x0
   171f8:	e5972000 	ldr	r2, [r7]
   171fc:	0a000004 	beq	17214 <.text+0x7214>
   17200:	e353000a 	cmp	r3, #10	; 0xa
   17204:	0a000007 	beq	17228 <.text+0x7228>
   17208:	e353000b 	cmp	r3, #11	; 0xb
   1720c:	1a00002f 	bne	172d0 <.text+0x72d0>
   17210:	ea000008 	b	17238 <.text+0x7238>
   17214:	e5c23001 	strb	r3, [r2, #1]
   17218:	e5c23000 	strb	r3, [r2]
   1721c:	e1a0c004 	mov	ip, r4
   17220:	e3a03002 	mov	r3, #2	; 0x2
   17224:	eaffffca 	b	17154 <.text+0x7154>
   17228:	e3a03000 	mov	r3, #0	; 0x0
   1722c:	e1a0c004 	mov	ip, r4
   17230:	e5c23000 	strb	r3, [r2]
   17234:	ea000015 	b	17290 <.text+0x7290>
   17238:	e1d500b2 	ldrh	r0, [r5, #2]
   1723c:	e3500000 	cmp	r0, #0	; 0x0
   17240:	03a0c001 	moveq	ip, #1	; 0x1
   17244:	05880000 	streq	r0, [r8]
   17248:	0a000021 	beq	172d4 <.text+0x72d4>
   1724c:	ea00001f 	b	172d0 <.text+0x72d0>
   17250:	e5d56001 	ldrb	r6, [r5, #1]
   17254:	e3560001 	cmp	r6, #1	; 0x1
   17258:	e5977000 	ldr	r7, [r7]
   1725c:	0a00000d 	beq	17298 <.text+0x7298>
   17260:	3a000002 	bcc	17270 <.text+0x7270>
   17264:	e3560003 	cmp	r6, #3	; 0x3
   17268:	1a000018 	bne	172d0 <.text+0x72d0>
   1726c:	ea000010 	b	172b4 <.text+0x72b4>
   17270:	e5d50004 	ldrb	r0, [r5, #4]
   17274:	ebfffdf6 	bl	16a54 <USBHwEPGetStatus>
   17278:	e1a000a0 	mov	r0, r0, lsr #1
   1727c:	e2000001 	and	r0, r0, #1	; 0x1
   17280:	e3a03000 	mov	r3, #0	; 0x0
   17284:	e5c73001 	strb	r3, [r7, #1]
   17288:	e5c70000 	strb	r0, [r7]
   1728c:	e3a0c001 	mov	ip, #1	; 0x1
   17290:	e5884000 	str	r4, [r8]
   17294:	ea00000e 	b	172d4 <.text+0x72d4>
   17298:	e1d510b2 	ldrh	r1, [r5, #2]
   1729c:	e3510000 	cmp	r1, #0	; 0x0
   172a0:	1a00000a 	bne	172d0 <.text+0x72d0>
   172a4:	e5d50004 	ldrb	r0, [r5, #4]
   172a8:	ebfffdf2 	bl	16a78 <USBHwEPStall>
   172ac:	e1a0c006 	mov	ip, r6
   172b0:	ea000007 	b	172d4 <.text+0x72d4>
   172b4:	e1d530b2 	ldrh	r3, [r5, #2]
   172b8:	e3530000 	cmp	r3, #0	; 0x0
   172bc:	1a000003 	bne	172d0 <.text+0x72d0>
   172c0:	e5d50004 	ldrb	r0, [r5, #4]
   172c4:	e3a01001 	mov	r1, #1	; 0x1
   172c8:	ebfffdea 	bl	16a78 <USBHwEPStall>
   172cc:	eaffff93 	b	17120 <.text+0x7120>
   172d0:	e3a0c000 	mov	ip, #0	; 0x0
   172d4:	e1a0000c 	mov	r0, ip
   172d8:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   172dc:	e12fff1e 	bx	lr
   172e0:	400011f8 	strmid	r1, [r0], -r8
   172e4:	400011fc 	strmid	r1, [r0], -ip
   172e8:	40001200 	andmi	r1, r0, r0, lsl #4

000172ec <free>:
   172ec:	e59f3014 	ldr	r3, [pc, #20]	; 17308 <.text+0x7308>
   172f0:	e1a01000 	mov	r1, r0
   172f4:	e52de004 	str	lr, [sp, #-4]!
   172f8:	e5930000 	ldr	r0, [r3]
   172fc:	eb000256 	bl	17c5c <_free_r>
   17300:	e49de004 	ldr	lr, [sp], #4
   17304:	e12fff1e 	bx	lr
   17308:	40000490 	mulmi	r0, r0, r4

0001730c <malloc>:
   1730c:	e59f3014 	ldr	r3, [pc, #20]	; 17328 <.text+0x7328>
   17310:	e1a01000 	mov	r1, r0
   17314:	e52de004 	str	lr, [sp, #-4]!
   17318:	e5930000 	ldr	r0, [r3]
   1731c:	eb000002 	bl	1732c <_malloc_r>
   17320:	e49de004 	ldr	lr, [sp], #4
   17324:	e12fff1e 	bx	lr
   17328:	40000490 	mulmi	r0, r0, r4

0001732c <_malloc_r>:
   1732c:	e281300b 	add	r3, r1, #11	; 0xb
   17330:	e3530016 	cmp	r3, #22	; 0x16
   17334:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17338:	93a08010 	movls	r8, #16	; 0x10
   1733c:	83c38007 	bichi	r8, r3, #7	; 0x7
   17340:	e1580001 	cmp	r8, r1
   17344:	23a03000 	movcs	r3, #0	; 0x0
   17348:	33a03001 	movcc	r3, #1	; 0x1
   1734c:	e1933fa8 	orrs	r3, r3, r8, lsr #31
   17350:	e1a0a000 	mov	sl, r0
   17354:	13a0300c 	movne	r3, #12	; 0xc
   17358:	13a00000 	movne	r0, #0	; 0x0
   1735c:	158a3000 	strne	r3, [sl]
   17360:	1a00018a 	bne	17990 <_malloc_r+0x664>
   17364:	e1a0000a 	mov	r0, sl
   17368:	eb0001a0 	bl	179f0 <__malloc_lock>
   1736c:	e3580f7e 	cmp	r8, #504	; 0x1f8
   17370:	2a000011 	bcs	173bc <_malloc_r+0x90>
   17374:	e59f361c 	ldr	r3, [pc, #1564]	; 17998 <.text+0x7998>
   17378:	e1a021a8 	mov	r2, r8, lsr #3
   1737c:	e0833182 	add	r3, r3, r2, lsl #3
   17380:	e593400c 	ldr	r4, [r3, #12]
   17384:	e1540003 	cmp	r4, r3
   17388:	1a000003 	bne	1739c <_malloc_r+0x70>
   1738c:	e2843008 	add	r3, r4, #8	; 0x8
   17390:	e593400c 	ldr	r4, [r3, #12]
   17394:	e1540003 	cmp	r4, r3
   17398:	0a000005 	beq	173b4 <_malloc_r+0x88>
   1739c:	e5943004 	ldr	r3, [r4, #4]
   173a0:	e3c33003 	bic	r3, r3, #3	; 0x3
   173a4:	e0843003 	add	r3, r4, r3
   173a8:	e5932004 	ldr	r2, [r3, #4]
   173ac:	e594000c 	ldr	r0, [r4, #12]
   173b0:	ea00016e 	b	17970 <_malloc_r+0x644>
   173b4:	e2825002 	add	r5, r2, #2	; 0x2
   173b8:	ea00002a 	b	17468 <_malloc_r+0x13c>
   173bc:	e1b024a8 	movs	r2, r8, lsr #9
   173c0:	01a021a8 	moveq	r2, r8, lsr #3
   173c4:	0a000017 	beq	17428 <_malloc_r+0xfc>
   173c8:	e3520004 	cmp	r2, #4	; 0x4
   173cc:	91a03328 	movls	r3, r8, lsr #6
   173d0:	92832038 	addls	r2, r3, #56	; 0x38
   173d4:	9a000013 	bls	17428 <_malloc_r+0xfc>
   173d8:	e3520014 	cmp	r2, #20	; 0x14
   173dc:	9282205b 	addls	r2, r2, #91	; 0x5b
   173e0:	9a000010 	bls	17428 <_malloc_r+0xfc>
   173e4:	e3520054 	cmp	r2, #84	; 0x54
   173e8:	91a03628 	movls	r3, r8, lsr #12
   173ec:	9283206e 	addls	r2, r3, #110	; 0x6e
   173f0:	9a00000c 	bls	17428 <_malloc_r+0xfc>
   173f4:	e3520f55 	cmp	r2, #340	; 0x154
   173f8:	91a037a8 	movls	r3, r8, lsr #15
   173fc:	92832077 	addls	r2, r3, #119	; 0x77
   17400:	9a000008 	bls	17428 <_malloc_r+0xfc>
   17404:	e59f3590 	ldr	r3, [pc, #1424]	; 1799c <.text+0x799c>
   17408:	e1520003 	cmp	r2, r3
   1740c:	83a0207e 	movhi	r2, #126	; 0x7e
   17410:	8a000004 	bhi	17428 <_malloc_r+0xfc>
   17414:	ea000001 	b	17420 <_malloc_r+0xf4>
   17418:	e2422001 	sub	r2, r2, #1	; 0x1
   1741c:	ea000010 	b	17464 <_malloc_r+0x138>
   17420:	e1a03928 	mov	r3, r8, lsr #18
   17424:	e283207c 	add	r2, r3, #124	; 0x7c
   17428:	e59f3568 	ldr	r3, [pc, #1384]	; 17998 <.text+0x7998>
   1742c:	e083c182 	add	ip, r3, r2, lsl #3
   17430:	e59c400c 	ldr	r4, [ip, #12]
   17434:	ea000008 	b	1745c <_malloc_r+0x130>
   17438:	e5943004 	ldr	r3, [r4, #4]
   1743c:	e3c33003 	bic	r3, r3, #3	; 0x3
   17440:	e0681003 	rsb	r1, r8, r3
   17444:	e351000f 	cmp	r1, #15	; 0xf
   17448:	cafffff2 	bgt	17418 <_malloc_r+0xec>
   1744c:	e3510000 	cmp	r1, #0	; 0x0
   17450:	e594000c 	ldr	r0, [r4, #12]
   17454:	aa000143 	bge	17968 <_malloc_r+0x63c>
   17458:	e1a04000 	mov	r4, r0
   1745c:	e154000c 	cmp	r4, ip
   17460:	1afffff4 	bne	17438 <_malloc_r+0x10c>
   17464:	e2825001 	add	r5, r2, #1	; 0x1
   17468:	e59fb528 	ldr	fp, [pc, #1320]	; 17998 <.text+0x7998>
   1746c:	e28b7008 	add	r7, fp, #8	; 0x8
   17470:	e5974008 	ldr	r4, [r7, #8]
   17474:	e1540007 	cmp	r4, r7
   17478:	0a000054 	beq	175d0 <_malloc_r+0x2a4>
   1747c:	e5943004 	ldr	r3, [r4, #4]
   17480:	e3c32003 	bic	r2, r3, #3	; 0x3
   17484:	e0680002 	rsb	r0, r8, r2
   17488:	e350000f 	cmp	r0, #15	; 0xf
   1748c:	da000009 	ble	174b8 <_malloc_r+0x18c>
   17490:	e0842008 	add	r2, r4, r8
   17494:	e3883001 	orr	r3, r8, #1	; 0x1
   17498:	e3801001 	orr	r1, r0, #1	; 0x1
   1749c:	e5843004 	str	r3, [r4, #4]
   174a0:	e587200c 	str	r2, [r7, #12]
   174a4:	e5872008 	str	r2, [r7, #8]
   174a8:	e7820000 	str	r0, [r2, r0]
   174ac:	e9820082 	stmib	r2, {r1, r7}
   174b0:	e582700c 	str	r7, [r2, #12]
   174b4:	ea000132 	b	17984 <_malloc_r+0x658>
   174b8:	e3500000 	cmp	r0, #0	; 0x0
   174bc:	e587700c 	str	r7, [r7, #12]
   174c0:	e5877008 	str	r7, [r7, #8]
   174c4:	a0842002 	addge	r2, r4, r2
   174c8:	a5923004 	ldrge	r3, [r2, #4]
   174cc:	a3833001 	orrge	r3, r3, #1	; 0x1
   174d0:	a5823004 	strge	r3, [r2, #4]
   174d4:	aa00012a 	bge	17984 <_malloc_r+0x658>
   174d8:	e3520c02 	cmp	r2, #512	; 0x200
   174dc:	2a00000c 	bcs	17514 <_malloc_r+0x1e8>
   174e0:	e1a011a2 	mov	r1, r2, lsr #3
   174e4:	e59b2004 	ldr	r2, [fp, #4]
   174e8:	e1a00121 	mov	r0, r1, lsr #2
   174ec:	e3a03001 	mov	r3, #1	; 0x1
   174f0:	e1822013 	orr	r2, r2, r3, lsl r0
   174f4:	e08b1181 	add	r1, fp, r1, lsl #3
   174f8:	e5913008 	ldr	r3, [r1, #8]
   174fc:	e584100c 	str	r1, [r4, #12]
   17500:	e5843008 	str	r3, [r4, #8]
   17504:	e58b2004 	str	r2, [fp, #4]
   17508:	e583400c 	str	r4, [r3, #12]
   1750c:	e5814008 	str	r4, [r1, #8]
   17510:	ea00002e 	b	175d0 <_malloc_r+0x2a4>
   17514:	e1b014a2 	movs	r1, r2, lsr #9
   17518:	01a011a2 	moveq	r1, r2, lsr #3
   1751c:	0a000013 	beq	17570 <_malloc_r+0x244>
   17520:	e3510004 	cmp	r1, #4	; 0x4
   17524:	91a03322 	movls	r3, r2, lsr #6
   17528:	92831038 	addls	r1, r3, #56	; 0x38
   1752c:	9a00000f 	bls	17570 <_malloc_r+0x244>
   17530:	e3510014 	cmp	r1, #20	; 0x14
   17534:	9281105b 	addls	r1, r1, #91	; 0x5b
   17538:	9a00000c 	bls	17570 <_malloc_r+0x244>
   1753c:	e3510054 	cmp	r1, #84	; 0x54
   17540:	91a03622 	movls	r3, r2, lsr #12
   17544:	9283106e 	addls	r1, r3, #110	; 0x6e
   17548:	9a000008 	bls	17570 <_malloc_r+0x244>
   1754c:	e3510f55 	cmp	r1, #340	; 0x154
   17550:	91a037a2 	movls	r3, r2, lsr #15
   17554:	92831077 	addls	r1, r3, #119	; 0x77
   17558:	9a000004 	bls	17570 <_malloc_r+0x244>
   1755c:	e59f3438 	ldr	r3, [pc, #1080]	; 1799c <.text+0x799c>
   17560:	e1510003 	cmp	r1, r3
   17564:	91a03922 	movls	r3, r2, lsr #18
   17568:	83a0107e 	movhi	r1, #126	; 0x7e
   1756c:	9283107c 	addls	r1, r3, #124	; 0x7c
   17570:	e08b0181 	add	r0, fp, r1, lsl #3
   17574:	e590c008 	ldr	ip, [r0, #8]
   17578:	e15c0000 	cmp	ip, r0
   1757c:	1a00000a 	bne	175ac <_malloc_r+0x280>
   17580:	e59f0410 	ldr	r0, [pc, #1040]	; 17998 <.text+0x7998>
   17584:	e5902004 	ldr	r2, [r0, #4]
   17588:	e1a01121 	mov	r1, r1, lsr #2
   1758c:	e3a03001 	mov	r3, #1	; 0x1
   17590:	e1822113 	orr	r2, r2, r3, lsl r1
   17594:	e1a0e00c 	mov	lr, ip
   17598:	e5802004 	str	r2, [r0, #4]
   1759c:	ea000007 	b	175c0 <_malloc_r+0x294>
   175a0:	e59cc008 	ldr	ip, [ip, #8]
   175a4:	e15c0000 	cmp	ip, r0
   175a8:	0a000003 	beq	175bc <_malloc_r+0x290>
   175ac:	e59c3004 	ldr	r3, [ip, #4]
   175b0:	e3c33003 	bic	r3, r3, #3	; 0x3
   175b4:	e1520003 	cmp	r2, r3
   175b8:	3afffff8 	bcc	175a0 <_malloc_r+0x274>
   175bc:	e59ce00c 	ldr	lr, [ip, #12]
   175c0:	e584e00c 	str	lr, [r4, #12]
   175c4:	e584c008 	str	ip, [r4, #8]
   175c8:	e58c400c 	str	r4, [ip, #12]
   175cc:	e58e4008 	str	r4, [lr, #8]
   175d0:	e3550000 	cmp	r5, #0	; 0x0
   175d4:	e2853003 	add	r3, r5, #3	; 0x3
   175d8:	a1a03005 	movge	r3, r5
   175dc:	e1a03143 	mov	r3, r3, asr #2
   175e0:	e3a02001 	mov	r2, #1	; 0x1
   175e4:	e1a02312 	mov	r2, r2, lsl r3
   175e8:	e59f93a8 	ldr	r9, [pc, #936]	; 17998 <.text+0x7998>
   175ec:	e5991004 	ldr	r1, [r9, #4]
   175f0:	e1520001 	cmp	r2, r1
   175f4:	8a000037 	bhi	176d8 <_malloc_r+0x3ac>
   175f8:	e1120001 	tst	r2, r1
   175fc:	01a02082 	moveq	r2, r2, lsl #1
   17600:	03c53003 	biceq	r3, r5, #3	; 0x3
   17604:	0a000001 	beq	17610 <_malloc_r+0x2e4>
   17608:	ea000004 	b	17620 <_malloc_r+0x2f4>
   1760c:	e1a02082 	mov	r2, r2, lsl #1
   17610:	e1120001 	tst	r2, r1
   17614:	e2833004 	add	r3, r3, #4	; 0x4
   17618:	0afffffb 	beq	1760c <_malloc_r+0x2e0>
   1761c:	e1a05003 	mov	r5, r3
   17620:	e08b6185 	add	r6, fp, r5, lsl #3
   17624:	e1a0e005 	mov	lr, r5
   17628:	e1a01006 	mov	r1, r6
   1762c:	e591400c 	ldr	r4, [r1, #12]
   17630:	ea000008 	b	17658 <_malloc_r+0x32c>
   17634:	e5943004 	ldr	r3, [r4, #4]
   17638:	e3c33003 	bic	r3, r3, #3	; 0x3
   1763c:	e068c003 	rsb	ip, r8, r3
   17640:	e35c000f 	cmp	ip, #15	; 0xf
   17644:	ca0000ad 	bgt	17900 <_malloc_r+0x5d4>
   17648:	e35c0000 	cmp	ip, #0	; 0x0
   1764c:	e594000c 	ldr	r0, [r4, #12]
   17650:	aa0000b9 	bge	1793c <_malloc_r+0x610>
   17654:	e1a04000 	mov	r4, r0
   17658:	e1540001 	cmp	r4, r1
   1765c:	1afffff4 	bne	17634 <_malloc_r+0x308>
   17660:	e28ee001 	add	lr, lr, #1	; 0x1
   17664:	e31e0003 	tst	lr, #3	; 0x3
   17668:	12841008 	addne	r1, r4, #8	; 0x8
   1766c:	1affffee 	bne	1762c <_malloc_r+0x300>
   17670:	e1a00005 	mov	r0, r5
   17674:	e1a01006 	mov	r1, r6
   17678:	e3100003 	tst	r0, #3	; 0x3
   1767c:	e2411008 	sub	r1, r1, #8	; 0x8
   17680:	e2400001 	sub	r0, r0, #1	; 0x1
   17684:	0a00000f 	beq	176c8 <_malloc_r+0x39c>
   17688:	e5913008 	ldr	r3, [r1, #8]
   1768c:	e1530001 	cmp	r3, r1
   17690:	0afffff8 	beq	17678 <_malloc_r+0x34c>
   17694:	e5993004 	ldr	r3, [r9, #4]
   17698:	e1a02082 	mov	r2, r2, lsl #1
   1769c:	e1520003 	cmp	r2, r3
   176a0:	8a00000c 	bhi	176d8 <_malloc_r+0x3ac>
   176a4:	e3520000 	cmp	r2, #0	; 0x0
   176a8:	0a00000a 	beq	176d8 <_malloc_r+0x3ac>
   176ac:	e1a0500e 	mov	r5, lr
   176b0:	ea000001 	b	176bc <_malloc_r+0x390>
   176b4:	e2855004 	add	r5, r5, #4	; 0x4
   176b8:	e1a02082 	mov	r2, r2, lsl #1
   176bc:	e1120003 	tst	r2, r3
   176c0:	0afffffb 	beq	176b4 <_malloc_r+0x388>
   176c4:	eaffffd5 	b	17620 <_malloc_r+0x2f4>
   176c8:	e5993004 	ldr	r3, [r9, #4]
   176cc:	e1c33002 	bic	r3, r3, r2
   176d0:	e5893004 	str	r3, [r9, #4]
   176d4:	eaffffee 	b	17694 <_malloc_r+0x368>
   176d8:	e5996008 	ldr	r6, [r9, #8]
   176dc:	e5963004 	ldr	r3, [r6, #4]
   176e0:	e3c37003 	bic	r7, r3, #3	; 0x3
   176e4:	e0681007 	rsb	r1, r8, r7
   176e8:	e351000f 	cmp	r1, #15	; 0xf
   176ec:	c3a03000 	movgt	r3, #0	; 0x0
   176f0:	d3a03001 	movle	r3, #1	; 0x1
   176f4:	e1570008 	cmp	r7, r8
   176f8:	33833001 	orrcc	r3, r3, #1	; 0x1
   176fc:	e3530000 	cmp	r3, #0	; 0x0
   17700:	0a000070 	beq	178c8 <_malloc_r+0x59c>
   17704:	e59f3294 	ldr	r3, [pc, #660]	; 179a0 <.text+0x79a0>
   17708:	e5932000 	ldr	r2, [r3]
   1770c:	e59f3290 	ldr	r3, [pc, #656]	; 179a4 <.text+0x79a4>
   17710:	e5933000 	ldr	r3, [r3]
   17714:	e2822010 	add	r2, r2, #16	; 0x10
   17718:	e3730001 	cmn	r3, #1	; 0x1
   1771c:	e0884002 	add	r4, r8, r2
   17720:	12843eff 	addne	r3, r4, #4080	; 0xff0
   17724:	1283300f 	addne	r3, r3, #15	; 0xf
   17728:	13c34eff 	bicne	r4, r3, #4080	; 0xff0
   1772c:	13c4400f 	bicne	r4, r4, #15	; 0xf
   17730:	e1a0000a 	mov	r0, sl
   17734:	e1a01004 	mov	r1, r4
   17738:	ebffe879 	bl	11924 <_sbrk_r>
   1773c:	e3700001 	cmn	r0, #1	; 0x1
   17740:	0a000051 	beq	1788c <_malloc_r+0x560>
   17744:	e086c007 	add	ip, r6, r7
   17748:	e150000c 	cmp	r0, ip
   1774c:	e1a05000 	mov	r5, r0
   17750:	2a000002 	bcs	17760 <_malloc_r+0x434>
   17754:	e1560009 	cmp	r6, r9
   17758:	1a00004b 	bne	1788c <_malloc_r+0x560>
   1775c:	ea000062 	b	178ec <_malloc_r+0x5c0>
   17760:	e59f2240 	ldr	r2, [pc, #576]	; 179a8 <.text+0x79a8>
   17764:	e5923000 	ldr	r3, [r2]
   17768:	e0841003 	add	r1, r4, r3
   1776c:	e5821000 	str	r1, [r2]
   17770:	1a000007 	bne	17794 <_malloc_r+0x468>
   17774:	e1a03a00 	mov	r3, r0, lsl #20
   17778:	e1a03a23 	mov	r3, r3, lsr #20
   1777c:	e3530000 	cmp	r3, #0	; 0x0
   17780:	00843007 	addeq	r3, r4, r7
   17784:	05992008 	ldreq	r2, [r9, #8]
   17788:	03833001 	orreq	r3, r3, #1	; 0x1
   1778c:	05823004 	streq	r3, [r2, #4]
   17790:	0a000033 	beq	17864 <_malloc_r+0x538>
   17794:	e59f2208 	ldr	r2, [pc, #520]	; 179a4 <.text+0x79a4>
   17798:	e5923000 	ldr	r3, [r2]
   1779c:	e3730001 	cmn	r3, #1	; 0x1
   177a0:	106c3000 	rsbne	r3, ip, r0
   177a4:	159f21fc 	ldrne	r2, [pc, #508]	; 179a8 <.text+0x79a8>
   177a8:	10813003 	addne	r3, r1, r3
   177ac:	05820000 	streq	r0, [r2]
   177b0:	15823000 	strne	r3, [r2]
   177b4:	e2103007 	ands	r3, r0, #7	; 0x7
   177b8:	12631008 	rsbne	r1, r3, #8	; 0x8
   177bc:	10805001 	addne	r5, r0, r1
   177c0:	01a01003 	moveq	r1, r3
   177c4:	e0853004 	add	r3, r5, r4
   177c8:	e1a03a03 	mov	r3, r3, lsl #20
   177cc:	e1a03a23 	mov	r3, r3, lsr #20
   177d0:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
   177d4:	e0814003 	add	r4, r1, r3
   177d8:	e1a01004 	mov	r1, r4
   177dc:	e1a0000a 	mov	r0, sl
   177e0:	ebffe84f 	bl	11924 <_sbrk_r>
   177e4:	e59f31bc 	ldr	r3, [pc, #444]	; 179a8 <.text+0x79a8>
   177e8:	e3700001 	cmn	r0, #1	; 0x1
   177ec:	01a00005 	moveq	r0, r5
   177f0:	03a04000 	moveq	r4, #0	; 0x0
   177f4:	e5931000 	ldr	r1, [r3]
   177f8:	e0652000 	rsb	r2, r5, r0
   177fc:	e0822004 	add	r2, r2, r4
   17800:	e0811004 	add	r1, r1, r4
   17804:	e3822001 	orr	r2, r2, #1	; 0x1
   17808:	e1560009 	cmp	r6, r9
   1780c:	e5831000 	str	r1, [r3]
   17810:	e5852004 	str	r2, [r5, #4]
   17814:	e5895008 	str	r5, [r9, #8]
   17818:	0a000011 	beq	17864 <_malloc_r+0x538>
   1781c:	e357000f 	cmp	r7, #15	; 0xf
   17820:	93a03001 	movls	r3, #1	; 0x1
   17824:	95853004 	strls	r3, [r5, #4]
   17828:	9a000017 	bls	1788c <_malloc_r+0x560>
   1782c:	e5963004 	ldr	r3, [r6, #4]
   17830:	e247200c 	sub	r2, r7, #12	; 0xc
   17834:	e3c22007 	bic	r2, r2, #7	; 0x7
   17838:	e2033001 	and	r3, r3, #1	; 0x1
   1783c:	e1833002 	orr	r3, r3, r2
   17840:	e3a01005 	mov	r1, #5	; 0x5
   17844:	e352000f 	cmp	r2, #15	; 0xf
   17848:	e0862002 	add	r2, r6, r2
   1784c:	e5863004 	str	r3, [r6, #4]
   17850:	e5821008 	str	r1, [r2, #8]
   17854:	e5821004 	str	r1, [r2, #4]
   17858:	82861008 	addhi	r1, r6, #8	; 0x8
   1785c:	81a0000a 	movhi	r0, sl
   17860:	8b0000fd 	blhi	17c5c <_free_r>
   17864:	e59f1140 	ldr	r1, [pc, #320]	; 179ac <.text+0x79ac>
   17868:	e59f3138 	ldr	r3, [pc, #312]	; 179a8 <.text+0x79a8>
   1786c:	e5932000 	ldr	r2, [r3]
   17870:	e5913000 	ldr	r3, [r1]
   17874:	e1520003 	cmp	r2, r3
   17878:	85812000 	strhi	r2, [r1]
   1787c:	e59f112c 	ldr	r1, [pc, #300]	; 179b0 <.text+0x79b0>
   17880:	e5913000 	ldr	r3, [r1]
   17884:	e1520003 	cmp	r2, r3
   17888:	85812000 	strhi	r2, [r1]
   1788c:	e5993008 	ldr	r3, [r9, #8]
   17890:	e5932004 	ldr	r2, [r3, #4]
   17894:	e3c22003 	bic	r2, r2, #3	; 0x3
   17898:	e0681002 	rsb	r1, r8, r2
   1789c:	e351000f 	cmp	r1, #15	; 0xf
   178a0:	c3a03000 	movgt	r3, #0	; 0x0
   178a4:	d3a03001 	movle	r3, #1	; 0x1
   178a8:	e1520008 	cmp	r2, r8
   178ac:	33833001 	orrcc	r3, r3, #1	; 0x1
   178b0:	e3530000 	cmp	r3, #0	; 0x0
   178b4:	0a000003 	beq	178c8 <_malloc_r+0x59c>
   178b8:	e1a0000a 	mov	r0, sl
   178bc:	eb00004c 	bl	179f4 <__malloc_unlock>
   178c0:	e3a00000 	mov	r0, #0	; 0x0
   178c4:	ea000031 	b	17990 <_malloc_r+0x664>
   178c8:	e5994008 	ldr	r4, [r9, #8]
   178cc:	e3811001 	orr	r1, r1, #1	; 0x1
   178d0:	e0842008 	add	r2, r4, r8
   178d4:	e3883001 	orr	r3, r8, #1	; 0x1
   178d8:	e1a0000a 	mov	r0, sl
   178dc:	e5843004 	str	r3, [r4, #4]
   178e0:	e5892008 	str	r2, [r9, #8]
   178e4:	e5821004 	str	r1, [r2, #4]
   178e8:	ea000026 	b	17988 <_malloc_r+0x65c>
   178ec:	e59f20b4 	ldr	r2, [pc, #180]	; 179a8 <.text+0x79a8>
   178f0:	e5923000 	ldr	r3, [r2]
   178f4:	e0841003 	add	r1, r4, r3
   178f8:	e5821000 	str	r1, [r2]
   178fc:	eaffffa4 	b	17794 <_malloc_r+0x468>
   17900:	e3883001 	orr	r3, r8, #1	; 0x1
   17904:	e594000c 	ldr	r0, [r4, #12]
   17908:	e5843004 	str	r3, [r4, #4]
   1790c:	e0843008 	add	r3, r4, r8
   17910:	e5b41008 	ldr	r1, [r4, #8]!
   17914:	e38c2001 	orr	r2, ip, #1	; 0x1
   17918:	e5801008 	str	r1, [r0, #8]
   1791c:	e581000c 	str	r0, [r1, #12]
   17920:	e1a0000a 	mov	r0, sl
   17924:	e5873008 	str	r3, [r7, #8]
   17928:	e587300c 	str	r3, [r7, #12]
   1792c:	e783c00c 	str	ip, [r3, ip]
   17930:	e9830084 	stmib	r3, {r2, r7}
   17934:	e583700c 	str	r7, [r3, #12]
   17938:	ea000007 	b	1795c <_malloc_r+0x630>
   1793c:	e0843003 	add	r3, r4, r3
   17940:	e5932004 	ldr	r2, [r3, #4]
   17944:	e5b41008 	ldr	r1, [r4, #8]!
   17948:	e3822001 	orr	r2, r2, #1	; 0x1
   1794c:	e5832004 	str	r2, [r3, #4]
   17950:	e5801008 	str	r1, [r0, #8]
   17954:	e581000c 	str	r0, [r1, #12]
   17958:	e1a0000a 	mov	r0, sl
   1795c:	eb000024 	bl	179f4 <__malloc_unlock>
   17960:	e1a00004 	mov	r0, r4
   17964:	ea000009 	b	17990 <_malloc_r+0x664>
   17968:	e0843003 	add	r3, r4, r3
   1796c:	e5932004 	ldr	r2, [r3, #4]
   17970:	e5941008 	ldr	r1, [r4, #8]
   17974:	e3822001 	orr	r2, r2, #1	; 0x1
   17978:	e5801008 	str	r1, [r0, #8]
   1797c:	e5832004 	str	r2, [r3, #4]
   17980:	e581000c 	str	r0, [r1, #12]
   17984:	e1a0000a 	mov	r0, sl
   17988:	eb000019 	bl	179f4 <__malloc_unlock>
   1798c:	e2840008 	add	r0, r4, #8	; 0x8
   17990:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17994:	e12fff1e 	bx	lr
   17998:	40000080 	andmi	r0, r0, r0, lsl #1
   1799c:	00000554 	andeq	r0, r0, r4, asr r5
   179a0:	40001204 	andmi	r1, r0, r4, lsl #4
   179a4:	4000048c 	andmi	r0, r0, ip, lsl #9
   179a8:	40001210 	andmi	r1, r0, r0, lsl r2
   179ac:	40001208 	andmi	r1, r0, r8, lsl #4
   179b0:	4000120c 	andmi	r1, r0, ip, lsl #4

000179b4 <memcpy>:
   179b4:	e3a0c000 	mov	ip, #0	; 0x0
   179b8:	ea000002 	b	179c8 <memcpy+0x14>
   179bc:	e7dc3001 	ldrb	r3, [ip, r1]
   179c0:	e7cc3000 	strb	r3, [ip, r0]
   179c4:	e28cc001 	add	ip, ip, #1	; 0x1
   179c8:	e2522001 	subs	r2, r2, #1	; 0x1
   179cc:	2afffffa 	bcs	179bc <memcpy+0x8>
   179d0:	e12fff1e 	bx	lr

000179d4 <memset>:
   179d4:	e3a03000 	mov	r3, #0	; 0x0
   179d8:	ea000001 	b	179e4 <memset+0x10>
   179dc:	e7c31000 	strb	r1, [r3, r0]
   179e0:	e2833001 	add	r3, r3, #1	; 0x1
   179e4:	e2522001 	subs	r2, r2, #1	; 0x1
   179e8:	2afffffb 	bcs	179dc <memset+0x8>
   179ec:	e12fff1e 	bx	lr

000179f0 <__malloc_lock>:
   179f0:	e12fff1e 	bx	lr

000179f4 <__malloc_unlock>:
   179f4:	e12fff1e 	bx	lr

000179f8 <strchr>:
   179f8:	e20110ff 	and	r1, r1, #255	; 0xff
   179fc:	ea000000 	b	17a04 <strchr+0xc>
   17a00:	e2800001 	add	r0, r0, #1	; 0x1
   17a04:	e5d03000 	ldrb	r3, [r0]
   17a08:	e3530000 	cmp	r3, #0	; 0x0
   17a0c:	0a000002 	beq	17a1c <strchr+0x24>
   17a10:	e1530001 	cmp	r3, r1
   17a14:	1afffff9 	bne	17a00 <strchr+0x8>
   17a18:	e12fff1e 	bx	lr
   17a1c:	e3510000 	cmp	r1, #0	; 0x0
   17a20:	13a00000 	movne	r0, #0	; 0x0
   17a24:	e12fff1e 	bx	lr

00017a28 <strcmp>:
   17a28:	ea000000 	b	17a30 <strcmp+0x8>
   17a2c:	e2811001 	add	r1, r1, #1	; 0x1
   17a30:	e5d02000 	ldrb	r2, [r0]
   17a34:	e3520000 	cmp	r2, #0	; 0x0
   17a38:	e2800001 	add	r0, r0, #1	; 0x1
   17a3c:	0a000002 	beq	17a4c <strcmp+0x24>
   17a40:	e5d13000 	ldrb	r3, [r1]
   17a44:	e1530002 	cmp	r3, r2
   17a48:	0afffff7 	beq	17a2c <strcmp+0x4>
   17a4c:	e5d10000 	ldrb	r0, [r1]
   17a50:	e0600002 	rsb	r0, r0, r2
   17a54:	e12fff1e 	bx	lr

00017a58 <strlen>:
   17a58:	e1a02000 	mov	r2, r0
   17a5c:	ea000000 	b	17a64 <strlen+0xc>
   17a60:	e2800001 	add	r0, r0, #1	; 0x1
   17a64:	e5d03000 	ldrb	r3, [r0]
   17a68:	e3530000 	cmp	r3, #0	; 0x0
   17a6c:	1afffffb 	bne	17a60 <strlen+0x8>
   17a70:	e0620000 	rsb	r0, r2, r0
   17a74:	e12fff1e 	bx	lr

00017a78 <strncmp>:
   17a78:	e3520000 	cmp	r2, #0	; 0x0
   17a7c:	01a00002 	moveq	r0, r2
   17a80:	012fff1e 	bxeq	lr
   17a84:	ea000005 	b	17aa0 <strncmp+0x28>
   17a88:	e3520000 	cmp	r2, #0	; 0x0
   17a8c:	0a000009 	beq	17ab8 <strncmp+0x40>
   17a90:	e35c0000 	cmp	ip, #0	; 0x0
   17a94:	0a000007 	beq	17ab8 <strncmp+0x40>
   17a98:	e2800001 	add	r0, r0, #1	; 0x1
   17a9c:	e2811001 	add	r1, r1, #1	; 0x1
   17aa0:	e2522001 	subs	r2, r2, #1	; 0x1
   17aa4:	3a000003 	bcc	17ab8 <strncmp+0x40>
   17aa8:	e5d1c000 	ldrb	ip, [r1]
   17aac:	e5d03000 	ldrb	r3, [r0]
   17ab0:	e15c0003 	cmp	ip, r3
   17ab4:	0afffff3 	beq	17a88 <strncmp+0x10>
   17ab8:	e5d02000 	ldrb	r2, [r0]
   17abc:	e5d13000 	ldrb	r3, [r1]
   17ac0:	e0630002 	rsb	r0, r3, r2
   17ac4:	e12fff1e 	bx	lr

00017ac8 <strncpy>:
   17ac8:	e1a0c000 	mov	ip, r0
   17acc:	ea000005 	b	17ae8 <strncpy+0x20>
   17ad0:	e5d13000 	ldrb	r3, [r1]
   17ad4:	e3530000 	cmp	r3, #0	; 0x0
   17ad8:	e2422001 	sub	r2, r2, #1	; 0x1
   17adc:	e4cc3001 	strb	r3, [ip], #1
   17ae0:	0a000002 	beq	17af0 <strncpy+0x28>
   17ae4:	e2811001 	add	r1, r1, #1	; 0x1
   17ae8:	e3520000 	cmp	r2, #0	; 0x0
   17aec:	1afffff7 	bne	17ad0 <strncpy+0x8>
   17af0:	e1a0100c 	mov	r1, ip
   17af4:	ea000001 	b	17b00 <strncpy+0x38>
   17af8:	e3a03000 	mov	r3, #0	; 0x0
   17afc:	e5413001 	strb	r3, [r1, #-1]
   17b00:	e2422001 	sub	r2, r2, #1	; 0x1
   17b04:	e3720001 	cmn	r2, #1	; 0x1
   17b08:	e2811001 	add	r1, r1, #1	; 0x1
   17b0c:	1afffff9 	bne	17af8 <strncpy+0x30>
   17b10:	e12fff1e 	bx	lr

00017b14 <strrchr>:
   17b14:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   17b18:	e2515000 	subs	r5, r1, #0	; 0x0
   17b1c:	e1a03000 	mov	r3, r0
   17b20:	13a04000 	movne	r4, #0	; 0x0
   17b24:	1a000002 	bne	17b34 <strrchr+0x20>
   17b28:	ea000007 	b	17b4c <strrchr+0x38>
   17b2c:	e1a04000 	mov	r4, r0
   17b30:	e2803001 	add	r3, r0, #1	; 0x1
   17b34:	e1a00003 	mov	r0, r3
   17b38:	e1a01005 	mov	r1, r5
   17b3c:	ebffffad 	bl	179f8 <strchr>
   17b40:	e3500000 	cmp	r0, #0	; 0x0
   17b44:	1afffff8 	bne	17b2c <strrchr+0x18>
   17b48:	ea000001 	b	17b54 <strrchr+0x40>
   17b4c:	ebffffa9 	bl	179f8 <strchr>
   17b50:	e1a04000 	mov	r4, r0
   17b54:	e1a00004 	mov	r0, r4
   17b58:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   17b5c:	e12fff1e 	bx	lr

00017b60 <_malloc_trim_r>:
   17b60:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   17b64:	e59f70e4 	ldr	r7, [pc, #228]	; 17c50 <.text+0x7c50>
   17b68:	e1a04001 	mov	r4, r1
   17b6c:	e1a05000 	mov	r5, r0
   17b70:	ebffff9e 	bl	179f0 <__malloc_lock>
   17b74:	e5973008 	ldr	r3, [r7, #8]
   17b78:	e5933004 	ldr	r3, [r3, #4]
   17b7c:	e3c36003 	bic	r6, r3, #3	; 0x3
   17b80:	e0644006 	rsb	r4, r4, r6
   17b84:	e2844efe 	add	r4, r4, #4064	; 0xfe0
   17b88:	e284400f 	add	r4, r4, #15	; 0xf
   17b8c:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
   17b90:	e3c4400f 	bic	r4, r4, #15	; 0xf
   17b94:	e2444a01 	sub	r4, r4, #4096	; 0x1000
   17b98:	e3540a01 	cmp	r4, #4096	; 0x1000
   17b9c:	e3a01000 	mov	r1, #0	; 0x0
   17ba0:	e1a00005 	mov	r0, r5
   17ba4:	ba00001c 	blt	17c1c <_malloc_trim_r+0xbc>
   17ba8:	ebffe75d 	bl	11924 <_sbrk_r>
   17bac:	e5973008 	ldr	r3, [r7, #8]
   17bb0:	e0863003 	add	r3, r6, r3
   17bb4:	e1500003 	cmp	r0, r3
   17bb8:	e2641000 	rsb	r1, r4, #0	; 0x0
   17bbc:	e1a00005 	mov	r0, r5
   17bc0:	1a000015 	bne	17c1c <_malloc_trim_r+0xbc>
   17bc4:	ebffe756 	bl	11924 <_sbrk_r>
   17bc8:	e0643006 	rsb	r3, r4, r6
   17bcc:	e3700001 	cmn	r0, #1	; 0x1
   17bd0:	e3a01000 	mov	r1, #0	; 0x0
   17bd4:	e59fe078 	ldr	lr, [pc, #120]	; 17c54 <.text+0x7c54>
   17bd8:	e383c001 	orr	ip, r3, #1	; 0x1
   17bdc:	e1a00005 	mov	r0, r5
   17be0:	1a000010 	bne	17c28 <_malloc_trim_r+0xc8>
   17be4:	ebffe74e 	bl	11924 <_sbrk_r>
   17be8:	e597c008 	ldr	ip, [r7, #8]
   17bec:	e1a02000 	mov	r2, r0
   17bf0:	e06c3002 	rsb	r3, ip, r2
   17bf4:	e353000f 	cmp	r3, #15	; 0xf
   17bf8:	e1a00005 	mov	r0, r5
   17bfc:	e3831001 	orr	r1, r3, #1	; 0x1
   17c00:	da000005 	ble	17c1c <_malloc_trim_r+0xbc>
   17c04:	e59f304c 	ldr	r3, [pc, #76]	; 17c58 <.text+0x7c58>
   17c08:	e5933000 	ldr	r3, [r3]
   17c0c:	e0633002 	rsb	r3, r3, r2
   17c10:	e59f203c 	ldr	r2, [pc, #60]	; 17c54 <.text+0x7c54>
   17c14:	e58c1004 	str	r1, [ip, #4]
   17c18:	e5823000 	str	r3, [r2]
   17c1c:	ebffff74 	bl	179f4 <__malloc_unlock>
   17c20:	e3a00000 	mov	r0, #0	; 0x0
   17c24:	ea000007 	b	17c48 <_malloc_trim_r+0xe8>
   17c28:	e59e3000 	ldr	r3, [lr]
   17c2c:	e5972008 	ldr	r2, [r7, #8]
   17c30:	e0643003 	rsb	r3, r4, r3
   17c34:	e1a00005 	mov	r0, r5
   17c38:	e582c004 	str	ip, [r2, #4]
   17c3c:	e58e3000 	str	r3, [lr]
   17c40:	ebffff6b 	bl	179f4 <__malloc_unlock>
   17c44:	e3a00001 	mov	r0, #1	; 0x1
   17c48:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   17c4c:	e12fff1e 	bx	lr
   17c50:	40000080 	andmi	r0, r0, r0, lsl #1
   17c54:	40001210 	andmi	r1, r0, r0, lsl r2
   17c58:	4000048c 	andmi	r0, r0, ip, lsl #9

00017c5c <_free_r>:
   17c5c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17c60:	e2515000 	subs	r5, r1, #0	; 0x0
   17c64:	e1a08000 	mov	r8, r0
   17c68:	0a00008c 	beq	17ea0 <_free_r+0x244>
   17c6c:	ebffff5f 	bl	179f0 <__malloc_lock>
   17c70:	e5153004 	ldr	r3, [r5, #-4]
   17c74:	e59f722c 	ldr	r7, [pc, #556]	; 17ea8 <.text+0x7ea8>
   17c78:	e245e008 	sub	lr, r5, #8	; 0x8
   17c7c:	e3c30001 	bic	r0, r3, #1	; 0x1
   17c80:	e08e4000 	add	r4, lr, r0
   17c84:	e5972008 	ldr	r2, [r7, #8]
   17c88:	e5941004 	ldr	r1, [r4, #4]
   17c8c:	e1540002 	cmp	r4, r2
   17c90:	e3c16003 	bic	r6, r1, #3	; 0x3
   17c94:	e2031001 	and	r1, r3, #1	; 0x1
   17c98:	1a000015 	bne	17cf4 <_free_r+0x98>
   17c9c:	e3510000 	cmp	r1, #0	; 0x0
   17ca0:	e0800006 	add	r0, r0, r6
   17ca4:	1a000006 	bne	17cc4 <_free_r+0x68>
   17ca8:	e5151008 	ldr	r1, [r5, #-8]
   17cac:	e061e00e 	rsb	lr, r1, lr
   17cb0:	e59e200c 	ldr	r2, [lr, #12]
   17cb4:	e59e3008 	ldr	r3, [lr, #8]
   17cb8:	e5823008 	str	r3, [r2, #8]
   17cbc:	e583200c 	str	r2, [r3, #12]
   17cc0:	e0800001 	add	r0, r0, r1
   17cc4:	e59f31e0 	ldr	r3, [pc, #480]	; 17eac <.text+0x7eac>
   17cc8:	e5933000 	ldr	r3, [r3]
   17ccc:	e1500003 	cmp	r0, r3
   17cd0:	e3803001 	orr	r3, r0, #1	; 0x1
   17cd4:	e587e008 	str	lr, [r7, #8]
   17cd8:	e58e3004 	str	r3, [lr, #4]
   17cdc:	3a00006d 	bcc	17e98 <_free_r+0x23c>
   17ce0:	e59f31c8 	ldr	r3, [pc, #456]	; 17eb0 <.text+0x7eb0>
   17ce4:	e1a00008 	mov	r0, r8
   17ce8:	e5931000 	ldr	r1, [r3]
   17cec:	ebffff9b 	bl	17b60 <_malloc_trim_r>
   17cf0:	ea000068 	b	17e98 <_free_r+0x23c>
   17cf4:	e3510000 	cmp	r1, #0	; 0x0
   17cf8:	e5846004 	str	r6, [r4, #4]
   17cfc:	13a01000 	movne	r1, #0	; 0x0
   17d00:	1a000009 	bne	17d2c <_free_r+0xd0>
   17d04:	e5152008 	ldr	r2, [r5, #-8]
   17d08:	e062e00e 	rsb	lr, r2, lr
   17d0c:	e59ec008 	ldr	ip, [lr, #8]
   17d10:	e2873008 	add	r3, r7, #8	; 0x8
   17d14:	e15c0003 	cmp	ip, r3
   17d18:	159e300c 	ldrne	r3, [lr, #12]
   17d1c:	1583c008 	strne	ip, [r3, #8]
   17d20:	158c300c 	strne	r3, [ip, #12]
   17d24:	e0800002 	add	r0, r0, r2
   17d28:	03a01001 	moveq	r1, #1	; 0x1
   17d2c:	e0843006 	add	r3, r4, r6
   17d30:	e5933004 	ldr	r3, [r3, #4]
   17d34:	e3130001 	tst	r3, #1	; 0x1
   17d38:	1a000012 	bne	17d88 <_free_r+0x12c>
   17d3c:	e3510000 	cmp	r1, #0	; 0x0
   17d40:	e0800006 	add	r0, r0, r6
   17d44:	1a00000b 	bne	17d78 <_free_r+0x11c>
   17d48:	e5942008 	ldr	r2, [r4, #8]
   17d4c:	e59f3160 	ldr	r3, [pc, #352]	; 17eb4 <.text+0x7eb4>
   17d50:	e1520003 	cmp	r2, r3
   17d54:	1a000007 	bne	17d78 <_free_r+0x11c>
   17d58:	e3803001 	orr	r3, r0, #1	; 0x1
   17d5c:	e582e00c 	str	lr, [r2, #12]
   17d60:	e582e008 	str	lr, [r2, #8]
   17d64:	e78e0000 	str	r0, [lr, r0]
   17d68:	e58e3004 	str	r3, [lr, #4]
   17d6c:	e58e2008 	str	r2, [lr, #8]
   17d70:	e58e200c 	str	r2, [lr, #12]
   17d74:	ea000047 	b	17e98 <_free_r+0x23c>
   17d78:	e2842008 	add	r2, r4, #8	; 0x8
   17d7c:	e892000c 	ldmia	r2, {r2, r3}
   17d80:	e5832008 	str	r2, [r3, #8]
   17d84:	e582300c 	str	r3, [r2, #12]
   17d88:	e3803001 	orr	r3, r0, #1	; 0x1
   17d8c:	e3510000 	cmp	r1, #0	; 0x0
   17d90:	e58e3004 	str	r3, [lr, #4]
   17d94:	e78e0000 	str	r0, [lr, r0]
   17d98:	1a00003e 	bne	17e98 <_free_r+0x23c>
   17d9c:	e3500c02 	cmp	r0, #512	; 0x200
   17da0:	2a00000d 	bcs	17ddc <_free_r+0x180>
   17da4:	e1a001a0 	mov	r0, r0, lsr #3
   17da8:	e5972004 	ldr	r2, [r7, #4]
   17dac:	e1a01120 	mov	r1, r0, lsr #2
   17db0:	e3a03001 	mov	r3, #1	; 0x1
   17db4:	e1822113 	orr	r2, r2, r3, lsl r1
   17db8:	e59f30e8 	ldr	r3, [pc, #232]	; 17ea8 <.text+0x7ea8>
   17dbc:	e0833180 	add	r3, r3, r0, lsl #3
   17dc0:	e5931008 	ldr	r1, [r3, #8]
   17dc4:	e58e300c 	str	r3, [lr, #12]
   17dc8:	e58e1008 	str	r1, [lr, #8]
   17dcc:	e5872004 	str	r2, [r7, #4]
   17dd0:	e581e00c 	str	lr, [r1, #12]
   17dd4:	e583e008 	str	lr, [r3, #8]
   17dd8:	ea00002e 	b	17e98 <_free_r+0x23c>
   17ddc:	e1b014a0 	movs	r1, r0, lsr #9
   17de0:	01a011a0 	moveq	r1, r0, lsr #3
   17de4:	0a000013 	beq	17e38 <_free_r+0x1dc>
   17de8:	e3510004 	cmp	r1, #4	; 0x4
   17dec:	91a03320 	movls	r3, r0, lsr #6
   17df0:	92831038 	addls	r1, r3, #56	; 0x38
   17df4:	9a00000f 	bls	17e38 <_free_r+0x1dc>
   17df8:	e3510014 	cmp	r1, #20	; 0x14
   17dfc:	9281105b 	addls	r1, r1, #91	; 0x5b
   17e00:	9a00000c 	bls	17e38 <_free_r+0x1dc>
   17e04:	e3510054 	cmp	r1, #84	; 0x54
   17e08:	91a03620 	movls	r3, r0, lsr #12
   17e0c:	9283106e 	addls	r1, r3, #110	; 0x6e
   17e10:	9a000008 	bls	17e38 <_free_r+0x1dc>
   17e14:	e3510f55 	cmp	r1, #340	; 0x154
   17e18:	91a037a0 	movls	r3, r0, lsr #15
   17e1c:	92831077 	addls	r1, r3, #119	; 0x77
   17e20:	9a000004 	bls	17e38 <_free_r+0x1dc>
   17e24:	e59f308c 	ldr	r3, [pc, #140]	; 17eb8 <.text+0x7eb8>
   17e28:	e1510003 	cmp	r1, r3
   17e2c:	91a03920 	movls	r3, r0, lsr #18
   17e30:	83a0107e 	movhi	r1, #126	; 0x7e
   17e34:	9283107c 	addls	r1, r3, #124	; 0x7c
   17e38:	e59f3068 	ldr	r3, [pc, #104]	; 17ea8 <.text+0x7ea8>
   17e3c:	e0832181 	add	r2, r3, r1, lsl #3
   17e40:	e592c008 	ldr	ip, [r2, #8]
   17e44:	e15c0002 	cmp	ip, r2
   17e48:	1a000009 	bne	17e74 <_free_r+0x218>
   17e4c:	e5973004 	ldr	r3, [r7, #4]
   17e50:	e3a02001 	mov	r2, #1	; 0x1
   17e54:	e1a01121 	mov	r1, r1, lsr #2
   17e58:	e1833112 	orr	r3, r3, r2, lsl r1
   17e5c:	e1a0200c 	mov	r2, ip
   17e60:	e5873004 	str	r3, [r7, #4]
   17e64:	ea000007 	b	17e88 <_free_r+0x22c>
   17e68:	e59cc008 	ldr	ip, [ip, #8]
   17e6c:	e15c0002 	cmp	ip, r2
   17e70:	0a000003 	beq	17e84 <_free_r+0x228>
   17e74:	e59c3004 	ldr	r3, [ip, #4]
   17e78:	e3c33003 	bic	r3, r3, #3	; 0x3
   17e7c:	e1500003 	cmp	r0, r3
   17e80:	3afffff8 	bcc	17e68 <_free_r+0x20c>
   17e84:	e59c200c 	ldr	r2, [ip, #12]
   17e88:	e58e200c 	str	r2, [lr, #12]
   17e8c:	e58ec008 	str	ip, [lr, #8]
   17e90:	e58ce00c 	str	lr, [ip, #12]
   17e94:	e582e008 	str	lr, [r2, #8]
   17e98:	e1a00008 	mov	r0, r8
   17e9c:	ebfffed4 	bl	179f4 <__malloc_unlock>
   17ea0:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   17ea4:	e12fff1e 	bx	lr
   17ea8:	40000080 	andmi	r0, r0, r0, lsl #1
   17eac:	40000488 	andmi	r0, r0, r8, lsl #9
   17eb0:	40001204 	andmi	r1, r0, r4, lsl #4
   17eb4:	40000088 	andmi	r0, r0, r8, lsl #1
   17eb8:	00000554 	andeq	r0, r0, r4, asr r5

00017ebc <__aeabi_uidiv>:
   17ebc:	e2512001 	subs	r2, r1, #1	; 0x1
   17ec0:	012fff1e 	bxeq	lr
   17ec4:	3a000036 	bcc	17fa4 <__aeabi_uidiv+0xe8>
   17ec8:	e1500001 	cmp	r0, r1
   17ecc:	9a000022 	bls	17f5c <__aeabi_uidiv+0xa0>
   17ed0:	e1110002 	tst	r1, r2
   17ed4:	0a000023 	beq	17f68 <__aeabi_uidiv+0xac>
   17ed8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   17edc:	01a01181 	moveq	r1, r1, lsl #3
   17ee0:	03a03008 	moveq	r3, #8	; 0x8
   17ee4:	13a03001 	movne	r3, #1	; 0x1
   17ee8:	e3510201 	cmp	r1, #268435456	; 0x10000000
   17eec:	31510000 	cmpcc	r1, r0
   17ef0:	31a01201 	movcc	r1, r1, lsl #4
   17ef4:	31a03203 	movcc	r3, r3, lsl #4
   17ef8:	3afffffa 	bcc	17ee8 <__aeabi_uidiv+0x2c>
   17efc:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   17f00:	31510000 	cmpcc	r1, r0
   17f04:	31a01081 	movcc	r1, r1, lsl #1
   17f08:	31a03083 	movcc	r3, r3, lsl #1
   17f0c:	3afffffa 	bcc	17efc <__aeabi_uidiv+0x40>
   17f10:	e3a02000 	mov	r2, #0	; 0x0
   17f14:	e1500001 	cmp	r0, r1
   17f18:	20400001 	subcs	r0, r0, r1
   17f1c:	21822003 	orrcs	r2, r2, r3
   17f20:	e15000a1 	cmp	r0, r1, lsr #1
   17f24:	204000a1 	subcs	r0, r0, r1, lsr #1
   17f28:	218220a3 	orrcs	r2, r2, r3, lsr #1
   17f2c:	e1500121 	cmp	r0, r1, lsr #2
   17f30:	20400121 	subcs	r0, r0, r1, lsr #2
   17f34:	21822123 	orrcs	r2, r2, r3, lsr #2
   17f38:	e15001a1 	cmp	r0, r1, lsr #3
   17f3c:	204001a1 	subcs	r0, r0, r1, lsr #3
   17f40:	218221a3 	orrcs	r2, r2, r3, lsr #3
   17f44:	e3500000 	cmp	r0, #0	; 0x0
   17f48:	11b03223 	movnes	r3, r3, lsr #4
   17f4c:	11a01221 	movne	r1, r1, lsr #4
   17f50:	1affffef 	bne	17f14 <__aeabi_uidiv+0x58>
   17f54:	e1a00002 	mov	r0, r2
   17f58:	e12fff1e 	bx	lr
   17f5c:	03a00001 	moveq	r0, #1	; 0x1
   17f60:	13a00000 	movne	r0, #0	; 0x0
   17f64:	e12fff1e 	bx	lr
   17f68:	e3510801 	cmp	r1, #65536	; 0x10000
   17f6c:	21a01821 	movcs	r1, r1, lsr #16
   17f70:	23a02010 	movcs	r2, #16	; 0x10
   17f74:	33a02000 	movcc	r2, #0	; 0x0
   17f78:	e3510c01 	cmp	r1, #256	; 0x100
   17f7c:	21a01421 	movcs	r1, r1, lsr #8
   17f80:	22822008 	addcs	r2, r2, #8	; 0x8
   17f84:	e3510010 	cmp	r1, #16	; 0x10
   17f88:	21a01221 	movcs	r1, r1, lsr #4
   17f8c:	22822004 	addcs	r2, r2, #4	; 0x4
   17f90:	e3510004 	cmp	r1, #4	; 0x4
   17f94:	82822003 	addhi	r2, r2, #3	; 0x3
   17f98:	908220a1 	addls	r2, r2, r1, lsr #1
   17f9c:	e1a00230 	mov	r0, r0, lsr r2
   17fa0:	e12fff1e 	bx	lr
   17fa4:	e52de008 	str	lr, [sp, #-8]!
   17fa8:	eb0000c7 	bl	182cc <__aeabi_idiv0>
   17fac:	e3a00000 	mov	r0, #0	; 0x0
   17fb0:	e49de008 	ldr	lr, [sp], #8
   17fb4:	e12fff1e 	bx	lr

00017fb8 <__aeabi_uidivmod>:
   17fb8:	e92d4003 	stmdb	sp!, {r0, r1, lr}
   17fbc:	ebffffbe 	bl	17ebc <__aeabi_uidiv>
   17fc0:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
   17fc4:	e0030092 	mul	r3, r2, r0
   17fc8:	e0411003 	sub	r1, r1, r3
   17fcc:	e12fff1e 	bx	lr

00017fd0 <__aeabi_idiv>:
   17fd0:	e3510000 	cmp	r1, #0	; 0x0
   17fd4:	e020c001 	eor	ip, r0, r1
   17fd8:	0a000042 	beq	180e8 <__aeabi_idiv+0x118>
   17fdc:	42611000 	rsbmi	r1, r1, #0	; 0x0
   17fe0:	e2512001 	subs	r2, r1, #1	; 0x1
   17fe4:	0a000027 	beq	18088 <__aeabi_idiv+0xb8>
   17fe8:	e1b03000 	movs	r3, r0
   17fec:	42603000 	rsbmi	r3, r0, #0	; 0x0
   17ff0:	e1530001 	cmp	r3, r1
   17ff4:	9a000026 	bls	18094 <__aeabi_idiv+0xc4>
   17ff8:	e1110002 	tst	r1, r2
   17ffc:	0a000028 	beq	180a4 <__aeabi_idiv+0xd4>
   18000:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   18004:	01a01181 	moveq	r1, r1, lsl #3
   18008:	03a02008 	moveq	r2, #8	; 0x8
   1800c:	13a02001 	movne	r2, #1	; 0x1
   18010:	e3510201 	cmp	r1, #268435456	; 0x10000000
   18014:	31510003 	cmpcc	r1, r3
   18018:	31a01201 	movcc	r1, r1, lsl #4
   1801c:	31a02202 	movcc	r2, r2, lsl #4
   18020:	3afffffa 	bcc	18010 <__aeabi_idiv+0x40>
   18024:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   18028:	31510003 	cmpcc	r1, r3
   1802c:	31a01081 	movcc	r1, r1, lsl #1
   18030:	31a02082 	movcc	r2, r2, lsl #1
   18034:	3afffffa 	bcc	18024 <__aeabi_idiv+0x54>
   18038:	e3a00000 	mov	r0, #0	; 0x0
   1803c:	e1530001 	cmp	r3, r1
   18040:	20433001 	subcs	r3, r3, r1
   18044:	21800002 	orrcs	r0, r0, r2
   18048:	e15300a1 	cmp	r3, r1, lsr #1
   1804c:	204330a1 	subcs	r3, r3, r1, lsr #1
   18050:	218000a2 	orrcs	r0, r0, r2, lsr #1
   18054:	e1530121 	cmp	r3, r1, lsr #2
   18058:	20433121 	subcs	r3, r3, r1, lsr #2
   1805c:	21800122 	orrcs	r0, r0, r2, lsr #2
   18060:	e15301a1 	cmp	r3, r1, lsr #3
   18064:	204331a1 	subcs	r3, r3, r1, lsr #3
   18068:	218001a2 	orrcs	r0, r0, r2, lsr #3
   1806c:	e3530000 	cmp	r3, #0	; 0x0
   18070:	11b02222 	movnes	r2, r2, lsr #4
   18074:	11a01221 	movne	r1, r1, lsr #4
   18078:	1affffef 	bne	1803c <__aeabi_idiv+0x6c>
   1807c:	e35c0000 	cmp	ip, #0	; 0x0
   18080:	42600000 	rsbmi	r0, r0, #0	; 0x0
   18084:	e12fff1e 	bx	lr
   18088:	e13c0000 	teq	ip, r0
   1808c:	42600000 	rsbmi	r0, r0, #0	; 0x0
   18090:	e12fff1e 	bx	lr
   18094:	33a00000 	movcc	r0, #0	; 0x0
   18098:	01a00fcc 	moveq	r0, ip, asr #31
   1809c:	03800001 	orreq	r0, r0, #1	; 0x1
   180a0:	e12fff1e 	bx	lr
   180a4:	e3510801 	cmp	r1, #65536	; 0x10000
   180a8:	21a01821 	movcs	r1, r1, lsr #16
   180ac:	23a02010 	movcs	r2, #16	; 0x10
   180b0:	33a02000 	movcc	r2, #0	; 0x0
   180b4:	e3510c01 	cmp	r1, #256	; 0x100
   180b8:	21a01421 	movcs	r1, r1, lsr #8
   180bc:	22822008 	addcs	r2, r2, #8	; 0x8
   180c0:	e3510010 	cmp	r1, #16	; 0x10
   180c4:	21a01221 	movcs	r1, r1, lsr #4
   180c8:	22822004 	addcs	r2, r2, #4	; 0x4
   180cc:	e3510004 	cmp	r1, #4	; 0x4
   180d0:	82822003 	addhi	r2, r2, #3	; 0x3
   180d4:	908220a1 	addls	r2, r2, r1, lsr #1
   180d8:	e35c0000 	cmp	ip, #0	; 0x0
   180dc:	e1a00233 	mov	r0, r3, lsr r2
   180e0:	42600000 	rsbmi	r0, r0, #0	; 0x0
   180e4:	e12fff1e 	bx	lr
   180e8:	e52de008 	str	lr, [sp, #-8]!
   180ec:	eb000076 	bl	182cc <__aeabi_idiv0>
   180f0:	e3a00000 	mov	r0, #0	; 0x0
   180f4:	e49de008 	ldr	lr, [sp], #8
   180f8:	e12fff1e 	bx	lr

000180fc <__aeabi_idivmod>:
   180fc:	e92d4003 	stmdb	sp!, {r0, r1, lr}
   18100:	ebffffb2 	bl	17fd0 <__aeabi_idiv>
   18104:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
   18108:	e0030092 	mul	r3, r2, r0
   1810c:	e0411003 	sub	r1, r1, r3
   18110:	e12fff1e 	bx	lr

00018114 <__umodsi3>:
   18114:	e2512001 	subs	r2, r1, #1	; 0x1
   18118:	3a00002c 	bcc	181d0 <__umodsi3+0xbc>
   1811c:	11500001 	cmpne	r0, r1
   18120:	03a00000 	moveq	r0, #0	; 0x0
   18124:	81110002 	tsthi	r1, r2
   18128:	00000002 	andeq	r0, r0, r2
   1812c:	912fff1e 	bxls	lr
   18130:	e3a02000 	mov	r2, #0	; 0x0
   18134:	e3510201 	cmp	r1, #268435456	; 0x10000000
   18138:	31510000 	cmpcc	r1, r0
   1813c:	31a01201 	movcc	r1, r1, lsl #4
   18140:	32822004 	addcc	r2, r2, #4	; 0x4
   18144:	3afffffa 	bcc	18134 <__umodsi3+0x20>
   18148:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   1814c:	31510000 	cmpcc	r1, r0
   18150:	31a01081 	movcc	r1, r1, lsl #1
   18154:	32822001 	addcc	r2, r2, #1	; 0x1
   18158:	3afffffa 	bcc	18148 <__umodsi3+0x34>
   1815c:	e2522003 	subs	r2, r2, #3	; 0x3
   18160:	ba00000e 	blt	181a0 <__umodsi3+0x8c>
   18164:	e1500001 	cmp	r0, r1
   18168:	20400001 	subcs	r0, r0, r1
   1816c:	e15000a1 	cmp	r0, r1, lsr #1
   18170:	204000a1 	subcs	r0, r0, r1, lsr #1
   18174:	e1500121 	cmp	r0, r1, lsr #2
   18178:	20400121 	subcs	r0, r0, r1, lsr #2
   1817c:	e15001a1 	cmp	r0, r1, lsr #3
   18180:	204001a1 	subcs	r0, r0, r1, lsr #3
   18184:	e3500001 	cmp	r0, #1	; 0x1
   18188:	e1a01221 	mov	r1, r1, lsr #4
   1818c:	a2522004 	subges	r2, r2, #4	; 0x4
   18190:	aafffff3 	bge	18164 <__umodsi3+0x50>
   18194:	e3120003 	tst	r2, #3	; 0x3
   18198:	13300000 	teqne	r0, #0	; 0x0
   1819c:	0a00000a 	beq	181cc <__umodsi3+0xb8>
   181a0:	e3720002 	cmn	r2, #2	; 0x2
   181a4:	ba000006 	blt	181c4 <__umodsi3+0xb0>
   181a8:	0a000002 	beq	181b8 <__umodsi3+0xa4>
   181ac:	e1500001 	cmp	r0, r1
   181b0:	20400001 	subcs	r0, r0, r1
   181b4:	e1a010a1 	mov	r1, r1, lsr #1
   181b8:	e1500001 	cmp	r0, r1
   181bc:	20400001 	subcs	r0, r0, r1
   181c0:	e1a010a1 	mov	r1, r1, lsr #1
   181c4:	e1500001 	cmp	r0, r1
   181c8:	20400001 	subcs	r0, r0, r1
   181cc:	e12fff1e 	bx	lr
   181d0:	e52de008 	str	lr, [sp, #-8]!
   181d4:	eb00003c 	bl	182cc <__aeabi_idiv0>
   181d8:	e3a00000 	mov	r0, #0	; 0x0
   181dc:	e49de008 	ldr	lr, [sp], #8
   181e0:	e12fff1e 	bx	lr

000181e4 <__modsi3>:
   181e4:	e3510000 	cmp	r1, #0	; 0x0
   181e8:	0a000032 	beq	182b8 <__modsi3+0xd4>
   181ec:	42611000 	rsbmi	r1, r1, #0	; 0x0
   181f0:	e1b0c000 	movs	ip, r0
   181f4:	42600000 	rsbmi	r0, r0, #0	; 0x0
   181f8:	e2512001 	subs	r2, r1, #1	; 0x1
   181fc:	11500001 	cmpne	r0, r1
   18200:	03a00000 	moveq	r0, #0	; 0x0
   18204:	81110002 	tsthi	r1, r2
   18208:	00000002 	andeq	r0, r0, r2
   1820c:	9a000026 	bls	182ac <__modsi3+0xc8>
   18210:	e3a02000 	mov	r2, #0	; 0x0
   18214:	e3510201 	cmp	r1, #268435456	; 0x10000000
   18218:	31510000 	cmpcc	r1, r0
   1821c:	31a01201 	movcc	r1, r1, lsl #4
   18220:	32822004 	addcc	r2, r2, #4	; 0x4
   18224:	3afffffa 	bcc	18214 <__modsi3+0x30>
   18228:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   1822c:	31510000 	cmpcc	r1, r0
   18230:	31a01081 	movcc	r1, r1, lsl #1
   18234:	32822001 	addcc	r2, r2, #1	; 0x1
   18238:	3afffffa 	bcc	18228 <__modsi3+0x44>
   1823c:	e2522003 	subs	r2, r2, #3	; 0x3
   18240:	ba00000e 	blt	18280 <__modsi3+0x9c>
   18244:	e1500001 	cmp	r0, r1
   18248:	20400001 	subcs	r0, r0, r1
   1824c:	e15000a1 	cmp	r0, r1, lsr #1
   18250:	204000a1 	subcs	r0, r0, r1, lsr #1
   18254:	e1500121 	cmp	r0, r1, lsr #2
   18258:	20400121 	subcs	r0, r0, r1, lsr #2
   1825c:	e15001a1 	cmp	r0, r1, lsr #3
   18260:	204001a1 	subcs	r0, r0, r1, lsr #3
   18264:	e3500001 	cmp	r0, #1	; 0x1
   18268:	e1a01221 	mov	r1, r1, lsr #4
   1826c:	a2522004 	subges	r2, r2, #4	; 0x4
   18270:	aafffff3 	bge	18244 <__modsi3+0x60>
   18274:	e3120003 	tst	r2, #3	; 0x3
   18278:	13300000 	teqne	r0, #0	; 0x0
   1827c:	0a00000a 	beq	182ac <__modsi3+0xc8>
   18280:	e3720002 	cmn	r2, #2	; 0x2
   18284:	ba000006 	blt	182a4 <__modsi3+0xc0>
   18288:	0a000002 	beq	18298 <__modsi3+0xb4>
   1828c:	e1500001 	cmp	r0, r1
   18290:	20400001 	subcs	r0, r0, r1
   18294:	e1a010a1 	mov	r1, r1, lsr #1
   18298:	e1500001 	cmp	r0, r1
   1829c:	20400001 	subcs	r0, r0, r1
   182a0:	e1a010a1 	mov	r1, r1, lsr #1
   182a4:	e1500001 	cmp	r0, r1
   182a8:	20400001 	subcs	r0, r0, r1
   182ac:	e35c0000 	cmp	ip, #0	; 0x0
   182b0:	42600000 	rsbmi	r0, r0, #0	; 0x0
   182b4:	e12fff1e 	bx	lr
   182b8:	e52de008 	str	lr, [sp, #-8]!
   182bc:	eb000002 	bl	182cc <__aeabi_idiv0>
   182c0:	e3a00000 	mov	r0, #0	; 0x0
   182c4:	e49de008 	ldr	lr, [sp], #8
   182c8:	e12fff1e 	bx	lr

000182cc <__aeabi_idiv0>:
   182cc:	e12fff1e 	bx	lr

000182d0 <welcome>:
   182d0:	676e6f53 73694c20 0d0a3a74 00000000     Song List:......
	...

000182e8 <NotFound>:
   182e8:	656c6946 746f4e20 756f4620 0021646e     File Not Found!.

000182f8 <USB>:
   182f8:	20425355 6e6e6f43 65746365 00002164     USB Connected!..

00018308 <newline>:
   18308:	0000000a                                ....

0001830c <volume>:
   1830c:	756c6f56 0000656d                       Volume..

00018314 <contrast>:
   18314:	746e6f43 74736172 00000000              Contrast....

00018320 <radio_power>:
   18320:	69646152 6f50206f 00726577              Radio Power.

0001832c <radio_channel_menu>:
   1832c:	69646152 6843206f 656e6e61 0000006c     Radio Channel...

0001833c <settings>:
   1833c:	74746553 73676e69 0000003a              Settings:...

00018348 <text_array>:
   18348:	00000000 f6f60000 e0000000 2800e000     ...............(
   18358:	28fe28fe 54d66400 10ccc208 b24cc626     .(.(.d.T....&.L.
   18368:	000a6c92 0000e000 82443800 44820000     .l.......8D....D
   18378:	50880038 088850f8 08083e08 06050000     8..P.P...>......
   18388:	08080800 00000808 02000606 8060100c     ..............`.
   18398:	a2928a7c fe42007c 86420002 4462928a     |...|.B...B...bD
   183a8:	6c929282 fe503010 a2a2e410 523c9ca2     ...l.0P.......<R
   183b8:	800c9292 80e09886 9292926c 9292606c     ........l...l`..
   183c8:	00007894 00003636 00363500 82442810     .x..66...56..(D.
   183d8:	28282800 82002828 40102844 60908a80     .(((((..D(.@...`
   183e8:	baba827c 88483e62 92fe3e48 7c6c9292     |...b>H.H>....l|
   183f8:	44828282 828282fe 9292fe7c 90fe8292     ...D....|.......
   18408:	7c809090 4e8a8282 101010fe fe8282fe     ...|...N........
   18418:	82848282 fe8080fc 82442810 020202fe     .........(D.....
   18428:	2040fe02 60fefe40 7cfe0c10 7c828282     ..@ @..`...|...|
   18438:	909090fe 82827c60 90fe7e86 64629498     ....`|...~....bd
   18448:	4c929292 80fe8080 0202fc80 04f8fc02     ...L............
   18458:	fcf80402 fc020c02 281028c6 1e20c0c6     .........(.(.. .
   18468:	8a86c020 00c2a292 0082fe00 00000000      ...............
   18478:	10608000 4020020c 01204080 01010101     ..`... @.@ .....
   18488:	00204080 2a2a0400 12fe1e2a 1c1c2222     .@ ...***...""..
   18498:	14222222 1222221c 2a2a1cfe 7e10182a     """..""...***..~
   184a8:	18408090 1e252525 101010fe 5e12000e     ..@.%%%........^
   184b8:	01020002 fe5e1101 22140808 02fe8200     ......^...."....
   184c8:	1c203e00 203e1e20 1c1e2020 1c222222     .> . .>   ..""".
   184d8:	2424243f 24241818 103e013f 12102020     ?$$$..$$?.>.  ..
   184e8:	042a2a2a 123c1000 02023c04 0c303e02     ***...<..<...>0.
   184f8:	38300c02 38061806 14081422 05053822     ..08...8"..."8..
   18508:	26223e05 0022322a 82826c10 02ff0204     .>"&*2"..l......
   18518:	6c828204 10080010 00100818                       ...l.......

00018523 <logo_spark>:
	...
   1852b:	00000078 00000000 00000000 00000000     x...............
   1853b:	000000f0 00000000 00000000 01000000     ................
   1854b:	000000e0 00000000 00000000 01000000     ................
   1855b:	000000e0 00000000 00000000 01000000     ................
   1856b:	000000f0 00000000 00000000 00000000     ................
   1857b:	000080fb 00000000 00000000 00000000     ................
   1858b:	000080ff 00000000 00000000 00000000     ................
   1859b:	0000807f 00000000 00000000 0c000000     ................
   185ab:	0000c03f 00000000 00000000 1c000000     ?...............
   185bb:	0000c03f 00000000 00000000 3c000000     ?..............<
   185cb:	0000c07f 00000000 00000000 3f000000     ...............?
   185db:	000080ff 00000000 00000000 3f000000     ...............?
   185eb:	000080ff 00000000 00000000 3f000000     ...............?
   185fb:	000080ff 00000000 00000000 3f000000     ...............?
   1860b:	000000ff 00000000 00000000 3f000000     ...............?
   1861b:	000000fe 00000000 00000000 3f000000     ...............?
   1862b:	000000fc 00000000 00000000 3f000000     ...............?
   1863b:	000000e0 00000000 00000000 3e000000     ...............>
	...
   18657:	3c000000 00000000 00000000 00000000     ...<............
   18667:	38000000 00000000 00000000 00000000     ...8............
   18677:	30000000 0000000f 00000000 00000000     ...0............
   18687:	200e0000 0000001f 00000000 00000000     ... ............
   18697:	001e0000 0000003f 00000000 00000000     ....?...........
   186a7:	001e0000 0000003c 00000000 00000000     ....<...........
   186b7:	001e0000 0000003c 00000000 019fe00f     ....<...........
   186c7:	1e9e09fc 9f73707f 00000000 87fff13f     .....ps.....?...
   186d7:	3dde3ffe fff378ff 00000080 c7fff93c     .?.=.x......<...
   186e7:	79de3fdf fff378ff 000000c0 cfc37978     .?.y.x......xy..
   186f7:	f01c3f0f e3f3783c 000000c0 e0c1017c     .?..<x......|...
   18707:	e01f3e0f c3f3783c 000000c0 e081c13f     .>..<x......?...
   18717:	e01f3c3f c1f3783c 000000c0 e381f11f     ?<..<x..........
   18727:	e01f3cff c1f3783c 000000c0 e781f907     .<..<x..........
   18737:	f01f3cef c1f3783c 000000c0 ef81f900     .<..<x..........
   18747:	f81e3c07 c1f3783c 000000c0 efc17978     .<..<x......xy..
   18757:	781e3c0f c1f3783c 000000c0 cfe37978     .<.x<x......xy..
   18767:	3c1e3c0f c1f37c3c 000000c0 cffff93f     .<.<<|......?...
   18777:	3e1e3cff c1f37f3c 000000cf 87fff11f     .<.><...........
   18787:	1e1e3cff c1f33f3c 000000c7 039ec107     .<..<?..........
   18797:	020000e0 00200e00 00000000 00800100     ...... .........
	...
   187b3:	00800100 00000000 00000000 00000000     ................
   187c3:	00800300 00c00000 00001800 00000808     ................
   187d3:	c3870100 f0e1e003 08333ef8 00001e3e     .........>3.>...
   187e3:	03860100 e0b00103 083b66dc 00003266     .........f;.f2..
   187f3:	c3870000 4080e103 083b63d8 00003c60     .......@.c;.`<..
   18803:	83870000 4080c103 083f63f8 00000e60     .......@.c?.`...
   18813:	03060000 40b00103 083766d8 00003266     .......@.f7.f2..
   18823:	c3070000 40e0e0e3 08333ec8 00003e3e     .......@.>3.>>..
   18833:	c3070000 40e0e0e3 08333c88 00001e3c     .......@.<3.<...
	...

00018983 <abSense>:
   18983:	00ff0070 0a000000 00000000 0000ffff     p...............
	...

00018995 <abInquiry>:
   18995:	02048000 0000001f 5543504c 20204253     ........LPCUSB  
   189a5:	7373614d 6f747320 65676172 20202020     Mass storage    
   189b5:	20312e30 94000000                                0.1 ...

000189bc <_global_impure_ptr>:
   189bc:	40000494 00006425 00006e4f 0066664f     ...@%d..On..Off.
   189cc:	49204453 2074696e 6f727245 00000a72     SD Init Error...
   189dc:	4f204453 526e6570 20746f6f 6f727245     SD OpenRoot Erro
   189ec:	00000a72 756e616d 20203a66 30257830     r...manuf:  0x%0
   189fc:	0d0a7832 00000000 3a6d656f 20202020     2x......oem:    
   18a0c:	0d0a7325 00000000 646f7270 2020203a     %s......prod:   
   18a1c:	0d0a7325 00000000 3a766572 20202020     %s......rev:    
   18a2c:	78323025 00000d0a 69726573 203a6c61     %02x....serial: 
   18a3c:	30257830 0a786c38 0000000d 65746164     0x%08lx.....date
   18a4c:	2020203a 64323025 3230252f 000d0a64     :   %02d/%02d...
   18a5c:	657a6973 2020203a 0a646c25 0000000d     size:   %ld.....
   18a6c:	79706f63 2020203a 0d0a6425 00000000     copy:   %d......
   18a7c:	702e7277 203a2e72 252f6425 000d0a64     wr.pr.: %d/%d...
   18a8c:	6d726f66 203a7461 0d0a6425 00000000     format: %d......
   18a9c:	65657266 2020203a 2f646c25 0a646c25     free:   %ld/%ld.
   18aac:	0000000d 6e65706f 20676e69 74726170     ....opening part
   18abc:	6f697469 6166206e 64656c69 00000d0a     ition failed....
   18acc:	6e65706f 20676e69 656c6966 74737973     opening filesyst
   18adc:	66206d65 656c6961 000d0a64 0000002f     em failed.../...
   18aec:	6e65706f 20676e69 746f6f72 72696420     opening root dir
   18afc:	6f746365 66207972 656c6961 000d0a64     ectory failed...
   18b0c:	52204453 4e205741 4120544f 4c494156     SD RAW NOT AVAIL
   18b1c:	454c4241 00000d0a 64253d69 6572202c     ABLE....i=%d, re
   18b2c:	6e6f7073 253d6573 000d0a64 65720d0a     sponse=%d.....re
   18b3c:	6e6f7073 203a6573 0d0a6425 00000000     sponse: %d......
   18b4c:	203d2069 66377830 0d0a6666 00000000     i = 0x7fff......
   18b5c:	434f4c42 4953204b 5320455a 45205445     BLOCK SIZE SET E
   18b6c:	0a205252 0000000d 725f6473 725f7761     RR .....sd_raw_r
   18b7c:	20646165 6b726f62 000d0a73 4c4c414d     ead borks...MALL
   18b8c:	4620434f 534c4941 00000d0a 6c696146     OC FAILS....Fail
   18b9c:	52206465 69646165 4820676e 65646165     ed Reading Heade
   18bac:	000d0a72 74696e49 696c6169 676e6973     r...Initialising
   18bbc:	42535520 61747320 000a6b63 72617453      USB stack..Star
   18bcc:	676e6974 42535520 6d6f6320 696e756d     ting USB communi
   18bdc:	69746163 000a6e6f 3a445343 00000000     cation..CSD:....
   18bec:	32302520 00000078 75677241 746e656d      %02x...Argument
   18bfc:	74756f20 20666f20 6e756f62 0a2e7364      out of bounds..
   18c0c:	00000000 72646441 20737365 2074756f     ....Address out 
   18c1c:	6220666f 646e756f 000a2e73 6f727245     of bounds...Erro
   18c2c:	75642072 676e6972 61726520 73206573     r during erase s
   18c3c:	65757165 2e65636e 0000000a 20435243     equence.....CRC 
   18c4c:	6c696166 0a2e6465 00000000 656c6c49     failed......Ille
   18c5c:	206c6167 6d6d6f63 2e646e61 0000000a     gal command.....
   18c6c:	73617245 65722065 20746573 65657328     Erase reset (see
   18c7c:	6e615320 6b736944 636f6420 35702073      SanDisk docs p5
   18c8c:	2933312d 00000a2e 0000002e 6e6b6e55     -13)........Unkn
   18c9c:	206e776f 6f727265 78302072 28207825     own error 0x%x (
   18cac:	20656573 446e6153 206b7369 73636f64     see SanDisk docs
   18cbc:	2d357020 2e293331 0000000a 70736572      p5-13).....resp
   18ccc:	6678303d 00000a66 70736572 78303d21     =0xff...resp!=0x
   18cdc:	000a6666 64726143 20736920 6b636f4c     ff..Card is Lock
   18cec:	0a2e6465 00000000 45205057 65736172     ed......WP Erase
   18cfc:	696b5320 4c202c70 2f6b636f 6f6c6e55      Skip, Lock/Unlo
   18d0c:	43206b63 4620646d 656c6961 000a2e64     ck Cmd Failed...
   18d1c:	656e6547 206c6172 6e55202f 776f6e6b     General / Unknow
   18d2c:	7265206e 20726f72 63202d2d 20647261     n error -- card 
   18d3c:	6b6f7262 2e3f6e65 0000000a 65746e49     broken?.....Inte
   18d4c:	6c616e72 72616320 6f632064 6f72746e     rnal card contro
   18d5c:	72656c6c 72726520 0a2e726f 00000000     ller error......
   18d6c:	64726143 746e6920 616e7265 4345206c     Card internal EC
   18d7c:	61772043 70612073 65696c70 62202c64     C was applied, b
   18d8c:	66207475 656c6961 6f742064 726f6320     ut failed to cor
   18d9c:	74636572 65687420 74616420 000a2e61     rect the data...
   18dac:	74697257 72702065 6365746f 69762074     Write protect vi
   18dbc:	74616c6f 2e6e6f69 0000000a 69206e41     olation.....An i
   18dcc:	6c61766e 73206469 63656c65 6e6f6974     nvalid selection
   18ddc:	6573202c 726f7463 6f662073 72652072     , sectors for er
   18dec:	2e657361 0000000a 2074754f 5220666f     ase.....Out of R
   18dfc:	65676e61 5343202c 764f5f44 72777265     ange, CSD_Overwr
   18e0c:	2e657469 0000000a 6e6b6e55 206e776f     ite.....Unknown 
   18e1c:	6f727265 30203a72 20782578 65657328     error: 0x%x (see
   18e2c:	6e615320 6b736944 636f6420 35702073      SanDisk docs p5
   18e3c:	2934312d 00000a2e 49204453 2074696e     -14)....SD Init 
   18e4c:	656e6f64 0a2e2e2e 00000000 64726143     done........Card
   18e5c:	64696420 2074276e 75746572 74206e72      didn't return t
   18e6c:	72206568 79646165 61747320 202c6574     he ready state, 
   18e7c:	61657262 676e696b 2e707520 000a2e2e     breaking up.....
   18e8c:	49697073 2074696e 20726f66 28495053     spiInit for SPI(
   18e9c:	000a2930 00000043                       0)..C...
