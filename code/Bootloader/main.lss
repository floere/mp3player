
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bl_version_number 00000008  00000000  000080e0  00018000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000626c  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         000008cc  40000200  0000626c  00010200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000768  40000acc  40000acc  00018008  2**2
                  ALLOC
  4 .debug_line   00001672  00000000  00000000  00018008  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005472  00000000  00000000  0001967a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001afe  00000000  00000000  0001eaec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000300  00000000  00000000  000205f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000e00  00000000  00000000  000208f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00002fe9  00000000  00000000  000216f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000098c  00000000  00000000  000246d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000019e6  00000000  00000000  00025065  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000360  00000000  00000000  00026a4b  2**0
                  CONTENTS, READONLY
 13 .debug_ranges 00000358  00000000  00000000  00026dab  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_startup>:
_startup:

# Exception Vectors

_vectors:       ldr     PC, Reset_Addr         
       0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <Reset_Addr>
                ldr     PC, Undef_Addr
       4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <Undef_Addr>
                ldr     PC, SWI_Addr
       8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <SWI_Addr>
                ldr     PC, PAbt_Addr
       c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <PAbt_Addr>
                ldr     PC, DAbt_Addr
      10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <DAbt_Addr>
                nop							/* Reserved Vector (holds Philips ISP checksum) */
      14:	e1a00000 	nop			(mov r0,r0)
                //ldr     PC, [PC,#-0xFF0]	/* see page 71 of "Insiders Guide to the Philips ARM7-Based Microcontrollers" by Trevor Martin  */
				ldr     PC, IRQ_Addr //Original line from DCarne implementation
      18:	e59ff014 	ldr	pc, [pc, #20]	; 34 <IRQ_Addr>
                ldr     PC, FIQ_Addr
      1c:	e59ff014 	ldr	pc, [pc, #20]	; 38 <FIQ_Addr>

00000020 <Reset_Addr>:
      20:	00000040 	andeq	r0, r0, r0, asr #32

00000024 <Undef_Addr>:
      24:	000001b8 	streqh	r0, [r0], -r8

00000028 <SWI_Addr>:
      28:	000001b4 	streqh	r0, [r0], -r4

0000002c <PAbt_Addr>:
      2c:	000001b8 	streqh	r0, [r0], -r8

00000030 <DAbt_Addr>:
      30:	000001b8 	streqh	r0, [r0], -r8

00000034 <IRQ_Addr>:
      34:	000000c0 	andeq	r0, r0, r0, asr #1

00000038 <FIQ_Addr>:
      38:	000001b0 	streqh	r0, [r0], -r0
      3c:	00000000 	andeq	r0, r0, r0

00000040 <Reset_Handler>:

Reset_Addr:     .word   Reset_Handler		/* defined in this module below  */
Undef_Addr:     .word   UNDEF_Routine		/* defined in main.c  */
SWI_Addr:       .word   SWI_Routine			/* defined in main.c  */
PAbt_Addr:      .word   UNDEF_Routine		/* defined in main.c  */
DAbt_Addr:      .word   UNDEF_Routine		/* defined in main.c  */
IRQ_Addr:       .word   IRQ_Handler			/* defined in main.c  */
//IRQ_Addr:       .word   IRQ_Routine			/* defined in main.c  */
FIQ_Addr:       .word   FIQ_Routine			/* defined in main.c  */
                .word   0					/* rounds the vectors and ISR addresses to 64 bytes total  */

# Reset Handler

Reset_Handler:  

				/* Setup a stack for each mode - note that this only sets up a usable stack
				for User mode.   Also each mode is setup with interrupts initially disabled. */
    			  
    			ldr   r0, =_stack_end
      40:	e59f0090 	ldr	r0, [pc, #144]	; d8 <.text+0xd8>
    			msr   CPSR_c, #MODE_UND|I_BIT|F_BIT 	/* Undefined Instruction Mode  */
      44:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    			mov   sp, r0
      48:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #UND_STACK_SIZE
      4c:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_ABT|I_BIT|F_BIT 	/* Abort Mode */
      50:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    			mov   sp, r0
      54:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #ABT_STACK_SIZE
      58:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_FIQ|I_BIT|F_BIT 	/* FIQ Mode */
      5c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    			mov   sp, r0	
      60:	e1a0d000 	mov	sp, r0
   				sub   r0, r0, #FIQ_STACK_SIZE
      64:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_IRQ|I_BIT|F_BIT 	/* IRQ Mode */
      68:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    			mov   sp, r0
      6c:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #IRQ_STACK_SIZE
      70:	e2400080 	sub	r0, r0, #128	; 0x80
    			msr   CPSR_c, #MODE_SVC|I_BIT|F_BIT 	/* Supervisor Mode */
      74:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    			mov   sp, r0
      78:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #SVC_STACK_SIZE
      7c:	e2400080 	sub	r0, r0, #128	; 0x80
    	/*		msr   CPSR_c, #MODE_SYS|I_BIT|F_BIT */	/* User Mode */
    			msr   CPSR_c, #MODE_SYS|F_BIT 	/* User Mode */
      80:	e321f05f 	msr	CPSR_c, #95	; 0x5f
    			mov   sp, r0
      84:	e1a0d000 	mov	sp, r0

				/* copy .data section (Copy from ROM to RAM) */
                ldr     R1, =_etext
      88:	e59f104c 	ldr	r1, [pc, #76]	; dc <.text+0xdc>
                ldr     R2, =_data
      8c:	e59f204c 	ldr	r2, [pc, #76]	; e0 <.text+0xe0>
                ldr     R3, =_edata
      90:	e59f304c 	ldr	r3, [pc, #76]	; e4 <.text+0xe4>
1:        		cmp     R2, R3
      94:	e1520003 	cmp	r2, r3
                ldrlo   R0, [R1], #4
      98:	34910004 	ldrcc	r0, [r1], #4
                strlo   R0, [R2], #4
      9c:	34820004 	strcc	r0, [r2], #4
                blo     1b
      a0:	3afffffb 	bcc	94 <ABT_STACK_SIZE+0x14>

				/* Clear .bss section (Zero init)  */
                mov     R0, #0
      a4:	e3a00000 	mov	r0, #0	; 0x0
                ldr     R1, =_bss_start
      a8:	e59f1038 	ldr	r1, [pc, #56]	; e8 <.text+0xe8>
                ldr     R2, =_bss_end
      ac:	e59f2038 	ldr	r2, [pc, #56]	; ec <.text+0xec>
2:				cmp     R1, R2
      b0:	e1510002 	cmp	r1, r2
                strlo   R0, [R1], #4
      b4:	34810004 	strcc	r0, [r1], #4
                blo     2b
      b8:	3afffffc 	bcc	b0 <ABT_STACK_SIZE+0x30>

				/* Enter the C code  */
                b       main
      bc:	ea00000c 	b	f4 <main>

000000c0 <IRQ_Handler>:

.endfunc

//Needed because of glitch in GCC compiler v4.1.1
IRQ_Handler: 	
				sub lr, lr, #4
      c0:	e24ee004 	sub	lr, lr, #4	; 0x4
				stmdb sp!, {r0-r12, lr}
      c4:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
				ldr r0, =0xFFFFF030
      c8:	e59f0020 	ldr	r0, [pc, #32]	; f0 <.text+0xf0>
				mov lr, pc
      cc:	e1a0e00f 	mov	lr, pc
				ldr pc, [r0]
      d0:	e590f000 	ldr	pc, [r0]
				ldmia sp!, {r0-r12, pc}^
      d4:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^
      d8:	40007edc 	ldrmid	r7, [r0], -ip
      dc:	0000626c 	andeq	r6, r0, ip, ror #4
      e0:	40000200 	andmi	r0, r0, r0, lsl #4
      e4:	40000acc 	andmi	r0, r0, ip, asr #21
      e8:	40000acc 	andmi	r0, r0, ip, asr #21
      ec:	40001234 	andmi	r1, r0, r4, lsr r2
      f0:	fffff030 	undefined instruction 0xfffff030

000000f4 <main>:
#define OFF	1


int main (void)
{
      f4:	e52de004 	str	lr, [sp, #-4]!

	boot_up();
      f8:	eb000069 	bl	2a4 <boot_up>
	rprintf("Boot up complete\n");
      fc:	e59f0084 	ldr	r0, [pc, #132]	; 188 <.text+0x188>
     100:	eb0000b4 	bl	3d8 <rprintf>

	if(IOPIN0 & (1<<23))
     104:	e59f3080 	ldr	r3, [pc, #128]	; 18c <.text+0x18c>
     108:	e5933000 	ldr	r3, [r3]
     10c:	e3130502 	tst	r3, #8388608	; 0x800000
     110:	0a000001 	beq	11c <main+0x28>
	{
		main_msc();
     114:	eb000c8f 	bl	3358 <main_msc>
     118:	ea000001 	b	124 <main+0x30>
	}
	else{
		rprintf("No USB Detected\n");
     11c:	e59f006c 	ldr	r0, [pc, #108]	; 190 <.text+0x190>
     120:	eb0000ac 	bl	3d8 <rprintf>
	}
	
	//Init SD
	if(sd_raw_init())
     124:	eb000526 	bl	15c4 <sd_raw_init>
     128:	e3500000 	cmp	r0, #0	; 0x0
     12c:	0a00000d 	beq	168 <main+0x74>
	{
		openroot();
     130:	eb0002cd 	bl	c6c <openroot>
		rprintf("Root open\n");
     134:	e59f0058 	ldr	r0, [pc, #88]	; 194 <.text+0x194>
     138:	eb0000a6 	bl	3d8 <rprintf>
		if(root_file_exists(FW_FILE))
     13c:	e59f0054 	ldr	r0, [pc, #84]	; 198 <.text+0x198>
     140:	eb0001e2 	bl	8d0 <root_file_exists>
     144:	e3500000 	cmp	r0, #0	; 0x0
     148:	0a00000a 	beq	178 <main+0x84>
		{
			rprintf("New firmware found\n");
     14c:	e59f0048 	ldr	r0, [pc, #72]	; 19c <.text+0x19c>
     150:	eb0000a0 	bl	3d8 <rprintf>
			load_fw(FW_FILE);
     154:	e59f003c 	ldr	r0, [pc, #60]	; 198 <.text+0x198>
     158:	eb000187 	bl	77c <load_fw>
			rprintf("New firmware loaded\n");
     15c:	e59f003c 	ldr	r0, [pc, #60]	; 1a0 <.text+0x1a0>
     160:	eb00009c 	bl	3d8 <rprintf>
     164:	ea000003 	b	178 <main+0x84>
		}
	}
	else{
		//Didn't find a card to initialize
		rprintf("No SD Card Detected\n");
     168:	e59f0034 	ldr	r0, [pc, #52]	; 1a4 <.text+0x1a4>
     16c:	eb000099 	bl	3d8 <rprintf>
		delay_ms(250);
     170:	e3a000fa 	mov	r0, #250	; 0xfa
     174:	eb000010 	bl	1bc <delay_ms>
	}
	rprintf("Boot Done. Calling firmware...\n");
     178:	e59f0028 	ldr	r0, [pc, #40]	; 1a8 <.text+0x1a8>
     17c:	eb000095 	bl	3d8 <rprintf>
	call_firmware();
     180:	eb000177 	bl	764 <call_firmware>
     184:	eafffffe 	b	184 <main+0x90>
     188:	00005d00 	andeq	r5, r0, r0, lsl #26
     18c:	e0028000 	and	r8, r2, r0
     190:	00005d14 	andeq	r5, r0, r4, lsl sp
     194:	00005d28 	andeq	r5, r0, r8, lsr #26
     198:	00005d34 	andeq	r5, r0, r4, lsr sp
     19c:	00005d3c 	andeq	r5, r0, ip, lsr sp
     1a0:	00005d50 	andeq	r5, r0, r0, asr sp
     1a4:	00005d68 	andeq	r5, r0, r8, ror #26
     1a8:	00005d80 	andeq	r5, r0, r0, lsl #27

000001ac <IRQ_Routine>:
/* Define catchall routines for vector table */
void IRQ_Routine (void)   __attribute__ ((interrupt("IRQ")));
void IRQ_Routine (void)
{
}
     1ac:	e25ef004 	subs	pc, lr, #4	; 0x4

000001b0 <FIQ_Routine>:

void FIQ_Routine (void)   __attribute__ ((interrupt("FIQ")));
void FIQ_Routine (void)
{
}
     1b0:	e25ef004 	subs	pc, lr, #4	; 0x4

000001b4 <SWI_Routine>:

void SWI_Routine (void)   __attribute__ ((interrupt("SWI")));
void SWI_Routine (void)
{
}
     1b4:	e1b0f00e 	movs	pc, lr

000001b8 <UNDEF_Routine>:

void UNDEF_Routine (void) __attribute__ ((interrupt("UNDEF")));
void UNDEF_Routine (void)
{
};
     1b8:	e1b0f00e 	movs	pc, lr

000001bc <delay_ms>:

//Short delay
void delay_ms(int count)
{
    int i;
    count *= 10000;
     1bc:	e59f301c 	ldr	r3, [pc, #28]	; 1e0 <.text+0x1e0>
     1c0:	e0000093 	mul	r0, r3, r0
     1c4:	e3a03000 	mov	r3, #0	; 0x0
     1c8:	ea000001 	b	1d4 <delay_ms+0x18>
    for (i = 0; i < count; i++)
    {
        asm volatile ("nop");
     1cc:	e1a00000 	nop			(mov r0,r0)
     1d0:	e2833001 	add	r3, r3, #1	; 0x1
     1d4:	e1530000 	cmp	r3, r0
     1d8:	bafffffb 	blt	1cc <delay_ms+0x10>
    }
}
     1dc:	e12fff1e 	bx	lr
     1e0:	00002710 	andeq	r2, r0, r0, lsl r7

000001e4 <system_init>:

void boot_up(void)
{
    //Initialize the MCU clock PLL
    system_init();

	IODIR0 |= (1 << 31);
	IOCLR0 |= (1 << 31); //Turn on USB LED

    //Init UART0 for debug
    PINSEL0 |= 0x00000005; //enable uart0
    U0LCR = 0x83; // 8 bits, no Parity, 1 Stop bit, DLAB = 1 
    U0DLM = 0x00; 
    U0DLL = 0x20; // 9600 Baud Rate @ 58982400 VPB Clock  
    U0LCR = 0x03; // DLAB = 0                          

    //Init rprintf
    rprintf_devopen(putc_serial0); 
    rprintf("\n\n\nUSB Bootloader v1.1\n");

	//IOSET0 |= (1 << 31); //Turn off USB LED
}

/**********************************************************
  Initialize
 **********************************************************/

#define PLOCK 0x400

void system_init(void)
{
    // Setting Multiplier and Divider values
    PLLCFG=0x24;
     1e4:	e59f2068 	ldr	r2, [pc, #104]	; 254 <.text+0x254>
     1e8:	e3a03024 	mov	r3, #36	; 0x24
     1ec:	e5823084 	str	r3, [r2, #132]
    feed();

    // Enabling the PLL */
    PLLCON=0x1;
    feed();

    // Wait for the PLL to lock to set frequency
    while(!(PLLSTAT & PLOCK)) ;

    // Connect the PLL as the clock source
    PLLCON=0x3;
    feed();

    // Enabling MAM and setting number of clocks used for Flash memory fetch (4 cclks in this case)
    //MAMTIM=0x3; //VCOM?
    MAMCR=0x2;
    MAMTIM=0x4; //Original

    // Setting peripheral Clock (pclk) to System Clock (cclk)
    VPBDIV=0x1;
}

void feed(void)
{
    PLLFEED=0xAA;
     1f0:	e3a010aa 	mov	r1, #170	; 0xaa
    PLLFEED=0x55;
     1f4:	e3a00055 	mov	r0, #85	; 0x55
     1f8:	e3a03001 	mov	r3, #1	; 0x1
     1fc:	e582108c 	str	r1, [r2, #140]
     200:	e582008c 	str	r0, [r2, #140]
     204:	e5823080 	str	r3, [r2, #128]
     208:	e582108c 	str	r1, [r2, #140]
     20c:	e582008c 	str	r0, [r2, #140]
     210:	e59f203c 	ldr	r2, [pc, #60]	; 254 <.text+0x254>
     214:	e5923088 	ldr	r3, [r2, #136]
     218:	e3130b01 	tst	r3, #1024	; 0x400
     21c:	0afffffb 	beq	210 <system_init+0x2c>
     220:	e3a03003 	mov	r3, #3	; 0x3
     224:	e5823080 	str	r3, [r2, #128]
     228:	e28330a7 	add	r3, r3, #167	; 0xa7
     22c:	e582308c 	str	r3, [r2, #140]
     230:	e3a03055 	mov	r3, #85	; 0x55
     234:	e582308c 	str	r3, [r2, #140]
     238:	e3a03002 	mov	r3, #2	; 0x2
     23c:	e5823000 	str	r3, [r2]
     240:	e0833003 	add	r3, r3, r3
     244:	e5823004 	str	r3, [r2, #4]
     248:	e3a03001 	mov	r3, #1	; 0x1
     24c:	e5823100 	str	r3, [r2, #256]
     250:	e12fff1e 	bx	lr
     254:	e01fc000 	ands	ip, pc, r0

00000258 <feed>:
     258:	e59f3010 	ldr	r3, [pc, #16]	; 270 <.text+0x270>
     25c:	e3a020aa 	mov	r2, #170	; 0xaa
     260:	e583208c 	str	r2, [r3, #140]
     264:	e3a02055 	mov	r2, #85	; 0x55
     268:	e583208c 	str	r2, [r3, #140]
}
     26c:	e12fff1e 	bx	lr
     270:	e01fc000 	ands	ip, pc, r0

00000274 <reset>:

void reset(void)
{
    // Intentionally fault Watchdog to trigger a reset condition
    WDMOD |= 3;
     274:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
     278:	e5923000 	ldr	r3, [r2]
     27c:	e3833003 	orr	r3, r3, #3	; 0x3
     280:	e5823000 	str	r3, [r2]
    WDFEED = 0xAA;
     284:	e3a010aa 	mov	r1, #170	; 0xaa
    WDFEED = 0x55;
     288:	e3a03055 	mov	r3, #85	; 0x55
     28c:	e5821008 	str	r1, [r2, #8]
     290:	e5823008 	str	r3, [r2, #8]
    WDFEED = 0xAA;
    WDFEED = 0x00;
     294:	e3a03000 	mov	r3, #0	; 0x0
     298:	e5821008 	str	r1, [r2, #8]
     29c:	e5823008 	str	r3, [r2, #8]
}
     2a0:	e12fff1e 	bx	lr

000002a4 <boot_up>:
     2a4:	e52de004 	str	lr, [sp, #-4]!
     2a8:	ebffffcd 	bl	1e4 <system_init>
     2ac:	e59f2060 	ldr	r2, [pc, #96]	; 314 <.text+0x314>
     2b0:	e5923008 	ldr	r3, [r2, #8]
     2b4:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
     2b8:	e5823008 	str	r3, [r2, #8]
     2bc:	e592300c 	ldr	r3, [r2, #12]
     2c0:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
     2c4:	e582300c 	str	r3, [r2, #12]
     2c8:	e59f1048 	ldr	r1, [pc, #72]	; 318 <.text+0x318>
     2cc:	e5913000 	ldr	r3, [r1]
     2d0:	e3833005 	orr	r3, r3, #5	; 0x5
     2d4:	e5813000 	str	r3, [r1]
     2d8:	e2422907 	sub	r2, r2, #114688	; 0x1c000
     2dc:	e3a03083 	mov	r3, #131	; 0x83
     2e0:	e582300c 	str	r3, [r2, #12]
     2e4:	e3a03000 	mov	r3, #0	; 0x0
     2e8:	e5823004 	str	r3, [r2, #4]
     2ec:	e2833020 	add	r3, r3, #32	; 0x20
     2f0:	e5823000 	str	r3, [r2]
     2f4:	e3a03003 	mov	r3, #3	; 0x3
     2f8:	e59f001c 	ldr	r0, [pc, #28]	; 31c <.text+0x31c>
     2fc:	e582300c 	str	r3, [r2, #12]
     300:	eb000020 	bl	388 <rprintf_devopen>
     304:	e59f0014 	ldr	r0, [pc, #20]	; 320 <.text+0x320>
     308:	eb000032 	bl	3d8 <rprintf>
     30c:	e49de004 	ldr	lr, [sp], #4
     310:	e12fff1e 	bx	lr
     314:	e0028000 	and	r8, r2, r0
     318:	e002c000 	and	ip, r2, r0
     31c:	000006e4 	andeq	r0, r0, r4, ror #13
     320:	00005da0 	andeq	r5, r0, r0, lsr #27

00000324 <_read_r>:
	}
*/
//	return len - i;
	return 0;
}
     324:	e3a00000 	mov	r0, #0	; 0x0
     328:	e12fff1e 	bx	lr

0000032c <_write_r>:

_ssize_t _write_r (
    struct _reent *r, 
    int file, 
    const void *ptr, 
    size_t len)
{
/*
	int i;
	const unsigned char *p;
	
	p = (const unsigned char*) ptr;
	
	for (i = 0; i < len; i++) {
		if (*p == '\n' ) uart0Putch('\r');
		uart0Putch(*p++);
	}
*/
	return len;
}
     32c:	e1a00003 	mov	r0, r3
     330:	e12fff1e 	bx	lr

00000334 <_close_r>:

int _close_r(
    struct _reent *r, 
    int file)
{
	return 0;
}
     334:	e3a00000 	mov	r0, #0	; 0x0
     338:	e12fff1e 	bx	lr

0000033c <_lseek_r>:

_off_t _lseek_r(
    struct _reent *r, 
    int file, 
    _off_t ptr, 
    int dir)
{
	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
}
     33c:	e3a00000 	mov	r0, #0	; 0x0
     340:	e12fff1e 	bx	lr

00000344 <_fstat_r>:


int _fstat_r(
    struct _reent *r, 
    int file, 
    struct stat *st)
{
	/*  Always set as character device.				*/
	st->st_mode = S_IFCHR;	
     344:	e3a03a02 	mov	r3, #8192	; 0x2000
		/* assigned to strong type with implicit 	*/
		/* signed/unsigned conversion.  Required by 	*/
		/* newlib.					*/

	return 0;
}
     348:	e3a00000 	mov	r0, #0	; 0x0
     34c:	e5823004 	str	r3, [r2, #4]
     350:	e12fff1e 	bx	lr

00000354 <isatty>:

int isatty(int file); /* avoid warning */

int isatty(int file)
{
	return 1;
}
     354:	e3a00001 	mov	r0, #1	; 0x1
     358:	e12fff1e 	bx	lr

0000035c <_sbrk_r>:

#if 0
static void _exit (int n) {
label:  goto label; /* endless loop */
}
#endif 

/* "malloc clue function" */

	/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************/
/*  Support function.  Adjusts end of heap to provide more memory to	*/
/* memory allocator. Simple and dumb with no sanity checks.		*/
/*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
/*			support multiple threads of operation.		*/
/*  ptrdiff_t nbytes	-- number of bytes to add.			*/
/*  Returns pointer to start of new heap area.				*/
/*  Note:  This implementation is not thread safe (despite taking a	*/
/* _reent structure as a parameter).  					*/
/*  Since _s_r is not used in the current implementation, the following	*/
/* messages must be suppressed.						*/

void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error	*/

	if (!heap_ptr) {	/*  Initialize if first time through.		*/
     35c:	e59f201c 	ldr	r2, [pc, #28]	; 380 <.text+0x380>
     360:	e5923000 	ldr	r3, [r2]
     364:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
     368:	059f3014 	ldreq	r3, [pc, #20]	; 384 <.text+0x384>
     36c:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.			*/
     370:	e5920000 	ldr	r0, [r2]
	heap_ptr += nbytes;	/*  Increase heap.				*/
     374:	e0803001 	add	r3, r0, r1
     378:	e5823000 	str	r3, [r2]
	
	return base;		/*  Return pointer to start of new heap area.	*/
}
     37c:	e12fff1e 	bx	lr
     380:	40000acc 	andmi	r0, r0, ip, asr #21
     384:	40001234 	andmi	r1, r0, r4, lsr r2

00000388 <rprintf_devopen>:
static int (*putcharfunc)(int c);

void rprintf_devopen( int(*put)(int) )
{
    putcharfunc = put;
     388:	e59f3004 	ldr	r3, [pc, #4]	; 394 <.text+0x394>
     38c:	e5830000 	str	r0, [r3]
}
     390:	e12fff1e 	bx	lr
     394:	40000ad0 	ldrmid	r0, [r0], -r0

00000398 <myputchar>:

static void myputchar(unsigned char c)
{
     398:	e92d4010 	stmdb	sp!, {r4, lr}
     39c:	e20040ff 	and	r4, r0, #255	; 0xff
    if(c == '\n') putcharfunc('\r');
     3a0:	e354000a 	cmp	r4, #10	; 0xa
     3a4:	e3a0000d 	mov	r0, #13	; 0xd
     3a8:	059f3024 	ldreq	r3, [pc, #36]	; 3d4 <.text+0x3d4>
     3ac:	0593c000 	ldreq	ip, [r3]
     3b0:	01a0e00f 	moveq	lr, pc
     3b4:	012fff1c 	bxeq	ip
    putcharfunc(c);
     3b8:	e1a00004 	mov	r0, r4
     3bc:	e59f3010 	ldr	r3, [pc, #16]	; 3d4 <.text+0x3d4>
     3c0:	e593c000 	ldr	ip, [r3]
     3c4:	e1a0e00f 	mov	lr, pc
     3c8:	e12fff1c 	bx	ip
}
     3cc:	e8bd4010 	ldmia	sp!, {r4, lr}
     3d0:	e12fff1e 	bx	lr
     3d4:	40000ad0 	ldrmid	r0, [r0], -r0

000003d8 <rprintf>:

void rprintf(char const *format, ...)
{
     3d8:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
     3dc:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
     3e0:	e24dd010 	sub	sp, sp, #16	; 0x10
    unsigned char scratch[SCRATCH];
    unsigned char format_flag;
    unsigned short base;
    unsigned char *ptr;
    unsigned char issigned=0;
    va_list ap;

    #ifdef USE_LONG
        // #warning "use long"
        unsigned char islong=0;
        unsigned long u_val=0;
        long s_val=0;
    #else
        unsigned int u_val=0;
        int s_val=0;
    #endif

    unsigned char fill;
    unsigned char width;

    va_start (ap, format);
     3e4:	e28d3030 	add	r3, sp, #48	; 0x30
     3e8:	e58d300c 	str	r3, [sp, #12]
     3ec:	e59d502c 	ldr	r5, [sp, #44]
    for (;;)
    {
		delay_ms(1); //Added for VCOM testing - without it, rprintf will overrun the VCOM buffer causing it to crash
     3f0:	e3a00001 	mov	r0, #1	; 0x1
     3f4:	ebffff70 	bl	1bc <delay_ms>
     3f8:	ea000002 	b	408 <rprintf+0x30>
		
        while ((format_flag = *(format++)) != '%')
        {      // Until '%' or '\0'
            if (!format_flag){va_end (ap); return;}
     3fc:	e3530000 	cmp	r3, #0	; 0x0
     400:	0a00008e 	beq	640 <rprintf+0x268>
                myputchar(format_flag);
     404:	ebffffe3 	bl	398 <myputchar>
     408:	e4d53001 	ldrb	r3, [r5], #1
     40c:	e3530025 	cmp	r3, #37	; 0x25
     410:	e1a00003 	mov	r0, r3
     414:	1afffff8 	bne	3fc <rprintf+0x24>
        }

        issigned=0; //default unsigned
        base = 10;

        format_flag = *format++; //get char after '%'
     418:	e4d52001 	ldrb	r2, [r5], #1

        #ifdef PADDING
            width=0; //no formatting
            fill=0;  //no formatting
            if(format_flag=='0' || format_flag==' ') //SPACE or ZERO padding  ?
     41c:	e3520020 	cmp	r2, #32	; 0x20
     420:	13520030 	cmpne	r2, #48	; 0x30
     424:	13a03000 	movne	r3, #0	; 0x0
     428:	03a03001 	moveq	r3, #1	; 0x1
     42c:	11a07003 	movne	r7, r3
     430:	11a00002 	movne	r0, r2
     434:	11a0a007 	movne	sl, r7
     438:	1a000007 	bne	45c <rprintf+0x84>
            {
                fill=format_flag;
                format_flag = *format++; //get char after padding char
     43c:	e4d50001 	ldrb	r0, [r5], #1
                if(format_flag>='0' && format_flag<='9')
     440:	e2403030 	sub	r3, r0, #48	; 0x30
     444:	e20370ff 	and	r7, r3, #255	; 0xff
     448:	e3570009 	cmp	r7, #9	; 0x9
                {
                    width=format_flag-'0';
                    format_flag = *format++; //get char after width char
     44c:	94d50001 	ldrlsb	r0, [r5], #1
     450:	81a0a002 	movhi	sl, r2
     454:	83a07000 	movhi	r7, #0	; 0x0
     458:	91a0a002 	movls	sl, r2
                }
            }
        #endif

        #ifdef USE_LONG
            islong=0; //default int value
            #ifdef USE_UPPER
            if(format_flag=='l' || format_flag=='L') //Long value
     45c:	e350004c 	cmp	r0, #76	; 0x4c
     460:	1350006c 	cmpne	r0, #108	; 0x6c
            #else
            if(format_flag=='l') //Long value
            #endif
        {
            islong=1;
            format_flag = *format++; //get char after 'l' or 'L'
     464:	04d50001 	ldreqb	r0, [r5], #1
     468:	13a03000 	movne	r3, #0	; 0x0
     46c:	03a03001 	moveq	r3, #1	; 0x1
     470:	03a03001 	moveq	r3, #1	; 0x1
        }
        #endif

        switch (format_flag)
     474:	e3500058 	cmp	r0, #88	; 0x58
     478:	0a00003e 	beq	578 <rprintf+0x1a0>
     47c:	8a00000b 	bhi	4b0 <rprintf+0xd8>
     480:	e3500049 	cmp	r0, #73	; 0x49
     484:	0a00006a 	beq	634 <rprintf+0x25c>
     488:	8a000003 	bhi	49c <rprintf+0xc4>
     48c:	e3500043 	cmp	r0, #67	; 0x43
     490:	0a000015 	beq	4ec <rprintf+0x114>
     494:	e3500044 	cmp	r0, #68	; 0x44
     498:	ea00000a 	b	4c8 <rprintf+0xf0>
     49c:	e3500053 	cmp	r0, #83	; 0x53
     4a0:	0a000017 	beq	504 <rprintf+0x12c>
     4a4:	e3500055 	cmp	r0, #85	; 0x55
     4a8:	1a000013 	bne	4fc <rprintf+0x124>
     4ac:	ea000020 	b	534 <rprintf+0x15c>
     4b0:	e3500069 	cmp	r0, #105	; 0x69
     4b4:	0a00005e 	beq	634 <rprintf+0x25c>
     4b8:	8a000004 	bhi	4d0 <rprintf+0xf8>
     4bc:	e3500063 	cmp	r0, #99	; 0x63
     4c0:	0a000009 	beq	4ec <rprintf+0x114>
     4c4:	e3500064 	cmp	r0, #100	; 0x64
     4c8:	1a00000b 	bne	4fc <rprintf+0x124>
     4cc:	ea000058 	b	634 <rprintf+0x25c>
     4d0:	e3500075 	cmp	r0, #117	; 0x75
     4d4:	0a000016 	beq	534 <rprintf+0x15c>
     4d8:	e3500078 	cmp	r0, #120	; 0x78
     4dc:	0a000025 	beq	578 <rprintf+0x1a0>
     4e0:	e3500073 	cmp	r0, #115	; 0x73
     4e4:	1a000004 	bne	4fc <rprintf+0x124>
     4e8:	ea000005 	b	504 <rprintf+0x12c>
        {
            #ifdef USE_CHAR
                case 'c':
                    #ifdef USE_UPPER
                    case 'C':
                #endif
                format_flag = va_arg(ap,int);
     4ec:	e59d200c 	ldr	r2, [sp, #12]
     4f0:	e2823004 	add	r3, r2, #4	; 0x4
     4f4:	e58d300c 	str	r3, [sp, #12]
     4f8:	e5d20000 	ldrb	r0, [r2]
                // no break -> run into default
            #endif

            default:
                myputchar(format_flag);
     4fc:	ebffffa5 	bl	398 <myputchar>
     500:	eaffffba 	b	3f0 <rprintf+0x18>
                continue;

                #ifdef USE_STRING
                    #ifdef USE_UPPER
                    case 'S':
                #endif
                case 's':
                ptr = (unsigned char*)va_arg(ap,char *);
     504:	e59d300c 	ldr	r3, [sp, #12]
     508:	e5936000 	ldr	r6, [r3]
     50c:	e3a04000 	mov	r4, #0	; 0x0
     510:	e2833004 	add	r3, r3, #4	; 0x4
     514:	e58d300c 	str	r3, [sp, #12]
     518:	ea000000 	b	520 <rprintf+0x148>
                while(*ptr) { myputchar(*ptr); ptr++; }
     51c:	ebffff9d 	bl	398 <myputchar>
     520:	e7d43006 	ldrb	r3, [r4, r6]
     524:	e2530000 	subs	r0, r3, #0	; 0x0
     528:	e2844001 	add	r4, r4, #1	; 0x1
     52c:	1afffffa 	bne	51c <rprintf+0x144>
     530:	eaffffae 	b	3f0 <rprintf+0x18>
                    continue;
                #endif

                #ifdef USE_OCTAL
                    case 'o':
                    #ifdef USE_UPPER
                    case 'O':
                #endif
                base = 8;
                myputchar('0');
                goto CONVERSION_LOOP;
                #endif

                #ifdef USE_INTEGER //don't use %i, is same as %d
                    case 'i':
                    #ifdef USE_UPPER
                    case 'I':
                #endif
                #endif
                case 'd':
                #ifdef USE_UPPER
                    case 'D':
                #endif
                issigned=1;
                // no break -> run into next case
            case 'u':
                #ifdef USE_UPPER
                    case 'U':
                #endif

                //don't insert some case below this if USE_HEX is undefined !
                //or put       goto CONVERSION_LOOP;  before next case.
                #ifdef USE_HEX
                    goto CONVERSION_LOOP;
                    case 'x':
                    #ifdef USE_UPPER
                    case 'X':
                #endif
                base = 16;
                #endif

                CONVERSION_LOOP:
     534:	e3a0800a 	mov	r8, #10	; 0xa
     538:	ea00000f 	b	57c <rprintf+0x1a4>

                if(issigned) //Signed types
                {
                    #ifdef USE_LONG
                        if(islong) { s_val = va_arg(ap,long); }
     53c:	e59d300c 	ldr	r3, [sp, #12]
     540:	e5934000 	ldr	r4, [r3]
     544:	e2833004 	add	r3, r3, #4	; 0x4
     548:	e58d300c 	str	r3, [sp, #12]
     54c:	ea000003 	b	560 <rprintf+0x188>
                            else { s_val = va_arg(ap,int); }
     550:	e59d200c 	ldr	r2, [sp, #12]
     554:	e2823004 	add	r3, r2, #4	; 0x4
     558:	e58d300c 	str	r3, [sp, #12]
     55c:	e5924000 	ldr	r4, [r2]
                        #else
                        s_val = va_arg(ap,int);
                    #endif

                    if(s_val < 0) //Value negativ ?
     560:	e3540000 	cmp	r4, #0	; 0x0
                    {
                        s_val = - s_val; //Make it positiv
                        myputchar('-');    //Output sign
     564:	b3a0002d 	movlt	r0, #45	; 0x2d
     568:	b2644000 	rsblt	r4, r4, #0	; 0x0
     56c:	bbffff89 	bllt	398 <myputchar>
                    }

                    u_val = (unsigned long)s_val;
     570:	e3a0800a 	mov	r8, #10	; 0xa
     574:	ea000008 	b	59c <rprintf+0x1c4>
     578:	e3a08010 	mov	r8, #16	; 0x10
     57c:	e59d200c 	ldr	r2, [sp, #12]
                }
                else //Unsigned types
                {
                    #ifdef USE_LONG
                        if(islong) { u_val = va_arg(ap,unsigned long); }
     580:	e3530000 	cmp	r3, #0	; 0x0
     584:	12823004 	addne	r3, r2, #4	; 0x4
                            else { u_val = va_arg(ap,unsigned int); }
     588:	02823004 	addeq	r3, r2, #4	; 0x4
     58c:	15924000 	ldrne	r4, [r2]
     590:	158d300c 	strne	r3, [sp, #12]
     594:	058d300c 	streq	r3, [sp, #12]
     598:	05924000 	ldreq	r4, [r2]
                        #else
                        u_val = va_arg(ap,unsigned int);
                    #endif
                }

                ptr = scratch + SCRATCH;
                *--ptr = 0;
     59c:	e3a03000 	mov	r3, #0	; 0x0
     5a0:	e5cd300b 	strb	r3, [sp, #11]
     5a4:	e28d600b 	add	r6, sp, #11	; 0xb
                do
                {
                    char ch = u_val % base + '0';
     5a8:	e1a00004 	mov	r0, r4
     5ac:	e1a01008 	mov	r1, r8
     5b0:	eb00158e 	bl	5bf0 <__umodsi3>
     5b4:	e2800030 	add	r0, r0, #48	; 0x30
     5b8:	e20030ff 	and	r3, r0, #255	; 0xff
                    #ifdef USE_HEX
                        if (ch > '9')
     5bc:	e3530039 	cmp	r3, #57	; 0x39
                        {
                            ch += 'a' - '9' - 1;
                            #ifdef USE_UPPERHEX
                            ch-=0x20;
     5c0:	e2832007 	add	r2, r3, #7	; 0x7
     5c4:	820230ff 	andhi	r3, r2, #255	; 0xff
                        #endif
                    }
                    #endif
                    *--ptr = ch;
     5c8:	e5463001 	strb	r3, [r6, #-1]
                    u_val /= base;
     5cc:	e1a00004 	mov	r0, r4
     5d0:	e1a01008 	mov	r1, r8
     5d4:	eb0014ef 	bl	5998 <__aeabi_uidiv>

                    #ifdef PADDING
                        if(width) width--; //calculate number of padding chars
     5d8:	e3570000 	cmp	r7, #0	; 0x0
     5dc:	e2473001 	sub	r3, r7, #1	; 0x1
     5e0:	120370ff 	andne	r7, r3, #255	; 0xff
                    #endif
                }
                while (u_val);
     5e4:	e3500000 	cmp	r0, #0	; 0x0
     5e8:	e2466001 	sub	r6, r6, #1	; 0x1
     5ec:	e1a04000 	mov	r4, r0
     5f0:	1affffec 	bne	5a8 <rprintf+0x1d0>
     5f4:	e1a01007 	mov	r1, r7
     5f8:	e1a02006 	mov	r2, r6
     5fc:	ea000000 	b	604 <rprintf+0x22c>

                #ifdef PADDING
                    while(width--) *--ptr = fill; //insert padding chars
     600:	e562a001 	strb	sl, [r2, #-1]!
     604:	e2473001 	sub	r3, r7, #1	; 0x1
     608:	e20370ff 	and	r7, r3, #255	; 0xff
     60c:	e35700ff 	cmp	r7, #255	; 0xff
     610:	1afffffa 	bne	600 <rprintf+0x228>
     614:	e0614006 	rsb	r4, r1, r6
     618:	ea000000 	b	620 <rprintf+0x248>
                #endif

                while(*ptr) { myputchar(*ptr); ptr++; }
     61c:	ebffff5d 	bl	398 <myputchar>
     620:	e5d43000 	ldrb	r3, [r4]
     624:	e2530000 	subs	r0, r3, #0	; 0x0
     628:	e2844001 	add	r4, r4, #1	; 0x1
     62c:	1afffffa 	bne	61c <rprintf+0x244>
     630:	eaffff6e 	b	3f0 <rprintf+0x18>
     634:	e3530000 	cmp	r3, #0	; 0x0
     638:	1affffbf 	bne	53c <rprintf+0x164>
     63c:	eaffffc3 	b	550 <rprintf+0x178>
                    }
        }
    }
     640:	e28dd010 	add	sp, sp, #16	; 0x10
     644:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
     648:	e28dd010 	add	sp, sp, #16	; 0x10
     64c:	e12fff1e 	bx	lr

00000650 <init_serial0>:
void init_serial0 ( unsigned long baudrate )
{
    unsigned long Fdiv;

    PINSEL0 = 0x00000005;                  /* Enable RxD0 and TxD0              */
     650:	e59f3040 	ldr	r3, [pc, #64]	; 698 <.text+0x698>
     654:	e92d4010 	stmdb	sp!, {r4, lr}
     658:	e3a02005 	mov	r2, #5	; 0x5
    U0LCR = 0x83;                          /* 8 bits, no Parity, 1 Stop bit     */
     65c:	e59f4038 	ldr	r4, [pc, #56]	; 69c <.text+0x69c>
     660:	e5832000 	str	r2, [r3]
     664:	e3a03083 	mov	r3, #131	; 0x83
     668:	e1a01000 	mov	r1, r0
     66c:	e584300c 	str	r3, [r4, #12]
    Fdiv = ( Fpclk / 16 ) / baudrate ;     /* baud rate                        */
     670:	e59f0028 	ldr	r0, [pc, #40]	; 6a0 <.text+0x6a0>
     674:	eb0014c7 	bl	5998 <__aeabi_uidiv>
    U0DLM = Fdiv / 256;
    U0DLL = Fdiv % 256;
     678:	e20030ff 	and	r3, r0, #255	; 0xff
     67c:	e1a00420 	mov	r0, r0, lsr #8
     680:	e5840004 	str	r0, [r4, #4]
     684:	e5843000 	str	r3, [r4]
    U0LCR = 0x03;                           /* DLAB = 0                         */
     688:	e3a03003 	mov	r3, #3	; 0x3
     68c:	e584300c 	str	r3, [r4, #12]
}
     690:	e8bd4010 	ldmia	sp!, {r4, lr}
     694:	e12fff1e 	bx	lr
     698:	e002c000 	and	ip, r2, r0
     69c:	e000c000 	and	ip, r0, r0
     6a0:	000e4e1c 	andeq	r4, lr, ip, lsl lr

000006a4 <putchar_serial0>:

/* Write character to Serial Port 0 with \n -> \r\n  */
int putchar_serial0 (int ch)
{
    if (ch == '\n')
     6a4:	e350000a 	cmp	r0, #10	; 0xa
     6a8:	1a000005 	bne	6c4 <putchar_serial0+0x20>
    {
        while (!(U0LSR & 0x20));
     6ac:	e59f202c 	ldr	r2, [pc, #44]	; 6e0 <.text+0x6e0>
     6b0:	e5923014 	ldr	r3, [r2, #20]
     6b4:	e3130020 	tst	r3, #32	; 0x20
     6b8:	0afffffb 	beq	6ac <putchar_serial0+0x8>
        U0THR = CR;                  /* output CR */
     6bc:	e3a0300d 	mov	r3, #13	; 0xd
     6c0:	e5823000 	str	r3, [r2]
    }
    while (!(U0LSR & 0x20));
     6c4:	e59f2014 	ldr	r2, [pc, #20]	; 6e0 <.text+0x6e0>
     6c8:	e5923014 	ldr	r3, [r2, #20]
     6cc:	e3130020 	tst	r3, #32	; 0x20
     6d0:	0afffffb 	beq	6c4 <putchar_serial0+0x20>
    return (U0THR = ch);
     6d4:	e5820000 	str	r0, [r2]
     6d8:	e5920000 	ldr	r0, [r2]
}
     6dc:	e12fff1e 	bx	lr
     6e0:	e000c000 	and	ip, r0, r0

000006e4 <putc_serial0>:

/* Write character to Serial Port 0 without \n -> \r\n  */
int putc_serial0 (int ch)
{
    while (!(U0LSR & 0x20));
     6e4:	e59f2014 	ldr	r2, [pc, #20]	; 700 <.text+0x700>
     6e8:	e5923014 	ldr	r3, [r2, #20]
     6ec:	e3130020 	tst	r3, #32	; 0x20
     6f0:	0afffffb 	beq	6e4 <putc_serial0>
    return (U0THR = ch);
     6f4:	e5820000 	str	r0, [r2]
     6f8:	e5920000 	ldr	r0, [r2]
}
     6fc:	e12fff1e 	bx	lr
     700:	e000c000 	and	ip, r0, r0

00000704 <putstring_serial0>:


void putstring_serial0 (const char *string)
{
     704:	e92d4010 	stmdb	sp!, {r4, lr}
     708:	e1a04000 	mov	r4, r0
     70c:	ea000000 	b	714 <putstring_serial0+0x10>
    char ch;

    while ((ch = *string))
    {
        putchar_serial0(ch);
     710:	ebffffe3 	bl	6a4 <putchar_serial0>
     714:	e5d43000 	ldrb	r3, [r4]
     718:	e2530000 	subs	r0, r3, #0	; 0x0
        string++;
     71c:	e2844001 	add	r4, r4, #1	; 0x1
     720:	1afffffa 	bne	710 <putstring_serial0+0xc>
    }
}
     724:	e8bd4010 	ldmia	sp!, {r4, lr}
     728:	e12fff1e 	bx	lr

0000072c <getkey_serial0>:


/* Read character from Serial Port   */
int getkey_serial0 (void)
{
	if (U0LSR & 0x01)
     72c:	e59f2010 	ldr	r2, [pc, #16]	; 744 <.text+0x744>
     730:	e5923014 	ldr	r3, [r2, #20]
     734:	e2133001 	ands	r3, r3, #1	; 0x1
     738:	e1a00003 	mov	r0, r3
    {
        return (U0RBR);
     73c:	15920000 	ldrne	r0, [r2]
    }
    else
    {
        return 0;
    }
}
     740:	e12fff1e 	bx	lr
     744:	e000c000 	and	ip, r0, r0

00000748 <getc0>:

/* Read character from Serial Port   */
int getc0 (void)
{
	while ( (U0LSR & 0x01) == 0 ); //Wait for character
     748:	e59f2010 	ldr	r2, [pc, #16]	; 760 <.text+0x760>
     74c:	e5923014 	ldr	r3, [r2, #20]
     750:	e3130001 	tst	r3, #1	; 0x1
     754:	0afffffb 	beq	748 <getc0>
	return U0RBR;
     758:	e5920000 	ldr	r0, [r2]
}
     75c:	e12fff1e 	bx	lr
     760:	e000c000 	and	ip, r0, r0

00000764 <call_firmware>:
    return 0;
}

void call_firmware(void)
{
     764:	e52de004 	str	lr, [sp, #-4]!
    /* Note that we're calling a routine that *SHOULD*
           * re-init the stack... so this function should never return...
           */
    void(*fncall)(void)=(void*)STARTADDR;
    fncall();
     768:	e3a03801 	mov	r3, #65536	; 0x10000
     76c:	e1a0e00f 	mov	lr, pc
     770:	e12fff13 	bx	r3

}
     774:	e49de004 	ldr	lr, [sp], #4
     778:	e12fff1e 	bx	lr

0000077c <load_fw>:
     77c:	e59f2130 	ldr	r2, [pc, #304]	; 8b4 <.text+0x8b4>
     780:	e3a03009 	mov	r3, #9	; 0x9
     784:	e5823004 	str	r3, [r2, #4]
     788:	e2833011 	add	r3, r3, #17	; 0x11
     78c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     790:	e5823008 	str	r3, [r2, #8]
     794:	e1a08000 	mov	r8, r0
     798:	e59f4118 	ldr	r4, [pc, #280]	; 8b8 <.text+0x8b8>
     79c:	e1a00002 	mov	r0, r2
     7a0:	e59f1114 	ldr	r1, [pc, #276]	; 8bc <.text+0x8bc>
     7a4:	e594c000 	ldr	ip, [r4]
     7a8:	e1a0e00f 	mov	lr, pc
     7ac:	e12fff1c 	bx	ip
     7b0:	e59f1104 	ldr	r1, [pc, #260]	; 8bc <.text+0x8bc>
     7b4:	e59f0104 	ldr	r0, [pc, #260]	; 8c0 <.text+0x8c0>
     7b8:	e594c000 	ldr	ip, [r4]
     7bc:	e1a0e00f 	mov	lr, pc
     7c0:	e12fff1c 	bx	ip
     7c4:	e1a00008 	mov	r0, r8
     7c8:	eb00010a 	bl	bf8 <root_open>
     7cc:	e59f20f0 	ldr	r2, [pc, #240]	; 8c4 <.text+0x8c4>
     7d0:	e1a07000 	mov	r7, r0
     7d4:	e3a03000 	mov	r3, #0	; 0x0
     7d8:	e4c23001 	strb	r3, [r2], #1
     7dc:	e59f30e4 	ldr	r3, [pc, #228]	; 8c8 <.text+0x8c8>
     7e0:	e1520003 	cmp	r2, r3
     7e4:	1afffffa 	bne	7d4 <load_fw+0x58>
     7e8:	e3a06801 	mov	r6, #65536	; 0x10000
     7ec:	ea000021 	b	878 <load_fw+0xfc>
     7f0:	e3560a79 	cmp	r6, #495616	; 0x79000
     7f4:	a2463a79 	subge	r3, r6, #495616	; 0x79000
     7f8:	b2463902 	sublt	r3, r6, #32768	; 0x8000
     7fc:	a1a03643 	movge	r3, r3, asr #12
     800:	b1a037c3 	movlt	r3, r3, asr #15
     804:	a2832017 	addge	r2, r3, #23	; 0x17
     808:	b2832008 	addlt	r2, r3, #8	; 0x8
     80c:	e59f30a0 	ldr	r3, [pc, #160]	; 8b4 <.text+0x8b4>
     810:	e59f10a4 	ldr	r1, [pc, #164]	; 8bc <.text+0x8bc>
     814:	e1a00003 	mov	r0, r3
     818:	e5832008 	str	r2, [r3, #8]
     81c:	e5832004 	str	r2, [r3, #4]
     820:	e59f5090 	ldr	r5, [pc, #144]	; 8b8 <.text+0x8b8>
     824:	e595c000 	ldr	ip, [r5]
     828:	e1a0e00f 	mov	lr, pc
     82c:	e12fff1c 	bx	ip
     830:	e59f408c 	ldr	r4, [pc, #140]	; 8c4 <.text+0x8c4>
     834:	e59f0090 	ldr	r0, [pc, #144]	; 8cc <.text+0x8cc>
     838:	e3a03c02 	mov	r3, #512	; 0x200
     83c:	e580300c 	str	r3, [r0, #12]
     840:	e5806004 	str	r6, [r0, #4]
     844:	e5804008 	str	r4, [r0, #8]
     848:	e59f106c 	ldr	r1, [pc, #108]	; 8bc <.text+0x8bc>
     84c:	e595c000 	ldr	ip, [r5]
     850:	e1a0e00f 	mov	lr, pc
     854:	e12fff1c 	bx	ip
     858:	e3a03000 	mov	r3, #0	; 0x0
     85c:	e4c43001 	strb	r3, [r4], #1
     860:	e59f3060 	ldr	r3, [pc, #96]	; 8c8 <.text+0x8c8>
     864:	e1540003 	cmp	r4, r3
     868:	1afffffa 	bne	858 <load_fw+0xdc>
     86c:	e2866c02 	add	r6, r6, #512	; 0x200
     870:	e3560a7d 	cmp	r6, #512000	; 0x7d000
     874:	0a000006 	beq	894 <load_fw+0x118>
     878:	e1a00007 	mov	r0, r7
     87c:	e59f1040 	ldr	r1, [pc, #64]	; 8c4 <.text+0x8c4>
     880:	e3a02c02 	mov	r2, #512	; 0x200
     884:	eb000593 	bl	1ed8 <fat16_read_file>
     888:	e1a00800 	mov	r0, r0, lsl #16
     88c:	e3500000 	cmp	r0, #0	; 0x0
     890:	caffffd6 	bgt	7f0 <load_fw+0x74>
     894:	eb00030c 	bl	14cc <sd_raw_sync>
     898:	e1a00007 	mov	r0, r7
     89c:	eb0008cc 	bl	2bd4 <fat16_close_file>
     8a0:	e1a00008 	mov	r0, r8
     8a4:	eb000016 	bl	904 <root_delete>
     8a8:	e3a00000 	mov	r0, #0	; 0x0
     8ac:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
     8b0:	e12fff1e 	bx	lr
     8b4:	40000204 	andmi	r0, r0, r4, lsl #4
     8b8:	40000200 	andmi	r0, r0, r0, lsl #4
     8bc:	400011f0 	strmid	r1, [r0], -r0
     8c0:	4000022c 	andmi	r0, r0, ip, lsr #4
     8c4:	40000ff0 	strmid	r0, [r0], -r0
     8c8:	400011f0 	strmid	r1, [r0], -r0
     8cc:	40000218 	andmi	r0, r0, r8, lsl r2

000008d0 <root_file_exists>:

/* returns 1 if file exists, 0 else */
int root_file_exists(char* name)
{
    return(find_file_in_dir(fs,dd,name,&dir_entry));
     8d0:	e59f3020 	ldr	r3, [pc, #32]	; 8f8 <.text+0x8f8>
     8d4:	e5931000 	ldr	r1, [r3]
     8d8:	e59f301c 	ldr	r3, [pc, #28]	; 8fc <.text+0x8fc>
     8dc:	e1a02000 	mov	r2, r0
     8e0:	e52de004 	str	lr, [sp, #-4]!
     8e4:	e5930000 	ldr	r0, [r3]
     8e8:	e59f3010 	ldr	r3, [pc, #16]	; 900 <.text+0x900>
     8ec:	eb0006e4 	bl	2484 <find_file_in_dir>
}
     8f0:	e49de004 	ldr	lr, [sp], #4
     8f4:	e12fff1e 	bx	lr
     8f8:	40001230 	andmi	r1, r0, r0, lsr r2
     8fc:	400011f8 	strmid	r1, [r0], -r8
     900:	400011fc 	strmid	r1, [r0], -ip

00000904 <root_delete>:

/* returns NULL if error, pointer if file opened */
struct fat16_file_struct * root_open_new(char* name)
{
    if(fat16_create_file(dd,name,&dir_entry))
    {
        return(open_file_in_dir(fs,dd,name));
    }
    else
    {
        return NULL;
    }
}

struct fat16_file_struct * root_open(char* name)
{
    return(open_file_in_dir(fs,dd,name));
}

uint8_t print_disk_info(const struct fat16_fs_struct* disk_fs)
{
    if(!disk_fs)
        return 0;

    struct sd_raw_info disk_info;
    if(!sd_raw_get_info(&disk_info))
        return 0;

//    int temp = get_output();
//    set_output(UART_ONLY);
    rprintf("manuf:  0x%02x\n\r", disk_info.manufacturer);
    rprintf("oem:    %s\n\r", disk_info.oem);
    rprintf("prod:   %s\n\r", disk_info.product);
    rprintf("rev:    %02x\n\r", disk_info.revision);
    rprintf("serial: 0x%08lx\n\r", disk_info.serial);
    rprintf("date:   %02d/%02d\n\r", disk_info.manufacturing_month, disk_info.manufacturing_year);
    rprintf("size:   %ld\n\r", disk_info.capacity);
    rprintf("copy:   %d\n\r", disk_info.flag_copy);
    rprintf("wr.pr.: %d/%d\n\r", disk_info.flag_write_protect_temp, disk_info.flag_write_protect);
    rprintf("format: %d\n\r", disk_info.format);
    rprintf("free:   %ld/%ld\n\r", fat16_get_fs_free(disk_fs), fat16_get_fs_size(disk_fs));
//    set_output(temp);
    return 1;
}

void root_disk_info(void)
{
    print_disk_info(fs);
}

/* sequential calls return sequential characters
 * of the sequence of file names in the rootdir
 * in place of '\0' it returns ',' only
 * returning a zero when the end of all files
 * has been reached.
 *
 * Assert (1) reset whenever you want to re-start
 */
char rootDirectory_files_stream(int reset)
{

    static int idx = 0;

    /* If reset, we need to reset the dir */
    if(reset)
    {
        fat16_reset_dir(dd);
        return 0;
    }

    /* Whenever IDX is zero, we're gonna start a new file,
       * so read a new one.
       * if there's no new file,
       * return 0, because it's over
       */
    if(idx == 0)
    {
        if(fat16_read_dir(dd,&dir_entry)==0)
        {
            return '\0';
        }
    }

    /* If we've reached the end of a string,
       * return comma instead of \0,
       * so the list is comma delimited,
       * and terminated with a zero
       */
    if(dir_entry.long_name[idx]=='\0')
    {
        idx = 0;
        return ',';
    }


    return dir_entry.long_name[idx++];

}
//Description: Fills buf with len number of chars.  Returns the number of files
//				that were cycled through during the read
//Pre: buf is an array of characters at least as big as len
//		len is the size of the array to read
//Post: buf contains the characters of the filenames in Root, starting at the first file
//		and ending after len characters
int rootDirectory_files(char* buf, int len)
{
    int i;
    int num=0;
    /* Loop will walk through every file in directory dd */
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        i = 0;
        /* Spin through the filename */
        while(dir_entry.long_name[i]!='\0')
        {
            /* And copy each character into buf */
            *buf++=dir_entry.long_name[i++];
            len--;
            if(len==1)
            {
                /* Buf if we ever get to the end of buf, quit */
                *buf='\0';
                return 1;
            }
        }
        *buf++=',';
        num++;
        len--;
        if(len==1)
        {
            /* Buf if we ever get to the end of buf, quit */
            *buf='\0';
            return 1;
        }
    }
    *buf='\0';
    return num;
}

void root_format(void)
{
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        fat16_delete_file(fs,&dir_entry);
        fat16_reset_dir(dd);
    }
}

int root_delete(char* filename)
{
     904:	e92d4010 	stmdb	sp!, {r4, lr}
    if(find_file_in_dir(fs,dd,filename,&dir_entry))
     908:	e59f3038 	ldr	r3, [pc, #56]	; 948 <.text+0x948>
     90c:	e59f4038 	ldr	r4, [pc, #56]	; 94c <.text+0x94c>
     910:	e5931000 	ldr	r1, [r3]
     914:	e1a02000 	mov	r2, r0
     918:	e59f3030 	ldr	r3, [pc, #48]	; 950 <.text+0x950>
     91c:	e5940000 	ldr	r0, [r4]
     920:	eb0006d7 	bl	2484 <find_file_in_dir>
     924:	e3500000 	cmp	r0, #0	; 0x0
    {
        fat16_delete_file(fs,&dir_entry);
     928:	e59f1020 	ldr	r1, [pc, #32]	; 950 <.text+0x950>
     92c:	e3a00001 	mov	r0, #1	; 0x1
     930:	0a000002 	beq	940 <root_delete+0x3c>
     934:	e5940000 	ldr	r0, [r4]
     938:	eb0005d4 	bl	2090 <fat16_delete_file>
     93c:	e3a00000 	mov	r0, #0	; 0x0
        return 0;
    }
    return 1;
}
     940:	e8bd4010 	ldmia	sp!, {r4, lr}
     944:	e12fff1e 	bx	lr
     948:	40001230 	andmi	r1, r0, r0, lsr r2
     94c:	400011f8 	strmid	r1, [r0], -r8
     950:	400011fc 	strmid	r1, [r0], -ip

00000954 <root_format>:
     954:	e92d4010 	stmdb	sp!, {r4, lr}
     958:	e59f303c 	ldr	r3, [pc, #60]	; 99c <.text+0x99c>
     95c:	e5930000 	ldr	r0, [r3]
     960:	ea000003 	b	974 <root_format+0x20>
     964:	e59f3034 	ldr	r3, [pc, #52]	; 9a0 <.text+0x9a0>
     968:	e5930000 	ldr	r0, [r3]
     96c:	eb0005c7 	bl	2090 <fat16_delete_file>
     970:	e5940000 	ldr	r0, [r4]
     974:	e59f4020 	ldr	r4, [pc, #32]	; 99c <.text+0x99c>
     978:	eb0005bd 	bl	2074 <fat16_reset_dir>
     97c:	e59f1020 	ldr	r1, [pc, #32]	; 9a4 <.text+0x9a4>
     980:	e5940000 	ldr	r0, [r4]
     984:	eb000638 	bl	226c <fat16_read_dir>
     988:	e3500000 	cmp	r0, #0	; 0x0
     98c:	e59f1010 	ldr	r1, [pc, #16]	; 9a4 <.text+0x9a4>
     990:	1afffff3 	bne	964 <root_format+0x10>
     994:	e8bd4010 	ldmia	sp!, {r4, lr}
     998:	e12fff1e 	bx	lr
     99c:	40001230 	andmi	r1, r0, r0, lsr r2
     9a0:	400011f8 	strmid	r1, [r0], -r8
     9a4:	400011fc 	strmid	r1, [r0], -ip

000009a8 <rootDirectory_files>:
     9a8:	e59f30a0 	ldr	r3, [pc, #160]	; a50 <.text+0xa50>
     9ac:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
     9b0:	e1a04000 	mov	r4, r0
     9b4:	e5930000 	ldr	r0, [r3]
     9b8:	e1a05001 	mov	r5, r1
     9bc:	eb0005ac 	bl	2074 <fat16_reset_dir>
     9c0:	e3a06000 	mov	r6, #0	; 0x0
     9c4:	ea000017 	b	a28 <rootDirectory_files+0x80>
     9c8:	e3520001 	cmp	r2, #1	; 0x1
     9cc:	e5c41000 	strb	r1, [r4]
     9d0:	e1a04000 	mov	r4, r0
     9d4:	1a000004 	bne	9ec <rootDirectory_files+0x44>
     9d8:	e3a03000 	mov	r3, #0	; 0x0
     9dc:	e1a06002 	mov	r6, r2
     9e0:	e5c03000 	strb	r3, [r0]
     9e4:	ea000016 	b	a44 <rootDirectory_files+0x9c>
     9e8:	e59f3064 	ldr	r3, [pc, #100]	; a54 <.text+0xa54>
     9ec:	e5d31000 	ldrb	r1, [r3]
     9f0:	e2452001 	sub	r2, r5, #1	; 0x1
     9f4:	e3510000 	cmp	r1, #0	; 0x0
     9f8:	e2833001 	add	r3, r3, #1	; 0x1
     9fc:	e1a05002 	mov	r5, r2
     a00:	e2840001 	add	r0, r4, #1	; 0x1
     a04:	1affffef 	bne	9c8 <rootDirectory_files+0x20>
     a08:	e3a0302c 	mov	r3, #44	; 0x2c
     a0c:	e3520001 	cmp	r2, #1	; 0x1
     a10:	e5c43000 	strb	r3, [r4]
     a14:	e1a04000 	mov	r4, r0
     a18:	01a06002 	moveq	r6, r2
     a1c:	05c01000 	streqb	r1, [r0]
     a20:	0a000007 	beq	a44 <rootDirectory_files+0x9c>
     a24:	e2866001 	add	r6, r6, #1	; 0x1
     a28:	e59f3020 	ldr	r3, [pc, #32]	; a50 <.text+0xa50>
     a2c:	e59f1020 	ldr	r1, [pc, #32]	; a54 <.text+0xa54>
     a30:	e5930000 	ldr	r0, [r3]
     a34:	eb00060c 	bl	226c <fat16_read_dir>
     a38:	e3500000 	cmp	r0, #0	; 0x0
     a3c:	1affffe9 	bne	9e8 <rootDirectory_files+0x40>
     a40:	e5c40000 	strb	r0, [r4]
     a44:	e1a00006 	mov	r0, r6
     a48:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
     a4c:	e12fff1e 	bx	lr
     a50:	40001230 	andmi	r1, r0, r0, lsr r2
     a54:	400011fc 	strmid	r1, [r0], -ip

00000a58 <rootDirectory_files_stream>:
     a58:	e3500000 	cmp	r0, #0	; 0x0
     a5c:	e52de004 	str	lr, [sp, #-4]!
     a60:	0a000004 	beq	a78 <rootDirectory_files_stream+0x20>
     a64:	e59f3064 	ldr	r3, [pc, #100]	; ad0 <.text+0xad0>
     a68:	e5930000 	ldr	r0, [r3]
     a6c:	eb000580 	bl	2074 <fat16_reset_dir>
     a70:	e3a00000 	mov	r0, #0	; 0x0
     a74:	ea000013 	b	ac8 <rootDirectory_files_stream+0x70>
     a78:	e59f3054 	ldr	r3, [pc, #84]	; ad4 <.text+0xad4>
     a7c:	e5933000 	ldr	r3, [r3]
     a80:	e3530000 	cmp	r3, #0	; 0x0
     a84:	e59f104c 	ldr	r1, [pc, #76]	; ad8 <.text+0xad8>
     a88:	1a000004 	bne	aa0 <rootDirectory_files_stream+0x48>
     a8c:	e59f303c 	ldr	r3, [pc, #60]	; ad0 <.text+0xad0>
     a90:	e5930000 	ldr	r0, [r3]
     a94:	eb0005f4 	bl	226c <fat16_read_dir>
     a98:	e3500000 	cmp	r0, #0	; 0x0
     a9c:	0a000009 	beq	ac8 <rootDirectory_files_stream+0x70>
     aa0:	e59f102c 	ldr	r1, [pc, #44]	; ad4 <.text+0xad4>
     aa4:	e59f302c 	ldr	r3, [pc, #44]	; ad8 <.text+0xad8>
     aa8:	e5912000 	ldr	r2, [r1]
     aac:	e7d33002 	ldrb	r3, [r3, r2]
     ab0:	e2822001 	add	r2, r2, #1	; 0x1
     ab4:	e3530000 	cmp	r3, #0	; 0x0
     ab8:	05813000 	streq	r3, [r1]
     abc:	15812000 	strne	r2, [r1]
     ac0:	e3a0002c 	mov	r0, #44	; 0x2c
     ac4:	11a00003 	movne	r0, r3
     ac8:	e49de004 	ldr	lr, [sp], #4
     acc:	e12fff1e 	bx	lr
     ad0:	40001230 	andmi	r1, r0, r0, lsr r2
     ad4:	40000ad4 	ldrmid	r0, [r0], -r4
     ad8:	400011fc 	strmid	r1, [r0], -ip

00000adc <print_disk_info>:
     adc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     ae0:	e2505000 	subs	r5, r0, #0	; 0x0
     ae4:	e24dd01c 	sub	sp, sp, #28	; 0x1c
     ae8:	e1a0400d 	mov	r4, sp
     aec:	e1a0000d 	mov	r0, sp
     af0:	0a00002d 	beq	bac <print_disk_info+0xd0>
     af4:	eb0000f2 	bl	ec4 <sd_raw_get_info>
     af8:	e3500000 	cmp	r0, #0	; 0x0
     afc:	e59f00b8 	ldr	r0, [pc, #184]	; bbc <.text+0xbbc>
     b00:	0a000029 	beq	bac <print_disk_info+0xd0>
     b04:	e5dd1000 	ldrb	r1, [sp]
     b08:	ebfffe32 	bl	3d8 <rprintf>
     b0c:	e59f00ac 	ldr	r0, [pc, #172]	; bc0 <.text+0xbc0>
     b10:	e28d1001 	add	r1, sp, #1	; 0x1
     b14:	ebfffe2f 	bl	3d8 <rprintf>
     b18:	e28d1004 	add	r1, sp, #4	; 0x4
     b1c:	e59f00a0 	ldr	r0, [pc, #160]	; bc4 <.text+0xbc4>
     b20:	ebfffe2c 	bl	3d8 <rprintf>
     b24:	e59f009c 	ldr	r0, [pc, #156]	; bc8 <.text+0xbc8>
     b28:	e5dd100a 	ldrb	r1, [sp, #10]
     b2c:	ebfffe29 	bl	3d8 <rprintf>
     b30:	e59f0094 	ldr	r0, [pc, #148]	; bcc <.text+0xbcc>
     b34:	e59d100c 	ldr	r1, [sp, #12]
     b38:	ebfffe26 	bl	3d8 <rprintf>
     b3c:	e5dd2010 	ldrb	r2, [sp, #16]
     b40:	e59f0088 	ldr	r0, [pc, #136]	; bd0 <.text+0xbd0>
     b44:	e5dd1011 	ldrb	r1, [sp, #17]
     b48:	ebfffe22 	bl	3d8 <rprintf>
     b4c:	e59f0080 	ldr	r0, [pc, #128]	; bd4 <.text+0xbd4>
     b50:	e59d1014 	ldr	r1, [sp, #20]
     b54:	ebfffe1f 	bl	3d8 <rprintf>
     b58:	e59f0078 	ldr	r0, [pc, #120]	; bd8 <.text+0xbd8>
     b5c:	e5dd1018 	ldrb	r1, [sp, #24]
     b60:	ebfffe1c 	bl	3d8 <rprintf>
     b64:	e5dd2019 	ldrb	r2, [sp, #25]
     b68:	e59f006c 	ldr	r0, [pc, #108]	; bdc <.text+0xbdc>
     b6c:	e5dd101a 	ldrb	r1, [sp, #26]
     b70:	ebfffe18 	bl	3d8 <rprintf>
     b74:	e5dd101b 	ldrb	r1, [sp, #27]
     b78:	e59f0060 	ldr	r0, [pc, #96]	; be0 <.text+0xbe0>
     b7c:	ebfffe15 	bl	3d8 <rprintf>
     b80:	e1a00005 	mov	r0, r5
     b84:	eb000575 	bl	2160 <fat16_get_fs_free>
     b88:	e1a04000 	mov	r4, r0
     b8c:	e1a00005 	mov	r0, r5
     b90:	eb000569 	bl	213c <fat16_get_fs_size>
     b94:	e1a01004 	mov	r1, r4
     b98:	e1a02000 	mov	r2, r0
     b9c:	e59f0040 	ldr	r0, [pc, #64]	; be4 <.text+0xbe4>
     ba0:	ebfffe0c 	bl	3d8 <rprintf>
     ba4:	e3a00001 	mov	r0, #1	; 0x1
     ba8:	ea000000 	b	bb0 <print_disk_info+0xd4>
     bac:	e3a00000 	mov	r0, #0	; 0x0
     bb0:	e28dd01c 	add	sp, sp, #28	; 0x1c
     bb4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     bb8:	e12fff1e 	bx	lr
     bbc:	00005db8 	streqh	r5, [r0], -r8
     bc0:	00005dcc 	andeq	r5, r0, ip, asr #27
     bc4:	00005ddc 	ldreqd	r5, [r0], -ip
     bc8:	00005dec 	andeq	r5, r0, ip, ror #27
     bcc:	00005dfc 	streqd	r5, [r0], -ip
     bd0:	00005e10 	andeq	r5, r0, r0, lsl lr
     bd4:	00005e24 	andeq	r5, r0, r4, lsr #28
     bd8:	00005e34 	andeq	r5, r0, r4, lsr lr
     bdc:	00005e44 	andeq	r5, r0, r4, asr #28
     be0:	00005e54 	andeq	r5, r0, r4, asr lr
     be4:	00005e64 	andeq	r5, r0, r4, ror #28

00000be8 <root_disk_info>:
     be8:	e59f3004 	ldr	r3, [pc, #4]	; bf4 <.text+0xbf4>
     bec:	e5930000 	ldr	r0, [r3]
     bf0:	eaffffb9 	b	adc <print_disk_info>
     bf4:	400011f8 	strmid	r1, [r0], -r8

00000bf8 <root_open>:
     bf8:	e59f301c 	ldr	r3, [pc, #28]	; c1c <.text+0xc1c>
     bfc:	e5931000 	ldr	r1, [r3]
     c00:	e59f3018 	ldr	r3, [pc, #24]	; c20 <.text+0xc20>
     c04:	e1a02000 	mov	r2, r0
     c08:	e52de004 	str	lr, [sp, #-4]!
     c0c:	e5930000 	ldr	r0, [r3]
     c10:	eb000839 	bl	2cfc <open_file_in_dir>
     c14:	e49de004 	ldr	lr, [sp], #4
     c18:	e12fff1e 	bx	lr
     c1c:	40001230 	andmi	r1, r0, r0, lsr r2
     c20:	400011f8 	strmid	r1, [r0], -r8

00000c24 <root_open_new>:
     c24:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     c28:	e59f5030 	ldr	r5, [pc, #48]	; c60 <.text+0xc60>
     c2c:	e1a04000 	mov	r4, r0
     c30:	e1a01000 	mov	r1, r0
     c34:	e59f2028 	ldr	r2, [pc, #40]	; c64 <.text+0xc64>
     c38:	e5950000 	ldr	r0, [r5]
     c3c:	eb000905 	bl	3058 <fat16_create_file>
     c40:	e3500000 	cmp	r0, #0	; 0x0
     c44:	e1a02004 	mov	r2, r4
     c48:	159f3018 	ldrne	r3, [pc, #24]	; c68 <.text+0xc68>
     c4c:	15951000 	ldrne	r1, [r5]
     c50:	15930000 	ldrne	r0, [r3]
     c54:	1b000828 	blne	2cfc <open_file_in_dir>
     c58:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     c5c:	e12fff1e 	bx	lr
     c60:	40001230 	andmi	r1, r0, r0, lsr r2
     c64:	400011fc 	strmid	r1, [r0], -ip
     c68:	400011f8 	strmid	r1, [r0], -r8

00000c6c <openroot>:
     c6c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     c70:	e3a03000 	mov	r3, #0	; 0x0
     c74:	e59f10ac 	ldr	r1, [pc, #172]	; d28 <.text+0xd28>
     c78:	e59f20ac 	ldr	r2, [pc, #172]	; d2c <.text+0xd2c>
     c7c:	e59f00ac 	ldr	r0, [pc, #172]	; d30 <.text+0xd30>
     c80:	eb000970 	bl	3248 <partition_open>
     c84:	e59f40a8 	ldr	r4, [pc, #168]	; d34 <.text+0xd34>
     c88:	e1a0c000 	mov	ip, r0
     c8c:	e35c0000 	cmp	ip, #0	; 0x0
     c90:	e3e03000 	mvn	r3, #0	; 0x0
     c94:	e59f108c 	ldr	r1, [pc, #140]	; d28 <.text+0xd28>
     c98:	e59f208c 	ldr	r2, [pc, #140]	; d2c <.text+0xd2c>
     c9c:	e59f008c 	ldr	r0, [pc, #140]	; d30 <.text+0xd30>
     ca0:	e59f5090 	ldr	r5, [pc, #144]	; d38 <.text+0xd38>
     ca4:	e584c000 	str	ip, [r4]
     ca8:	1a000005 	bne	cc4 <openroot+0x58>
     cac:	eb000965 	bl	3248 <partition_open>
     cb0:	e1a03000 	mov	r3, r0
     cb4:	e3530000 	cmp	r3, #0	; 0x0
     cb8:	e59f007c 	ldr	r0, [pc, #124]	; d3c <.text+0xd3c>
     cbc:	e5843000 	str	r3, [r4]
     cc0:	0a000013 	beq	d14 <openroot+0xa8>
     cc4:	e59f3068 	ldr	r3, [pc, #104]	; d34 <.text+0xd34>
     cc8:	e5930000 	ldr	r0, [r3]
     ccc:	eb000864 	bl	2e64 <fat16_open>
     cd0:	e3500000 	cmp	r0, #0	; 0x0
     cd4:	e5850000 	str	r0, [r5]
     cd8:	e59f2060 	ldr	r2, [pc, #96]	; d40 <.text+0xd40>
     cdc:	e59f1060 	ldr	r1, [pc, #96]	; d44 <.text+0xd44>
     ce0:	059f0060 	ldreq	r0, [pc, #96]	; d48 <.text+0xd48>
     ce4:	0a00000a 	beq	d14 <openroot+0xa8>
     ce8:	eb000814 	bl	2d40 <fat16_get_dir_entry_of_path>
     cec:	e59f104c 	ldr	r1, [pc, #76]	; d40 <.text+0xd40>
     cf0:	e5950000 	ldr	r0, [r5]
     cf4:	eb0007c0 	bl	2bfc <fat16_open_dir>
     cf8:	e59f304c 	ldr	r3, [pc, #76]	; d4c <.text+0xd4c>
     cfc:	e1a02000 	mov	r2, r0
     d00:	e3500000 	cmp	r0, #0	; 0x0
     d04:	e3a01000 	mov	r1, #0	; 0x0
     d08:	e59f0040 	ldr	r0, [pc, #64]	; d50 <.text+0xd50>
     d0c:	e5832000 	str	r2, [r3]
     d10:	1a000001 	bne	d1c <openroot+0xb0>
     d14:	ebfffdaf 	bl	3d8 <rprintf>
     d18:	e3a01001 	mov	r1, #1	; 0x1
     d1c:	e1a00001 	mov	r0, r1
     d20:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     d24:	e12fff1e 	bx	lr
     d28:	00001514 	andeq	r1, r0, r4, lsl r5
     d2c:	000012b8 	streqh	r1, [r0], -r8
     d30:	00001158 	andeq	r1, r0, r8, asr r1
     d34:	4000122c 	andmi	r1, r0, ip, lsr #4
     d38:	400011f8 	strmid	r1, [r0], -r8
     d3c:	00005e78 	andeq	r5, r0, r8, ror lr
     d40:	400011fc 	strmid	r1, [r0], -ip
     d44:	00005eb0 	streqh	r5, [r0], -r0
     d48:	00005e94 	muleq	r0, r4, lr
     d4c:	40001230 	andmi	r1, r0, r0, lsr r2
     d50:	00005eb4 	streqh	r5, [r0], -r4

00000d54 <sd_raw_available>:
 */
unsigned char sd_raw_available()
{
    unsigned int i;
    configure_pin_available();
     d54:	e59f2028 	ldr	r2, [pc, #40]	; d84 <.text+0xd84>
     d58:	e5923008 	ldr	r3, [r2, #8]
     d5c:	e3c33080 	bic	r3, r3, #128	; 0x80
     d60:	e5823008 	str	r3, [r2, #8]
    for(i=0;i<100000;i++);
    i = get_pin_available();
     d64:	e5921000 	ldr	r1, [r2]
    configure_pin_ss();
     d68:	e5923008 	ldr	r3, [r2, #8]
     d6c:	e3110080 	tst	r1, #128	; 0x80
     d70:	e3833080 	orr	r3, r3, #128	; 0x80
    return i == 0x00;
}
     d74:	03a00000 	moveq	r0, #0	; 0x0
     d78:	13a00001 	movne	r0, #1	; 0x1
     d7c:	e5823008 	str	r3, [r2, #8]
     d80:	e12fff1e 	bx	lr
     d84:	e0028000 	and	r8, r2, r0

00000d88 <sd_raw_locked>:

/**
 * \ingroup sd_raw
 * Checks wether the memory card is locked for write access.
 *
 * \returns 1 if the card is locked, 0 if it is not.
 */
unsigned char sd_raw_locked()
{
    return get_pin_locked() == 0x00;
}
     d88:	e3a00001 	mov	r0, #1	; 0x1
     d8c:	e12fff1e 	bx	lr

00000d90 <sd_raw_rec_byte>:

/**
 * \ingroup sd_raw
 * Sends a raw byte to the memory card.
 *
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(unsigned char b)
{
    S0SPDR = b;
    /* wait for byte to be shifted out */
    while(!(S0SPSR & 0x80));
}

/**
 * \ingroup sd_raw
 * Receives a raw byte from the memory card.
 *
 * \returns The byte which should be read.
 * \see sd_raw_send_byte
 */
unsigned char sd_raw_rec_byte(void)
{
    /* send dummy data for receiving some */
    S0SPDR = 0xff;
     d90:	e59f3020 	ldr	r3, [pc, #32]	; db8 <.text+0xdb8>
     d94:	e3a020ff 	mov	r2, #255	; 0xff
     d98:	e5832008 	str	r2, [r3, #8]
    while(!(S0SPSR & 0x80));
     d9c:	e59f2014 	ldr	r2, [pc, #20]	; db8 <.text+0xdb8>
     da0:	e5923004 	ldr	r3, [r2, #4]
     da4:	e3130080 	tst	r3, #128	; 0x80
     da8:	0afffffb 	beq	d9c <sd_raw_rec_byte+0xc>

    return S0SPDR;
     dac:	e5920008 	ldr	r0, [r2, #8]
     db0:	e20000ff 	and	r0, r0, #255	; 0xff
}
     db4:	e12fff1e 	bx	lr
     db8:	e0020000 	and	r0, r2, r0

00000dbc <sd_raw_send_command_r1>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R1 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
{
     dbc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
     dc0:	e20050ff 	and	r5, r0, #255	; 0xff
     dc4:	e1a04001 	mov	r4, r1
    unsigned char response;
    unsigned char i;

    /* wait some clock cycles */
    sd_raw_rec_byte();
     dc8:	ebfffff0 	bl	d90 <sd_raw_rec_byte>
     dcc:	e59f30c4 	ldr	r3, [pc, #196]	; e98 <.text+0xe98>
     dd0:	e3852040 	orr	r2, r5, #64	; 0x40
     dd4:	e5832008 	str	r2, [r3, #8]
     dd8:	e59f20b8 	ldr	r2, [pc, #184]	; e98 <.text+0xe98>
     ddc:	e5923004 	ldr	r3, [r2, #4]
     de0:	e3130080 	tst	r3, #128	; 0x80
     de4:	0afffffb 	beq	dd8 <sd_raw_send_command_r1+0x1c>
     de8:	e1a03c24 	mov	r3, r4, lsr #24
     dec:	e5823008 	str	r3, [r2, #8]
     df0:	e59f20a0 	ldr	r2, [pc, #160]	; e98 <.text+0xe98>
     df4:	e5923004 	ldr	r3, [r2, #4]
     df8:	e3130080 	tst	r3, #128	; 0x80
     dfc:	0afffffb 	beq	df0 <sd_raw_send_command_r1+0x34>
     e00:	e1a03824 	mov	r3, r4, lsr #16
     e04:	e20330ff 	and	r3, r3, #255	; 0xff
     e08:	e5823008 	str	r3, [r2, #8]
     e0c:	e59f2084 	ldr	r2, [pc, #132]	; e98 <.text+0xe98>
     e10:	e5923004 	ldr	r3, [r2, #4]
     e14:	e3130080 	tst	r3, #128	; 0x80
     e18:	0afffffb 	beq	e0c <sd_raw_send_command_r1+0x50>
     e1c:	e1a03424 	mov	r3, r4, lsr #8
     e20:	e20330ff 	and	r3, r3, #255	; 0xff
     e24:	e5823008 	str	r3, [r2, #8]
     e28:	e59f2068 	ldr	r2, [pc, #104]	; e98 <.text+0xe98>
     e2c:	e5923004 	ldr	r3, [r2, #4]
     e30:	e3130080 	tst	r3, #128	; 0x80
     e34:	0afffffb 	beq	e28 <sd_raw_send_command_r1+0x6c>
     e38:	e20430ff 	and	r3, r4, #255	; 0xff
     e3c:	e5823008 	str	r3, [r2, #8]
     e40:	e59f2050 	ldr	r2, [pc, #80]	; e98 <.text+0xe98>
     e44:	e5923004 	ldr	r3, [r2, #4]
     e48:	e3130080 	tst	r3, #128	; 0x80
     e4c:	0afffffb 	beq	e40 <sd_raw_send_command_r1+0x84>
     e50:	e3550000 	cmp	r5, #0	; 0x0
     e54:	13a030ff 	movne	r3, #255	; 0xff
     e58:	03a03095 	moveq	r3, #149	; 0x95
     e5c:	e5823008 	str	r3, [r2, #8]
     e60:	e59f3030 	ldr	r3, [pc, #48]	; e98 <.text+0xe98>
     e64:	e5933004 	ldr	r3, [r3, #4]
     e68:	e3130080 	tst	r3, #128	; 0x80
     e6c:	0afffffb 	beq	e60 <sd_raw_send_command_r1+0xa4>
     e70:	e3a04000 	mov	r4, #0	; 0x0

    /* send command via SPI */
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);

    /* receive response */
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
     e74:	ebffffc5 	bl	d90 <sd_raw_rec_byte>
     e78:	e2843001 	add	r3, r4, #1	; 0x1
        if(response != 0xff)
     e7c:	e35000ff 	cmp	r0, #255	; 0xff
     e80:	e20340ff 	and	r4, r3, #255	; 0xff
     e84:	1a000001 	bne	e90 <sd_raw_send_command_r1+0xd4>
     e88:	e354000a 	cmp	r4, #10	; 0xa
     e8c:	1afffff8 	bne	e74 <sd_raw_send_command_r1+0xb8>
            break;
    }

    return response;
}
     e90:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
     e94:	e12fff1e 	bx	lr
     e98:	e0020000 	and	r0, r2, r0

00000e9c <SDoff>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R2 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
/*
unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
{
    unsigned short response;
    unsigned char i;

    // wait some clock cycles
    sd_raw_rec_byte();

    // send command via SPI
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);

    // receive response
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
        if(response != 0xff)
            break;
    }
    response <<= 8;
    response |= sd_raw_rec_byte();

    return response;
}
*/

/**
 * \ingroup sd_raw
 * Reads raw data from the card.
 *
 * \param[in] offset The offset from which to read.
 * \param[out] buffer The buffer into which to write the data.
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write
 */
unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
{
    unsigned int block_address;
    unsigned short block_offset;
    unsigned short read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_address = offset & 0xfffffe00;
        block_offset = offset & 0x01ff;
        read_length = 512 - block_offset; /* read up to block border */
        if(read_length > length)
            read_length = length;

        #if !SD_RAW_SAVE_RAM
            /* check if the requested data is cached */
            if(block_address != raw_block_address)
            #endif
        {
            #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            /* address card */
            select_card();

            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
            {
                unselect_card();
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);

            #if SD_RAW_SAVE_RAM
                /* read byte block */
                unsigned short read_to = block_offset + read_length;
                for(unsigned short i = 0; i < 512; ++i)
                {
                    unsigned char b = sd_raw_rec_byte();
                    if(i >= block_offset && i < read_to)
                        *buffer++ = b;
                }
            #else
                /* read byte block */
                unsigned char* cache = raw_block;
                unsigned short i;
                for(i = 0; i < 512; ++i)
                    *cache++ = sd_raw_rec_byte();
                raw_block_address = block_address;
    
                memcpy(buffer, raw_block + block_offset, read_length);
                buffer += read_length;
            #endif

            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();

            /* deaddress card */
            unselect_card();

            /* let card some time to finish */
            sd_raw_rec_byte();
        }
        #if !SD_RAW_SAVE_RAM
            else
            {
                /* use cached data */
                memcpy(buffer, raw_block + block_offset, read_length);
            }
        #endif

        length -= read_length;
        offset += read_length;
    }

    return 1;
}

/**
 * \ingroup sd_raw
 * Continuously reads units of \c interval bytes and calls a callback function.
 *
 * This function starts reading at the specified offset. Every \c interval bytes,
 * it calls the callback function with the associated data buffer.
 *
 * By returning zero, the callback may stop reading.
 *
 * \note Within the callback function, you can not start another read or
 *       write operation.
 * \note This function only works if the following conditions are met:
 *       - (offset - (offset % 512)) % interval == 0
 *       - length % interval == 0
 *
 * \param[in] offset Offset from which to start reading.
 * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 * \param[in] interval Number of bytes to read before calling the callback function.
 * \param[in] length Number of bytes to read altogether.
 * \param[in] callback The function to call every interval bytes.
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read, sd_raw_write
 */
unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short interval, unsigned short length, sd_raw_interval_handler callback, void* p)
{
    if(!buffer || interval == 0 || length < interval || !callback)
        return 0;

    #if !SD_RAW_SAVE_RAM
        while(length >= interval)
        {
            /* as reading is now buffered, we directly
                     * hand over the request to sd_raw_read()
                     */
            if(!sd_raw_read(offset, buffer, interval))
                return 0;
            if(!callback(buffer, offset, p))
                break;
            offset += interval;
            length -= interval;
        }
    
        return 1;
    #else
        /* address card */
        select_card();
    
        unsigned short block_offset;
        unsigned short read_length;
        unsigned char* buffer_cur;
        unsigned char finished = 0;
        do
        {
            /* determine byte count to read at once */
            block_offset = offset & 0x01ff;
            read_length = 512 - block_offset;
    
            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
            {
                unselect_card();
                return 0;
            }
    
            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
            unsigned short i;
            /* read up to the data of interest */
            for(i = 0; i < block_offset; ++i)
                sd_raw_rec_byte();
    
            /* read interval bytes of data and execute the callback */
            do
            {
                if(read_length < interval || length < interval)
                    break;
    
                buffer_cur = buffer;
                for(i = 0; i < interval; ++i)
                    *buffer_cur++ = sd_raw_rec_byte();
    
                if(!callback(buffer, offset + (512 - read_length), p))
                {
                    finished = 1;
                    break;
                }
    
                read_length -= interval;
                length -= interval;
    
            }
            while(read_length > 0 && length > 0);
    
            /* read rest of data block */
            while(read_length-- > 0)
                sd_raw_rec_byte();
    
            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();
    
            if(length < interval)
                break;
    
            offset = (offset & 0xfffffe00) + 512;
    
        }
        while(!finished);
    
        /* deaddress card */
        unselect_card();
    
        /* let card some time to finish */
        sd_raw_rec_byte();
    
        return 1;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes raw data to the card.
 *
 * \note If write buffering is enabled, you might have to
 *       call sd_raw_sync() before disconnecting the card
 *       to ensure all remaining data has been written.
 *
 * \param[in] offset The offset where to start writing.
 * \param[in] buffer The buffer containing the data to be written.
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read
 */
unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
{
    #if SD_RAW_WRITE_SUPPORT
    
        if(get_pin_locked())
            return 0;
    
        unsigned int block_address;
        unsigned short block_offset;
        unsigned short write_length;
        while(length > 0)
        {
            /* determine byte count to write at once */
            block_address = offset & 0xfffffe00;
            block_offset = offset & 0x01ff;
            write_length = 512 - block_offset; /* write up to block border */
            if(write_length > length)
                write_length = length;
    
            /* Merge the data to write with the content of the block.
                     * Use the cached block if available.
                     */
            if(block_address != raw_block_address)
            {
                #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            if(block_offset || write_length < 512)
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
                    return 0;
            }
            raw_block_address = block_address;
        }

        if(buffer != raw_block)
        {
            memcpy(raw_block + block_offset, buffer, write_length);

            #if SD_RAW_WRITE_BUFFERING
                raw_block_written = 0;
    
                if(length == write_length)
                    return 1;
            #endif
        }

        buffer += write_length;

        /* address card */
        select_card();

        /* send single block request */
        if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
        {
            unselect_card();
            return 0;
        }

        /* send start byte */
        sd_raw_send_byte(0xfe);

        /* write byte block */
        unsigned char* cache = raw_block;
        unsigned short i;
        for(i = 0; i < 512; ++i)
            sd_raw_send_byte(*cache++);

        /* write dummy crc16 */
        sd_raw_send_byte(0xff);
        sd_raw_send_byte(0xff);

        /* wait while card is busy */
        while(sd_raw_rec_byte() != 0xff);
        sd_raw_rec_byte();

        /* deaddress card */
        unselect_card();

        length -= write_length;
        offset += write_length;

        #if SD_RAW_WRITE_BUFFERING
            raw_block_written = 1;
        #endif
    }

    return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes the write buffer's content to the card.
 *
 * \note When write buffering is enabled, you should
 *       call this function before disconnecting the
 *       card to ensure all remaining data has been
 *       written.
 *
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write
 */
unsigned char sd_raw_sync()
{
    #if SD_RAW_WRITE_SUPPORT
        #if SD_RAW_WRITE_BUFFERING
        if(raw_block_written)
            return 1;
        if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
            return 0;
    #endif
    return 1;
    #else
    return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Reads informational data from the card.
 *
 * This function reads and returns the card's registers
 * containing manufacturing and status information.
 *
 * \note: The information retrieved by this function is
 *        not required in any way to operate on the card,
 *        but it might be nice to display some of the data
 *        to the user.
 *
 * \param[in] info A pointer to the structure into which to save the information.
 * \returns 0 on failure, 1 on success.
 */
unsigned char sd_raw_get_info(struct sd_raw_info* info)
{
    if(!info || !sd_raw_available())
        return 0;

    memset(info, 0, sizeof(*info));

    select_card();

    /* read cid register */
    if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    unsigned char i;
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 0:
                info->manufacturer = b;
                break;
            case 1:
            case 2:
                info->oem[i - 1] = b;
                break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                info->product[i - 3] = b;
                break;
            case 8:
                info->revision = b;
                break;
            case 9:
            case 10:
            case 11:
            case 12:
                info->serial |= (unsigned int) b << ((12 - i) * 8);
                break;
            case 13:
                info->manufacturing_year = b << 4;
                break;
            case 14:
                info->manufacturing_year |= b >> 4;
                info->manufacturing_month = b & 0x0f;
                break;
        }
    }

    /* read csd register */
    unsigned char csd_read_bl_len = 0;
    unsigned char csd_c_size_mult = 0;
    unsigned short csd_c_size = 0;
    if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 5:
                csd_read_bl_len = b & 0x0f;
                break;
            case 6:
                csd_c_size = (unsigned short) (b & 0x03) << 8;
                break;
            case 7:
                csd_c_size |= b;
                csd_c_size <<= 2;
                break;
            case 8:
                csd_c_size |= b >> 6;
                ++csd_c_size;
                break;
            case 9:
                csd_c_size_mult = (b & 0x03) << 1;
                break;
            case 10:
                csd_c_size_mult |= b >> 7;

                info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);

                break;
            case 14:
                if(b & 0x40)
                    info->flag_copy = 1;
                if(b & 0x20)
                    info->flag_write_protect = 1;
                if(b & 0x10)
                    info->flag_write_protect_temp = 1;
                info->format = (b & 0x0c) >> 2;
                break;
        }
    }

    unselect_card();

    return 1;
}

void SDoff(void)
{
    IODIR1 &= ~(CS);
     e9c:	e59f201c 	ldr	r2, [pc, #28]	; ec0 <.text+0xec0>
     ea0:	e5923018 	ldr	r3, [r2, #24]
     ea4:	e3c33080 	bic	r3, r3, #128	; 0x80
     ea8:	e5823018 	str	r3, [r2, #24]
    PINSEL0 &= ~(0x1500);
     eac:	e2822901 	add	r2, r2, #16384	; 0x4000
     eb0:	e5923000 	ldr	r3, [r2]
     eb4:	e3c33c15 	bic	r3, r3, #5376	; 0x1500
     eb8:	e5823000 	str	r3, [r2]
}
     ebc:	e12fff1e 	bx	lr
     ec0:	e0028000 	and	r8, r2, r0

00000ec4 <sd_raw_get_info>:
     ec4:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     ec8:	e2504000 	subs	r4, r0, #0	; 0x0
     ecc:	0a000097 	beq	1130 <.text+0x1130>
     ed0:	ebffff9f 	bl	d54 <sd_raw_available>
     ed4:	e3500000 	cmp	r0, #0	; 0x0
     ed8:	0a000094 	beq	1130 <.text+0x1130>
     edc:	e59f5270 	ldr	r5, [pc, #624]	; 1154 <.text+0x1154>
     ee0:	e3a01000 	mov	r1, #0	; 0x0
     ee4:	e3a0201c 	mov	r2, #28	; 0x1c
     ee8:	e1a00004 	mov	r0, r4
     eec:	eb00116f 	bl	54b0 <memset>
     ef0:	e595300c 	ldr	r3, [r5, #12]
     ef4:	e3833080 	orr	r3, r3, #128	; 0x80
     ef8:	e3a0000a 	mov	r0, #10	; 0xa
     efc:	e3a01000 	mov	r1, #0	; 0x0
     f00:	e585300c 	str	r3, [r5, #12]
     f04:	ebffffac 	bl	dbc <sd_raw_send_command_r1>
     f08:	e3500000 	cmp	r0, #0	; 0x0
     f0c:	15953004 	ldrne	r3, [r5, #4]
     f10:	13a00000 	movne	r0, #0	; 0x0
     f14:	13833080 	orrne	r3, r3, #128	; 0x80
     f18:	15853004 	strne	r3, [r5, #4]
     f1c:	1a00008a 	bne	114c <.text+0x114c>
     f20:	ebffff9a 	bl	d90 <sd_raw_rec_byte>
     f24:	e35000fe 	cmp	r0, #254	; 0xfe
     f28:	1afffffc 	bne	f20 <sd_raw_get_info+0x5c>
     f2c:	ebffff97 	bl	d90 <sd_raw_rec_byte>
     f30:	e3a05000 	mov	r5, #0	; 0x0
     f34:	ea000012 	b	f84 <.text+0xf84>
     f38:	ebffff94 	bl	d90 <sd_raw_rec_byte>
     f3c:	e355000e 	cmp	r5, #14	; 0xe
     f40:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
     f44:	ea000026 	b	fe4 <.text+0xfe4>
     f48:	00000f84 	andeq	r0, r0, r4, lsl #31
     f4c:	00000f8c 	andeq	r0, r0, ip, lsl #31
     f50:	00000f8c 	andeq	r0, r0, ip, lsl #31
     f54:	00000f94 	muleq	r0, r4, pc
     f58:	00000f94 	muleq	r0, r4, pc
     f5c:	00000f94 	muleq	r0, r4, pc
     f60:	00000f94 	muleq	r0, r4, pc
     f64:	00000f94 	muleq	r0, r4, pc
     f68:	00000fa0 	andeq	r0, r0, r0, lsr #31
     f6c:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f70:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f74:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f78:	00000fa8 	andeq	r0, r0, r8, lsr #31
     f7c:	00000fc0 	andeq	r0, r0, r0, asr #31
     f80:	00000fcc 	andeq	r0, r0, ip, asr #31
     f84:	e5c40000 	strb	r0, [r4]
     f88:	ea00006a 	b	1138 <.text+0x1138>
     f8c:	e7c50004 	strb	r0, [r5, r4]
     f90:	ea000013 	b	fe4 <.text+0xfe4>
     f94:	e0853004 	add	r3, r5, r4
     f98:	e5c30001 	strb	r0, [r3, #1]
     f9c:	ea000010 	b	fe4 <.text+0xfe4>
     fa0:	e5c4000a 	strb	r0, [r4, #10]
     fa4:	ea000063 	b	1138 <.text+0x1138>
     fa8:	e594200c 	ldr	r2, [r4, #12]
     fac:	e265300c 	rsb	r3, r5, #12	; 0xc
     fb0:	e1a03183 	mov	r3, r3, lsl #3
     fb4:	e1822310 	orr	r2, r2, r0, lsl r3
     fb8:	e584200c 	str	r2, [r4, #12]
     fbc:	ea000008 	b	fe4 <.text+0xfe4>
     fc0:	e1a03200 	mov	r3, r0, lsl #4
     fc4:	e5c43010 	strb	r3, [r4, #16]
     fc8:	ea00005a 	b	1138 <.text+0x1138>
     fcc:	e5d43010 	ldrb	r3, [r4, #16]
     fd0:	e200200f 	and	r2, r0, #15	; 0xf
     fd4:	e1833220 	orr	r3, r3, r0, lsr #4
     fd8:	e5c43010 	strb	r3, [r4, #16]
     fdc:	e5c42011 	strb	r2, [r4, #17]
     fe0:	ea000054 	b	1138 <.text+0x1138>
     fe4:	e2853001 	add	r3, r5, #1	; 0x1
     fe8:	e20350ff 	and	r5, r3, #255	; 0xff
     fec:	e3550011 	cmp	r5, #17	; 0x11
     ff0:	9affffd0 	bls	f38 <sd_raw_get_info+0x74>
     ff4:	e3a00009 	mov	r0, #9	; 0x9
     ff8:	e3a01000 	mov	r1, #0	; 0x0
     ffc:	ebffff6e 	bl	dbc <sd_raw_send_command_r1>
    1000:	e3500000 	cmp	r0, #0	; 0x0
    1004:	159f2148 	ldrne	r2, [pc, #328]	; 1154 <.text+0x1154>
    1008:	15923004 	ldrne	r3, [r2, #4]
    100c:	13a00000 	movne	r0, #0	; 0x0
    1010:	13833080 	orrne	r3, r3, #128	; 0x80
    1014:	1a000043 	bne	1128 <.text+0x1128>
    1018:	ebffff5c 	bl	d90 <sd_raw_rec_byte>
    101c:	e35000fe 	cmp	r0, #254	; 0xfe
    1020:	1afffffc 	bne	1018 <.text+0x1018>
    1024:	ebffff59 	bl	d90 <sd_raw_rec_byte>
    1028:	e3a07000 	mov	r7, #0	; 0x0
    102c:	e3a05001 	mov	r5, #1	; 0x1
    1030:	e1a08007 	mov	r8, r7
    1034:	e1a06007 	mov	r6, r7
    1038:	ebffff54 	bl	d90 <sd_raw_rec_byte>
    103c:	e2453005 	sub	r3, r5, #5	; 0x5
    1040:	e2852001 	add	r2, r5, #1	; 0x1
    1044:	e3530009 	cmp	r3, #9	; 0x9
    1048:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    104c:	ea00002e 	b	110c <.text+0x110c>
    1050:	00001078 	andeq	r1, r0, r8, ror r0
    1054:	00001080 	andeq	r1, r0, r0, lsl #1
    1058:	0000108c 	andeq	r1, r0, ip, lsl #1
    105c:	00001098 	muleq	r0, r8, r0
    1060:	000010b0 	streqh	r1, [r0], -r0
    1064:	000010bc 	streqh	r1, [r0], -ip
    1068:	0000110c 	andeq	r1, r0, ip, lsl #2
    106c:	0000110c 	andeq	r1, r0, ip, lsl #2
    1070:	0000110c 	andeq	r1, r0, ip, lsl #2
    1074:	000010d8 	ldreqd	r1, [r0], -r8
    1078:	e200800f 	and	r8, r0, #15	; 0xf
    107c:	ea000030 	b	1144 <.text+0x1144>
    1080:	e2003003 	and	r3, r0, #3	; 0x3
    1084:	e1a06403 	mov	r6, r3, lsl #8
    1088:	ea00002d 	b	1144 <.text+0x1144>
    108c:	e1863000 	orr	r3, r6, r0
    1090:	e1a03903 	mov	r3, r3, lsl #18
    1094:	ea000003 	b	10a8 <.text+0x10a8>
    1098:	e1a03900 	mov	r3, r0, lsl #18
    109c:	e1863c23 	orr	r3, r6, r3, lsr #24
    10a0:	e2833001 	add	r3, r3, #1	; 0x1
    10a4:	e1a03803 	mov	r3, r3, lsl #16
    10a8:	e1a06823 	mov	r6, r3, lsr #16
    10ac:	ea000024 	b	1144 <.text+0x1144>
    10b0:	e2003003 	and	r3, r0, #3	; 0x3
    10b4:	e1a07083 	mov	r7, r3, lsl #1
    10b8:	ea000021 	b	1144 <.text+0x1144>
    10bc:	e18733a0 	orr	r3, r7, r0, lsr #7
    10c0:	e20370ff 	and	r7, r3, #255	; 0xff
    10c4:	e2883002 	add	r3, r8, #2	; 0x2
    10c8:	e0873003 	add	r3, r7, r3
    10cc:	e1a03316 	mov	r3, r6, lsl r3
    10d0:	e5843014 	str	r3, [r4, #20]
    10d4:	ea00001a 	b	1144 <.text+0x1144>
    10d8:	e3100040 	tst	r0, #64	; 0x40
    10dc:	13a03001 	movne	r3, #1	; 0x1
    10e0:	15c43018 	strneb	r3, [r4, #24]
    10e4:	e3100020 	tst	r0, #32	; 0x20
    10e8:	13a03001 	movne	r3, #1	; 0x1
    10ec:	15c43019 	strneb	r3, [r4, #25]
    10f0:	e3100010 	tst	r0, #16	; 0x10
    10f4:	13a03001 	movne	r3, #1	; 0x1
    10f8:	15c4301a 	strneb	r3, [r4, #26]
    10fc:	e200300c 	and	r3, r0, #12	; 0xc
    1100:	e1a03143 	mov	r3, r3, asr #2
    1104:	e5c4301b 	strb	r3, [r4, #27]
    1108:	ea00000d 	b	1144 <.text+0x1144>
    110c:	e20250ff 	and	r5, r2, #255	; 0xff
    1110:	e3550011 	cmp	r5, #17	; 0x11
    1114:	9affffc7 	bls	1038 <.text+0x1038>
    1118:	e59f2034 	ldr	r2, [pc, #52]	; 1154 <.text+0x1154>
    111c:	e5923004 	ldr	r3, [r2, #4]
    1120:	e3a00001 	mov	r0, #1	; 0x1
    1124:	e3833080 	orr	r3, r3, #128	; 0x80
    1128:	e5823004 	str	r3, [r2, #4]
    112c:	ea000006 	b	114c <.text+0x114c>
    1130:	e3a00000 	mov	r0, #0	; 0x0
    1134:	ea000004 	b	114c <.text+0x114c>
    1138:	e2853001 	add	r3, r5, #1	; 0x1
    113c:	e20350ff 	and	r5, r3, #255	; 0xff
    1140:	eaffff7c 	b	f38 <sd_raw_get_info+0x74>
    1144:	e20250ff 	and	r5, r2, #255	; 0xff
    1148:	eaffffba 	b	1038 <.text+0x1038>
    114c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    1150:	e12fff1e 	bx	lr
    1154:	e0028000 	and	r8, r2, r0

00001158 <sd_raw_read>:
    1158:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    115c:	e1a02802 	mov	r2, r2, lsl #16
    1160:	e1a09000 	mov	r9, r0
    1164:	e1a0a001 	mov	sl, r1
    1168:	e1a08822 	mov	r8, r2, lsr #16
    116c:	ea000046 	b	128c <sd_raw_read+0x134>
    1170:	e1a06b89 	mov	r6, r9, lsl #23
    1174:	e1a06ba6 	mov	r6, r6, lsr #23
    1178:	e59f3120 	ldr	r3, [pc, #288]	; 12a0 <.text+0x12a0>
    117c:	e2662c02 	rsb	r2, r6, #512	; 0x200
    1180:	e1a02802 	mov	r2, r2, lsl #16
    1184:	e5930000 	ldr	r0, [r3]
    1188:	e3c95f7f 	bic	r5, r9, #508	; 0x1fc
    118c:	e3c55003 	bic	r5, r5, #3	; 0x3
    1190:	e1a02822 	mov	r2, r2, lsr #16
    1194:	e1580002 	cmp	r8, r2
    1198:	31a07008 	movcc	r7, r8
    119c:	21a07002 	movcs	r7, r2
    11a0:	e1550000 	cmp	r5, r0
    11a4:	0a00002f 	beq	1268 <sd_raw_read+0x110>
    11a8:	e59f30f4 	ldr	r3, [pc, #244]	; 12a4 <.text+0x12a4>
    11ac:	e5d33000 	ldrb	r3, [r3]
    11b0:	e3530000 	cmp	r3, #0	; 0x0
    11b4:	1a000004 	bne	11cc <sd_raw_read+0x74>
    11b8:	e59f10e8 	ldr	r1, [pc, #232]	; 12a8 <.text+0x12a8>
    11bc:	e3a02c02 	mov	r2, #512	; 0x200
    11c0:	eb00003c 	bl	12b8 <sd_raw_write>
    11c4:	e3500000 	cmp	r0, #0	; 0x0
    11c8:	0a000032 	beq	1298 <sd_raw_read+0x140>
    11cc:	e59f40d8 	ldr	r4, [pc, #216]	; 12ac <.text+0x12ac>
    11d0:	e594300c 	ldr	r3, [r4, #12]
    11d4:	e3833080 	orr	r3, r3, #128	; 0x80
    11d8:	e3a00011 	mov	r0, #17	; 0x11
    11dc:	e1a01005 	mov	r1, r5
    11e0:	e584300c 	str	r3, [r4, #12]
    11e4:	ebfffef4 	bl	dbc <sd_raw_send_command_r1>
    11e8:	e3500000 	cmp	r0, #0	; 0x0
    11ec:	15943004 	ldrne	r3, [r4, #4]
    11f0:	13a00000 	movne	r0, #0	; 0x0
    11f4:	13833080 	orrne	r3, r3, #128	; 0x80
    11f8:	15843004 	strne	r3, [r4, #4]
    11fc:	1a000025 	bne	1298 <sd_raw_read+0x140>
    1200:	ebfffee2 	bl	d90 <sd_raw_rec_byte>
    1204:	e35000fe 	cmp	r0, #254	; 0xfe
    1208:	1afffffc 	bne	1200 <sd_raw_read+0xa8>
    120c:	e59f409c 	ldr	r4, [pc, #156]	; 12b0 <.text+0x12b0>
    1210:	ebfffede 	bl	d90 <sd_raw_rec_byte>
    1214:	e59f3098 	ldr	r3, [pc, #152]	; 12b4 <.text+0x12b4>
    1218:	e5440001 	strb	r0, [r4, #-1]
    121c:	e2844001 	add	r4, r4, #1	; 0x1
    1220:	e1540003 	cmp	r4, r3
    1224:	1afffff9 	bne	1210 <sd_raw_read+0xb8>
    1228:	e59f3070 	ldr	r3, [pc, #112]	; 12a0 <.text+0x12a0>
    122c:	e59f1074 	ldr	r1, [pc, #116]	; 12a8 <.text+0x12a8>
    1230:	e1a02007 	mov	r2, r7
    1234:	e5835000 	str	r5, [r3]
    1238:	e0861001 	add	r1, r6, r1
    123c:	e1a0000a 	mov	r0, sl
    1240:	eb001092 	bl	5490 <memcpy>
    1244:	ebfffed1 	bl	d90 <sd_raw_rec_byte>
    1248:	ebfffed0 	bl	d90 <sd_raw_rec_byte>
    124c:	e59f2058 	ldr	r2, [pc, #88]	; 12ac <.text+0x12ac>
    1250:	e5923004 	ldr	r3, [r2, #4]
    1254:	e3833080 	orr	r3, r3, #128	; 0x80
    1258:	e5823004 	str	r3, [r2, #4]
    125c:	e08aa007 	add	sl, sl, r7
    1260:	ebfffeca 	bl	d90 <sd_raw_rec_byte>
    1264:	ea000004 	b	127c <sd_raw_read+0x124>
    1268:	e59f1038 	ldr	r1, [pc, #56]	; 12a8 <.text+0x12a8>
    126c:	e1a0000a 	mov	r0, sl
    1270:	e0861001 	add	r1, r6, r1
    1274:	e1a02007 	mov	r2, r7
    1278:	eb001084 	bl	5490 <memcpy>
    127c:	e0673008 	rsb	r3, r7, r8
    1280:	e1a03803 	mov	r3, r3, lsl #16
    1284:	e0899007 	add	r9, r9, r7
    1288:	e1a08823 	mov	r8, r3, lsr #16
    128c:	e3580000 	cmp	r8, #0	; 0x0
    1290:	1affffb6 	bne	1170 <sd_raw_read+0x18>
    1294:	e3a00001 	mov	r0, #1	; 0x1
    1298:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    129c:	e12fff1e 	bx	lr
    12a0:	40000cd8 	ldrmid	r0, [r0], -r8
    12a4:	40000cdc 	ldrmid	r0, [r0], -ip
    12a8:	40000ad8 	ldrmid	r0, [r0], -r8
    12ac:	e0028000 	and	r8, r2, r0
    12b0:	40000ad9 	ldrmid	r0, [r0], -r9
    12b4:	40000cd9 	ldrmid	r0, [r0], -r9

000012b8 <sd_raw_write>:
    12b8:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    12bc:	e1a02802 	mov	r2, r2, lsl #16
    12c0:	e1a0a000 	mov	sl, r0
    12c4:	e1a08001 	mov	r8, r1
    12c8:	e1a07822 	mov	r7, r2, lsr #16
    12cc:	ea000069 	b	1478 <sd_raw_write+0x1c0>
    12d0:	e1a04b8a 	mov	r4, sl, lsl #23
    12d4:	e1a04ba4 	mov	r4, r4, lsr #23
    12d8:	e59f91cc 	ldr	r9, [pc, #460]	; 14ac <.text+0x14ac>
    12dc:	e2643c02 	rsb	r3, r4, #512	; 0x200
    12e0:	e1a03803 	mov	r3, r3, lsl #16
    12e4:	e3ca5f7f 	bic	r5, sl, #508	; 0x1fc
    12e8:	e5990000 	ldr	r0, [r9]
    12ec:	e3c55003 	bic	r5, r5, #3	; 0x3
    12f0:	e1a03823 	mov	r3, r3, lsr #16
    12f4:	e1570003 	cmp	r7, r3
    12f8:	31a06007 	movcc	r6, r7
    12fc:	21a06003 	movcs	r6, r3
    1300:	e1550000 	cmp	r5, r0
    1304:	0a000017 	beq	1368 <sd_raw_write+0xb0>
    1308:	e59f31a0 	ldr	r3, [pc, #416]	; 14b0 <.text+0x14b0>
    130c:	e5d33000 	ldrb	r3, [r3]
    1310:	e3530000 	cmp	r3, #0	; 0x0
    1314:	1a000004 	bne	132c <sd_raw_write+0x74>
    1318:	e59f1194 	ldr	r1, [pc, #404]	; 14b4 <.text+0x14b4>
    131c:	e3a02c02 	mov	r2, #512	; 0x200
    1320:	ebffffe4 	bl	12b8 <sd_raw_write>
    1324:	e3500000 	cmp	r0, #0	; 0x0
    1328:	0a000055 	beq	1484 <sd_raw_write+0x1cc>
    132c:	e59f3184 	ldr	r3, [pc, #388]	; 14b8 <.text+0x14b8>
    1330:	e1560003 	cmp	r6, r3
    1334:	83a03000 	movhi	r3, #0	; 0x0
    1338:	93a03001 	movls	r3, #1	; 0x1
    133c:	e3540000 	cmp	r4, #0	; 0x0
    1340:	13833001 	orrne	r3, r3, #1	; 0x1
    1344:	e3530000 	cmp	r3, #0	; 0x0
    1348:	0a000005 	beq	1364 <sd_raw_write+0xac>
    134c:	e1a00005 	mov	r0, r5
    1350:	e59f115c 	ldr	r1, [pc, #348]	; 14b4 <.text+0x14b4>
    1354:	e3a02c02 	mov	r2, #512	; 0x200
    1358:	ebffff7e 	bl	1158 <sd_raw_read>
    135c:	e3500000 	cmp	r0, #0	; 0x0
    1360:	0a000047 	beq	1484 <sd_raw_write+0x1cc>
    1364:	e5895000 	str	r5, [r9]
    1368:	e59f3144 	ldr	r3, [pc, #324]	; 14b4 <.text+0x14b4>
    136c:	e1580003 	cmp	r8, r3
    1370:	0a000008 	beq	1398 <sd_raw_write+0xe0>
    1374:	e0840003 	add	r0, r4, r3
    1378:	e1a02006 	mov	r2, r6
    137c:	e1a01008 	mov	r1, r8
    1380:	eb001042 	bl	5490 <memcpy>
    1384:	e59f3124 	ldr	r3, [pc, #292]	; 14b0 <.text+0x14b0>
    1388:	e3a02000 	mov	r2, #0	; 0x0
    138c:	e1570006 	cmp	r7, r6
    1390:	e5c32000 	strb	r2, [r3]
    1394:	0a000041 	beq	14a0 <sd_raw_write+0x1e8>
    1398:	e59f411c 	ldr	r4, [pc, #284]	; 14bc <.text+0x14bc>
    139c:	e594300c 	ldr	r3, [r4, #12]
    13a0:	e3833080 	orr	r3, r3, #128	; 0x80
    13a4:	e1a01005 	mov	r1, r5
    13a8:	e3a00018 	mov	r0, #24	; 0x18
    13ac:	e584300c 	str	r3, [r4, #12]
    13b0:	ebfffe81 	bl	dbc <sd_raw_send_command_r1>
    13b4:	e3500000 	cmp	r0, #0	; 0x0
    13b8:	1a000033 	bne	148c <sd_raw_write+0x1d4>
    13bc:	e59f30fc 	ldr	r3, [pc, #252]	; 14c0 <.text+0x14c0>
    13c0:	e3a020fe 	mov	r2, #254	; 0xfe
    13c4:	e5832008 	str	r2, [r3, #8]
    13c8:	e59f30f0 	ldr	r3, [pc, #240]	; 14c0 <.text+0x14c0>
    13cc:	e5933004 	ldr	r3, [r3, #4]
    13d0:	e3130080 	tst	r3, #128	; 0x80
    13d4:	0afffffb 	beq	13c8 <sd_raw_write+0x110>
    13d8:	e59f10e4 	ldr	r1, [pc, #228]	; 14c4 <.text+0x14c4>
    13dc:	e5512001 	ldrb	r2, [r1, #-1]
    13e0:	e59f30d8 	ldr	r3, [pc, #216]	; 14c0 <.text+0x14c0>
    13e4:	e5832008 	str	r2, [r3, #8]
    13e8:	e59f20d0 	ldr	r2, [pc, #208]	; 14c0 <.text+0x14c0>
    13ec:	e5923004 	ldr	r3, [r2, #4]
    13f0:	e3130080 	tst	r3, #128	; 0x80
    13f4:	0afffffb 	beq	13e8 <sd_raw_write+0x130>
    13f8:	e59f30c8 	ldr	r3, [pc, #200]	; 14c8 <.text+0x14c8>
    13fc:	e2811001 	add	r1, r1, #1	; 0x1
    1400:	e1510003 	cmp	r1, r3
    1404:	1afffff4 	bne	13dc <sd_raw_write+0x124>
    1408:	e3a030ff 	mov	r3, #255	; 0xff
    140c:	e5823008 	str	r3, [r2, #8]
    1410:	e59f20a8 	ldr	r2, [pc, #168]	; 14c0 <.text+0x14c0>
    1414:	e5923004 	ldr	r3, [r2, #4]
    1418:	e3130080 	tst	r3, #128	; 0x80
    141c:	0afffffb 	beq	1410 <sd_raw_write+0x158>
    1420:	e3a030ff 	mov	r3, #255	; 0xff
    1424:	e5823008 	str	r3, [r2, #8]
    1428:	e59f3090 	ldr	r3, [pc, #144]	; 14c0 <.text+0x14c0>
    142c:	e5933004 	ldr	r3, [r3, #4]
    1430:	e3130080 	tst	r3, #128	; 0x80
    1434:	0afffffb 	beq	1428 <sd_raw_write+0x170>
    1438:	ebfffe54 	bl	d90 <sd_raw_rec_byte>
    143c:	e35000ff 	cmp	r0, #255	; 0xff
    1440:	1afffffc 	bne	1438 <sd_raw_write+0x180>
    1444:	ebfffe51 	bl	d90 <sd_raw_rec_byte>
    1448:	e59f206c 	ldr	r2, [pc, #108]	; 14bc <.text+0x14bc>
    144c:	e5923004 	ldr	r3, [r2, #4]
    1450:	e3833080 	orr	r3, r3, #128	; 0x80
    1454:	e5823004 	str	r3, [r2, #4]
    1458:	e59f3050 	ldr	r3, [pc, #80]	; 14b0 <.text+0x14b0>
    145c:	e0661007 	rsb	r1, r6, r7
    1460:	e3a02001 	mov	r2, #1	; 0x1
    1464:	e1a01801 	mov	r1, r1, lsl #16
    1468:	e5c32000 	strb	r2, [r3]
    146c:	e08aa006 	add	sl, sl, r6
    1470:	e0888006 	add	r8, r8, r6
    1474:	e1a07821 	mov	r7, r1, lsr #16
    1478:	e3570000 	cmp	r7, #0	; 0x0
    147c:	1affff93 	bne	12d0 <sd_raw_write+0x18>
    1480:	ea000006 	b	14a0 <sd_raw_write+0x1e8>
    1484:	e3a00000 	mov	r0, #0	; 0x0
    1488:	ea000005 	b	14a4 <sd_raw_write+0x1ec>
    148c:	e5943004 	ldr	r3, [r4, #4]
    1490:	e3a00000 	mov	r0, #0	; 0x0
    1494:	e3833080 	orr	r3, r3, #128	; 0x80
    1498:	e5843004 	str	r3, [r4, #4]
    149c:	ea000000 	b	14a4 <sd_raw_write+0x1ec>
    14a0:	e3a00001 	mov	r0, #1	; 0x1
    14a4:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    14a8:	e12fff1e 	bx	lr
    14ac:	40000cd8 	ldrmid	r0, [r0], -r8
    14b0:	40000cdc 	ldrmid	r0, [r0], -ip
    14b4:	40000ad8 	ldrmid	r0, [r0], -r8
    14b8:	000001ff 	streqd	r0, [r0], -pc
    14bc:	e0028000 	and	r8, r2, r0
    14c0:	e0020000 	and	r0, r2, r0
    14c4:	40000ad9 	ldrmid	r0, [r0], -r9
    14c8:	40000cd9 	ldrmid	r0, [r0], -r9

000014cc <sd_raw_sync>:
    14cc:	e52de004 	str	lr, [sp, #-4]!
    14d0:	e59f3030 	ldr	r3, [pc, #48]	; 1508 <.text+0x1508>
    14d4:	e5d33000 	ldrb	r3, [r3]
    14d8:	e3530000 	cmp	r3, #0	; 0x0
    14dc:	e59f1028 	ldr	r1, [pc, #40]	; 150c <.text+0x150c>
    14e0:	e3a02c02 	mov	r2, #512	; 0x200
    14e4:	e3a00001 	mov	r0, #1	; 0x1
    14e8:	1a000004 	bne	1500 <sd_raw_sync+0x34>
    14ec:	e59f301c 	ldr	r3, [pc, #28]	; 1510 <.text+0x1510>
    14f0:	e5930000 	ldr	r0, [r3]
    14f4:	ebffff6f 	bl	12b8 <sd_raw_write>
    14f8:	e2500000 	subs	r0, r0, #0	; 0x0
    14fc:	13a00001 	movne	r0, #1	; 0x1
    1500:	e49de004 	ldr	lr, [sp], #4
    1504:	e12fff1e 	bx	lr
    1508:	40000cdc 	ldrmid	r0, [r0], -ip
    150c:	40000ad8 	ldrmid	r0, [r0], -r8
    1510:	40000cd8 	ldrmid	r0, [r0], -r8

00001514 <sd_raw_read_interval>:
    1514:	e1a02802 	mov	r2, r2, lsl #16
    1518:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
    151c:	e1a03803 	mov	r3, r3, lsl #16
    1520:	e3520000 	cmp	r2, #0	; 0x0
    1524:	13510000 	cmpne	r1, #0	; 0x0
    1528:	e1a07001 	mov	r7, r1
    152c:	e1a06000 	mov	r6, r0
    1530:	e1a05823 	mov	r5, r3, lsr #16
    1534:	e28d801c 	add	r8, sp, #28	; 0x1c
    1538:	e8980500 	ldmia	r8, {r8, sl}
    153c:	e1a04822 	mov	r4, r2, lsr #16
    1540:	0a00001a 	beq	15b0 <sd_raw_read_interval+0x9c>
    1544:	e2783001 	rsbs	r3, r8, #1	; 0x1
    1548:	33a03000 	movcc	r3, #0	; 0x0
    154c:	e1550004 	cmp	r5, r4
    1550:	33833001 	orrcc	r3, r3, #1	; 0x1
    1554:	e3530000 	cmp	r3, #0	; 0x0
    1558:	0a00000e 	beq	1598 <sd_raw_read_interval+0x84>
    155c:	ea000013 	b	15b0 <sd_raw_read_interval+0x9c>
    1560:	ebfffefc 	bl	1158 <sd_raw_read>
    1564:	e3500000 	cmp	r0, #0	; 0x0
    1568:	e1a01006 	mov	r1, r6
    156c:	e1a0200a 	mov	r2, sl
    1570:	e1a00007 	mov	r0, r7
    1574:	e0866004 	add	r6, r6, r4
    1578:	0a00000c 	beq	15b0 <sd_raw_read_interval+0x9c>
    157c:	e1a0e00f 	mov	lr, pc
    1580:	e12fff18 	bx	r8
    1584:	e3500000 	cmp	r0, #0	; 0x0
    1588:	0a00000a 	beq	15b8 <sd_raw_read_interval+0xa4>
    158c:	e0643005 	rsb	r3, r4, r5
    1590:	e1a03803 	mov	r3, r3, lsl #16
    1594:	e1a05823 	mov	r5, r3, lsr #16
    1598:	e1550004 	cmp	r5, r4
    159c:	e1a00006 	mov	r0, r6
    15a0:	e1a01007 	mov	r1, r7
    15a4:	e1a02004 	mov	r2, r4
    15a8:	2affffec 	bcs	1560 <sd_raw_read_interval+0x4c>
    15ac:	ea000001 	b	15b8 <sd_raw_read_interval+0xa4>
    15b0:	e3a00000 	mov	r0, #0	; 0x0
    15b4:	ea000000 	b	15bc <sd_raw_read_interval+0xa8>
    15b8:	e3a00001 	mov	r0, #1	; 0x1
    15bc:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
    15c0:	e12fff1e 	bx	lr

000015c4 <sd_raw_init>:
    15c4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    15c8:	e59f41e4 	ldr	r4, [pc, #484]	; 17b4 <.text+0x17b4>
    15cc:	e5943008 	ldr	r3, [r4, #8]
    15d0:	e3833080 	orr	r3, r3, #128	; 0x80
    15d4:	e5843008 	str	r3, [r4, #8]
    15d8:	e59f21d8 	ldr	r2, [pc, #472]	; 17b8 <.text+0x17b8>
    15dc:	e5923000 	ldr	r3, [r2]
    15e0:	e3833a01 	orr	r3, r3, #4096	; 0x1000
    15e4:	e5823000 	str	r3, [r2]
    15e8:	e5923000 	ldr	r3, [r2]
    15ec:	e3833b01 	orr	r3, r3, #1024	; 0x400
    15f0:	e5823000 	str	r3, [r2]
    15f4:	e5923000 	ldr	r3, [r2]
    15f8:	e3833c01 	orr	r3, r3, #256	; 0x100
    15fc:	e5823000 	str	r3, [r2]
    1600:	e5943004 	ldr	r3, [r4, #4]
    1604:	e3833080 	orr	r3, r3, #128	; 0x80
    1608:	e5843004 	str	r3, [r4, #4]
    160c:	e2422903 	sub	r2, r2, #49152	; 0xc000
    1610:	e3a03096 	mov	r3, #150	; 0x96
    1614:	e582300c 	str	r3, [r2, #12]
    1618:	e3a03038 	mov	r3, #56	; 0x38
    161c:	e5823000 	str	r3, [r2]
    1620:	ebfffdcb 	bl	d54 <sd_raw_available>
    1624:	e2505000 	subs	r5, r0, #0	; 0x0
    1628:	1a000002 	bne	1638 <sd_raw_init+0x74>
    162c:	e59f0188 	ldr	r0, [pc, #392]	; 17bc <.text+0x17bc>
    1630:	ebfffb68 	bl	3d8 <rprintf>
    1634:	ea00004f 	b	1778 <sd_raw_init+0x1b4>
    1638:	e5943008 	ldr	r3, [r4, #8]
    163c:	e3833080 	orr	r3, r3, #128	; 0x80
    1640:	e5843008 	str	r3, [r4, #8]
    1644:	e5943004 	ldr	r3, [r4, #4]
    1648:	e3833080 	orr	r3, r3, #128	; 0x80
    164c:	e5843004 	str	r3, [r4, #4]
    1650:	e3a04000 	mov	r4, #0	; 0x0
    1654:	ebfffdcd 	bl	d90 <sd_raw_rec_byte>
    1658:	e2843001 	add	r3, r4, #1	; 0x1
    165c:	e1a03803 	mov	r3, r3, lsl #16
    1660:	e1a04823 	mov	r4, r3, lsr #16
    1664:	e354000a 	cmp	r4, #10	; 0xa
    1668:	1afffff9 	bne	1654 <sd_raw_init+0x90>
    166c:	e59f2140 	ldr	r2, [pc, #320]	; 17b4 <.text+0x17b4>
    1670:	e592300c 	ldr	r3, [r2, #12]
    1674:	e3833080 	orr	r3, r3, #128	; 0x80
    1678:	e582300c 	str	r3, [r2, #12]
    167c:	e3a05000 	mov	r5, #0	; 0x0
    1680:	e3a00000 	mov	r0, #0	; 0x0
    1684:	e1a01000 	mov	r1, r0
    1688:	ebfffdcb 	bl	dbc <sd_raw_send_command_r1>
    168c:	e1a04000 	mov	r4, r0
    1690:	e1a01005 	mov	r1, r5
    1694:	e59f0124 	ldr	r0, [pc, #292]	; 17c0 <.text+0x17c0>
    1698:	e1a02004 	mov	r2, r4
    169c:	ebfffb4d 	bl	3d8 <rprintf>
    16a0:	e3540001 	cmp	r4, #1	; 0x1
    16a4:	e2855001 	add	r5, r5, #1	; 0x1
    16a8:	0a00000a 	beq	16d8 <sd_raw_init+0x114>
    16ac:	e3550c02 	cmp	r5, #512	; 0x200
    16b0:	1afffff2 	bne	1680 <sd_raw_init+0xbc>
    16b4:	e59f0108 	ldr	r0, [pc, #264]	; 17c4 <.text+0x17c4>
    16b8:	e1a01004 	mov	r1, r4
    16bc:	ebfffb45 	bl	3d8 <rprintf>
    16c0:	e59f20ec 	ldr	r2, [pc, #236]	; 17b4 <.text+0x17b4>
    16c4:	e5923004 	ldr	r3, [r2, #4]
    16c8:	e3a00000 	mov	r0, #0	; 0x0
    16cc:	e3833080 	orr	r3, r3, #128	; 0x80
    16d0:	e5823004 	str	r3, [r2, #4]
    16d4:	ea000034 	b	17ac <sd_raw_init+0x1e8>
    16d8:	e3a04000 	mov	r4, #0	; 0x0
    16dc:	e3a01000 	mov	r1, #0	; 0x0
    16e0:	e3a00001 	mov	r0, #1	; 0x1
    16e4:	ebfffdb4 	bl	dbc <sd_raw_send_command_r1>
    16e8:	e2843001 	add	r3, r4, #1	; 0x1
    16ec:	e3100001 	tst	r0, #1	; 0x1
    16f0:	e1a02803 	mov	r2, r3, lsl #16
    16f4:	0a000004 	beq	170c <sd_raw_init+0x148>
    16f8:	e59f30c8 	ldr	r3, [pc, #200]	; 17c8 <.text+0x17c8>
    16fc:	e1540003 	cmp	r4, r3
    1700:	e1a04822 	mov	r4, r2, lsr #16
    1704:	0a00001d 	beq	1780 <sd_raw_init+0x1bc>
    1708:	eafffff3 	b	16dc <sd_raw_init+0x118>
    170c:	e3a00010 	mov	r0, #16	; 0x10
    1710:	e3a01c02 	mov	r1, #512	; 0x200
    1714:	ebfffda8 	bl	dbc <sd_raw_send_command_r1>
    1718:	e3500000 	cmp	r0, #0	; 0x0
    171c:	159f2090 	ldrne	r2, [pc, #144]	; 17b4 <.text+0x17b4>
    1720:	15923004 	ldrne	r3, [r2, #4]
    1724:	159f00a0 	ldrne	r0, [pc, #160]	; 17cc <.text+0x17cc>
    1728:	13833080 	orrne	r3, r3, #128	; 0x80
    172c:	1a000017 	bne	1790 <sd_raw_init+0x1cc>
    1730:	e59fc07c 	ldr	ip, [pc, #124]	; 17b4 <.text+0x17b4>
    1734:	e59c3004 	ldr	r3, [ip, #4]
    1738:	e3833080 	orr	r3, r3, #128	; 0x80
    173c:	e58c3004 	str	r3, [ip, #4]
    1740:	e59f3088 	ldr	r3, [pc, #136]	; 17d0 <.text+0x17d0>
    1744:	e3e0c000 	mvn	ip, #0	; 0x0
    1748:	e583c000 	str	ip, [r3]
    174c:	e59f3080 	ldr	r3, [pc, #128]	; 17d4 <.text+0x17d4>
    1750:	e28cc03d 	add	ip, ip, #61	; 0x3d
    1754:	e583c00c 	str	ip, [r3, #12]
    1758:	e59f3078 	ldr	r3, [pc, #120]	; 17d8 <.text+0x17d8>
    175c:	e3a05001 	mov	r5, #1	; 0x1
    1760:	e59f1074 	ldr	r1, [pc, #116]	; 17dc <.text+0x17dc>
    1764:	e3a02c02 	mov	r2, #512	; 0x200
    1768:	e5c35000 	strb	r5, [r3]
    176c:	ebfffe79 	bl	1158 <sd_raw_read>
    1770:	e2504000 	subs	r4, r0, #0	; 0x0
    1774:	0a000009 	beq	17a0 <sd_raw_init+0x1dc>
    1778:	e1a00005 	mov	r0, r5
    177c:	ea00000a 	b	17ac <sd_raw_init+0x1e8>
    1780:	e59f202c 	ldr	r2, [pc, #44]	; 17b4 <.text+0x17b4>
    1784:	e5923004 	ldr	r3, [r2, #4]
    1788:	e59f0050 	ldr	r0, [pc, #80]	; 17e0 <.text+0x17e0>
    178c:	e3833080 	orr	r3, r3, #128	; 0x80
    1790:	e5823004 	str	r3, [r2, #4]
    1794:	ebfffb0f 	bl	3d8 <rprintf>
    1798:	e3a00000 	mov	r0, #0	; 0x0
    179c:	ea000002 	b	17ac <sd_raw_init+0x1e8>
    17a0:	e59f003c 	ldr	r0, [pc, #60]	; 17e4 <.text+0x17e4>
    17a4:	ebfffb0b 	bl	3d8 <rprintf>
    17a8:	e1a00004 	mov	r0, r4
    17ac:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    17b0:	e12fff1e 	bx	lr
    17b4:	e0028000 	and	r8, r2, r0
    17b8:	e002c000 	and	ip, r2, r0
    17bc:	00005ed4 	ldreqd	r5, [r0], -r4
    17c0:	00005eec 	andeq	r5, r0, ip, ror #29
    17c4:	00005f00 	andeq	r5, r0, r0, lsl #30
    17c8:	00007fff 	streqd	r7, [r0], -pc
    17cc:	00005f24 	andeq	r5, r0, r4, lsr #30
    17d0:	40000cd8 	ldrmid	r0, [r0], -r8
    17d4:	e0020000 	and	r0, r2, r0
    17d8:	40000cdc 	ldrmid	r0, [r0], -ip
    17dc:	40000ad8 	ldrmid	r0, [r0], -r8
    17e0:	00005f14 	andeq	r5, r0, r4, lsl pc
    17e4:	00005f3c 	andeq	r5, r0, ip, lsr pc

000017e8 <format_card>:

//NES : 10-28-7 
//Low-level formats a 512MB card
//Assumes *many* things
//You must pass this fuction 0xAA to get it to work (safety check)
char format_card(char make_sure)
{
    17e8:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    17ec:	e20000ff 	and	r0, r0, #255	; 0xff
	#define MBR_LOCATION	0x00
	#define BR_LOCATION		(MBR_LOCATION+0x80000)
	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))

	//Safety check
	if (make_sure != 0xAA) return 0;
    17f0:	e35000aa 	cmp	r0, #170	; 0xaa
    17f4:	e24ddc02 	sub	sp, sp, #512	; 0x200
    17f8:	13a00000 	movne	r0, #0	; 0x0
    17fc:	1a00006d 	bne	19b8 <format_card+0x1d0>
    1800:	e3a04000 	mov	r4, #0	; 0x0
	
	int i;
	unsigned char my_buff[512];
	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
    1804:	e3a06000 	mov	r6, #0	; 0x0
    1808:	e7c4600d 	strb	r6, [r4, sp]
    180c:	e2844001 	add	r4, r4, #1	; 0x1
    1810:	e3540c02 	cmp	r4, #512	; 0x200
    1814:	1afffffa 	bne	1804 <format_card+0x1c>
	
	//Init SD card interface
	sd_raw_init();
    1818:	ebffff69 	bl	15c4 <sd_raw_init>

	//Erase Master Boot record
	sd_raw_sync();
    181c:	ebffff2a 	bl	14cc <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
    1820:	e1a02004 	mov	r2, r4
    1824:	e1a0100d 	mov	r1, sp
    1828:	e1a00006 	mov	r0, r6
    182c:	ebfffea1 	bl	12b8 <sd_raw_write>

	//Erase Boot record
	sd_raw_sync();
    1830:	ebffff25 	bl	14cc <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
    1834:	e1a02004 	mov	r2, r4
    1838:	e1a0100d 	mov	r1, sp
    183c:	e3a00702 	mov	r0, #524288	; 0x80000
    1840:	ebfffe9c 	bl	12b8 <sd_raw_write>
    1844:	e3a04703 	mov	r4, #786432	; 0xc0000

	//Erase FAT tables
	for(i = 0 ; i < 0x00F5 ; i++) //0x00F5 = 245 bytes : comes from byte 0x16 from Boot Record
	{
		sd_raw_sync();
    1848:	ebffff1f 	bl	14cc <sd_raw_sync>
		sd_raw_write( (FAT_TABLE + (i*512)), my_buff, 512);
    184c:	e1a00004 	mov	r0, r4
    1850:	e1a0100d 	mov	r1, sp
    1854:	e3a02c02 	mov	r2, #512	; 0x200
    1858:	ebfffe96 	bl	12b8 <sd_raw_write>
    185c:	e59f3160 	ldr	r3, [pc, #352]	; 19c4 <.text+0x19c4>
    1860:	e2844c02 	add	r4, r4, #512	; 0x200
    1864:	e1540003 	cmp	r4, r3
    1868:	e1a0900d 	mov	r9, sp
    186c:	1afffff5 	bne	1848 <format_card+0x60>
	}
	
	//Write Master Boot Record
	#define PART1	0x01BE
	my_buff[PART1 + 0] = 0x00;
	my_buff[PART1 + 1] = 0x00;
	my_buff[PART1 + 2] = 0x01;
	my_buff[PART1 + 3] = 0x01;
	my_buff[PART1 + 4] = 0x06;
    1870:	e3a03006 	mov	r3, #6	; 0x6
    1874:	e5cd31c2 	strb	r3, [sp, #450]
	my_buff[PART1 + 5] = 0x1F;
    1878:	e2833019 	add	r3, r3, #25	; 0x19
    187c:	e5cd31c3 	strb	r3, [sp, #451]
	my_buff[PART1 + 6] = 0xE0;
    1880:	e3e0301f 	mvn	r3, #31	; 0x1f
    1884:	e3a04000 	mov	r4, #0	; 0x0
    1888:	e3a02001 	mov	r2, #1	; 0x1
	my_buff[PART1 + 7] = 0xD3;
	my_buff[PART1 + 8] = 0x00;
	my_buff[PART1 + 9] = 0x04;
	my_buff[PART1 + 10] = 0x00;
	my_buff[PART1 + 11] = 0x00;
	my_buff[PART1 + 12] = 0x00;
	my_buff[PART1 + 13] = 0x4C;
	my_buff[PART1 + 14] = 0x0F;
	my_buff[510] = 0x55;
    188c:	e3a05055 	mov	r5, #85	; 0x55
    1890:	e3a06004 	mov	r6, #4	; 0x4
    1894:	e3a0704c 	mov	r7, #76	; 0x4c
    1898:	e3a0800f 	mov	r8, #15	; 0xf
	my_buff[511] = 0xAA;
    189c:	e3e0a055 	mvn	sl, #85	; 0x55
    18a0:	e5cd31c4 	strb	r3, [sp, #452]
    18a4:	e3e0302c 	mvn	r3, #44	; 0x2c
    18a8:	e5cd31c5 	strb	r3, [sp, #453]
    18ac:	e5cd21c1 	strb	r2, [sp, #449]
    18b0:	e5cd21c0 	strb	r2, [sp, #448]
    18b4:	e5cd41be 	strb	r4, [sp, #446]
    18b8:	e5cd41bf 	strb	r4, [sp, #447]
    18bc:	e5cd41c6 	strb	r4, [sp, #454]
    18c0:	e5cd61c7 	strb	r6, [sp, #455]
    18c4:	e5cd41c8 	strb	r4, [sp, #456]
    18c8:	e5cd41c9 	strb	r4, [sp, #457]
    18cc:	e5cd41ca 	strb	r4, [sp, #458]
    18d0:	e5cd71cb 	strb	r7, [sp, #459]
    18d4:	e5cd81cc 	strb	r8, [sp, #460]
    18d8:	e5cd51fe 	strb	r5, [sp, #510]
    18dc:	e5cda1ff 	strb	sl, [sp, #511]

	sd_raw_sync();
    18e0:	ebfffef9 	bl	14cc <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
    18e4:	e1a0100d 	mov	r1, sp
    18e8:	e3a02c02 	mov	r2, #512	; 0x200
    18ec:	e1a00004 	mov	r0, r4
    18f0:	ebfffe70 	bl	12b8 <sd_raw_write>
	sd_raw_sync();
    18f4:	ebfffef4 	bl	14cc <sd_raw_sync>

	//Write Boot Record
	#define BOOTRECORD1	0x80000
	my_buff[0] = 0xEB;
    18f8:	e3e03014 	mvn	r3, #20	; 0x14
    18fc:	e5cd3000 	strb	r3, [sp]
	my_buff[1] = 0xFE;
    1900:	e2833013 	add	r3, r3, #19	; 0x13
    1904:	e5cd3001 	strb	r3, [sp, #1]
	my_buff[2] = 0x90;
    1908:	e3e0306f 	mvn	r3, #111	; 0x6f
    190c:	e5cd3002 	strb	r3, [sp, #2]
	my_buff[12] = 0x02;
	my_buff[13] = 0x10;
    1910:	e2833080 	add	r3, r3, #128	; 0x80
    1914:	e5cd300d 	strb	r3, [sp, #13]
	my_buff[14] = 0x16;
    1918:	e2833006 	add	r3, r3, #6	; 0x6
    191c:	e5cd300e 	strb	r3, [sp, #14]
	my_buff[16] = 0x02;
	my_buff[18] = 0x02;
	my_buff[21] = 0xF8;
    1920:	e3e03007 	mvn	r3, #7	; 0x7
    1924:	e5cd3015 	strb	r3, [sp, #21]
	my_buff[22] = 0xF5;
    1928:	e3e0300a 	mvn	r3, #10	; 0xa
    192c:	e5cd3016 	strb	r3, [sp, #22]
	my_buff[24] = 0x20;
	my_buff[26] = 0x20;
	my_buff[29] = 0x04;
	my_buff[33] = 0x4C;
	my_buff[34] = 0x0F;
	my_buff[38] = 0x29;
    1930:	e2833034 	add	r3, r3, #52	; 0x34
    1934:	e5cd3026 	strb	r3, [sp, #38]
	my_buff[54] = 0x46;
    1938:	e283301d 	add	r3, r3, #29	; 0x1d
    193c:	e5cd3036 	strb	r3, [sp, #54]
	my_buff[55] = 0x41;
    1940:	e3a03041 	mov	r3, #65	; 0x41
    1944:	e5cd3037 	strb	r3, [sp, #55]
	my_buff[56] = 0x54;
    1948:	e2833013 	add	r3, r3, #19	; 0x13
    194c:	e5cd3038 	strb	r3, [sp, #56]
	my_buff[57] = 0x31;
    1950:	e3a03031 	mov	r3, #49	; 0x31
    1954:	e3a02020 	mov	r2, #32	; 0x20
    1958:	e3a01002 	mov	r1, #2	; 0x2
    195c:	e5cd3039 	strb	r3, [sp, #57]
	my_buff[58] = 0x36;
    1960:	e2833005 	add	r3, r3, #5	; 0x5
    1964:	e5cd303a 	strb	r3, [sp, #58]
    1968:	e5cd1012 	strb	r1, [sp, #18]
	my_buff[59] = 0x20;
	my_buff[60] = 0x20;
	my_buff[61] = 0x20;
    196c:	e5cd203d 	strb	r2, [sp, #61]
    1970:	e5cd100c 	strb	r1, [sp, #12]
    1974:	e5cd1010 	strb	r1, [sp, #16]
    1978:	e5cd2018 	strb	r2, [sp, #24]
    197c:	e5cd201a 	strb	r2, [sp, #26]
    1980:	e5cd203b 	strb	r2, [sp, #59]
    1984:	e5cd203c 	strb	r2, [sp, #60]
    1988:	e5cd601d 	strb	r6, [sp, #29]
    198c:	e5cd7021 	strb	r7, [sp, #33]
    1990:	e5cd8022 	strb	r8, [sp, #34]
	my_buff[510] = 0x55;
	my_buff[511] = 0xAA;
    1994:	e5cda1ff 	strb	sl, [sp, #511]
    1998:	e5cd51fe 	strb	r5, [sp, #510]
	
	sd_raw_sync();
    199c:	ebfffeca 	bl	14cc <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
    19a0:	e1a0100d 	mov	r1, sp
    19a4:	e3a02c02 	mov	r2, #512	; 0x200
    19a8:	e3a00702 	mov	r0, #524288	; 0x80000
    19ac:	ebfffe41 	bl	12b8 <sd_raw_write>
	sd_raw_sync();
    19b0:	ebfffec5 	bl	14cc <sd_raw_sync>
    19b4:	e1a00005 	mov	r0, r5
	
	return(0x55); //Successful format
}
    19b8:	e28ddc02 	add	sp, sp, #512	; 0x200
    19bc:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    19c0:	e12fff1e 	bx	lr
    19c4:	000dea00 	andeq	lr, sp, r0, lsl #20

000019c8 <fat16_dir_entry_seek_callback>:
{
    struct fat16_read_callback_arg* arg = p;

    /* skip deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
    19c8:	e5d03000 	ldrb	r3, [r0]
    19cc:	e3530000 	cmp	r3, #0	; 0x0
    19d0:	135300e5 	cmpne	r3, #229	; 0xe5
    19d4:	0a000015 	beq	1a30 <fat16_dir_entry_seek_callback+0x68>
        return 1;

    if(arg->entry_cur == arg->entry_num)
    19d8:	e1d2c0b0 	ldrh	ip, [r2]
    19dc:	e1d230b2 	ldrh	r3, [r2, #2]
    19e0:	e153000c 	cmp	r3, ip
    19e4:	1a00000b 	bne	1a18 <fat16_dir_entry_seek_callback+0x50>
    {
        arg->entry_offset = offset;
    19e8:	e5821004 	str	r1, [r2, #4]
        arg->byte_count = buffer[11] == 0x0f ?
    19ec:	e5d0300b 	ldrb	r3, [r0, #11]
    19f0:	e353000f 	cmp	r3, #15	; 0xf
    19f4:	05d03000 	ldreqb	r3, [r0]
    19f8:	0203303f 	andeq	r3, r3, #63	; 0x3f
    19fc:	01a03283 	moveq	r3, r3, lsl #5
    1a00:	02833020 	addeq	r3, r3, #32	; 0x20
    1a04:	e3a01020 	mov	r1, #32	; 0x20
    1a08:	e3a00000 	mov	r0, #0	; 0x0
    1a0c:	020310ff 	andeq	r1, r3, #255	; 0xff
    1a10:	e5c21008 	strb	r1, [r2, #8]
    1a14:	e12fff1e 	bx	lr
        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
        32;
        return 0;
    }

    /* if we read a 8.3 entry, we reached a new directory entry */
    if(buffer[11] != 0x0f)
    1a18:	e5d0300b 	ldrb	r3, [r0, #11]
        ++arg->entry_cur;
    1a1c:	e28c1001 	add	r1, ip, #1	; 0x1
    1a20:	e353000f 	cmp	r3, #15	; 0xf
    1a24:	e3a00001 	mov	r0, #1	; 0x1
    1a28:	11c210b0 	strneh	r1, [r2]
    1a2c:	112fff1e 	bxne	lr
    1a30:	e3a00001 	mov	r0, #1	; 0x1

    return 1;
}
    1a34:	e12fff1e 	bx	lr

00001a38 <fat16_dir_entry_read_callback>:

/**
 * \ingroup fat16_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    1a38:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    struct fat16_dir_entry_struct* dir_entry = p;

    /* there should not be any deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
    1a3c:	e5d03000 	ldrb	r3, [r0]
    1a40:	e3530000 	cmp	r3, #0	; 0x0
    1a44:	135300e5 	cmpne	r3, #229	; 0xe5
    1a48:	e1a0c002 	mov	ip, r2
    1a4c:	0a000062 	beq	1bdc <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    if(!dir_entry->entry_offset)
    1a50:	e5923028 	ldr	r3, [r2, #40]
    1a54:	e3530000 	cmp	r3, #0	; 0x0
        dir_entry->entry_offset = offset;
    1a58:	05821028 	streq	r1, [r2, #40]

    switch(fat16_interpret_dir_entry(dir_entry, buffer))
    {
        case 0: /* failure */
            return 0;
            case 1: /* buffer successfully parsed, continue */
            return 1;
            case 2: /* directory entry complete, finish */
            return 0;
        }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Interprets a raw directory entry and puts the contained
 * information into the directory entry.
 *
 * For a single file there may exist multiple directory
 * entries. All except the last one are lfn entries, which
 * contain parts of the long filename. The last directory
 * entry is a traditional 8.3 style one. It contains all
 * other information like size, cluster, date and time.
 *
 * \param[in,out] dir_entry The directory entry to fill.
 * \param[in] raw_entry A pointer to 32 bytes of raw data.
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
    1a5c:	e5d02000 	ldrb	r2, [r0]
    1a60:	e3520000 	cmp	r2, #0	; 0x0
    1a64:	0a00005c 	beq	1bdc <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
    1a68:	e5d0300b 	ldrb	r3, [r0, #11]
    1a6c:	e353000f 	cmp	r3, #15	; 0xf
    1a70:	e280500b 	add	r5, r0, #11	; 0xb
    1a74:	1a000026 	bne	1b14 <fat16_dir_entry_read_callback+0xdc>
    {
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
    1a78:	e202203f 	and	r2, r2, #63	; 0x3f
    1a7c:	e3a0300d 	mov	r3, #13	; 0xd
    1a80:	e0030392 	mul	r3, r2, r3
    1a84:	e243300d 	sub	r3, r3, #13	; 0xd
    1a88:	e1a03803 	mov	r3, r3, lsl #16
    1a8c:	e1a02823 	mov	r2, r3, lsr #16

        if(char_offset + 12 < sizeof(dir_entry->long_name))
    1a90:	e282300c 	add	r3, r2, #12	; 0xc
    1a94:	e353001f 	cmp	r3, #31	; 0x1f
    1a98:	83a00001 	movhi	r0, #1	; 0x1
    1a9c:	8a00004f 	bhi	1be0 <fat16_dir_entry_read_callback+0x1a8>
        {
            /* Lfn supports unicode, but we do not, for now.
                                                 * So we assume pure ascii and read only every
                                                 * second byte.
                                                 */
            long_name[char_offset + 0] = raw_entry[1];
    1aa0:	e5d03001 	ldrb	r3, [r0, #1]
    1aa4:	e7cc3002 	strb	r3, [ip, r2]
            long_name[char_offset + 1] = raw_entry[3];
    1aa8:	e5d03003 	ldrb	r3, [r0, #3]
    1aac:	e08c2002 	add	r2, ip, r2
    1ab0:	e5c23001 	strb	r3, [r2, #1]
            long_name[char_offset + 2] = raw_entry[5];
    1ab4:	e5d03005 	ldrb	r3, [r0, #5]
    1ab8:	e5c23002 	strb	r3, [r2, #2]
            long_name[char_offset + 3] = raw_entry[7];
    1abc:	e5d03007 	ldrb	r3, [r0, #7]
    1ac0:	e5c23003 	strb	r3, [r2, #3]
            long_name[char_offset + 4] = raw_entry[9];
    1ac4:	e5d03009 	ldrb	r3, [r0, #9]
    1ac8:	e5c23004 	strb	r3, [r2, #4]
            long_name[char_offset + 5] = raw_entry[14];
    1acc:	e5d0300e 	ldrb	r3, [r0, #14]
    1ad0:	e5c23005 	strb	r3, [r2, #5]
            long_name[char_offset + 6] = raw_entry[16];
    1ad4:	e5d03010 	ldrb	r3, [r0, #16]
    1ad8:	e5c23006 	strb	r3, [r2, #6]
            long_name[char_offset + 7] = raw_entry[18];
    1adc:	e5d03012 	ldrb	r3, [r0, #18]
    1ae0:	e5c23007 	strb	r3, [r2, #7]
            long_name[char_offset + 8] = raw_entry[20];
    1ae4:	e5d03014 	ldrb	r3, [r0, #20]
    1ae8:	e5c23008 	strb	r3, [r2, #8]
            long_name[char_offset + 9] = raw_entry[22];
    1aec:	e5d03016 	ldrb	r3, [r0, #22]
    1af0:	e5c23009 	strb	r3, [r2, #9]
            long_name[char_offset + 10] = raw_entry[24];
    1af4:	e5d03018 	ldrb	r3, [r0, #24]
    1af8:	e5c2300a 	strb	r3, [r2, #10]
            long_name[char_offset + 11] = raw_entry[28];
    1afc:	e5d0301c 	ldrb	r3, [r0, #28]
    1b00:	e5c2300b 	strb	r3, [r2, #11]
            long_name[char_offset + 12] = raw_entry[30];
    1b04:	e5d0301e 	ldrb	r3, [r0, #30]
    1b08:	e3a00001 	mov	r0, #1	; 0x1
    1b0c:	e5c2300c 	strb	r3, [r2, #12]
    1b10:	ea000032 	b	1be0 <fat16_dir_entry_read_callback+0x1a8>
        }

        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
    1b14:	e5dc2000 	ldrb	r2, [ip]
    1b18:	e3520000 	cmp	r2, #0	; 0x0
    1b1c:	1a00001d 	bne	1b98 <fat16_dir_entry_read_callback+0x160>
    1b20:	e1a01002 	mov	r1, r2
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
    1b24:	e7d23000 	ldrb	r3, [r2, r0]
    1b28:	e3530020 	cmp	r3, #32	; 0x20
    1b2c:	e281e001 	add	lr, r1, #1	; 0x1
    1b30:	0a000004 	beq	1b48 <fat16_dir_entry_read_callback+0x110>
    1b34:	e20e10ff 	and	r1, lr, #255	; 0xff
    1b38:	e3510008 	cmp	r1, #8	; 0x8
                    break;
                long_name[i] = raw_entry[i];
    1b3c:	e7c2300c 	strb	r3, [r2, ip]
    1b40:	e2822001 	add	r2, r2, #1	; 0x1
    1b44:	1afffff6 	bne	1b24 <fat16_dir_entry_read_callback+0xec>
            }
            if(raw_entry[8] != ' ')
    1b48:	e5d03008 	ldrb	r3, [r0, #8]
    1b4c:	e3530020 	cmp	r3, #32	; 0x20
    1b50:	0a00000e 	beq	1b90 <fat16_dir_entry_read_callback+0x158>
            {
                long_name[i++] = '.';
    1b54:	e3a0302e 	mov	r3, #46	; 0x2e
    1b58:	e2812001 	add	r2, r1, #1	; 0x1
    1b5c:	e7cc3001 	strb	r3, [ip, r1]
    1b60:	e20210ff 	and	r1, r2, #255	; 0xff
    1b64:	e1a03000 	mov	r3, r0

                uint8_t j = 8;
                for(; j < 11; ++j)
                {
                    if(raw_entry[j] != ' ')
    1b68:	e5d32008 	ldrb	r2, [r3, #8]
    1b6c:	e3520020 	cmp	r2, #32	; 0x20
    1b70:	e280e003 	add	lr, r0, #3	; 0x3
                    {
                        long_name[i++] = raw_entry[j];
    1b74:	e2814001 	add	r4, r1, #1	; 0x1
    1b78:	e2833001 	add	r3, r3, #1	; 0x1
    1b7c:	0a000003 	beq	1b90 <fat16_dir_entry_read_callback+0x158>
    1b80:	e153000e 	cmp	r3, lr
    1b84:	e7cc2001 	strb	r2, [ip, r1]
    1b88:	e20410ff 	and	r1, r4, #255	; 0xff
    1b8c:	1afffff5 	bne	1b68 <fat16_dir_entry_read_callback+0x130>
                    }
                    else
                    {
                        break;
                    }
                }
            }

            long_name[i] = '\0';
    1b90:	e3a03000 	mov	r3, #0	; 0x0
    1b94:	e7cc3001 	strb	r3, [ip, r1]
        }

        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
    1b98:	e5d53000 	ldrb	r3, [r5]
    1b9c:	e5cc3020 	strb	r3, [ip, #32]
        dir_entry->cluster = ((uint16_t) raw_entry[26]) |
    1ba0:	e5d0201b 	ldrb	r2, [r0, #27]
    1ba4:	e5d0301a 	ldrb	r3, [r0, #26]
    1ba8:	e1833402 	orr	r3, r3, r2, lsl #8
    1bac:	e1cc32b2 	strh	r3, [ip, #34]
        ((uint16_t) raw_entry[27] << 8);
        dir_entry->file_size = ((uint32_t) raw_entry[28]) |
    1bb0:	e5d0301e 	ldrb	r3, [r0, #30]
    1bb4:	e5d0201c 	ldrb	r2, [r0, #28]
    1bb8:	e5d0101d 	ldrb	r1, [r0, #29]
    1bbc:	e5d0001f 	ldrb	r0, [r0, #31]
    1bc0:	e1a03803 	mov	r3, r3, lsl #16
    1bc4:	e1833c00 	orr	r3, r3, r0, lsl #24
    1bc8:	e1822401 	orr	r2, r2, r1, lsl #8
    1bcc:	e1822003 	orr	r2, r2, r3
    1bd0:	e3a00000 	mov	r0, #0	; 0x0
    1bd4:	e58c2024 	str	r2, [ip, #36]
    1bd8:	ea000000 	b	1be0 <fat16_dir_entry_read_callback+0x1a8>
    1bdc:	e3a00000 	mov	r0, #0	; 0x0
    1be0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    1be4:	e12fff1e 	bx	lr

00001be8 <fat16_get_next_cluster>:
        ((uint32_t) raw_entry[29] << 8) |
        ((uint32_t) raw_entry[30] << 16) |
        ((uint32_t) raw_entry[31] << 24);

        return 2;
    }
}

/**
 * \ingroup fat16_file
 * Retrieves the directory entry of a path.
 *
 * The given path may both describe a file or a directory.
 *
 * \param[in] fs The FAT16 filesystem on which to search.
 * \param[in] path The path of which to read the directory entry.
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !path || path[0] == '\0' || !dir_entry)
        return 0;

    if(path[0] == '/')
        ++path;

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT16_ATTRIB_DIR;

    if(path[0] == '\0')
        return 1;

    while(1)
    {
        struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
        if(!dd)
            break;

        /* extract the next hierarchy we will search for */
        const char* sep_pos = strchr(path, '/');
        if(!sep_pos)
            sep_pos = path + strlen(path);
        uint8_t length_to_sep = sep_pos - path;

        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
                strncmp(path, dir_entry->long_name, length_to_sep) != 0))
            continue;

            fat16_close_dir(dd);
            dd = 0;

            if(path[length_to_sep] == '\0')
    /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT16_ATTRIB_DIR)
            {
                /* we found a parent directory of the file we are searching for */
                path = sep_pos + 1;
                break;
            }

            /* a parent of the file exists, but not the file itself */
            return 0;
        }

        fat16_close_dir(dd);
    }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Retrieves the next following cluster of a given cluster.
 *
 * Using the filesystem file allocation table, this function returns
 * the number of the cluster containing the data directly following
 * the data within the cluster with the given number.
 *
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    1be8:	e52de004 	str	lr, [sp, #-4]!
    1bec:	e1a03801 	mov	r3, r1, lsl #16
    1bf0:	e1a03823 	mov	r3, r3, lsr #16
    1bf4:	e24dd004 	sub	sp, sp, #4	; 0x4
    if(!fs || cluster_num < 2)
        return 0;

    /* read appropriate fat entry */
    uint8_t fat_entry[2];
    if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
    1bf8:	e3a02002 	mov	r2, #2	; 0x2
    1bfc:	e3500000 	cmp	r0, #0	; 0x0
    1c00:	13530001 	cmpne	r3, #1	; 0x1
    1c04:	e08d1002 	add	r1, sp, r2
    1c08:	e1a0c000 	mov	ip, r0
    1c0c:	9a00001a 	bls	1c7c <fat16_get_next_cluster+0x94>
    1c10:	e5900008 	ldr	r0, [r0, #8]
    1c14:	e0200293 	mla	r0, r3, r2, r0
    1c18:	e59c3000 	ldr	r3, [ip]
    1c1c:	e593c000 	ldr	ip, [r3]
    1c20:	e1a0e00f 	mov	lr, pc
    1c24:	e12fff1c 	bx	ip
    1c28:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    /* determine next cluster from fat */
    cluster_num = ((uint16_t) fat_entry[0]) |
    ((uint16_t) fat_entry[1] << 8);
	///*
    if(cluster_num == FAT16_CLUSTER_FREE ||
    1c2c:	e59f1058 	ldr	r1, [pc, #88]	; 1c8c <.text+0x1c8c>
    1c30:	0a000011 	beq	1c7c <fat16_get_next_cluster+0x94>
    1c34:	e5dd2002 	ldrb	r2, [sp, #2]
    1c38:	e5dd3003 	ldrb	r3, [sp, #3]
    1c3c:	e1920403 	orrs	r0, r2, r3, lsl #8
    1c40:	13a03000 	movne	r3, #0	; 0x0
    1c44:	03a03001 	moveq	r3, #1	; 0x1
    1c48:	e1500001 	cmp	r0, r1
    1c4c:	03833001 	orreq	r3, r3, #1	; 0x1
    1c50:	e2802010 	add	r2, r0, #16	; 0x10
    1c54:	e3530000 	cmp	r3, #0	; 0x0
    1c58:	e1a02802 	mov	r2, r2, lsl #16
    1c5c:	1a000006 	bne	1c7c <fat16_get_next_cluster+0x94>
    1c60:	e1500001 	cmp	r0, r1
    1c64:	93a03000 	movls	r3, #0	; 0x0
    1c68:	83a03001 	movhi	r3, #1	; 0x1
    1c6c:	e3520806 	cmp	r2, #393216	; 0x60000
    1c70:	93833001 	orrls	r3, r3, #1	; 0x1
    1c74:	e3530000 	cmp	r3, #0	; 0x0
    1c78:	0a000000 	beq	1c80 <fat16_get_next_cluster+0x98>
        cluster_num == FAT16_CLUSTER_BAD ||
       (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
	   //********************************************************************************
       //(cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
	   (cluster_num >= FAT16_CLUSTER_LAST_MIN))
	   //********************************************************************************
    //*/
	return 0;

    return cluster_num;
    1c7c:	e3a00000 	mov	r0, #0	; 0x0
}
    1c80:	e28dd004 	add	sp, sp, #4	; 0x4
    1c84:	e49de004 	ldr	lr, [sp], #4
    1c88:	e12fff1e 	bx	lr
    1c8c:	0000fff7 	streqd	pc, [r0], -r7

00001c90 <fat16_free_clusters>:

/**
 * \ingroup fat16_fs
 * Appends a new cluster chain to an existing one.
 *
 * Set cluster_num to zero to create a completely new one.
 *
 * \param[in] fs The file system on which to operate.
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs)
            return 0;
    
        device_read_t device_read = fs->partition->device_read;
        device_write_t device_write = fs->partition->device_write;
        uint32_t fat_offset = fs->header.fat_offset;
        uint16_t cluster_max = fs->header.fat_size / 2;
        uint16_t cluster_next = 0;
        uint16_t count_left = count;
        uint8_t buffer[2];
        uint16_t cluster_new;
        for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
        {
            if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                return 0;
    
            /* check if this is a free cluster */
            if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
                buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
            {
                /* allocate cluster */
                if(count_left == count)
                {
                    buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
                    buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
                }
                else
                {
                    buffer[0] = cluster_next & 0xff;
                    buffer[1] = (cluster_next >> 8) & 0xff;
                }
    
                if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                    break;
    
                cluster_next = cluster_new;
                if(--count_left == 0)
                    break;
            }
        }
    
        do
        {
            if(count_left > 0)
                break;
    
            /* We allocated a new cluster chain. Now join
                                             * it with the existing one.
                                             */
            if(cluster_num >= 2)
            {
                buffer[0] = cluster_next & 0xff;
                buffer[1] = (cluster_next >> 8) & 0xff;
                if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
                    break;
            }
    
            return cluster_next;
    
        }
        while(0);
    
        /* No space left on device or writing error.
                             * Free up all clusters already allocated.
                             */
        fat16_free_clusters(fs, cluster_next);
    
        return 0;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_fs
 * Frees a cluster chain, or a part thereof.
 *
 * Marks the specified cluster and all clusters which are sequentially
 * referenced by it as free. They may then be used again for future
 * file allocations.
 *
 * \note If this function is used for freeing just a part of a cluster
 *       chain, the new end of the chain is not correctly terminated
 *       within the FAT. Use fat16_terminate_clusters() instead.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat16_terminate_clusters
 */
uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    1c90:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    1c94:	e1a01801 	mov	r1, r1, lsl #16
    1c98:	e1a03821 	mov	r3, r1, lsr #16
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
    1c9c:	e3500000 	cmp	r0, #0	; 0x0
    1ca0:	13530001 	cmpne	r3, #1	; 0x1
    1ca4:	e24dd004 	sub	sp, sp, #4	; 0x4
    1ca8:	e1a05000 	mov	r5, r0
            return 0;
    
        uint32_t fat_offset = fs->header.fat_offset;
    1cac:	85907008 	ldrhi	r7, [r0, #8]
    1cb0:	8a00001d 	bhi	1d2c <fat16_free_clusters+0x9c>
    1cb4:	ea000024 	b	1d4c <fat16_free_clusters+0xbc>
        uint8_t buffer[2];
        while(cluster_num)
        {
            if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
    1cb8:	e5953000 	ldr	r3, [r5]
    1cbc:	e593c000 	ldr	ip, [r3]
    1cc0:	e1a0e00f 	mov	lr, pc
    1cc4:	e12fff1c 	bx	ip
                return 0;
    
            /* get next cluster of current cluster before freeing current cluster */
            uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
            ((uint16_t) buffer[1] << 8);
    
            if(cluster_num_next == FAT16_CLUSTER_FREE)
                return 1;
            if(cluster_num_next == FAT16_CLUSTER_BAD ||
                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
               cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
               )
               )
            return 0;
			///*
			//**********************************************************
            //if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
            //    (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
            //   )
			if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN)
			//***********************************************************
			//*/
            cluster_num_next = 0;
    
            /* free cluster */
            buffer[0] = FAT16_CLUSTER_FREE & 0xff;
    1cc8:	e3a0e000 	mov	lr, #0	; 0x0
    1ccc:	e150000e 	cmp	r0, lr
            buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
            fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
    1cd0:	e1a01006 	mov	r1, r6
    1cd4:	e3a02002 	mov	r2, #2	; 0x2
    1cd8:	e1a00004 	mov	r0, r4
    1cdc:	0a00001a 	beq	1d4c <fat16_free_clusters+0xbc>
    1ce0:	e5dd3002 	ldrb	r3, [sp, #2]
    1ce4:	e5ddc003 	ldrb	ip, [sp, #3]
    1ce8:	e193340c 	orrs	r3, r3, ip, lsl #8
    1cec:	e1a04003 	mov	r4, r3
    1cf0:	e2833010 	add	r3, r3, #16	; 0x10
    1cf4:	e1a03803 	mov	r3, r3, lsl #16
    1cf8:	0a000015 	beq	1d54 <fat16_free_clusters+0xc4>
    1cfc:	e3530807 	cmp	r3, #458752	; 0x70000
    1d00:	9a000011 	bls	1d4c <fat16_free_clusters+0xbc>
    1d04:	e59f3058 	ldr	r3, [pc, #88]	; 1d64 <.text+0x1d64>
    1d08:	e5cde003 	strb	lr, [sp, #3]
    1d0c:	e5cde002 	strb	lr, [sp, #2]
    1d10:	e1540003 	cmp	r4, r3
    1d14:	81a0400e 	movhi	r4, lr
    1d18:	e5953000 	ldr	r3, [r5]
    1d1c:	e593c008 	ldr	ip, [r3, #8]
    1d20:	e1a0e00f 	mov	lr, pc
    1d24:	e12fff1c 	bx	ip
    1d28:	e1a03004 	mov	r3, r4
    1d2c:	e0874083 	add	r4, r7, r3, lsl #1
    1d30:	e28d6002 	add	r6, sp, #2	; 0x2
    1d34:	e3530000 	cmp	r3, #0	; 0x0
    1d38:	e1a01006 	mov	r1, r6
    1d3c:	e3a02002 	mov	r2, #2	; 0x2
    1d40:	e1a00004 	mov	r0, r4
    1d44:	1affffdb 	bne	1cb8 <fat16_free_clusters+0x28>
    1d48:	ea000001 	b	1d54 <fat16_free_clusters+0xc4>
    1d4c:	e3a00000 	mov	r0, #0	; 0x0
    1d50:	ea000000 	b	1d58 <fat16_free_clusters+0xc8>
    1d54:	e3a00001 	mov	r0, #1	; 0x1
    
            /* We continue in any case here, even if freeing the cluster failed.
                                             * The cluster is lost, but maybe we can still free up some later ones.
                                             */
    
            cluster_num = cluster_num_next;
        }
    
        return 1;
    #else
        return 0;
    #endif
}
    1d58:	e28dd004 	add	sp, sp, #4	; 0x4
    1d5c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    1d60:	e12fff1e 	bx	lr
    1d64:	0000fff7 	streqd	pc, [r0], -r7

00001d68 <fat16_append_clusters>:
    1d68:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1d6c:	e1a01801 	mov	r1, r1, lsl #16
    1d70:	e24dd014 	sub	sp, sp, #20	; 0x14
    1d74:	e1a02802 	mov	r2, r2, lsl #16
    1d78:	e1a01821 	mov	r1, r1, lsr #16
    1d7c:	e2507000 	subs	r7, r0, #0	; 0x0
    1d80:	e58d1000 	str	r1, [sp]
    1d84:	e1a09822 	mov	r9, r2, lsr #16
    1d88:	0a00004e 	beq	1ec8 <fat16_append_clusters+0x160>
    1d8c:	e5972000 	ldr	r2, [r7]
    1d90:	e597300c 	ldr	r3, [r7, #12]
    1d94:	e5921008 	ldr	r1, [r2, #8]
    1d98:	e1a03783 	mov	r3, r3, lsl #15
    1d9c:	e3a04000 	mov	r4, #0	; 0x0
    1da0:	e5922000 	ldr	r2, [r2]
    1da4:	e597b008 	ldr	fp, [r7, #8]
    1da8:	e1a03823 	mov	r3, r3, lsr #16
    1dac:	e1a05009 	mov	r5, r9
    1db0:	e1a0a004 	mov	sl, r4
    1db4:	e58d1008 	str	r1, [sp, #8]
    1db8:	e58d2004 	str	r2, [sp, #4]
    1dbc:	e58d300c 	str	r3, [sp, #12]
    1dc0:	ea000023 	b	1e54 <fat16_append_clusters+0xec>
    1dc4:	e08b8086 	add	r8, fp, r6, lsl #1
    1dc8:	e1a00008 	mov	r0, r8
    1dcc:	e28d1012 	add	r1, sp, #18	; 0x12
    1dd0:	e3a02002 	mov	r2, #2	; 0x2
    1dd4:	e59d3004 	ldr	r3, [sp, #4]
    1dd8:	e1a0e00f 	mov	lr, pc
    1ddc:	e12fff13 	bx	r3
    1de0:	e3500000 	cmp	r0, #0	; 0x0
    1de4:	0a000037 	beq	1ec8 <fat16_append_clusters+0x160>
    1de8:	e5dd3012 	ldrb	r3, [sp, #18]
    1dec:	e3530000 	cmp	r3, #0	; 0x0
    1df0:	1a000016 	bne	1e50 <fat16_append_clusters+0xe8>
    1df4:	e5dd3013 	ldrb	r3, [sp, #19]
    1df8:	e3530000 	cmp	r3, #0	; 0x0
    1dfc:	1a000013 	bne	1e50 <fat16_append_clusters+0xe8>
    1e00:	e1550009 	cmp	r5, r9
    1e04:	03e03000 	mvneq	r3, #0	; 0x0
    1e08:	11a03424 	movne	r3, r4, lsr #8
    1e0c:	05cd3013 	streqb	r3, [sp, #19]
    1e10:	05cd3012 	streqb	r3, [sp, #18]
    1e14:	15cd3013 	strneb	r3, [sp, #19]
    1e18:	15cd4012 	strneb	r4, [sp, #18]
    1e1c:	e1a00008 	mov	r0, r8
    1e20:	e28d1012 	add	r1, sp, #18	; 0x12
    1e24:	e3a02002 	mov	r2, #2	; 0x2
    1e28:	e59d3008 	ldr	r3, [sp, #8]
    1e2c:	e1a0e00f 	mov	lr, pc
    1e30:	e12fff13 	bx	r3
    1e34:	e3500000 	cmp	r0, #0	; 0x0
    1e38:	0a00000a 	beq	1e68 <fat16_append_clusters+0x100>
    1e3c:	e2453001 	sub	r3, r5, #1	; 0x1
    1e40:	e1a03803 	mov	r3, r3, lsl #16
    1e44:	e1b05823 	movs	r5, r3, lsr #16
    1e48:	0a000019 	beq	1eb4 <fat16_append_clusters+0x14c>
    1e4c:	e1a04006 	mov	r4, r6
    1e50:	e28aa001 	add	sl, sl, #1	; 0x1
    1e54:	e59d100c 	ldr	r1, [sp, #12]
    1e58:	e1a0380a 	mov	r3, sl, lsl #16
    1e5c:	e15a0001 	cmp	sl, r1
    1e60:	e1a06823 	mov	r6, r3, lsr #16
    1e64:	1affffd6 	bne	1dc4 <fat16_append_clusters+0x5c>
    1e68:	e3550000 	cmp	r5, #0	; 0x0
    1e6c:	1a000012 	bne	1ebc <fat16_append_clusters+0x154>
    1e70:	e59d3000 	ldr	r3, [sp]
    1e74:	e3530001 	cmp	r3, #1	; 0x1
    1e78:	9a00000b 	bls	1eac <fat16_append_clusters+0x144>
    1e7c:	e59d1000 	ldr	r1, [sp]
    1e80:	e1a03424 	mov	r3, r4, lsr #8
    1e84:	e5cd3013 	strb	r3, [sp, #19]
    1e88:	e08b0081 	add	r0, fp, r1, lsl #1
    1e8c:	e5cd4012 	strb	r4, [sp, #18]
    1e90:	e28d1012 	add	r1, sp, #18	; 0x12
    1e94:	e3a02002 	mov	r2, #2	; 0x2
    1e98:	e59d3008 	ldr	r3, [sp, #8]
    1e9c:	e1a0e00f 	mov	lr, pc
    1ea0:	e12fff13 	bx	r3
    1ea4:	e3500000 	cmp	r0, #0	; 0x0
    1ea8:	0a000003 	beq	1ebc <fat16_append_clusters+0x154>
    1eac:	e1a00004 	mov	r0, r4
    1eb0:	ea000005 	b	1ecc <fat16_append_clusters+0x164>
    1eb4:	e1a04006 	mov	r4, r6
    1eb8:	eaffffec 	b	1e70 <fat16_append_clusters+0x108>
    1ebc:	e1a00007 	mov	r0, r7
    1ec0:	e1a01004 	mov	r1, r4
    1ec4:	ebffff71 	bl	1c90 <fat16_free_clusters>
    1ec8:	e3a00000 	mov	r0, #0	; 0x0
    1ecc:	e28dd014 	add	sp, sp, #20	; 0x14
    1ed0:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ed4:	e12fff1e 	bx	lr

00001ed8 <fat16_read_file>:

/**
 * \ingroup fat16_fs
 * Frees a part of a cluster chain and correctly terminates the rest.
 *
 * Marks the specified cluster as the new end of a cluster chain and
 * frees all following clusters.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The new end of the cluster chain.
 * \returns 0 on failure, 1 on success.
 * \see fat16_free_clusters
 */
uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
            return 0;
    
        /* fetch next cluster before overwriting the cluster entry */
        uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
    
        /* mark cluster as the last one */
        uint8_t buffer[2];
        buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
        buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
        if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
            return 0;
    
        /* free remaining clusters */
        if(cluster_num_next)
            return fat16_free_clusters(fs, cluster_num_next);
        else
            return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Opens a file on a FAT16 filesystem.
 *
 * \param[in] fs The filesystem on which the file to open lies.
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat16_close_file
 */
struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_file_struct* fd = malloc(sizeof(*fd));
    if(!fd)
        return 0;

    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    fd->fs = fs;
    fd->pos = 0;
    fd->pos_cluster = dir_entry->cluster;

    return fd;
}

/**
 * \ingroup fat16_file
 * Closes a file.
 *
 * \param[in] fd The file handle of the file to close.
 * \see fat16_open_file
 */
void fat16_close_file(struct fat16_file_struct* fd)
{
    if(fd)
        free(fd);
}

/**
 * \ingroup fat16_file
 * Reads data from a file.
 *
 * The data requested is read from the current file location.
 *
 * \param[in] fd The file handle of the file from which to read.
 * \param[out] buffer The buffer into which to write.
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat16_write_file
 */
int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
{
    1ed8:	e1a02802 	mov	r2, r2, lsl #16
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
    1edc:	e3510000 	cmp	r1, #0	; 0x0
    1ee0:	13500000 	cmpne	r0, #0	; 0x0
    1ee4:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ee8:	e1a06000 	mov	r6, r0
    1eec:	e1a0b001 	mov	fp, r1
    1ef0:	e1a08822 	mov	r8, r2, lsr #16
    1ef4:	0a000050 	beq	203c <fat16_read_file+0x164>
    1ef8:	e3580000 	cmp	r8, #0	; 0x0
    1efc:	0a00004e 	beq	203c <fat16_read_file+0x164>
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
    1f00:	e5907030 	ldr	r7, [r0, #48]
    1f04:	e5902028 	ldr	r2, [r0, #40]
    1f08:	e0873008 	add	r3, r7, r8
    1f0c:	e1530002 	cmp	r3, r2
    1f10:	9a000003 	bls	1f24 <fat16_read_file+0x4c>
        buffer_len = fd->dir_entry.file_size - fd->pos;
    1f14:	e0673002 	rsb	r3, r7, r2
    1f18:	e1a03803 	mov	r3, r3, lsl #16
    if(buffer_len == 0)
    1f1c:	e1b08823 	movs	r8, r3, lsr #16
    1f20:	0a000050 	beq	2068 <fat16_read_file+0x190>
        return 0;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
    1f24:	e1d653b4 	ldrh	r5, [r6, #52]
    1f28:	e5963000 	ldr	r3, [r6]
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;

    /* find cluster in which to start reading */
    if(!cluster_num)
    1f2c:	e3550000 	cmp	r5, #0	; 0x0
    1f30:	e1d391b2 	ldrh	r9, [r3, #18]
    1f34:	1a000011 	bne	1f80 <fat16_read_file+0xa8>
    {
        cluster_num = fd->dir_entry.cluster;
    1f38:	e1d652b6 	ldrh	r5, [r6, #38]

        if(!cluster_num)
    1f3c:	e3550000 	cmp	r5, #0	; 0x0
    1f40:	1a000002 	bne	1f50 <fat16_read_file+0x78>
        {
            if(!fd->pos)
    1f44:	e3570000 	cmp	r7, #0	; 0x0
    1f48:	0a000046 	beq	2068 <fat16_read_file+0x190>
    1f4c:	ea00003a 	b	203c <fat16_read_file+0x164>
                return 0;
            else
                return -1;
        }

        if(fd->pos)
    1f50:	e3570000 	cmp	r7, #0	; 0x0
    1f54:	11a04007 	movne	r4, r7
    1f58:	1a000004 	bne	1f70 <fat16_read_file+0x98>
    1f5c:	ea000007 	b	1f80 <fat16_read_file+0xa8>
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
    1f60:	e5960000 	ldr	r0, [r6]
    1f64:	ebffff1f 	bl	1be8 <fat16_get_next_cluster>
                if(!cluster_num)
    1f68:	e2505000 	subs	r5, r0, #0	; 0x0
    1f6c:	0a000032 	beq	203c <fat16_read_file+0x164>
    1f70:	e1540009 	cmp	r4, r9
    1f74:	e1a01005 	mov	r1, r5
    1f78:	e0694004 	rsb	r4, r9, r4
    1f7c:	2afffff7 	bcs	1f60 <fat16_read_file+0x88>
    1f80:	e1a00007 	mov	r0, r7
    1f84:	e1a01009 	mov	r1, r9
    1f88:	eb000f18 	bl	5bf0 <__umodsi3>
    1f8c:	e1a00800 	mov	r0, r0, lsl #16
    1f90:	e1a0a820 	mov	sl, r0, lsr #16
    1f94:	e1a07008 	mov	r7, r8
                    return -1;
            }
        }
    }

    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
        (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
    1f98:	e06a3009 	rsb	r3, sl, r9
    1f9c:	e596c000 	ldr	ip, [r6]
    1fa0:	e1a03803 	mov	r3, r3, lsl #16
    1fa4:	e1a03823 	mov	r3, r3, lsr #16
    1fa8:	e1570003 	cmp	r7, r3
    1fac:	31a03007 	movcc	r3, r7
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
    1fb0:	e59c2018 	ldr	r2, [ip, #24]
    1fb4:	e1a03803 	mov	r3, r3, lsl #16
    1fb8:	e1a04823 	mov	r4, r3, lsr #16
    1fbc:	e08a2002 	add	r2, sl, r2
    1fc0:	e2453002 	sub	r3, r5, #2	; 0x2
    1fc4:	e0202399 	mla	r0, r9, r3, r2
    1fc8:	e1a0100b 	mov	r1, fp
    1fcc:	e1a02004 	mov	r2, r4
    1fd0:	e59c3000 	ldr	r3, [ip]
    1fd4:	e593c000 	ldr	ip, [r3]
    1fd8:	e1a0e00f 	mov	lr, pc
    1fdc:	e12fff1c 	bx	ip
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
    1fe0:	e0643007 	rsb	r3, r4, r7
    1fe4:	e3500000 	cmp	r0, #0	; 0x0
        fd->pos += copy_length;

        if(first_cluster_offset + copy_length >= cluster_size)
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
    1fe8:	e1a01005 	mov	r1, r5
    1fec:	e08bb004 	add	fp, fp, r4
    1ff0:	e08a2004 	add	r2, sl, r4
    1ff4:	e1a00803 	mov	r0, r3, lsl #16
    1ff8:	0a000011 	beq	2044 <fat16_read_file+0x16c>
    1ffc:	e5963030 	ldr	r3, [r6, #48]
    2000:	e1520009 	cmp	r2, r9
    2004:	e0833004 	add	r3, r3, r4
    2008:	e5863030 	str	r3, [r6, #48]
    200c:	e1a07820 	mov	r7, r0, lsr #16
    2010:	ba000004 	blt	2028 <fat16_read_file+0x150>
    2014:	e5960000 	ldr	r0, [r6]
    2018:	ebfffef2 	bl	1be8 <fat16_get_next_cluster>
    201c:	e2505000 	subs	r5, r0, #0	; 0x0
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
                return buffer_len - buffer_left;
    2020:	e3a0a000 	mov	sl, #0	; 0x0
    2024:	0a00000a 	beq	2054 <fat16_read_file+0x17c>
            }
        }

        fd->pos_cluster = cluster_num;

    }
    while(buffer_left > 0); /* check if we are done */
    2028:	e3570000 	cmp	r7, #0	; 0x0
    202c:	e1c653b4 	strh	r5, [r6, #52]
    2030:	1affffd8 	bne	1f98 <fat16_read_file+0xc0>

    return buffer_len;
    2034:	e1a03808 	mov	r3, r8, lsl #16
    2038:	ea000003 	b	204c <fat16_read_file+0x174>
    203c:	e3e00000 	mvn	r0, #0	; 0x0
    2040:	ea000009 	b	206c <fat16_read_file+0x194>
    2044:	e0673008 	rsb	r3, r7, r8
    2048:	e1a03803 	mov	r3, r3, lsl #16
    204c:	e1a00843 	mov	r0, r3, asr #16
    2050:	ea000005 	b	206c <fat16_read_file+0x194>
    2054:	e0673008 	rsb	r3, r7, r8
    2058:	e1a03803 	mov	r3, r3, lsl #16
    205c:	e1a00843 	mov	r0, r3, asr #16
    2060:	e1c653b4 	strh	r5, [r6, #52]
    2064:	ea000000 	b	206c <fat16_read_file+0x194>
    2068:	e3a00000 	mov	r0, #0	; 0x0
}
    206c:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2070:	e12fff1e 	bx	lr

00002074 <fat16_reset_dir>:

/**
 * \ingroup fat16_file
 * Writes data to a file.
 *
 * The data is written to the current file location.
 *
 * \param[in] fd The file handle of the file to which to write.
 * \param[in] buffer The buffer from which to read the data to be written.
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat16_read_file
 */
int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
{
    #if FAT16_WRITE_SUPPORT
        /* check arguments */
        if(!fd || !buffer || buffer_len < 1)
            return -1;
        if(fd->pos > fd->dir_entry.file_size)
            return -1;
    
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint16_t cluster_num = fd->pos_cluster;
        uint16_t buffer_left = buffer_len;
        uint16_t first_cluster_offset = fd->pos % cluster_size;
    
        /* find cluster in which to start writing */
        if(!cluster_num)
        {
            cluster_num = fd->dir_entry.cluster;
    
            if(!cluster_num)
            {
                if(!fd->pos)
                {
                    /* empty file */
                    fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
                    if(!cluster_num)
                        return -1;
                }
                else
                {
                    return -1;
                }
            }
    
            if(fd->pos)
            {
                uint32_t pos = fd->pos;
                uint16_t cluster_num_next;
                while(pos >= cluster_size)
                {
                    pos -= cluster_size;
                    cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                    if(!cluster_num_next && pos == 0)
        /* the file exactly ends on a cluster boundary, and we append to it */
                        cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                    if(!cluster_num_next)
                        return -1;
    
                    cluster_num = cluster_num_next;
                }
            }
        }
    
        /* write data */
        do
        {
            /* calculate data size to write to cluster */
            uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
            (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
            uint16_t write_length = cluster_size - first_cluster_offset;
            if(write_length > buffer_left)
                write_length = buffer_left;
    
            /* write data which fits into the current cluster */
            if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
                break;
    
            /* calculate new file position */
            buffer += write_length;
            buffer_left -= write_length;
            fd->pos += write_length;
    
            if(first_cluster_offset + write_length >= cluster_size)
            {
                /* we are on a cluster boundary, so get the next cluster */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num_next && buffer_left > 0)
        /* we reached the last cluster, append a new one */
                    cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                if(!cluster_num_next)
                {
                    fd->pos_cluster = 0;
                    break;
                }
    
                cluster_num = cluster_num_next;
                first_cluster_offset = 0;
            }
    
            fd->pos_cluster = cluster_num;
    
        }
        while(buffer_left > 0); /* check if we are done */
    
        /* update directory entry */
        if(fd->pos > fd->dir_entry.file_size)
        {
            uint32_t size_old = fd->dir_entry.file_size;
    
            /* update file size */
            fd->dir_entry.file_size = fd->pos;
            /* write directory entry */
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
            {
                /* We do not return an error here since we actually wrote
                                                             * some data to disk. So we calculate the amount of data
                                                             * we wrote to disk and which lies within the old file size.
                                                             */
                buffer_left = fd->pos - size_old;
                fd->pos = size_old;
            }
        }
    
        return buffer_len - buffer_left;
    
    #else
        return -1;
    #endif
}

/**
 * \ingroup fat16_file
 * Repositions the read/write file offset.
 *
 * Changes the file offset where the next call to fat16_read_file()
 * or fat16_write_file() starts reading/writing.
 *
 * If the new offset is beyond the end of the file, fat16_resize_file()
 * is implicitly called, i.e. the file is expanded.
 *
 * The new offset can be given in different ways determined by
 * the \c whence parameter:
 * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
 * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
 * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
 *
 * The resulting absolute offset is written to the location the \c offset
 * parameter points to.
 *
 * \param[in] fd The file decriptor of the file on which to seek.
 * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
 *                   parameter. The function writes the new absolute offset
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
{
    if(!fd || !offset)
        return 0;

    uint32_t new_pos = fd->pos;
    switch(whence)
    {
        case FAT16_SEEK_SET:
            new_pos = *offset;
            break;
        case FAT16_SEEK_CUR:
            new_pos += *offset;
            break;
        case FAT16_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
        return 0;

    fd->pos = new_pos;
    fd->pos_cluster = 0;

    *offset = new_pos;
    return 1;
}

/**
 * \ingroup fat16_file
 * Resizes a file to have a specific size.
 *
 * Enlarges or shrinks the file pointed to by the file descriptor to have
 * exactly the specified size.
 *
 * If the file is truncated, all bytes having an equal or larger offset
 * than the given size are lost. If the file is expanded, the additional
 * bytes are allocated.
 *
 * \note Please be aware that this function just allocates or deallocates disk
 * space, it does not explicitely clear it. To avoid data leakage, this
 * must be done manually.
 *
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
{
    #if FAT16_WRITE_SUPPORT
        if(!fd)
            return 0;
    
        uint16_t cluster_num = fd->dir_entry.cluster;
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint32_t size_new = size;
    
        do
        {
            if(cluster_num == 0 && size_new == 0)
        /* the file stays empty */
                break;
    
            /* seek to the next cluster as long as we need the space */
            while(size_new > cluster_size)
            {
                /* get next cluster of file */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(cluster_num_next)
                {
                    cluster_num = cluster_num_next;
                    size_new -= cluster_size;
                }
                else
                {
                    break;
                }
            }
    
            if(size_new > cluster_size || cluster_num == 0)
            {
                /* Allocate new cluster chain and append
                                                             * it to the existing one, if available.
                                                             */
                uint16_t cluster_count = size_new / cluster_size;
                if((uint32_t) cluster_count * cluster_size < size_new)
                    ++cluster_count;
                uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_count);
                if(!cluster_new_chain)
                    return 0;
    
                if(!cluster_num)
                {
                    cluster_num = cluster_new_chain;
                    fd->dir_entry.cluster = cluster_num;
                }
            }
    
            /* write new directory entry */
            fd->dir_entry.file_size = size;
            if(size == 0)
                fd->dir_entry.cluster = 0;
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
                return 0;
    
            if(size == 0)
            {
                /* free all clusters of file */
                fat16_free_clusters(fd->fs, cluster_num);
            }
            else if(size_new <= cluster_size)
            {
                /* free all clusters no longer needed */
                fat16_terminate_clusters(fd->fs, cluster_num);
            }
    
        }
        while(0);
    
        /* correct file position */
        if(size < fd->pos)
        {
            fd->pos = size;
            fd->pos_cluster = 0;
        }
    
        return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_dir
 * Opens a directory.
 *
 * \param[in] fs The filesystem on which the directory to open resides.
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat16_close_dir
 */
struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_dir_struct* dd = malloc(sizeof(*dd));
    if(!dd)
        return 0;

    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    dd->fs = fs;
    dd->entry_next = 0;

    return dd;
}

/**
 * \ingroup fat16_dir
 * Closes a directory descriptor.
 *
 * This function destroys a directory descriptor which was
 * previously obtained by calling fat16_open_dir(). When this
 * function returns, the given descriptor will be invalid.
 *
 * \param[in] dd The directory descriptor to close.
 * \see fat16_open_dir
 */
void fat16_close_dir(struct fat16_dir_struct* dd)
{
    if(dd)
        free(dd);
}

/**
 * \ingroup fat16_dir
 * Reads the next directory entry contained within a parent directory.
 *
 * \param[in] dd The descriptor of the parent directory from which to read the entry.
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat16_reset_dir
 */
uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
{
    if(!dd || !dir_entry)
        return 0;

    if(dd->dir_entry.cluster == 0)
    {
        /* read entry from root directory */
        if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }
    else
    {
        /* read entry from a subdirectory */
        if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }

    /* restart reading */
    dd->entry_next = 0;

    return 0;
}

/**
 * \ingroup fat16_dir
 * Resets a directory handle.
 *
 * Resets the directory handle such that reading restarts
 * with the first directory entry.
 *
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
    2074:	e3500000 	cmp	r0, #0	; 0x0
    2078:	e1a03000 	mov	r3, r0
        return 0;

    dd->entry_next = 0;
    207c:	13a03000 	movne	r3, #0	; 0x0
    2080:	11c033b0 	strneh	r3, [r0, #48]
    2084:	13a03001 	movne	r3, #1	; 0x1
    return 1;
}
    2088:	e1a00003 	mov	r0, r3
    208c:	e12fff1e 	bx	lr

00002090 <fat16_delete_file>:

/**
 * \ingroup fat16_fs
 * Writes a directory entry to disk.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
            return 0;
    
        device_write_t device_write = fs->partition->device_write;
        uint32_t offset = dir_entry->entry_offset;
        uint8_t name_len = strlen(dir_entry->long_name);
        uint8_t lfn_entry_count = (name_len + 12) / 13;
        uint8_t buffer[32];
    
        /* write 8.3 entry */
    
        /* generate 8.3 file name */
        memset(&buffer[0], ' ', 11);
        char* name_ext = strrchr(dir_entry->long_name, '.');
        if(name_ext)
        {
            ++name_ext;
    
            uint8_t name_ext_len = strlen(name_ext);
            name_len -= name_ext_len + 1;
    
            if(name_ext_len > 3)
                name_ext_len = 3;
    
            memcpy(&buffer[8], name_ext, name_ext_len);
        }
    
        if(name_len <= 8)
        {
            memcpy(buffer, dir_entry->long_name, name_len);
        }
        else
        {
            memcpy(buffer, dir_entry->long_name, 8);
    
            /* Minimize 8.3 name clashes by appending
                                             * the lower byte of the cluster number.
                                             */
            uint8_t num = dir_entry->cluster & 0xff;
    
            buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
            num &= 0x0f;
            buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
        }
    
        /* fill directory entry buffer */
        memset(&buffer[11], 0, sizeof(buffer) - 11);
        buffer[0x0b] = dir_entry->attributes;

        //Not used in bootloader
		#ifdef MAIN_FIRMWARE
			//Added modified date/time 12-26-07
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			//*******************************************
			//char * current_time;
			//*******************************************
/*			current_time = GPS_get_time();
			char * current_date;
			current_date = GPS_get_date();
			
			uint16_t modified_time, modified_date;
			uint8_t c_hour, c_minute, c_second;
			uint8_t c_year, c_month, c_day;
			
			c_hour = (current_time[0] - '0') * 10;
			c_hour += (current_time[1] - '0');
			c_minute = (current_time[3] - '0') * 10;
			c_minute += (current_time[4] - '0');
			c_second = (current_time[6] - '0') * 10;
			c_second += (current_time[7] - '0');
			
			c_day = (current_date[0] - '0') * 10;
			c_day += (current_date[1] - '0');
			c_month = (current_date[3] - '0') * 10;
			c_month += (current_date[4] - '0');
			c_year = (current_date[6] - '0') * 10;
			c_year += (current_date[7] - '0');
			
			//Correct for 1980 = 0, 2000 = 20, year code
			c_year += 20;
			
			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);

			//Do a little error correction
			if (c_year < 26) //26 = 2006
			{
				modified_time = 0;
				modified_date = 0;
			}

			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
			//rprintf("mod_time=%x\n", modified_time);
			//rprintf("mod_date=%x\n", modified_date);
			
			buffer[0x16] = (modified_time >> 0) & 0xFF;
			buffer[0x17] = (modified_time >> 8) & 0xFF;
			buffer[0x18] = (modified_date >> 0) & 0xFF;
			buffer[0x19] = (modified_date >> 8) & 0xFF;
			*/
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
		#endif

        buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
        buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
        buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
        buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
        buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
        buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
    
        /* write to disk */
        if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
            return 0;
    
        /* calculate checksum of 8.3 name */
        uint8_t checksum = buffer[0];
        uint8_t i;
        for(i = 1; i < 11; ++i)
            checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
        /* write lfn entries */
        uint8_t lfn_entry;
        for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
        {
            memset(buffer, 0, sizeof(buffer));
            memset(&buffer[0x01], 0xff, 10);
            memset(&buffer[0x0e], 0xff, 12);
            memset(&buffer[0x1c], 0xff, 4);
    
            buffer[0x00] = lfn_entry;
            if(lfn_entry == lfn_entry_count)
                buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
    
            /* set file name */
            const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
            i = 1;
            while(i < 0x1f)
            {
                buffer[i++] = *long_name_curr;
                buffer[i++] = 0;
    
                switch(i)
                {
                    case 0x0b:
                        i = 0x0e;
                        break;
                    case 0x1a:
                        i = 0x1c;
                        break;
                }
    
                if(!*long_name_curr++)
                    break;
            }
    
            /* mark as lfn entry */
            buffer[0x0b] = 0x0f;
    
            /* set checksum */
            buffer[0x0d] = checksum;
    
            /* write entry */
            device_write(offset, buffer, sizeof(buffer));
    
            offset += sizeof(buffer);
        }
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Creates a file.
 *
 * Creates a file and obtains the directory entry of the
 * new file. If the file to create already exists, the
 * directory entry of the existing file will be returned
 * within the dir_entry parameter.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] parent The handle of the directory in which to create the file.
 * \param[in] file The name of the file to create.
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_file
 */
uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!parent || !file || !file[0])
            return 0;
    
        /* check if the file already exists */
        while(1)
        {
            if(!fat16_read_dir(parent, dir_entry))
                break;
    
            if(strcmp(file, dir_entry->long_name) == 0)
            {
                fat16_reset_dir(parent);
                return 1;
            }
        }
    
        memset(dir_entry, 0, sizeof(*dir_entry));
        strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    
        /* search for a place where to write the directory entry to disk */
        uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
        uint8_t free_dir_entries_found = 0;
        struct fat16_fs_struct* fs = parent->fs;
        uint16_t cluster_num = parent->dir_entry.cluster;
        uint32_t dir_entry_offset = 0;
        uint32_t offset = 0;
        uint32_t offset_to = 0;
    
        if(cluster_num == 0)
        {
            /* we read/write from the root directory entry */
            offset = fs->header.root_dir_offset;
            offset_to = fs->header.cluster_zero_offset;
            dir_entry_offset = offset;
        }
    
        while(1)
        {
            if(offset == offset_to)
            {
                if(cluster_num == 0)
				/* We iterated through the whole root directory entry
                * and could not find enough space for the directory entry.
                */
                return 0;
    
                if(offset)
                {
                    /* We reached a cluster boundary and have to
                    * switch to the next cluster.
                    */
    
                    uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
                    if(!cluster_next)
                    {
                        cluster_next = fat16_append_clusters(fs, cluster_num, 1);
                        if(!cluster_next)
                            return 0;
    
                        /* we appended a new cluster and know it is free */
                        dir_entry_offset = fs->header.cluster_zero_offset +
                        (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
    
                        /* TODO: This cluster has to be zeroed in an efficient way, or at least
                        *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
                        */
                        break;
                    }
                    cluster_num = cluster_next;
                }
    
                offset = fs->header.cluster_zero_offset +
                (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
                offset_to = offset + fs->header.cluster_size;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
    
            /* read next lfn or 8.3 entry */
            uint8_t first_char;
            if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
                return 0;
    
            /* check if we found a free directory entry */
            if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
            {
                /* check if we have the needed number of available entries */
                ++free_dir_entries_found;
                if(free_dir_entries_found >= free_dir_entries_needed)
                    break;
    
                offset += 32;
            }
            else
            {
                offset += 32;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
        }

        /* write directory entry to disk */
        dir_entry->entry_offset = dir_entry_offset;
        if(!fat16_write_dir_entry(fs, dir_entry))
            return 0;
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Deletes a file or directory.
 *
 * It is not checked if the file to delete is a directory.
 * If a directory is deleted without first deleting its
 * subdirectories and files, disk space occupied by these
 * files will get wasted as there is no chance to release
 * it and mark it as free.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat16_create_file
 */
uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
    2090:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
    2094:	e3510000 	cmp	r1, #0	; 0x0
    2098:	13500000 	cmpne	r0, #0	; 0x0
    209c:	e24dd00c 	sub	sp, sp, #12	; 0xc
    20a0:	e1a06000 	mov	r6, r0
    20a4:	e1a07001 	mov	r7, r1
    20a8:	0a00001f 	beq	212c <fat16_delete_file+0x9c>
            return 0;
    
        /* get offset of the file's directory entry */
        uint32_t dir_entry_offset = dir_entry->entry_offset;
    20ac:	e5915028 	ldr	r5, [r1, #40]
        if(!dir_entry_offset)
    20b0:	e3550000 	cmp	r5, #0	; 0x0
    20b4:	0a00001c 	beq	212c <fat16_delete_file+0x9c>
            return 0;
    
        uint8_t buffer[12];
        while(1)
        {
            /* read directory entry */
            if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
    20b8:	e1a0100d 	mov	r1, sp
    20bc:	e1a00005 	mov	r0, r5
    20c0:	e3a0200c 	mov	r2, #12	; 0xc
    20c4:	e5963000 	ldr	r3, [r6]
    20c8:	e593c000 	ldr	ip, [r3]
    20cc:	e1a0e00f 	mov	lr, pc
    20d0:	e12fff1c 	bx	ip
    20d4:	e3500000 	cmp	r0, #0	; 0x0
    20d8:	e1a0400d 	mov	r4, sp
                return 0;
    
            /* mark the directory entry as deleted */
            buffer[0] = FAT16_DIRENTRY_DELETED;
    
            /* write back entry */
            if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
    20dc:	e1a00005 	mov	r0, r5
    20e0:	e1a0100d 	mov	r1, sp
    20e4:	e3a0200c 	mov	r2, #12	; 0xc
                return 0;
    
            /* check if we deleted the whole entry */
            if(buffer[11] != 0x0f)
                break;
    
            dir_entry_offset += 32;
    20e8:	e2855020 	add	r5, r5, #32	; 0x20
    20ec:	0a00000e 	beq	212c <fat16_delete_file+0x9c>
    20f0:	e3e0301a 	mvn	r3, #26	; 0x1a
    20f4:	e5cd3000 	strb	r3, [sp]
    20f8:	e5963000 	ldr	r3, [r6]
    20fc:	e593c008 	ldr	ip, [r3, #8]
    2100:	e1a0e00f 	mov	lr, pc
    2104:	e12fff1c 	bx	ip
    2108:	e3500000 	cmp	r0, #0	; 0x0
    210c:	0a000006 	beq	212c <fat16_delete_file+0x9c>
    2110:	e5dd300b 	ldrb	r3, [sp, #11]
    2114:	e353000f 	cmp	r3, #15	; 0xf
    2118:	0affffe6 	beq	20b8 <fat16_delete_file+0x28>
        }
    
        /* We deleted the directory entry. The next thing to do is
                             * marking all occupied clusters as free.
                             */
        return fat16_free_clusters(fs, dir_entry->cluster);
    211c:	e1a00006 	mov	r0, r6
    2120:	e1d712b2 	ldrh	r1, [r7, #34]
    2124:	ebfffed9 	bl	1c90 <fat16_free_clusters>
    2128:	ea000000 	b	2130 <fat16_delete_file+0xa0>
    212c:	e3a00000 	mov	r0, #0	; 0x0
    #else
        return 0;
    #endif
}
    2130:	e28dd00c 	add	sp, sp, #12	; 0xc
    2134:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    2138:	e12fff1e 	bx	lr

0000213c <fat16_get_fs_size>:

/**
 * \ingroup fat16_fs
 * Returns the amount of total storage capacity of the filesystem in bytes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the filesystem size in bytes otherwise.
 */
uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
{
    if(!fs)
    213c:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
    2140:	1590300c 	ldrne	r3, [r0, #12]
    2144:	e1a02000 	mov	r2, r0
    2148:	11a030a3 	movne	r3, r3, lsr #1
    214c:	11d021b2 	ldrneh	r2, [r0, #18]
    2150:	12433002 	subne	r3, r3, #2	; 0x2
    2154:	10020293 	mulne	r2, r3, r2
}
    2158:	e1a00002 	mov	r0, r2
    215c:	e12fff1e 	bx	lr

00002160 <fat16_get_fs_free>:

/**
 * \ingroup fat16_fs
 * Returns the amount of free storage capacity on the filesystem in bytes.
 *
 * \note As the FAT16 filesystem is cluster based, this function does not
 *       return continuous values but multiples of the cluster size.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the free filesystem space in bytes otherwise.
 */
uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
{
    2160:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    if(!fs)
    2164:	e2506000 	subs	r6, r0, #0	; 0x0
    2168:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    216c:	0a000021 	beq	21f8 <fat16_get_fs_free+0x98>
        return 0;

    uint8_t fat[32];
    struct fat16_usage_count_callback_arg count_arg;
    count_arg.cluster_count = 0;
    count_arg.buffer_size = sizeof(fat);
    2170:	e3a03020 	mov	r3, #32	; 0x20
    2174:	e5cd302a 	strb	r3, [sp, #42]

    uint32_t fat_offset = fs->header.fat_offset;
    2178:	e5967008 	ldr	r7, [r6, #8]
    uint32_t fat_size = fs->header.fat_size;
    217c:	e596500c 	ldr	r5, [r6, #12]
    2180:	e3a03000 	mov	r3, #0	; 0x0
    2184:	e1cd32b8 	strh	r3, [sp, #40]
    2188:	ea000012 	b	21d8 <fat16_get_fs_free+0x78>
    while(fat_size > 0)
    {
        uint16_t length = UINT16_MAX - 1;
        if(fat_size < length)
    218c:	e59f3074 	ldr	r3, [pc, #116]	; 2208 <.text+0x2208>
    2190:	e1550003 	cmp	r5, r3
            length = fat_size;

        if(!fs->partition->device_read_interval(fat_offset,
    2194:	e59f3070 	ldr	r3, [pc, #112]	; 220c <.text+0x220c>
    2198:	91a04822 	movls	r4, r2, lsr #16
    219c:	e596c000 	ldr	ip, [r6]
    21a0:	e58d3000 	str	r3, [sp]
    21a4:	e28d3028 	add	r3, sp, #40	; 0x28
    21a8:	e58d3004 	str	r3, [sp, #4]
    21ac:	e1a00007 	mov	r0, r7
    21b0:	e28d1008 	add	r1, sp, #8	; 0x8
    21b4:	e3a02020 	mov	r2, #32	; 0x20
    21b8:	e1a03004 	mov	r3, r4
    21bc:	e59cc004 	ldr	ip, [ip, #4]
    21c0:	e1a0e00f 	mov	lr, pc
    21c4:	e12fff1c 	bx	ip
    21c8:	e3500000 	cmp	r0, #0	; 0x0
    21cc:	0a000009 	beq	21f8 <fat16_get_fs_free+0x98>
            fat,
           sizeof(fat),
           length,
           fat16_get_fs_free_callback,
           &count_arg
           )
           )
        return 0;

        fat_offset += length;
        fat_size -= length;
    21d0:	e0645005 	rsb	r5, r4, r5
    21d4:	e0877004 	add	r7, r7, r4
    21d8:	e3550000 	cmp	r5, #0	; 0x0
    21dc:	e59f402c 	ldr	r4, [pc, #44]	; 2210 <.text+0x2210>
    21e0:	e1a02805 	mov	r2, r5, lsl #16
    21e4:	1affffe8 	bne	218c <fat16_get_fs_free+0x2c>
    }

    return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
    21e8:	e1d621b2 	ldrh	r2, [r6, #18]
    21ec:	e1dd32b8 	ldrh	r3, [sp, #40]
    21f0:	e0000392 	mul	r0, r2, r3
    21f4:	ea000000 	b	21fc <fat16_get_fs_free+0x9c>
    21f8:	e3a00000 	mov	r0, #0	; 0x0
}
    21fc:	e28dd02c 	add	sp, sp, #44	; 0x2c
    2200:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    2204:	e12fff1e 	bx	lr
    2208:	0000fffd 	streqd	pc, [r0], -sp
    220c:	00002214 	andeq	r2, r0, r4, lsl r2
    2210:	0000fffe 	streqd	pc, [r0], -lr

00002214 <fat16_get_fs_free_callback>:

/**
 * \ingroup fat16_fs
 * Callback function used for counting free clusters.
 */
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
    2214:	e92d4010 	stmdb	sp!, {r4, lr}
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    uint8_t buffer_size = count_arg->buffer_size;
    2218:	e5d24002 	ldrb	r4, [r2, #2]
    221c:	e1a0c002 	mov	ip, r2
    2220:	e1a01000 	mov	r1, r0
    2224:	e3a0e000 	mov	lr, #0	; 0x0
    2228:	ea000007 	b	224c <fat16_get_fs_free_callback+0x38>
    uint8_t i;
    for(i = 0; i < buffer_size; i += 2)
    {
        if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
    222c:	e7de3000 	ldrb	r3, [lr, r0]
    2230:	e5d12001 	ldrb	r2, [r1, #1]
    2234:	e1932402 	orrs	r2, r3, r2, lsl #8
            ++(count_arg->cluster_count);
    2238:	01dc30b0 	ldreqh	r3, [ip]
    223c:	02833001 	addeq	r3, r3, #1	; 0x1
    2240:	01cc30b0 	streqh	r3, [ip]

        buffer += 2;
    2244:	e2811002 	add	r1, r1, #2	; 0x2
    2248:	e28ee002 	add	lr, lr, #2	; 0x2
    224c:	e20e30ff 	and	r3, lr, #255	; 0xff
    2250:	e1530004 	cmp	r3, r4
    2254:	3afffff4 	bcc	222c <fat16_get_fs_free_callback+0x18>
    }

    return 1;
}
    2258:	e3a00001 	mov	r0, #1	; 0x1
    225c:	e8bd4010 	ldmia	sp!, {r4, lr}
    2260:	e12fff1e 	bx	lr

00002264 <fat16_file_size>:

uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    while(fat16_read_dir(dd, dir_entry))
    {
        if(strcmp(dir_entry->long_name, name) == 0)
        {
            fat16_reset_dir(dd);
            return 1;
        }
    }

    return 0;
}

struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name)
{
    struct fat16_dir_entry_struct file_entry;
    if(!find_file_in_dir(fs, dd, name, &file_entry))
        return 0;

    return fat16_open_file(fs, &file_entry);
}

int fat16_file_size(struct fat16_file_struct * file)
{
    return(file->dir_entry.file_size);
}
    2264:	e5900028 	ldr	r0, [r0, #40]
    2268:	e12fff1e 	bx	lr

0000226c <fat16_read_dir>:
    226c:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2270:	e1a0a001 	mov	sl, r1
    2274:	e2711001 	rsbs	r1, r1, #1	; 0x1
    2278:	33a01000 	movcc	r1, #0	; 0x0
    227c:	e35a0000 	cmp	sl, #0	; 0x0
    2280:	13500000 	cmpne	r0, #0	; 0x0
    2284:	e24dd038 	sub	sp, sp, #56	; 0x38
    2288:	e1a08000 	mov	r8, r0
    228c:	0a000076 	beq	246c <fat16_read_dir+0x200>
    2290:	e1d032b6 	ldrh	r3, [r0, #38]
    2294:	e3530000 	cmp	r3, #0	; 0x0
    2298:	e1d093b0 	ldrh	r9, [r0, #48]
    229c:	e5906000 	ldr	r6, [r0]
    22a0:	1a00002c 	bne	2358 <fat16_read_dir+0xec>
    22a4:	e3560000 	cmp	r6, #0	; 0x0
    22a8:	11a07001 	movne	r7, r1
    22ac:	03817001 	orreq	r7, r1, #1	; 0x1
    22b0:	e3570000 	cmp	r7, #0	; 0x0
    22b4:	1a00006a 	bne	2464 <fat16_read_dir+0x1f8>
    22b8:	e5963000 	ldr	r3, [r6]
    22bc:	e28d502c 	add	r5, sp, #44	; 0x2c
    22c0:	e2864004 	add	r4, r6, #4	; 0x4
    22c4:	e1a01007 	mov	r1, r7
    22c8:	e3a0200c 	mov	r2, #12	; 0xc
    22cc:	e1a00005 	mov	r0, r5
    22d0:	e5936004 	ldr	r6, [r3, #4]
    22d4:	eb000c75 	bl	54b0 <memset>
    22d8:	e2840010 	add	r0, r4, #16	; 0x10
    22dc:	e8900009 	ldmia	r0, {r0, r3}
    22e0:	e59f2194 	ldr	r2, [pc, #404]	; 247c <.text+0x247c>
    22e4:	e0603003 	rsb	r3, r0, r3
    22e8:	e1a03803 	mov	r3, r3, lsl #16
    22ec:	e28d400c 	add	r4, sp, #12	; 0xc
    22f0:	e58d2000 	str	r2, [sp]
    22f4:	e1cd92be 	strh	r9, [sp, #46]
    22f8:	e58d5004 	str	r5, [sp, #4]
    22fc:	e1a03823 	mov	r3, r3, lsr #16
    2300:	e1a01004 	mov	r1, r4
    2304:	e3a02020 	mov	r2, #32	; 0x20
    2308:	e1a0e00f 	mov	lr, pc
    230c:	e12fff16 	bx	r6
    2310:	e3500000 	cmp	r0, #0	; 0x0
    2314:	0a000052 	beq	2464 <fat16_read_dir+0x1f8>
    2318:	e59d3030 	ldr	r3, [sp, #48]
    231c:	e3530000 	cmp	r3, #0	; 0x0
    2320:	0a00004f 	beq	2464 <fat16_read_dir+0x1f8>
    2324:	e1a01007 	mov	r1, r7
    2328:	e3a0202c 	mov	r2, #44	; 0x2c
    232c:	e1a0000a 	mov	r0, sl
    2330:	eb000c5e 	bl	54b0 <memset>
    2334:	e59f2144 	ldr	r2, [pc, #324]	; 2480 <.text+0x2480>
    2338:	e5dd3034 	ldrb	r3, [sp, #52]
    233c:	e88d0404 	stmia	sp, {r2, sl}
    2340:	e1a01004 	mov	r1, r4
    2344:	e59d0030 	ldr	r0, [sp, #48]
    2348:	e3a02020 	mov	r2, #32	; 0x20
    234c:	e1a0e00f 	mov	lr, pc
    2350:	e12fff16 	bx	r6
    2354:	ea000039 	b	2440 <fat16_read_dir+0x1d4>
    2358:	e3560000 	cmp	r6, #0	; 0x0
    235c:	e58d9008 	str	r9, [sp, #8]
    2360:	0a00003f 	beq	2464 <fat16_read_dir+0x1f8>
    2364:	e3510000 	cmp	r1, #0	; 0x0
    2368:	1a00003d 	bne	2464 <fat16_read_dir+0x1f8>
    236c:	e2800004 	add	r0, r0, #4	; 0x4
    2370:	e5d03020 	ldrb	r3, [r0, #32]
    2374:	e3130010 	tst	r3, #16	; 0x10
    2378:	0a000039 	beq	2464 <fat16_read_dir+0x1f8>
    237c:	e1d072b2 	ldrh	r7, [r0, #34]
    2380:	e1d691b2 	ldrh	r9, [r6, #18]
    2384:	e5962018 	ldr	r2, [r6, #24]
    2388:	e2473002 	sub	r3, r7, #2	; 0x2
    238c:	e0252399 	mla	r5, r9, r3, r2
    2390:	e28d402c 	add	r4, sp, #44	; 0x2c
    2394:	e3a01000 	mov	r1, #0	; 0x0
    2398:	e3a0200c 	mov	r2, #12	; 0xc
    239c:	e1a00004 	mov	r0, r4
    23a0:	eb000c42 	bl	54b0 <memset>
    23a4:	e59d3008 	ldr	r3, [sp, #8]
    23a8:	e1cd32be 	strh	r3, [sp, #46]
    23ac:	e59f30c8 	ldr	r3, [pc, #200]	; 247c <.text+0x247c>
    23b0:	e28db00c 	add	fp, sp, #12	; 0xc
    23b4:	e596c000 	ldr	ip, [r6]
    23b8:	e1a0100b 	mov	r1, fp
    23bc:	e58d3000 	str	r3, [sp]
    23c0:	e1a00005 	mov	r0, r5
    23c4:	e58d4004 	str	r4, [sp, #4]
    23c8:	e3a02020 	mov	r2, #32	; 0x20
    23cc:	e1a03009 	mov	r3, r9
    23d0:	e59cc004 	ldr	ip, [ip, #4]
    23d4:	e1a0e00f 	mov	lr, pc
    23d8:	e12fff1c 	bx	ip
    23dc:	e3500000 	cmp	r0, #0	; 0x0
    23e0:	e1a01007 	mov	r1, r7
    23e4:	e1a00006 	mov	r0, r6
    23e8:	0a00001d 	beq	2464 <fat16_read_dir+0x1f8>
    23ec:	e59d3030 	ldr	r3, [sp, #48]
    23f0:	e3530000 	cmp	r3, #0	; 0x0
    23f4:	1a000003 	bne	2408 <fat16_read_dir+0x19c>
    23f8:	ebfffdfa 	bl	1be8 <fat16_get_next_cluster>
    23fc:	e2507000 	subs	r7, r0, #0	; 0x0
    2400:	0a000017 	beq	2464 <fat16_read_dir+0x1f8>
    2404:	eaffffde 	b	2384 <fat16_read_dir+0x118>
    2408:	e3a01000 	mov	r1, #0	; 0x0
    240c:	e3a0202c 	mov	r2, #44	; 0x2c
    2410:	e1a0000a 	mov	r0, sl
    2414:	eb000c25 	bl	54b0 <memset>
    2418:	e59f2060 	ldr	r2, [pc, #96]	; 2480 <.text+0x2480>
    241c:	e596c000 	ldr	ip, [r6]
    2420:	e5dd3034 	ldrb	r3, [sp, #52]
    2424:	e88d0404 	stmia	sp, {r2, sl}
    2428:	e1a0100b 	mov	r1, fp
    242c:	e59d0030 	ldr	r0, [sp, #48]
    2430:	e3a02020 	mov	r2, #32	; 0x20
    2434:	e59cc004 	ldr	ip, [ip, #4]
    2438:	e1a0e00f 	mov	lr, pc
    243c:	e12fff1c 	bx	ip
    2440:	e3500000 	cmp	r0, #0	; 0x0
    2444:	0a000006 	beq	2464 <fat16_read_dir+0x1f8>
    2448:	e5da3000 	ldrb	r3, [sl]
    244c:	e3530000 	cmp	r3, #0	; 0x0
    2450:	11d833b0 	ldrneh	r3, [r8, #48]
    2454:	13a00001 	movne	r0, #1	; 0x1
    2458:	12833001 	addne	r3, r3, #1	; 0x1
    245c:	11c833b0 	strneh	r3, [r8, #48]
    2460:	1a000002 	bne	2470 <fat16_read_dir+0x204>
    2464:	e3a03000 	mov	r3, #0	; 0x0
    2468:	e1c833b0 	strh	r3, [r8, #48]
    246c:	e3a00000 	mov	r0, #0	; 0x0
    2470:	e28dd038 	add	sp, sp, #56	; 0x38
    2474:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2478:	e12fff1e 	bx	lr
    247c:	000019c8 	andeq	r1, r0, r8, asr #19
    2480:	00001a38 	andeq	r1, r0, r8, lsr sl

00002484 <find_file_in_dir>:
    2484:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    2488:	e1a04001 	mov	r4, r1
    248c:	e1a06002 	mov	r6, r2
    2490:	e1a05003 	mov	r5, r3
    2494:	ea000007 	b	24b8 <find_file_in_dir+0x34>
    2498:	eb000c19 	bl	5504 <strcmp>
    249c:	e3500000 	cmp	r0, #0	; 0x0
    24a0:	1a000004 	bne	24b8 <find_file_in_dir+0x34>
    24a4:	e3540000 	cmp	r4, #0	; 0x0
    24a8:	03a03001 	moveq	r3, #1	; 0x1
    24ac:	13a03001 	movne	r3, #1	; 0x1
    24b0:	11c403b0 	strneh	r0, [r4, #48]
    24b4:	ea000006 	b	24d4 <find_file_in_dir+0x50>
    24b8:	e1a01005 	mov	r1, r5
    24bc:	e1a00004 	mov	r0, r4
    24c0:	ebffff69 	bl	226c <fat16_read_dir>
    24c4:	e2503000 	subs	r3, r0, #0	; 0x0
    24c8:	e1a01006 	mov	r1, r6
    24cc:	e1a00005 	mov	r0, r5
    24d0:	1afffff0 	bne	2498 <find_file_in_dir+0x14>
    24d4:	e1a00003 	mov	r0, r3
    24d8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    24dc:	e12fff1e 	bx	lr

000024e0 <fat16_write_dir_entry>:
    24e0:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    24e4:	e3510000 	cmp	r1, #0	; 0x0
    24e8:	13500000 	cmpne	r0, #0	; 0x0
    24ec:	e24dd020 	sub	sp, sp, #32	; 0x20
    24f0:	e1a06001 	mov	r6, r1
    24f4:	0a000098 	beq	275c <fat16_write_dir_entry+0x27c>
    24f8:	e5903000 	ldr	r3, [r0]
    24fc:	e1a00001 	mov	r0, r1
    2500:	e5939008 	ldr	r9, [r3, #8]
    2504:	eb000c0a 	bl	5534 <strlen>
    2508:	e20050ff 	and	r5, r0, #255	; 0xff
    250c:	e3a0100d 	mov	r1, #13	; 0xd
    2510:	e285000c 	add	r0, r5, #12	; 0xc
    2514:	eb000d64 	bl	5aac <__aeabi_idiv>
    2518:	e3a01020 	mov	r1, #32	; 0x20
    251c:	e1a03000 	mov	r3, r0
    2520:	e3a0200b 	mov	r2, #11	; 0xb
    2524:	e1a0000d 	mov	r0, sp
    2528:	e203a0ff 	and	sl, r3, #255	; 0xff
    252c:	e5968028 	ldr	r8, [r6, #40]
    2530:	eb000bde 	bl	54b0 <memset>
    2534:	e1a00006 	mov	r0, r6
    2538:	e3a0102e 	mov	r1, #46	; 0x2e
    253c:	eb000c2b 	bl	55f0 <strrchr>
    2540:	e3500000 	cmp	r0, #0	; 0x0
    2544:	e1a0700d 	mov	r7, sp
    2548:	0a00000b 	beq	257c <fat16_write_dir_entry+0x9c>
    254c:	e2804001 	add	r4, r0, #1	; 0x1
    2550:	e1a00004 	mov	r0, r4
    2554:	eb000bf6 	bl	5534 <strlen>
    2558:	e20020ff 	and	r2, r0, #255	; 0xff
    255c:	e0623005 	rsb	r3, r2, r5
    2560:	e2433001 	sub	r3, r3, #1	; 0x1
    2564:	e3520003 	cmp	r2, #3	; 0x3
    2568:	23a02003 	movcs	r2, #3	; 0x3
    256c:	e1a01004 	mov	r1, r4
    2570:	e28d0008 	add	r0, sp, #8	; 0x8
    2574:	e20350ff 	and	r5, r3, #255	; 0xff
    2578:	eb000bc4 	bl	5490 <memcpy>
    257c:	e3550008 	cmp	r5, #8	; 0x8
    2580:	8a000004 	bhi	2598 <fat16_write_dir_entry+0xb8>
    2584:	e1a0000d 	mov	r0, sp
    2588:	e1a02005 	mov	r2, r5
    258c:	e1a01006 	mov	r1, r6
    2590:	eb000bbe 	bl	5490 <memcpy>
    2594:	ea00000e 	b	25d4 <fat16_write_dir_entry+0xf4>
    2598:	e3a02008 	mov	r2, #8	; 0x8
    259c:	e1a0000d 	mov	r0, sp
    25a0:	e1a01006 	mov	r1, r6
    25a4:	eb000bb9 	bl	5490 <memcpy>
    25a8:	e5d63022 	ldrb	r3, [r6, #34]
    25ac:	e353009f 	cmp	r3, #159	; 0x9f
    25b0:	e1a02223 	mov	r2, r3, lsr #4
    25b4:	e203300f 	and	r3, r3, #15	; 0xf
    25b8:	92822030 	addls	r2, r2, #48	; 0x30
    25bc:	82822061 	addhi	r2, r2, #97	; 0x61
    25c0:	e3530009 	cmp	r3, #9	; 0x9
    25c4:	92833030 	addls	r3, r3, #48	; 0x30
    25c8:	82833061 	addhi	r3, r3, #97	; 0x61
    25cc:	e5cd2006 	strb	r2, [sp, #6]
    25d0:	e5cd3007 	strb	r3, [sp, #7]
    25d4:	e3a01000 	mov	r1, #0	; 0x0
    25d8:	e3a02015 	mov	r2, #21	; 0x15
    25dc:	e28d000b 	add	r0, sp, #11	; 0xb
    25e0:	eb000bb2 	bl	54b0 <memset>
    25e4:	e5d63020 	ldrb	r3, [r6, #32]
    25e8:	e5cd300b 	strb	r3, [sp, #11]
    25ec:	e1d622b2 	ldrh	r2, [r6, #34]
    25f0:	e1a03422 	mov	r3, r2, lsr #8
    25f4:	e5cd201a 	strb	r2, [sp, #26]
    25f8:	e5cd301b 	strb	r3, [sp, #27]
    25fc:	e5963024 	ldr	r3, [r6, #36]
    2600:	e1a00c23 	mov	r0, r3, lsr #24
    2604:	e1a02423 	mov	r2, r3, lsr #8
    2608:	e1a01823 	mov	r1, r3, lsr #16
    260c:	e5cd201d 	strb	r2, [sp, #29]
    2610:	e5cd101e 	strb	r1, [sp, #30]
    2614:	e5cd001f 	strb	r0, [sp, #31]
    2618:	e5cd301c 	strb	r3, [sp, #28]
    261c:	e088028a 	add	r0, r8, sl, lsl #5
    2620:	e1a0100d 	mov	r1, sp
    2624:	e3a02020 	mov	r2, #32	; 0x20
    2628:	e1a0e00f 	mov	lr, pc
    262c:	e12fff19 	bx	r9
    2630:	e3500000 	cmp	r0, #0	; 0x0
    2634:	e1a0400d 	mov	r4, sp
    2638:	0a000047 	beq	275c <fat16_write_dir_entry+0x27c>
    263c:	e5dd7000 	ldrb	r7, [sp]
    2640:	e1a0100d 	mov	r1, sp
    2644:	e5f12001 	ldrb	r2, [r1, #1]!
    2648:	e1a03387 	mov	r3, r7, lsl #7
    264c:	e18330a7 	orr	r3, r3, r7, lsr #1
    2650:	e0833002 	add	r3, r3, r2
    2654:	e28d200a 	add	r2, sp, #10	; 0xa
    2658:	e1510002 	cmp	r1, r2
    265c:	e20370ff 	and	r7, r3, #255	; 0xff
    2660:	1afffff7 	bne	2644 <fat16_write_dir_entry+0x164>
    2664:	e1a0500a 	mov	r5, sl
    2668:	ea000037 	b	274c <fat16_write_dir_entry+0x26c>
    266c:	e3a01000 	mov	r1, #0	; 0x0
    2670:	e3a02020 	mov	r2, #32	; 0x20
    2674:	e1a0000d 	mov	r0, sp
    2678:	eb000b8c 	bl	54b0 <memset>
    267c:	e3a010ff 	mov	r1, #255	; 0xff
    2680:	e3a0200a 	mov	r2, #10	; 0xa
    2684:	e28d0001 	add	r0, sp, #1	; 0x1
    2688:	eb000b88 	bl	54b0 <memset>
    268c:	e3a010ff 	mov	r1, #255	; 0xff
    2690:	e3a0200c 	mov	r2, #12	; 0xc
    2694:	e28d000e 	add	r0, sp, #14	; 0xe
    2698:	eb000b84 	bl	54b0 <memset>
    269c:	e28d001c 	add	r0, sp, #28	; 0x1c
    26a0:	e3a010ff 	mov	r1, #255	; 0xff
    26a4:	e3a02004 	mov	r2, #4	; 0x4
    26a8:	eb000b80 	bl	54b0 <memset>
    26ac:	e155000a 	cmp	r5, sl
    26b0:	03853040 	orreq	r3, r5, #64	; 0x40
    26b4:	e5cd5000 	strb	r5, [sp]
    26b8:	05cd3000 	streqb	r3, [sp]
    26bc:	e3a0300d 	mov	r3, #13	; 0xd
    26c0:	e02e6395 	mla	lr, r5, r3, r6
    26c4:	e3a0c001 	mov	ip, #1	; 0x1
    26c8:	e28c3001 	add	r3, ip, #1	; 0x1
    26cc:	e20330ff 	and	r3, r3, #255	; 0xff
    26d0:	e2832001 	add	r2, r3, #1	; 0x1
    26d4:	e28d4020 	add	r4, sp, #32	; 0x20
    26d8:	e55e000d 	ldrb	r0, [lr, #-13]
    26dc:	e084100c 	add	r1, r4, ip
    26e0:	e202c0ff 	and	ip, r2, #255	; 0xff
    26e4:	e35c000b 	cmp	ip, #11	; 0xb
    26e8:	e0842003 	add	r2, r4, r3
    26ec:	e3a03000 	mov	r3, #0	; 0x0
    26f0:	e5410020 	strb	r0, [r1, #-32]
    26f4:	03a0c00e 	moveq	ip, #14	; 0xe
    26f8:	e5423020 	strb	r3, [r2, #-32]
    26fc:	0a000001 	beq	2708 <fat16_write_dir_entry+0x228>
    2700:	e35c001a 	cmp	ip, #26	; 0x1a
    2704:	028cc002 	addeq	ip, ip, #2	; 0x2
    2708:	e55e300d 	ldrb	r3, [lr, #-13]
    270c:	e3530000 	cmp	r3, #0	; 0x0
    2710:	e28ee001 	add	lr, lr, #1	; 0x1
    2714:	0a000001 	beq	2720 <fat16_write_dir_entry+0x240>
    2718:	e35c001e 	cmp	ip, #30	; 0x1e
    271c:	9affffe9 	bls	26c8 <fat16_write_dir_entry+0x1e8>
    2720:	e3a0300f 	mov	r3, #15	; 0xf
    2724:	e5cd300b 	strb	r3, [sp, #11]
    2728:	e1a00008 	mov	r0, r8
    272c:	e5cd700d 	strb	r7, [sp, #13]
    2730:	e1a0100d 	mov	r1, sp
    2734:	e3a02020 	mov	r2, #32	; 0x20
    2738:	e1a0e00f 	mov	lr, pc
    273c:	e12fff19 	bx	r9
    2740:	e2453001 	sub	r3, r5, #1	; 0x1
    2744:	e2888020 	add	r8, r8, #32	; 0x20
    2748:	e20350ff 	and	r5, r3, #255	; 0xff
    274c:	e3550000 	cmp	r5, #0	; 0x0
    2750:	1affffc5 	bne	266c <fat16_write_dir_entry+0x18c>
    2754:	e3a00001 	mov	r0, #1	; 0x1
    2758:	ea000000 	b	2760 <fat16_write_dir_entry+0x280>
    275c:	e3a00000 	mov	r0, #0	; 0x0
    2760:	e28dd020 	add	sp, sp, #32	; 0x20
    2764:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2768:	e12fff1e 	bx	lr

0000276c <fat16_resize_file>:
    276c:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2770:	e2506000 	subs	r6, r0, #0	; 0x0
    2774:	e24dd004 	sub	sp, sp, #4	; 0x4
    2778:	e1a0a001 	mov	sl, r1
    277c:	0a00005b 	beq	28f0 <fat16_resize_file+0x184>
    2780:	e1d642b6 	ldrh	r4, [r6, #38]
    2784:	e5963000 	ldr	r3, [r6]
    2788:	e2719001 	rsbs	r9, r1, #1	; 0x1
    278c:	33a09000 	movcc	r9, #0	; 0x0
    2790:	e3540000 	cmp	r4, #0	; 0x0
    2794:	03510000 	cmpeq	r1, #0	; 0x0
    2798:	e1d381b2 	ldrh	r8, [r3, #18]
    279c:	11a07001 	movne	r7, r1
    27a0:	1a000006 	bne	27c0 <fat16_resize_file+0x54>
    27a4:	ea000049 	b	28d0 <fat16_resize_file+0x164>
    27a8:	e5960000 	ldr	r0, [r6]
    27ac:	ebfffd0d 	bl	1be8 <fat16_get_next_cluster>
    27b0:	e3500000 	cmp	r0, #0	; 0x0
    27b4:	0a00004f 	beq	28f8 <fat16_resize_file+0x18c>
    27b8:	e0687007 	rsb	r7, r8, r7
    27bc:	e1a04000 	mov	r4, r0
    27c0:	e1570008 	cmp	r7, r8
    27c4:	e1a01004 	mov	r1, r4
    27c8:	8afffff6 	bhi	27a8 <fat16_resize_file+0x3c>
    27cc:	e2745001 	rsbs	r5, r4, #1	; 0x1
    27d0:	33a05000 	movcc	r5, #0	; 0x0
    27d4:	e3550000 	cmp	r5, #0	; 0x0
    27d8:	0a000011 	beq	2824 <fat16_resize_file+0xb8>
    27dc:	e1a01008 	mov	r1, r8
    27e0:	e1a00007 	mov	r0, r7
    27e4:	eb000c6b 	bl	5998 <__aeabi_uidiv>
    27e8:	e1a00800 	mov	r0, r0, lsl #16
    27ec:	e1a02820 	mov	r2, r0, lsr #16
    27f0:	e0030298 	mul	r3, r8, r2
    27f4:	e1530007 	cmp	r3, r7
    27f8:	32823001 	addcc	r3, r2, #1	; 0x1
    27fc:	31a03803 	movcc	r3, r3, lsl #16
    2800:	31a02823 	movcc	r2, r3, lsr #16
    2804:	e5960000 	ldr	r0, [r6]
    2808:	e1a01004 	mov	r1, r4
    280c:	ebfffd55 	bl	1d68 <fat16_append_clusters>
    2810:	e3500000 	cmp	r0, #0	; 0x0
    2814:	0a000035 	beq	28f0 <fat16_resize_file+0x184>
    2818:	e3550000 	cmp	r5, #0	; 0x0
    281c:	11c602b6 	strneh	r0, [r6, #38]
    2820:	11a04000 	movne	r4, r0
    2824:	e3590000 	cmp	r9, #0	; 0x0
    2828:	13a03000 	movne	r3, #0	; 0x0
    282c:	11c632b6 	strneh	r3, [r6, #38]
    2830:	e586a028 	str	sl, [r6, #40]
    2834:	e5960000 	ldr	r0, [r6]
    2838:	e2861004 	add	r1, r6, #4	; 0x4
    283c:	ebffff27 	bl	24e0 <fat16_write_dir_entry>
    2840:	e3500000 	cmp	r0, #0	; 0x0
    2844:	0a000029 	beq	28f0 <fat16_resize_file+0x184>
    2848:	e3590000 	cmp	r9, #0	; 0x0
    284c:	11a01004 	movne	r1, r4
    2850:	15960000 	ldrne	r0, [r6]
    2854:	1a00001c 	bne	28cc <fat16_resize_file+0x160>
    2858:	e1570008 	cmp	r7, r8
    285c:	8a00001b 	bhi	28d0 <fat16_resize_file+0x164>
    2860:	e1a03804 	mov	r3, r4, lsl #16
    2864:	e5965000 	ldr	r5, [r6]
    2868:	e1a04823 	mov	r4, r3, lsr #16
    286c:	e3550000 	cmp	r5, #0	; 0x0
    2870:	13540001 	cmpne	r4, #1	; 0x1
    2874:	9a000015 	bls	28d0 <fat16_resize_file+0x164>
    2878:	e1a01004 	mov	r1, r4
    287c:	e1a00005 	mov	r0, r5
    2880:	ebfffcd8 	bl	1be8 <fat16_get_next_cluster>
    2884:	e3e03000 	mvn	r3, #0	; 0x0
    2888:	e5cd3003 	strb	r3, [sp, #3]
    288c:	e5cd3002 	strb	r3, [sp, #2]
    2890:	e1a07000 	mov	r7, r0
    2894:	e5950008 	ldr	r0, [r5, #8]
    2898:	e5953000 	ldr	r3, [r5]
    289c:	e0800084 	add	r0, r0, r4, lsl #1
    28a0:	e28d1002 	add	r1, sp, #2	; 0x2
    28a4:	e3a02002 	mov	r2, #2	; 0x2
    28a8:	e593c008 	ldr	ip, [r3, #8]
    28ac:	e1a0e00f 	mov	lr, pc
    28b0:	e12fff1c 	bx	ip
    28b4:	e3500000 	cmp	r0, #0	; 0x0
    28b8:	0a000004 	beq	28d0 <fat16_resize_file+0x164>
    28bc:	e3570000 	cmp	r7, #0	; 0x0
    28c0:	0a000002 	beq	28d0 <fat16_resize_file+0x164>
    28c4:	e1a00005 	mov	r0, r5
    28c8:	e1a01007 	mov	r1, r7
    28cc:	ebfffcef 	bl	1c90 <fat16_free_clusters>
    28d0:	e5963030 	ldr	r3, [r6, #48]
    28d4:	e15a0003 	cmp	sl, r3
    28d8:	33a03000 	movcc	r3, #0	; 0x0
    28dc:	23a00001 	movcs	r0, #1	; 0x1
    28e0:	33a00001 	movcc	r0, #1	; 0x1
    28e4:	3586a030 	strcc	sl, [r6, #48]
    28e8:	31c633b4 	strcch	r3, [r6, #52]
    28ec:	ea000004 	b	2904 <fat16_resize_file+0x198>
    28f0:	e3a00000 	mov	r0, #0	; 0x0
    28f4:	ea000002 	b	2904 <fat16_resize_file+0x198>
    28f8:	e2745001 	rsbs	r5, r4, #1	; 0x1
    28fc:	33a05000 	movcc	r5, #0	; 0x0
    2900:	eaffffb5 	b	27dc <fat16_resize_file+0x70>
    2904:	e28dd004 	add	sp, sp, #4	; 0x4
    2908:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    290c:	e12fff1e 	bx	lr

00002910 <fat16_seek_file>:
    2910:	e3510000 	cmp	r1, #0	; 0x0
    2914:	13500000 	cmpne	r0, #0	; 0x0
    2918:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    291c:	e20220ff 	and	r2, r2, #255	; 0xff
    2920:	e1a05000 	mov	r5, r0
    2924:	e1a06001 	mov	r6, r1
    2928:	0a00001b 	beq	299c <fat16_seek_file+0x8c>
    292c:	e3520001 	cmp	r2, #1	; 0x1
    2930:	e5901030 	ldr	r1, [r0, #48]
    2934:	0a000004 	beq	294c <fat16_seek_file+0x3c>
    2938:	35964000 	ldrcc	r4, [r6]
    293c:	3a000008 	bcc	2964 <fat16_seek_file+0x54>
    2940:	e3520002 	cmp	r2, #2	; 0x2
    2944:	1a000014 	bne	299c <fat16_seek_file+0x8c>
    2948:	ea000002 	b	2958 <fat16_seek_file+0x48>
    294c:	e5963000 	ldr	r3, [r6]
    2950:	e0814003 	add	r4, r1, r3
    2954:	ea000002 	b	2964 <fat16_seek_file+0x54>
    2958:	e5902028 	ldr	r2, [r0, #40]
    295c:	e5963000 	ldr	r3, [r6]
    2960:	e0824003 	add	r4, r2, r3
    2964:	e5953028 	ldr	r3, [r5, #40]
    2968:	e1540003 	cmp	r4, r3
    296c:	9a000004 	bls	2984 <fat16_seek_file+0x74>
    2970:	e1a00005 	mov	r0, r5
    2974:	e1a01004 	mov	r1, r4
    2978:	ebffff7b 	bl	276c <fat16_resize_file>
    297c:	e3500000 	cmp	r0, #0	; 0x0
    2980:	0a000005 	beq	299c <fat16_seek_file+0x8c>
    2984:	e3a03000 	mov	r3, #0	; 0x0
    2988:	e3a00001 	mov	r0, #1	; 0x1
    298c:	e5854030 	str	r4, [r5, #48]
    2990:	e1c533b4 	strh	r3, [r5, #52]
    2994:	e5864000 	str	r4, [r6]
    2998:	ea000000 	b	29a0 <fat16_seek_file+0x90>
    299c:	e3a00000 	mov	r0, #0	; 0x0
    29a0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    29a4:	e12fff1e 	bx	lr

000029a8 <fat16_write_file>:
    29a8:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    29ac:	e1a02802 	mov	r2, r2, lsl #16
    29b0:	e24dd004 	sub	sp, sp, #4	; 0x4
    29b4:	e1a02822 	mov	r2, r2, lsr #16
    29b8:	e3510000 	cmp	r1, #0	; 0x0
    29bc:	13500000 	cmpne	r0, #0	; 0x0
    29c0:	e1a04000 	mov	r4, r0
    29c4:	e1a0b001 	mov	fp, r1
    29c8:	e58d2000 	str	r2, [sp]
    29cc:	0a000077 	beq	2bb0 <fat16_write_file+0x208>
    29d0:	e3520000 	cmp	r2, #0	; 0x0
    29d4:	0a000075 	beq	2bb0 <fat16_write_file+0x208>
    29d8:	e590a030 	ldr	sl, [r0, #48]
    29dc:	e5903028 	ldr	r3, [r0, #40]
    29e0:	e15a0003 	cmp	sl, r3
    29e4:	8a000071 	bhi	2bb0 <fat16_write_file+0x208>
    29e8:	e1d053b4 	ldrh	r5, [r0, #52]
    29ec:	e5900000 	ldr	r0, [r0]
    29f0:	e3550000 	cmp	r5, #0	; 0x0
    29f4:	e1d081b2 	ldrh	r8, [r0, #18]
    29f8:	1a000020 	bne	2a80 <fat16_write_file+0xd8>
    29fc:	e1d452b6 	ldrh	r5, [r4, #38]
    2a00:	e3550000 	cmp	r5, #0	; 0x0
    2a04:	1a000008 	bne	2a2c <fat16_write_file+0x84>
    2a08:	e35a0000 	cmp	sl, #0	; 0x0
    2a0c:	1a000067 	bne	2bb0 <fat16_write_file+0x208>
    2a10:	e1a01005 	mov	r1, r5
    2a14:	e3a02001 	mov	r2, #1	; 0x1
    2a18:	ebfffcd2 	bl	1d68 <fat16_append_clusters>
    2a1c:	e3500000 	cmp	r0, #0	; 0x0
    2a20:	e1a05000 	mov	r5, r0
    2a24:	e1c402b6 	strh	r0, [r4, #38]
    2a28:	0a000060 	beq	2bb0 <fat16_write_file+0x208>
    2a2c:	e5946030 	ldr	r6, [r4, #48]
    2a30:	e3560000 	cmp	r6, #0	; 0x0
    2a34:	12689000 	rsbne	r9, r8, #0	; 0x0
    2a38:	10687006 	rsbne	r7, r8, r6
    2a3c:	1a00000c 	bne	2a74 <fat16_write_file+0xcc>
    2a40:	ea00000e 	b	2a80 <fat16_write_file+0xd8>
    2a44:	e5940000 	ldr	r0, [r4]
    2a48:	ebfffc66 	bl	1be8 <fat16_get_next_cluster>
    2a4c:	e3500000 	cmp	r0, #0	; 0x0
    2a50:	03570000 	cmpeq	r7, #0	; 0x0
    2a54:	e0866009 	add	r6, r6, r9
    2a58:	e0877009 	add	r7, r7, r9
    2a5c:	e1a01005 	mov	r1, r5
    2a60:	e3a02001 	mov	r2, #1	; 0x1
    2a64:	05940000 	ldreq	r0, [r4]
    2a68:	0bfffcbe 	bleq	1d68 <fat16_append_clusters>
    2a6c:	e2505000 	subs	r5, r0, #0	; 0x0
    2a70:	0a00004e 	beq	2bb0 <fat16_write_file+0x208>
    2a74:	e1560008 	cmp	r6, r8
    2a78:	e1a01005 	mov	r1, r5
    2a7c:	2afffff0 	bcs	2a44 <fat16_write_file+0x9c>
    2a80:	e1a0000a 	mov	r0, sl
    2a84:	e1a01008 	mov	r1, r8
    2a88:	eb000c58 	bl	5bf0 <__umodsi3>
    2a8c:	e59d7000 	ldr	r7, [sp]
    2a90:	e1a00800 	mov	r0, r0, lsl #16
    2a94:	e1a0a820 	mov	sl, r0, lsr #16
    2a98:	e594c000 	ldr	ip, [r4]
    2a9c:	e06a3008 	rsb	r3, sl, r8
    2aa0:	e59c2018 	ldr	r2, [ip, #24]
    2aa4:	e1a03803 	mov	r3, r3, lsl #16
    2aa8:	e1a03823 	mov	r3, r3, lsr #16
    2aac:	e1570003 	cmp	r7, r3
    2ab0:	31a06007 	movcc	r6, r7
    2ab4:	21a06003 	movcs	r6, r3
    2ab8:	e08a2002 	add	r2, sl, r2
    2abc:	e2453002 	sub	r3, r5, #2	; 0x2
    2ac0:	e0202398 	mla	r0, r8, r3, r2
    2ac4:	e1a0100b 	mov	r1, fp
    2ac8:	e1a02006 	mov	r2, r6
    2acc:	e59c3000 	ldr	r3, [ip]
    2ad0:	e593c008 	ldr	ip, [r3, #8]
    2ad4:	e1a0e00f 	mov	lr, pc
    2ad8:	e12fff1c 	bx	ip
    2adc:	e0663007 	rsb	r3, r6, r7
    2ae0:	e3500000 	cmp	r0, #0	; 0x0
    2ae4:	e1a01005 	mov	r1, r5
    2ae8:	e08bb006 	add	fp, fp, r6
    2aec:	e08a2006 	add	r2, sl, r6
    2af0:	e1a00803 	mov	r0, r3, lsl #16
    2af4:	0a000018 	beq	2b5c <fat16_write_file+0x1b4>
    2af8:	e5943030 	ldr	r3, [r4, #48]
    2afc:	e1520008 	cmp	r2, r8
    2b00:	e0833006 	add	r3, r3, r6
    2b04:	e5843030 	str	r3, [r4, #48]
    2b08:	e1a07820 	mov	r7, r0, lsr #16
    2b0c:	ba00000f 	blt	2b50 <fat16_write_file+0x1a8>
    2b10:	e5940000 	ldr	r0, [r4]
    2b14:	ebfffc33 	bl	1be8 <fat16_get_next_cluster>
    2b18:	e3a0a000 	mov	sl, #0	; 0x0
    2b1c:	e150000a 	cmp	r0, sl
    2b20:	13a03000 	movne	r3, #0	; 0x0
    2b24:	03a03001 	moveq	r3, #1	; 0x1
    2b28:	e157000a 	cmp	r7, sl
    2b2c:	03a03000 	moveq	r3, #0	; 0x0
    2b30:	e153000a 	cmp	r3, sl
    2b34:	e1a01005 	mov	r1, r5
    2b38:	e3a02001 	mov	r2, #1	; 0x1
    2b3c:	15940000 	ldrne	r0, [r4]
    2b40:	1bfffc88 	blne	1d68 <fat16_append_clusters>
    2b44:	e3500000 	cmp	r0, #0	; 0x0
    2b48:	e1a05000 	mov	r5, r0
    2b4c:	0a000015 	beq	2ba8 <fat16_write_file+0x200>
    2b50:	e3570000 	cmp	r7, #0	; 0x0
    2b54:	e1c453b4 	strh	r5, [r4, #52]
    2b58:	1affffce 	bne	2a98 <fat16_write_file+0xf0>
    2b5c:	e5943030 	ldr	r3, [r4, #48]
    2b60:	e5945028 	ldr	r5, [r4, #40]
    2b64:	e1530005 	cmp	r3, r5
    2b68:	9a000009 	bls	2b94 <fat16_write_file+0x1ec>
    2b6c:	e5843028 	str	r3, [r4, #40]
    2b70:	e5940000 	ldr	r0, [r4]
    2b74:	e2841004 	add	r1, r4, #4	; 0x4
    2b78:	ebfffe58 	bl	24e0 <fat16_write_dir_entry>
    2b7c:	e3500000 	cmp	r0, #0	; 0x0
    2b80:	05943030 	ldreq	r3, [r4, #48]
    2b84:	00653003 	rsbeq	r3, r5, r3
    2b88:	01a03803 	moveq	r3, r3, lsl #16
    2b8c:	05845030 	streq	r5, [r4, #48]
    2b90:	01a07823 	moveq	r7, r3, lsr #16
    2b94:	e59d2000 	ldr	r2, [sp]
    2b98:	e0673002 	rsb	r3, r7, r2
    2b9c:	e1a03803 	mov	r3, r3, lsl #16
    2ba0:	e1a00843 	mov	r0, r3, asr #16
    2ba4:	ea000002 	b	2bb4 <fat16_write_file+0x20c>
    2ba8:	e1c403b4 	strh	r0, [r4, #52]
    2bac:	eaffffea 	b	2b5c <fat16_write_file+0x1b4>
    2bb0:	e3e00000 	mvn	r0, #0	; 0x0
    2bb4:	e28dd004 	add	sp, sp, #4	; 0x4
    2bb8:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2bbc:	e12fff1e 	bx	lr

00002bc0 <fat16_close_dir>:
    2bc0:	e3500000 	cmp	r0, #0	; 0x0
    2bc4:	e52de004 	str	lr, [sp, #-4]!
    2bc8:	1b00087e 	blne	4dc8 <free>
    2bcc:	e49de004 	ldr	lr, [sp], #4
    2bd0:	e12fff1e 	bx	lr

00002bd4 <fat16_close_file>:
    2bd4:	e3500000 	cmp	r0, #0	; 0x0
    2bd8:	e52de004 	str	lr, [sp, #-4]!
    2bdc:	1b000879 	blne	4dc8 <free>
    2be0:	e49de004 	ldr	lr, [sp], #4
    2be4:	e12fff1e 	bx	lr

00002be8 <fat16_close>:
    2be8:	e3500000 	cmp	r0, #0	; 0x0
    2bec:	e52de004 	str	lr, [sp, #-4]!
    2bf0:	1b000874 	blne	4dc8 <free>
    2bf4:	e49de004 	ldr	lr, [sp], #4
    2bf8:	e12fff1e 	bx	lr

00002bfc <fat16_open_dir>:
    2bfc:	e3510000 	cmp	r1, #0	; 0x0
    2c00:	13500000 	cmpne	r0, #0	; 0x0
    2c04:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2c08:	e1a07000 	mov	r7, r0
    2c0c:	e1a05001 	mov	r5, r1
    2c10:	13a08000 	movne	r8, #0	; 0x0
    2c14:	03a08001 	moveq	r8, #1	; 0x1
    2c18:	0a000013 	beq	2c6c <fat16_open_dir+0x70>
    2c1c:	e5d13020 	ldrb	r3, [r1, #32]
    2c20:	e3130010 	tst	r3, #16	; 0x10
    2c24:	e3a00034 	mov	r0, #52	; 0x34
    2c28:	0a00000f 	beq	2c6c <fat16_open_dir+0x70>
    2c2c:	eb00086d 	bl	4de8 <malloc>
    2c30:	e3500000 	cmp	r0, #0	; 0x0
    2c34:	e1a06000 	mov	r6, r0
    2c38:	e2804004 	add	r4, r0, #4	; 0x4
    2c3c:	0a00000a 	beq	2c6c <fat16_open_dir+0x70>
    2c40:	e1a0c005 	mov	ip, r5
    2c44:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2c48:	e1a0e004 	mov	lr, r4
    2c4c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2c50:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2c54:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2c58:	e89c0007 	ldmia	ip, {r0, r1, r2}
    2c5c:	e5867000 	str	r7, [r6]
    2c60:	e88e0007 	stmia	lr, {r0, r1, r2}
    2c64:	e1c683b0 	strh	r8, [r6, #48]
    2c68:	ea000000 	b	2c70 <fat16_open_dir+0x74>
    2c6c:	e3a06000 	mov	r6, #0	; 0x0
    2c70:	e1a00006 	mov	r0, r6
    2c74:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    2c78:	e12fff1e 	bx	lr

00002c7c <fat16_open_file>:
    2c7c:	e3510000 	cmp	r1, #0	; 0x0
    2c80:	13500000 	cmpne	r0, #0	; 0x0
    2c84:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2c88:	e1a05001 	mov	r5, r1
    2c8c:	e1a07000 	mov	r7, r0
    2c90:	0a000015 	beq	2cec <fat16_open_file+0x70>
    2c94:	e5d13020 	ldrb	r3, [r1, #32]
    2c98:	e2138010 	ands	r8, r3, #16	; 0x10
    2c9c:	e3a00038 	mov	r0, #56	; 0x38
    2ca0:	1a000011 	bne	2cec <fat16_open_file+0x70>
    2ca4:	eb00084f 	bl	4de8 <malloc>
    2ca8:	e3500000 	cmp	r0, #0	; 0x0
    2cac:	e1a06000 	mov	r6, r0
    2cb0:	e2804004 	add	r4, r0, #4	; 0x4
    2cb4:	0a00000c 	beq	2cec <fat16_open_file+0x70>
    2cb8:	e1a0c005 	mov	ip, r5
    2cbc:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2cc0:	e1a0e004 	mov	lr, r4
    2cc4:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2cc8:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
    2ccc:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
    2cd0:	e89c0007 	ldmia	ip, {r0, r1, r2}
    2cd4:	e88e0007 	stmia	lr, {r0, r1, r2}
    2cd8:	e1d552b2 	ldrh	r5, [r5, #34]
    2cdc:	e5867000 	str	r7, [r6]
    2ce0:	e5868030 	str	r8, [r6, #48]
    2ce4:	e1c653b4 	strh	r5, [r6, #52]
    2ce8:	ea000000 	b	2cf0 <fat16_open_file+0x74>
    2cec:	e3a06000 	mov	r6, #0	; 0x0
    2cf0:	e1a00006 	mov	r0, r6
    2cf4:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    2cf8:	e12fff1e 	bx	lr

00002cfc <open_file_in_dir>:
    2cfc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    2d00:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    2d04:	e1a0300d 	mov	r3, sp
    2d08:	e1a04000 	mov	r4, r0
    2d0c:	ebfffddc 	bl	2484 <find_file_in_dir>
    2d10:	e3500000 	cmp	r0, #0	; 0x0
    2d14:	e1a03000 	mov	r3, r0
    2d18:	e1a0500d 	mov	r5, sp
    2d1c:	e1a00004 	mov	r0, r4
    2d20:	e1a0100d 	mov	r1, sp
    2d24:	0a000001 	beq	2d30 <open_file_in_dir+0x34>
    2d28:	ebffffd3 	bl	2c7c <fat16_open_file>
    2d2c:	e1a03000 	mov	r3, r0
    2d30:	e1a00003 	mov	r0, r3
    2d34:	e28dd02c 	add	sp, sp, #44	; 0x2c
    2d38:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    2d3c:	e12fff1e 	bx	lr

00002d40 <fat16_get_dir_entry_of_path>:
    2d40:	e3510000 	cmp	r1, #0	; 0x0
    2d44:	13500000 	cmpne	r0, #0	; 0x0
    2d48:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2d4c:	e1a09000 	mov	r9, r0
    2d50:	e1a04001 	mov	r4, r1
    2d54:	e1a05002 	mov	r5, r2
    2d58:	0a00003c 	beq	2e50 <fat16_get_dir_entry_of_path+0x110>
    2d5c:	e5d13000 	ldrb	r3, [r1]
    2d60:	e3520000 	cmp	r2, #0	; 0x0
    2d64:	13530000 	cmpne	r3, #0	; 0x0
    2d68:	13a01000 	movne	r1, #0	; 0x0
    2d6c:	03a01001 	moveq	r1, #1	; 0x1
    2d70:	0a000036 	beq	2e50 <fat16_get_dir_entry_of_path+0x110>
    2d74:	e353002f 	cmp	r3, #47	; 0x2f
    2d78:	e1a00002 	mov	r0, r2
    2d7c:	e3a0202c 	mov	r2, #44	; 0x2c
    2d80:	02844001 	addeq	r4, r4, #1	; 0x1
    2d84:	eb0009c9 	bl	54b0 <memset>
    2d88:	e3a03010 	mov	r3, #16	; 0x10
    2d8c:	e5c53020 	strb	r3, [r5, #32]
    2d90:	e5d43000 	ldrb	r3, [r4]
    2d94:	e3530000 	cmp	r3, #0	; 0x0
    2d98:	0a00002e 	beq	2e58 <fat16_get_dir_entry_of_path+0x118>
    2d9c:	e1a00009 	mov	r0, r9
    2da0:	e1a01005 	mov	r1, r5
    2da4:	ebffff94 	bl	2bfc <fat16_open_dir>
    2da8:	e2507000 	subs	r7, r0, #0	; 0x0
    2dac:	0a000027 	beq	2e50 <fat16_get_dir_entry_of_path+0x110>
    2db0:	e1a00004 	mov	r0, r4
    2db4:	e3a0102f 	mov	r1, #47	; 0x2f
    2db8:	eb0009c5 	bl	54d4 <strchr>
    2dbc:	e2508000 	subs	r8, r0, #0	; 0x0
    2dc0:	1a000002 	bne	2dd0 <fat16_get_dir_entry_of_path+0x90>
    2dc4:	e1a00004 	mov	r0, r4
    2dc8:	eb0009d9 	bl	5534 <strlen>
    2dcc:	e0848000 	add	r8, r4, r0
    2dd0:	e0643008 	rsb	r3, r4, r8
    2dd4:	e20360ff 	and	r6, r3, #255	; 0xff
    2dd8:	ea000013 	b	2e2c <fat16_get_dir_entry_of_path+0xec>
    2ddc:	eb0009d4 	bl	5534 <strlen>
    2de0:	e1500006 	cmp	r0, r6
    2de4:	e1a01005 	mov	r1, r5
    2de8:	e1a02006 	mov	r2, r6
    2dec:	e1a00004 	mov	r0, r4
    2df0:	1a00000d 	bne	2e2c <fat16_get_dir_entry_of_path+0xec>
    2df4:	eb0009d6 	bl	5554 <strncmp>
    2df8:	e250a000 	subs	sl, r0, #0	; 0x0
    2dfc:	1a00000a 	bne	2e2c <fat16_get_dir_entry_of_path+0xec>
    2e00:	e1a00007 	mov	r0, r7
    2e04:	ebffff6d 	bl	2bc0 <fat16_close_dir>
    2e08:	e7d43006 	ldrb	r3, [r4, r6]
    2e0c:	e3530000 	cmp	r3, #0	; 0x0
    2e10:	0a000010 	beq	2e58 <fat16_get_dir_entry_of_path+0x118>
    2e14:	e5d53020 	ldrb	r3, [r5, #32]
    2e18:	e3130010 	tst	r3, #16	; 0x10
    2e1c:	0a00000b 	beq	2e50 <fat16_get_dir_entry_of_path+0x110>
    2e20:	e2884001 	add	r4, r8, #1	; 0x1
    2e24:	e1a0700a 	mov	r7, sl
    2e28:	ea000005 	b	2e44 <fat16_get_dir_entry_of_path+0x104>
    2e2c:	e1a01005 	mov	r1, r5
    2e30:	e1a00007 	mov	r0, r7
    2e34:	ebfffd0c 	bl	226c <fat16_read_dir>
    2e38:	e3500000 	cmp	r0, #0	; 0x0
    2e3c:	e1a00005 	mov	r0, r5
    2e40:	1affffe5 	bne	2ddc <fat16_get_dir_entry_of_path+0x9c>
    2e44:	e1a00007 	mov	r0, r7
    2e48:	ebffff5c 	bl	2bc0 <fat16_close_dir>
    2e4c:	eaffffd2 	b	2d9c <fat16_get_dir_entry_of_path+0x5c>
    2e50:	e3a00000 	mov	r0, #0	; 0x0
    2e54:	ea000000 	b	2e5c <fat16_get_dir_entry_of_path+0x11c>
    2e58:	e3a00001 	mov	r0, #1	; 0x1
    2e5c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2e60:	e12fff1e 	bx	lr

00002e64 <fat16_open>:
    2e64:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e68:	e2508000 	subs	r8, r0, #0	; 0x0
    2e6c:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    2e70:	0a000071 	beq	303c <fat16_open+0x1d8>
    2e74:	e5983008 	ldr	r3, [r8, #8]
    2e78:	e3530000 	cmp	r3, #0	; 0x0
    2e7c:	0a00006e 	beq	303c <fat16_open+0x1d8>
    2e80:	e3a0001c 	mov	r0, #28	; 0x1c
    2e84:	eb0007d7 	bl	4de8 <malloc>
    2e88:	e250b000 	subs	fp, r0, #0	; 0x0
    2e8c:	1a000003 	bne	2ea0 <fat16_open+0x3c>
    2e90:	e59f01b8 	ldr	r0, [pc, #440]	; 3050 <.text+0x3050>
    2e94:	ebfff54f 	bl	3d8 <rprintf>
    2e98:	e1a0a00b 	mov	sl, fp
    2e9c:	ea000067 	b	3040 <fat16_open+0x1dc>
    2ea0:	e3a01000 	mov	r1, #0	; 0x0
    2ea4:	e3a0201c 	mov	r2, #28	; 0x1c
    2ea8:	eb000980 	bl	54b0 <memset>
    2eac:	e5983010 	ldr	r3, [r8, #16]
    2eb0:	e1a03483 	mov	r3, r3, lsl #9
    2eb4:	e58d3008 	str	r3, [sp, #8]
    2eb8:	e58b8000 	str	r8, [fp]
    2ebc:	e283000b 	add	r0, r3, #11	; 0xb
    2ec0:	e28d1023 	add	r1, sp, #35	; 0x23
    2ec4:	e3a02019 	mov	r2, #25	; 0x19
    2ec8:	e598c000 	ldr	ip, [r8]
    2ecc:	e1a0e00f 	mov	lr, pc
    2ed0:	e12fff1c 	bx	ip
    2ed4:	e3500000 	cmp	r0, #0	; 0x0
    2ed8:	e1a0a00b 	mov	sl, fp
    2edc:	0a000052 	beq	302c <fat16_open+0x1c8>
    2ee0:	e5dd202e 	ldrb	r2, [sp, #46]
    2ee4:	e5dd302f 	ldrb	r3, [sp, #47]
    2ee8:	e1923403 	orrs	r3, r2, r3, lsl #8
    2eec:	e5dd0023 	ldrb	r0, [sp, #35]
    2ef0:	e5dd2024 	ldrb	r2, [sp, #36]
    2ef4:	e58d3010 	str	r3, [sp, #16]
    2ef8:	e5dd6026 	ldrb	r6, [sp, #38]
    2efc:	e5dd3025 	ldrb	r3, [sp, #37]
    2f00:	e58d001c 	str	r0, [sp, #28]
    2f04:	e58d2018 	str	r2, [sp, #24]
    2f08:	e58d3004 	str	r3, [sp, #4]
    2f0c:	e58d6014 	str	r6, [sp, #20]
    2f10:	e5dd1027 	ldrb	r1, [sp, #39]
    2f14:	e5dd9028 	ldrb	r9, [sp, #40]
    2f18:	e5dd7029 	ldrb	r7, [sp, #41]
    2f1c:	e5dd502a 	ldrb	r5, [sp, #42]
    2f20:	e5dd402b 	ldrb	r4, [sp, #43]
    2f24:	e5dde02c 	ldrb	lr, [sp, #44]
    2f28:	e5ddc038 	ldrb	ip, [sp, #56]
    2f2c:	e5dd2039 	ldrb	r2, [sp, #57]
    2f30:	e5dd303a 	ldrb	r3, [sp, #58]
    2f34:	e5dd003b 	ldrb	r0, [sp, #59]
    2f38:	0a00003b 	beq	302c <fat16_open+0x1c8>
    2f3c:	e1a03803 	mov	r3, r3, lsl #16
    2f40:	e18c2402 	orr	r2, ip, r2, lsl #8
    2f44:	e1833c00 	orr	r3, r3, r0, lsl #24
    2f48:	e1926003 	orrs	r6, r2, r3
    2f4c:	1a000002 	bne	2f5c <fat16_open+0xf8>
    2f50:	e194240e 	orrs	r2, r4, lr, lsl #8
    2f54:	0a000034 	beq	302c <fat16_open+0x1c8>
    2f58:	e1a06002 	mov	r6, r2
    2f5c:	e59d0010 	ldr	r0, [sp, #16]
    2f60:	e0000099 	mul	r0, r9, r0
    2f64:	e59d201c 	ldr	r2, [sp, #28]
    2f68:	e58d000c 	str	r0, [sp, #12]
    2f6c:	e59d0018 	ldr	r0, [sp, #24]
    2f70:	e1873405 	orr	r3, r7, r5, lsl #8
    2f74:	e1825400 	orr	r5, r2, r0, lsl #8
    2f78:	e59d2014 	ldr	r2, [sp, #20]
    2f7c:	e1a03283 	mov	r3, r3, lsl #5
    2f80:	e1829401 	orr	r9, r2, r1, lsl #8
    2f84:	e58d3000 	str	r3, [sp]
    2f88:	e0830005 	add	r0, r3, r5
    2f8c:	e59d300c 	ldr	r3, [sp, #12]
    2f90:	e1a01005 	mov	r1, r5
    2f94:	e2400001 	sub	r0, r0, #1	; 0x1
    2f98:	e0694006 	rsb	r4, r9, r6
    2f9c:	e0634004 	rsb	r4, r3, r4
    2fa0:	eb000ac1 	bl	5aac <__aeabi_idiv>
    2fa4:	e59d1004 	ldr	r1, [sp, #4]
    2fa8:	e0600004 	rsb	r0, r0, r4
    2fac:	eb000a79 	bl	5998 <__aeabi_uidiv>
    2fb0:	e2403eff 	sub	r3, r0, #4080	; 0xff0
    2fb4:	e2433005 	sub	r3, r3, #5	; 0x5
    2fb8:	e3530a0f 	cmp	r3, #61440	; 0xf000
    2fbc:	e1a07000 	mov	r7, r0
    2fc0:	2a000019 	bcs	302c <fat16_open+0x1c8>
    2fc4:	e28a4004 	add	r4, sl, #4	; 0x4
    2fc8:	e3a03006 	mov	r3, #6	; 0x6
    2fcc:	e5c8300c 	strb	r3, [r8, #12]
    2fd0:	e3a01000 	mov	r1, #0	; 0x0
    2fd4:	e3a02018 	mov	r2, #24	; 0x18
    2fd8:	e1a00004 	mov	r0, r4
    2fdc:	eb000933 	bl	54b0 <memset>
    2fe0:	e59dc008 	ldr	ip, [sp, #8]
    2fe4:	e02cc995 	mla	ip, r5, r9, ip
    2fe8:	e59de00c 	ldr	lr, [sp, #12]
    2fec:	e59d0004 	ldr	r0, [sp, #4]
    2ff0:	e02ece95 	mla	lr, r5, lr, ip
    2ff4:	e0010695 	mul	r1, r5, r6
    2ff8:	e0000095 	mul	r0, r5, r0
    2ffc:	e59d6000 	ldr	r6, [sp]
    3000:	e1a03087 	mov	r3, r7, lsl #1
    3004:	e08e2006 	add	r2, lr, r6
    3008:	e2833004 	add	r3, r3, #4	; 0x4
    300c:	e5842014 	str	r2, [r4, #20]
    3010:	e58a1004 	str	r1, [sl, #4]
    3014:	e5843008 	str	r3, [r4, #8]
    3018:	e1c400be 	strh	r0, [r4, #14]
    301c:	e584c004 	str	ip, [r4, #4]
    3020:	e1c450bc 	strh	r5, [r4, #12]
    3024:	e584e010 	str	lr, [r4, #16]
    3028:	ea000004 	b	3040 <fat16_open+0x1dc>
    302c:	e59f0020 	ldr	r0, [pc, #32]	; 3054 <.text+0x3054>
    3030:	ebfff4e8 	bl	3d8 <rprintf>
    3034:	e1a0000b 	mov	r0, fp
    3038:	eb000762 	bl	4dc8 <free>
    303c:	e3a0a000 	mov	sl, #0	; 0x0
    3040:	e1a0000a 	mov	r0, sl
    3044:	e28dd03c 	add	sp, sp, #60	; 0x3c
    3048:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    304c:	e12fff1e 	bx	lr
    3050:	00005f50 	andeq	r5, r0, r0, asr pc
    3054:	00005f60 	andeq	r5, r0, r0, ror #30

00003058 <fat16_create_file>:
    3058:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    305c:	e2706001 	rsbs	r6, r0, #1	; 0x1
    3060:	33a06000 	movcc	r6, #0	; 0x0
    3064:	e3500000 	cmp	r0, #0	; 0x0
    3068:	13510000 	cmpne	r1, #0	; 0x0
    306c:	e24dd004 	sub	sp, sp, #4	; 0x4
    3070:	e1a05000 	mov	r5, r0
    3074:	e1a04001 	mov	r4, r1
    3078:	e1a08002 	mov	r8, r2
    307c:	0a000065 	beq	3218 <fat16_create_file+0x1c0>
    3080:	e5d13000 	ldrb	r3, [r1]
    3084:	e3530000 	cmp	r3, #0	; 0x0
    3088:	0a000062 	beq	3218 <fat16_create_file+0x1c0>
    308c:	e1a01008 	mov	r1, r8
    3090:	e1a00005 	mov	r0, r5
    3094:	ebfffc74 	bl	226c <fat16_read_dir>
    3098:	e250a000 	subs	sl, r0, #0	; 0x0
    309c:	e1a01008 	mov	r1, r8
    30a0:	e1a00004 	mov	r0, r4
    30a4:	0a000007 	beq	30c8 <fat16_create_file+0x70>
    30a8:	eb000915 	bl	5504 <strcmp>
    30ac:	e3500000 	cmp	r0, #0	; 0x0
    30b0:	1afffff5 	bne	308c <fat16_create_file+0x34>
    30b4:	e3560000 	cmp	r6, #0	; 0x0
    30b8:	12800001 	addne	r0, r0, #1	; 0x1
    30bc:	03a00001 	moveq	r0, #1	; 0x1
    30c0:	01c563b0 	streqh	r6, [r5, #48]
    30c4:	ea000054 	b	321c <fat16_create_file+0x1c4>
    30c8:	e1a0100a 	mov	r1, sl
    30cc:	e3a0202c 	mov	r2, #44	; 0x2c
    30d0:	e1a00008 	mov	r0, r8
    30d4:	eb0008f5 	bl	54b0 <memset>
    30d8:	e1a01004 	mov	r1, r4
    30dc:	e3a0201f 	mov	r2, #31	; 0x1f
    30e0:	e1a00008 	mov	r0, r8
    30e4:	eb00092e 	bl	55a4 <strncpy>
    30e8:	e1a00004 	mov	r0, r4
    30ec:	eb000910 	bl	5534 <strlen>
    30f0:	e3a0100d 	mov	r1, #13	; 0xd
    30f4:	eb000a27 	bl	5998 <__aeabi_uidiv>
    30f8:	e1d572b6 	ldrh	r7, [r5, #38]
    30fc:	e5955000 	ldr	r5, [r5]
    3100:	e3570000 	cmp	r7, #0	; 0x0
    3104:	05954014 	ldreq	r4, [r5, #20]
    3108:	11a0600a 	movne	r6, sl
    310c:	e2800002 	add	r0, r0, #2	; 0x2
    3110:	0595a018 	ldreq	sl, [r5, #24]
    3114:	e200b0ff 	and	fp, r0, #255	; 0xff
    3118:	11a04006 	movne	r4, r6
    311c:	11a0a006 	movne	sl, r6
    3120:	01a06004 	moveq	r6, r4
    3124:	e3a09000 	mov	r9, #0	; 0x0
    3128:	e154000a 	cmp	r4, sl
    312c:	1a00001b 	bne	31a0 <fat16_create_file+0x148>
    3130:	e3570000 	cmp	r7, #0	; 0x0
    3134:	0a000037 	beq	3218 <fat16_create_file+0x1c0>
    3138:	e3540000 	cmp	r4, #0	; 0x0
    313c:	0a000010 	beq	3184 <fat16_create_file+0x12c>
    3140:	e1a00005 	mov	r0, r5
    3144:	e1a01007 	mov	r1, r7
    3148:	ebfffaa6 	bl	1be8 <fat16_get_next_cluster>
    314c:	e3500000 	cmp	r0, #0	; 0x0
    3150:	1a00000a 	bne	3180 <fat16_create_file+0x128>
    3154:	e1a01007 	mov	r1, r7
    3158:	e1a00005 	mov	r0, r5
    315c:	e3a02001 	mov	r2, #1	; 0x1
    3160:	ebfffb00 	bl	1d68 <fat16_append_clusters>
    3164:	e3500000 	cmp	r0, #0	; 0x0
    3168:	0a00002a 	beq	3218 <fat16_create_file+0x1c0>
    316c:	e1d511b2 	ldrh	r1, [r5, #18]
    3170:	e5952018 	ldr	r2, [r5, #24]
    3174:	e2403002 	sub	r3, r0, #2	; 0x2
    3178:	e0262391 	mla	r6, r1, r3, r2
    317c:	ea00001e 	b	31fc <fat16_create_file+0x1a4>
    3180:	e1a07000 	mov	r7, r0
    3184:	e1d511b2 	ldrh	r1, [r5, #18]
    3188:	e5952018 	ldr	r2, [r5, #24]
    318c:	e2473002 	sub	r3, r7, #2	; 0x2
    3190:	e0242391 	mla	r4, r1, r3, r2
    3194:	e3a09000 	mov	r9, #0	; 0x0
    3198:	e084a001 	add	sl, r4, r1
    319c:	e1a06004 	mov	r6, r4
    31a0:	e5953000 	ldr	r3, [r5]
    31a4:	e1a00004 	mov	r0, r4
    31a8:	e28d1003 	add	r1, sp, #3	; 0x3
    31ac:	e3a02001 	mov	r2, #1	; 0x1
    31b0:	e593c000 	ldr	ip, [r3]
    31b4:	e1a0e00f 	mov	lr, pc
    31b8:	e12fff1c 	bx	ip
    31bc:	e3500000 	cmp	r0, #0	; 0x0
    31c0:	0a000014 	beq	3218 <fat16_create_file+0x1c0>
    31c4:	e5dd3003 	ldrb	r3, [sp, #3]
    31c8:	e3530000 	cmp	r3, #0	; 0x0
    31cc:	135300e5 	cmpne	r3, #229	; 0xe5
    31d0:	13a03000 	movne	r3, #0	; 0x0
    31d4:	03a03001 	moveq	r3, #1	; 0x1
    31d8:	12846020 	addne	r6, r4, #32	; 0x20
    31dc:	11a09003 	movne	r9, r3
    31e0:	11a04006 	movne	r4, r6
    31e4:	1affffcf 	bne	3128 <fat16_create_file+0xd0>
    31e8:	e2893001 	add	r3, r9, #1	; 0x1
    31ec:	e20390ff 	and	r9, r3, #255	; 0xff
    31f0:	e159000b 	cmp	r9, fp
    31f4:	32844020 	addcc	r4, r4, #32	; 0x20
    31f8:	3affffca 	bcc	3128 <fat16_create_file+0xd0>
    31fc:	e5886028 	str	r6, [r8, #40]
    3200:	e1a00005 	mov	r0, r5
    3204:	e1a01008 	mov	r1, r8
    3208:	ebfffcb4 	bl	24e0 <fat16_write_dir_entry>
    320c:	e2500000 	subs	r0, r0, #0	; 0x0
    3210:	13a00001 	movne	r0, #1	; 0x1
    3214:	ea000000 	b	321c <fat16_create_file+0x1c4>
    3218:	e3a00000 	mov	r0, #0	; 0x0
    321c:	e28dd004 	add	sp, sp, #4	; 0x4
    3220:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3224:	e12fff1e 	bx	lr

00003228 <partition_close>:
 * \see partition_open
 */
uint8_t partition_close(struct partition_struct* partition)
{
    if(!partition)
    3228:	e2503000 	subs	r3, r0, #0	; 0x0
    322c:	e52de004 	str	lr, [sp, #-4]!
    3230:	0a000001 	beq	323c <partition_close+0x14>
        return 0;

    /* destroy partition descriptor */
    free(partition);
    3234:	eb0006e3 	bl	4dc8 <free>
    3238:	e3a03001 	mov	r3, #1	; 0x1

    return 1;
}
    323c:	e1a00003 	mov	r0, r3
    3240:	e49de004 	ldr	lr, [sp], #4
    3244:	e12fff1e 	bx	lr

00003248 <partition_open>:
    3248:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    324c:	e3510000 	cmp	r1, #0	; 0x0
    3250:	13500000 	cmpne	r0, #0	; 0x0
    3254:	e24dd010 	sub	sp, sp, #16	; 0x10
    3258:	e1a06000 	mov	r6, r0
    325c:	e1a07001 	mov	r7, r1
    3260:	13a04000 	movne	r4, #0	; 0x0
    3264:	03a04001 	moveq	r4, #1	; 0x1
    3268:	e1a08002 	mov	r8, r2
    326c:	e20330ff 	and	r3, r3, #255	; 0xff
    3270:	0a000033 	beq	3344 <partition_open+0xfc>
    3274:	e1a03c03 	mov	r3, r3, lsl #24
    3278:	e1a05c43 	mov	r5, r3, asr #24
    327c:	e3550003 	cmp	r5, #3	; 0x3
    3280:	ca00002f 	bgt	3344 <partition_open+0xfc>
    3284:	e3550000 	cmp	r5, #0	; 0x0
    3288:	ba00000b 	blt	32bc <partition_open+0x74>
    328c:	e1a00205 	mov	r0, r5, lsl #4
    3290:	e2800f6f 	add	r0, r0, #444	; 0x1bc
    3294:	e2800002 	add	r0, r0, #2	; 0x2
    3298:	e1a0100d 	mov	r1, sp
    329c:	e3a02010 	mov	r2, #16	; 0x10
    32a0:	e1a0e00f 	mov	lr, pc
    32a4:	e12fff16 	bx	r6
    32a8:	e3500000 	cmp	r0, #0	; 0x0
    32ac:	0a000024 	beq	3344 <partition_open+0xfc>
    32b0:	e5dd3004 	ldrb	r3, [sp, #4]
    32b4:	e3530000 	cmp	r3, #0	; 0x0
    32b8:	0a000021 	beq	3344 <partition_open+0xfc>
    32bc:	e3a00018 	mov	r0, #24	; 0x18
    32c0:	eb0006c8 	bl	4de8 <malloc>
    32c4:	e2503000 	subs	r3, r0, #0	; 0x0
    32c8:	0a00001d 	beq	3344 <partition_open+0xfc>
    32cc:	e1a01004 	mov	r1, r4
    32d0:	e3a02018 	mov	r2, #24	; 0x18
    32d4:	e1a04003 	mov	r4, r3
    32d8:	eb000874 	bl	54b0 <memset>
    32dc:	e3550000 	cmp	r5, #0	; 0x0
    32e0:	b3e03000 	mvnlt	r3, #0	; 0x0
    32e4:	e88401c0 	stmia	r4, {r6, r7, r8}
    32e8:	b5c4300c 	strltb	r3, [r4, #12]
    32ec:	ba000015 	blt	3348 <partition_open+0x100>
    32f0:	e5dd3004 	ldrb	r3, [sp, #4]
    32f4:	e5c4300c 	strb	r3, [r4, #12]
    32f8:	e5dd300a 	ldrb	r3, [sp, #10]
    32fc:	e5dd1009 	ldrb	r1, [sp, #9]
    3300:	e5dd000b 	ldrb	r0, [sp, #11]
    3304:	e5dd2008 	ldrb	r2, [sp, #8]
    3308:	e1a03803 	mov	r3, r3, lsl #16
    330c:	e1833c00 	orr	r3, r3, r0, lsl #24
    3310:	e1822401 	orr	r2, r2, r1, lsl #8
    3314:	e1822003 	orr	r2, r2, r3
    3318:	e5842010 	str	r2, [r4, #16]
    331c:	e5dd300e 	ldrb	r3, [sp, #14]
    3320:	e5dd200c 	ldrb	r2, [sp, #12]
    3324:	e5dd100d 	ldrb	r1, [sp, #13]
    3328:	e5dd000f 	ldrb	r0, [sp, #15]
    332c:	e1a03803 	mov	r3, r3, lsl #16
    3330:	e1822401 	orr	r2, r2, r1, lsl #8
    3334:	e1833c00 	orr	r3, r3, r0, lsl #24
    3338:	e1822003 	orr	r2, r2, r3
    333c:	e5842014 	str	r2, [r4, #20]
    3340:	ea000000 	b	3348 <partition_open+0x100>
    3344:	e3a04000 	mov	r4, #0	; 0x0
    3348:	e1a00004 	mov	r0, r4
    334c:	e28dd010 	add	sp, sp, #16	; 0x10
    3350:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    3354:	e12fff1e 	bx	lr

00003358 <main_msc>:
    msc_main
    ====
**************************************************************************/
int main_msc(void)
{
    3358:	e52de004 	str	lr, [sp, #-4]!
    // initialise the SD card
    BlockDevInit();
    335c:	eb0002e9 	bl	3f08 <BlockDevInit>

    rprintf("Initialising USB stack\n");
    3360:	e59f006c 	ldr	r0, [pc, #108]	; 33d4 <.text+0x33d4>
    3364:	ebfff41b 	bl	3d8 <rprintf>

    // initialise stack
    USBInit();
    3368:	eb0003d9 	bl	42d4 <USBInit>

    // enable bulk-in interrupts on NAKs
    // these are required to get the BOT protocol going again after a STALL
    USBHwNakIntEnable(INACK_BI);
    336c:	e3a00020 	mov	r0, #32	; 0x20
    3370:	eb00046b 	bl	4524 <USBHwNakIntEnable>

    // register descriptors
    USBRegisterDescriptors(abDescriptors);
    3374:	e59f005c 	ldr	r0, [pc, #92]	; 33d8 <.text+0x33d8>
    3378:	eb0005cb 	bl	4aac <USBRegisterDescriptors>

    // register class request handler
    USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
    337c:	e59f2058 	ldr	r2, [pc, #88]	; 33dc <.text+0x33dc>
    3380:	e3a00001 	mov	r0, #1	; 0x1
    3384:	e59f1054 	ldr	r1, [pc, #84]	; 33e0 <.text+0x33e0>
    3388:	eb000553 	bl	48dc <USBRegisterRequestHandler>

    // register endpoint handlers
    USBHwRegisterEPIntHandler(MSC_BULK_IN_EP, MSCBotBulkIn);
    338c:	e3a00085 	mov	r0, #133	; 0x85
    3390:	e59f104c 	ldr	r1, [pc, #76]	; 33e4 <.text+0x33e4>
    3394:	eb000435 	bl	4470 <USBHwRegisterEPIntHandler>
    USBHwRegisterEPIntHandler(MSC_BULK_OUT_EP, MSCBotBulkOut);
    3398:	e59f1048 	ldr	r1, [pc, #72]	; 33e8 <.text+0x33e8>
    339c:	e3a00002 	mov	r0, #2	; 0x2
    33a0:	eb000432 	bl	4470 <USBHwRegisterEPIntHandler>

    rprintf("Starting USB communication\n");
    33a4:	e59f0040 	ldr	r0, [pc, #64]	; 33ec <.text+0x33ec>
    33a8:	ebfff40a 	bl	3d8 <rprintf>
	
    // connect to bus
    USBHwConnect(TRUE);
    33ac:	e3a00001 	mov	r0, #1	; 0x1
    33b0:	eb000457 	bl	4514 <USBHwConnect>
    33b4:	ea000000 	b	33bc <main_msc+0x64>

    // call USB interrupt handler continuously
    while (IOPIN0 & (1<<23))
	{
		USBHwISR();
    33b8:	eb0004bc 	bl	46b0 <USBHwISR>
    33bc:	e59f302c 	ldr	r3, [pc, #44]	; 33f0 <.text+0x33f0>
    33c0:	e5933000 	ldr	r3, [r3]
    33c4:	e2130502 	ands	r0, r3, #8388608	; 0x800000
    33c8:	1afffffa 	bne	33b8 <main_msc+0x60>
    }

    return 0;
}
    33cc:	e49de004 	ldr	lr, [sp], #4
    33d0:	e12fff1e 	bx	lr
    33d4:	00005f78 	andeq	r5, r0, r8, ror pc
    33d8:	40000240 	andmi	r0, r0, r0, asr #4
    33dc:	40000ce0 	andmi	r0, r0, r0, ror #25
    33e0:	000033f4 	streqd	r3, [r0], -r4
    33e4:	000035b4 	streqh	r3, [r0], -r4
    33e8:	00003618 	andeq	r3, r0, r8, lsl r6
    33ec:	00005f90 	muleq	r0, r0, pc
    33f0:	e0028000 	and	r8, r2, r0

000033f4 <HandleClassRequest>:
    33f4:	e1d030b4 	ldrh	r3, [r0, #4]
    33f8:	e3530000 	cmp	r3, #0	; 0x0
    33fc:	e92d4010 	stmdb	sp!, {r4, lr}
    3400:	e1a03002 	mov	r3, r2
    3404:	e1a04001 	mov	r4, r1
    3408:	1a000012 	bne	3458 <HandleClassRequest+0x64>
    340c:	e1d0e0b2 	ldrh	lr, [r0, #2]
    3410:	e35e0000 	cmp	lr, #0	; 0x0
    3414:	1a00000f 	bne	3458 <HandleClassRequest+0x64>
    3418:	e5d0c001 	ldrb	ip, [r0, #1]
    341c:	e35c00fe 	cmp	ip, #254	; 0xfe
    3420:	05933000 	ldreq	r3, [r3]
    3424:	e3a02001 	mov	r2, #1	; 0x1
    3428:	05c3e000 	streqb	lr, [r3]
    342c:	e1a01002 	mov	r1, r2
    3430:	05842000 	streq	r2, [r4]
    3434:	0a000008 	beq	345c <HandleClassRequest+0x68>
    3438:	e35c00ff 	cmp	ip, #255	; 0xff
    343c:	1a000005 	bne	3458 <HandleClassRequest+0x64>
    3440:	e1d030b6 	ldrh	r3, [r0, #6]
    3444:	e3530000 	cmp	r3, #0	; 0x0
    3448:	1a000002 	bne	3458 <HandleClassRequest+0x64>
    344c:	eb000103 	bl	3860 <MSCBotReset>
    3450:	e3a01001 	mov	r1, #1	; 0x1
    3454:	ea000000 	b	345c <HandleClassRequest+0x68>
    3458:	e3a01000 	mov	r1, #0	; 0x0
    345c:	e1a00001 	mov	r0, r1
    3460:	e8bd4010 	ldmia	sp!, {r4, lr}
    3464:	e12fff1e 	bx	lr

00003468 <SendCSW>:
static void SendCSW(U8 bStatus)
{
    int iResidue;

    iResidue = CBW.dwCBWDataTransferLength - dwTransferSize;
    3468:	e59f203c 	ldr	r2, [pc, #60]	; 34ac <.text+0x34ac>
    346c:	e59f303c 	ldr	r3, [pc, #60]	; 34b0 <.text+0x34b0>
    3470:	e5921008 	ldr	r1, [r2, #8]
    3474:	e5933000 	ldr	r3, [r3]

    // construct CSW
    CSW.dwCSWSignature      = CSW_SIGNATURE;
    CSW.dwCSWTag            = CBW.dwCBWTag;
    3478:	e592c004 	ldr	ip, [r2, #4]
    347c:	e59f2030 	ldr	r2, [pc, #48]	; 34b4 <.text+0x34b4>
    3480:	e0631001 	rsb	r1, r3, r1
    CSW.dwCSWDataResidue    = MAX(iResidue, 0);
    CSW.bmCSWStatus         = bStatus;

    DBG("CSW: status=%x, residue=%d\n", bStatus, CSW.dwCSWDataResidue);

    // next state
    eState = eCSW;
    3484:	e59f302c 	ldr	r3, [pc, #44]	; 34b8 <.text+0x34b8>
    3488:	e5c2000c 	strb	r0, [r2, #12]
    348c:	e3a00003 	mov	r0, #3	; 0x3
    3490:	e5830000 	str	r0, [r3]
    3494:	e59f3020 	ldr	r3, [pc, #32]	; 34bc <.text+0x34bc>
    3498:	e3510000 	cmp	r1, #0	; 0x0
    349c:	b3a01000 	movlt	r1, #0	; 0x0
    34a0:	e8821008 	stmia	r2, {r3, ip}
    34a4:	e5821008 	str	r1, [r2, #8]
}
    34a8:	e12fff1e 	bx	lr
    34ac:	40000cec 	andmi	r0, r0, ip, ror #25
    34b0:	40000ce4 	andmi	r0, r0, r4, ror #25
    34b4:	40000d0c 	andmi	r0, r0, ip, lsl #26
    34b8:	40000d1c 	andmi	r0, r0, ip, lsl sp
    34bc:	53425355 	movtpl	r5, #9045	; 0x2355

000034c0 <BOTStall>:


/*************************************************************************
    CheckCBW
    ========
        Checks if CBW is valid and meaningful

    IN      pCBW    Command block wrapper
            iLen    Length of CBW

    Returns TRUE if valid and meaningful
**************************************************************************/
static BOOL CheckCBW(TCBW *pCBW, int iLen)
{
    // CBW valid?
    if (iLen != 31)
    {
        DBG("Invalid length (%d)\n", iLen);
        return FALSE;
    }
    if (pCBW->dwCBWSignature != CBW_SIGNATURE)
    {
        DBG("Invalid signature %x\n", pCBW->dwCBWSignature);
        return FALSE;
    }

    // CBW meaningful?
    if (pCBW->bCBWLun != 0)
    {
        DBG("Invalid LUN %d\n", pCBW->bCBWLun);
        return FALSE;
    }
    if ((pCBW->bCBWCBLength < 1) || (pCBW->bCBWCBLength > 16))
    {
        DBG("Invalid CB len %d\n", pCBW->bCBWCBLength);
        return FALSE;
    }
    return TRUE;
}


/*************************************************************************
    BOTStall
    ========
        Local function to stall ongoing transfer

    Which endpoint to stall is determined by looking at the transfer
    direction intended by the host.

**************************************************************************/
static void BOTStall(void)
{
    34c0:	e52de004 	str	lr, [sp, #-4]!
    if ((CBW.bmCBWFlags & 0x80) || (CBW.dwCBWDataTransferLength == 0))
    34c4:	e59f202c 	ldr	r2, [pc, #44]	; 34f8 <.text+0x34f8>
    34c8:	e1d230dc 	ldrsb	r3, [r2, #12]
    34cc:	e3530000 	cmp	r3, #0	; 0x0
    {
        // stall data-in or CSW
        USBHwEPStall(MSC_BULK_IN_EP, TRUE);
    34d0:	e3a00085 	mov	r0, #133	; 0x85
    34d4:	e3a01001 	mov	r1, #1	; 0x1
    34d8:	ba000003 	blt	34ec <BOTStall+0x2c>
    34dc:	e5923008 	ldr	r3, [r2, #8]
    34e0:	e3530000 	cmp	r3, #0	; 0x0
    }
    else
    {
        // stall data-out
        USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
    34e4:	13a00002 	movne	r0, #2	; 0x2
    34e8:	13a01001 	movne	r1, #1	; 0x1
    34ec:	eb000418 	bl	4554 <USBHwEPStall>
    }
}
    34f0:	e49de004 	ldr	lr, [sp], #4
    34f4:	e12fff1e 	bx	lr
    34f8:	40000cec 	andmi	r0, r0, ip, ror #25

000034fc <HandleDataIn>:


/*************************************************************************
    HandleDataIn
    ============
        Handles data from device-to-host

**************************************************************************/
static void HandleDataIn(void)
{
    34fc:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    int iChunk;

    // process data for host in SCSI layer
    pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
    3500:	e59f609c 	ldr	r6, [pc, #156]	; 35a4 <.text+0x35a4>
    3504:	e59f409c 	ldr	r4, [pc, #156]	; 35a8 <.text+0x35a8>
    3508:	e59f509c 	ldr	r5, [pc, #156]	; 35ac <.text+0x35ac>
    350c:	e5d6100e 	ldrb	r1, [r6, #14]
    3510:	e5942000 	ldr	r2, [r4]
    3514:	e5953000 	ldr	r3, [r5]
    3518:	e286000f 	add	r0, r6, #15	; 0xf
    351c:	eb000129 	bl	39c8 <SCSIHandleData>
    if (pbData == NULL)
    3520:	e3500000 	cmp	r0, #0	; 0x0
    {
        BOTStall();
        SendCSW(STATUS_FAILED);
        return;
    }

    // send data to host?
    if (dwOffset < dwTransferSize)
    3524:	e59f7084 	ldr	r7, [pc, #132]	; 35b0 <.text+0x35b0>
    3528:	e5840000 	str	r0, [r4]
    352c:	1a000002 	bne	353c <HandleDataIn+0x40>
    3530:	ebffffe2 	bl	34c0 <BOTStall>
    3534:	e3a00001 	mov	r0, #1	; 0x1
    3538:	ea000015 	b	3594 <HandleDataIn+0x98>
    353c:	e5952000 	ldr	r2, [r5]
    3540:	e5973000 	ldr	r3, [r7]
    3544:	e1520003 	cmp	r2, r3
    {
        iChunk = MIN(64, dwTransferSize - dwOffset);
        USBHwEPWrite(MSC_BULK_IN_EP, pbData, iChunk);
    3548:	e1a01000 	mov	r1, r0
    354c:	e0624003 	rsb	r4, r2, r3
    3550:	e3a00085 	mov	r0, #133	; 0x85
    3554:	2a000006 	bcs	3574 <HandleDataIn+0x78>
    3558:	e3540040 	cmp	r4, #64	; 0x40
    355c:	23a04040 	movcs	r4, #64	; 0x40
    3560:	e1a02004 	mov	r2, r4
    3564:	eb000402 	bl	4574 <USBHwEPWrite>
        dwOffset += iChunk;
    3568:	e5953000 	ldr	r3, [r5]
    356c:	e0833004 	add	r3, r3, r4
    3570:	e5853000 	str	r3, [r5]
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    3574:	e5952000 	ldr	r2, [r5]
    3578:	e5973000 	ldr	r3, [r7]
    357c:	e1520003 	cmp	r2, r3
    3580:	1a000005 	bne	359c <HandleDataIn+0xa0>
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
    3584:	e5963008 	ldr	r3, [r6, #8]
    3588:	e1520003 	cmp	r2, r3
        {
            // stall pipe
            DBG("stalling DIN");
            BOTStall();
    358c:	1bffffcb 	blne	34c0 <BOTStall>
        }
        // done
        SendCSW(STATUS_PASSED);
    3590:	e3a00000 	mov	r0, #0	; 0x0
    }
}
    3594:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    3598:	eaffffb2 	b	3468 <SendCSW>
    359c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    35a0:	e12fff1e 	bx	lr
    35a4:	40000cec 	andmi	r0, r0, ip, ror #25
    35a8:	40000d20 	andmi	r0, r0, r0, lsr #26
    35ac:	40000ce8 	andmi	r0, r0, r8, ror #25
    35b0:	40000ce4 	andmi	r0, r0, r4, ror #25

000035b4 <MSCBotBulkIn>:


/*************************************************************************
    HandleDataOut
    =============
        Handles data from host-to-device

**************************************************************************/
static void HandleDataOut(void)
{
    int iChunk;

    if (dwOffset < dwTransferSize)
    {
        // get data from host
        iChunk = USBHwEPRead(MSC_BULK_OUT_EP, pbData, dwTransferSize - dwOffset);
        // process data in SCSI layer
        pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
        if (pbData == NULL)
        {
            BOTStall();
            SendCSW(STATUS_FAILED);
            return;
        }
        dwOffset += iChunk;
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
        {
            // stall pipe
            DBG("stalling DOUT");
            BOTStall();
        }
        SendCSW(STATUS_PASSED);
    }
}


/*************************************************************************
    MSCBotBulkOut
    ===============
        Handles the BOT bulk OUT endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkOut(U8 bEP, U8 bEPStatus)
{
    int     iLen, iChunk;
    BOOL    fHostIn, fDevIn;

    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
    {
        return;
    }

    switch (eState)
    {

        case eCBW:
            iLen = USBHwEPRead(bEP, (U8 *)&CBW, sizeof(CBW));

            // check if we got a good CBW
            if (!CheckCBW(&CBW, iLen))
            {
                // see 6.6.1
                USBHwEPStall(MSC_BULK_IN_EP, TRUE);
                USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
                eState = eStalled;
                break;
            }

            DBG("CBW: len=%d, flags=%x, cmd=%x, cmdlen=%d\n",
                    CBW.dwCBWDataTransferLength, CBW.bmCBWFlags, CBW.CBWCB[0], CBW.bCBWCBLength);

            dwOffset = 0;
            dwTransferSize = 0;
            fHostIn = ((CBW.bmCBWFlags & 0x80) != 0);

            // verify request
            pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
            if (pbData == NULL)
            {
                // unknown command
                BOTStall();
                SendCSW(STATUS_FAILED);
                break;
            }

            // rule: if device and host disagree on direction, send CSW with status 2
            if ((iLen > 0) &&
                ((fHostIn && !fDevIn) ||
                (!fHostIn && fDevIn)))
            {
                DBG("Host and device disagree on direction\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            // rule: if D > H, send CSW with status 2
            if (iLen > CBW.dwCBWDataTransferLength)
            {
                DBG("Negative residue\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            dwTransferSize = iLen;
            if ((dwTransferSize == 0) || fDevIn)
            {
                // data from device-to-host
                eState = eDataIn;
                HandleDataIn();
            }
            else
            {
                // data from host-to-device
                eState = eDataOut;
            }
            break;

        case eDataOut:
            HandleDataOut();
            break;

        case eDataIn:
        case eCSW:
            iChunk = USBHwEPRead(bEP, NULL, 0);
            DBG("Phase error in state %d, %d bytes\n", eState, iChunk);
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}


/*************************************************************************
    MSCBotBulkIn
    ============
        Handles the BOT bulk IN endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkIn(U8 bEP, U8 bEPStatus)
{
    35b4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
    35b8:	e2114002 	ands	r4, r1, #2	; 0x2
    {
        return;
    }

    switch (eState)
    35bc:	e59f504c 	ldr	r5, [pc, #76]	; 3610 <.text+0x3610>
    35c0:	1a000010 	bne	3608 <MSCBotBulkIn+0x54>
    35c4:	e5953000 	ldr	r3, [r5]
    35c8:	e3530003 	cmp	r3, #3	; 0x3
    {

        case eCBW:
        case eDataOut:
        // ignore possibly old ACKs
            break;

        case eDataIn:
            HandleDataIn();
            break;

        case eCSW:
        // wait for an IN token, then send the CSW
            USBHwEPWrite(MSC_BULK_IN_EP, (U8 *)&CSW, 13);
    35cc:	e3a00085 	mov	r0, #133	; 0x85
    35d0:	e59f103c 	ldr	r1, [pc, #60]	; 3614 <.text+0x3614>
    35d4:	e3a0200d 	mov	r2, #13	; 0xd
    35d8:	0a000006 	beq	35f8 <MSCBotBulkIn+0x44>
    35dc:	e3530004 	cmp	r3, #4	; 0x4
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_IN_EP, TRUE);
    35e0:	e3a01001 	mov	r1, #1	; 0x1
    35e4:	0a000006 	beq	3604 <MSCBotBulkIn+0x50>
    35e8:	e3530002 	cmp	r3, #2	; 0x2
    35ec:	1a000005 	bne	3608 <MSCBotBulkIn+0x54>
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}
    35f0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    35f4:	eaffffc0 	b	34fc <HandleDataIn>
    35f8:	eb0003dd 	bl	4574 <USBHwEPWrite>
    35fc:	e5854000 	str	r4, [r5]
    3600:	ea000000 	b	3608 <MSCBotBulkIn+0x54>
    3604:	eb0003d2 	bl	4554 <USBHwEPStall>
    3608:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    360c:	e12fff1e 	bx	lr
    3610:	40000d1c 	andmi	r0, r0, ip, lsl sp
    3614:	40000d0c 	andmi	r0, r0, ip, lsl #26

00003618 <MSCBotBulkOut>:
    3618:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    361c:	e3110002 	tst	r1, #2	; 0x2
    3620:	e24dd008 	sub	sp, sp, #8	; 0x8
    3624:	e20000ff 	and	r0, r0, #255	; 0xff
    3628:	1a000083 	bne	383c <.text+0x383c>
    362c:	e59f3214 	ldr	r3, [pc, #532]	; 3848 <.text+0x3848>
    3630:	e5933000 	ldr	r3, [r3]
    3634:	e3530004 	cmp	r3, #4	; 0x4
    3638:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    363c:	ea00007e 	b	383c <.text+0x383c>
    3640:	00003654 	andeq	r3, r0, r4, asr r6
    3644:	0000373c 	andeq	r3, r0, ip, lsr r7
    3648:	000037d8 	ldreqd	r3, [r0], -r8
    364c:	000037d8 	ldreqd	r3, [r0], -r8
    3650:	000037f4 	streqd	r3, [r0], -r4
    3654:	e59f41f0 	ldr	r4, [pc, #496]	; 384c <.text+0x384c>
    3658:	e3a02020 	mov	r2, #32	; 0x20
    365c:	e1a01004 	mov	r1, r4
    3660:	eb0003e5 	bl	45fc <USBHwEPRead>
    3664:	e350001f 	cmp	r0, #31	; 0x1f
    3668:	e58d0000 	str	r0, [sp]
    366c:	1a00000a 	bne	369c <.text+0x369c>
    3670:	e5942000 	ldr	r2, [r4]
    3674:	e59f31d4 	ldr	r3, [pc, #468]	; 3850 <.text+0x3850>
    3678:	e1520003 	cmp	r2, r3
    367c:	1a000006 	bne	369c <.text+0x369c>
    3680:	e5d4e00d 	ldrb	lr, [r4, #13]
    3684:	e35e0000 	cmp	lr, #0	; 0x0
    3688:	1a000003 	bne	369c <.text+0x369c>
    368c:	e5d4100e 	ldrb	r1, [r4, #14]
    3690:	e2413001 	sub	r3, r1, #1	; 0x1
    3694:	e353000f 	cmp	r3, #15	; 0xf
    3698:	9a000059 	bls	3804 <.text+0x3804>
    369c:	e3a00085 	mov	r0, #133	; 0x85
    36a0:	e3a01001 	mov	r1, #1	; 0x1
    36a4:	eb0003aa 	bl	4554 <USBHwEPStall>
    36a8:	e3a00002 	mov	r0, #2	; 0x2
    36ac:	e3a01001 	mov	r1, #1	; 0x1
    36b0:	eb0003a7 	bl	4554 <USBHwEPStall>
    36b4:	e3a02004 	mov	r2, #4	; 0x4
    36b8:	ea00004a 	b	37e8 <.text+0x37e8>
    36bc:	e59d2000 	ldr	r2, [sp]
    36c0:	e3520000 	cmp	r2, #0	; 0x0
    36c4:	da00000b 	ble	36f8 <.text+0x36f8>
    36c8:	e3140080 	tst	r4, #128	; 0x80
    36cc:	e59d3004 	ldr	r3, [sp, #4]
    36d0:	0a000002 	beq	36e0 <.text+0x36e0>
    36d4:	e3530000 	cmp	r3, #0	; 0x0
    36d8:	0a000002 	beq	36e8 <.text+0x36e8>
    36dc:	ea000005 	b	36f8 <.text+0x36f8>
    36e0:	e3530000 	cmp	r3, #0	; 0x0
    36e4:	0a000003 	beq	36f8 <.text+0x36f8>
    36e8:	ebffff74 	bl	34c0 <BOTStall>
    36ec:	e3a00002 	mov	r0, #2	; 0x2
    36f0:	ebffff5c 	bl	3468 <SendCSW>
    36f4:	ea000050 	b	383c <.text+0x383c>
    36f8:	e59f314c 	ldr	r3, [pc, #332]	; 384c <.text+0x384c>
    36fc:	e5933008 	ldr	r3, [r3, #8]
    3700:	e1520003 	cmp	r2, r3
    3704:	8afffff7 	bhi	36e8 <.text+0x36e8>
    3708:	e59f3144 	ldr	r3, [pc, #324]	; 3854 <.text+0x3854>
    370c:	e3520000 	cmp	r2, #0	; 0x0
    3710:	e5832000 	str	r2, [r3]
    3714:	0a000003 	beq	3728 <.text+0x3728>
    3718:	e59d3004 	ldr	r3, [sp, #4]
    371c:	e3530000 	cmp	r3, #0	; 0x0
    3720:	03a02001 	moveq	r2, #1	; 0x1
    3724:	0a00002f 	beq	37e8 <.text+0x37e8>
    3728:	e59f3118 	ldr	r3, [pc, #280]	; 3848 <.text+0x3848>
    372c:	e3a02002 	mov	r2, #2	; 0x2
    3730:	e5832000 	str	r2, [r3]
    3734:	ebffff70 	bl	34fc <HandleDataIn>
    3738:	ea00003f 	b	383c <.text+0x383c>
    373c:	e59f5114 	ldr	r5, [pc, #276]	; 3858 <.text+0x3858>
    3740:	e59f310c 	ldr	r3, [pc, #268]	; 3854 <.text+0x3854>
    3744:	e5951000 	ldr	r1, [r5]
    3748:	e5932000 	ldr	r2, [r3]
    374c:	e1510002 	cmp	r1, r2
    3750:	2a000014 	bcs	37a8 <.text+0x37a8>
    3754:	e59f4100 	ldr	r4, [pc, #256]	; 385c <.text+0x385c>
    3758:	e0612002 	rsb	r2, r1, r2
    375c:	e3a00002 	mov	r0, #2	; 0x2
    3760:	e5941000 	ldr	r1, [r4]
    3764:	eb0003a4 	bl	45fc <USBHwEPRead>
    3768:	e1a06000 	mov	r6, r0
    376c:	e59f00d8 	ldr	r0, [pc, #216]	; 384c <.text+0x384c>
    3770:	e5953000 	ldr	r3, [r5]
    3774:	e5d0100e 	ldrb	r1, [r0, #14]
    3778:	e5942000 	ldr	r2, [r4]
    377c:	e280000f 	add	r0, r0, #15	; 0xf
    3780:	eb000090 	bl	39c8 <SCSIHandleData>
    3784:	e3500000 	cmp	r0, #0	; 0x0
    3788:	15953000 	ldrne	r3, [r5]
    378c:	10833006 	addne	r3, r3, r6
    3790:	e5840000 	str	r0, [r4]
    3794:	15853000 	strne	r3, [r5]
    3798:	1a000002 	bne	37a8 <.text+0x37a8>
    379c:	ebffff47 	bl	34c0 <BOTStall>
    37a0:	e3a00001 	mov	r0, #1	; 0x1
    37a4:	eaffffd1 	b	36f0 <.text+0x36f0>
    37a8:	e59f30a8 	ldr	r3, [pc, #168]	; 3858 <.text+0x3858>
    37ac:	e5932000 	ldr	r2, [r3]
    37b0:	e59f309c 	ldr	r3, [pc, #156]	; 3854 <.text+0x3854>
    37b4:	e5933000 	ldr	r3, [r3]
    37b8:	e1520003 	cmp	r2, r3
    37bc:	1a00001e 	bne	383c <.text+0x383c>
    37c0:	e59f3084 	ldr	r3, [pc, #132]	; 384c <.text+0x384c>
    37c4:	e5933008 	ldr	r3, [r3, #8]
    37c8:	e1520003 	cmp	r2, r3
    37cc:	1bffff3b 	blne	34c0 <BOTStall>
    37d0:	e3a00000 	mov	r0, #0	; 0x0
    37d4:	eaffffc5 	b	36f0 <.text+0x36f0>
    37d8:	e3a01000 	mov	r1, #0	; 0x0
    37dc:	e1a02001 	mov	r2, r1
    37e0:	eb000385 	bl	45fc <USBHwEPRead>
    37e4:	e3a02000 	mov	r2, #0	; 0x0
    37e8:	e59f3058 	ldr	r3, [pc, #88]	; 3848 <.text+0x3848>
    37ec:	e5832000 	str	r2, [r3]
    37f0:	ea000011 	b	383c <.text+0x383c>
    37f4:	e3a00002 	mov	r0, #2	; 0x2
    37f8:	e3a01001 	mov	r1, #1	; 0x1
    37fc:	eb000354 	bl	4554 <USBHwEPStall>
    3800:	ea00000d 	b	383c <.text+0x383c>
    3804:	e59fc048 	ldr	ip, [pc, #72]	; 3854 <.text+0x3854>
    3808:	e58ce000 	str	lr, [ip]
    380c:	e59fc044 	ldr	ip, [pc, #68]	; 3858 <.text+0x3858>
    3810:	e284000f 	add	r0, r4, #15	; 0xf
    3814:	e28d3004 	add	r3, sp, #4	; 0x4
    3818:	e1a0200d 	mov	r2, sp
    381c:	e58ce000 	str	lr, [ip]
    3820:	e5d4400c 	ldrb	r4, [r4, #12]
    3824:	eb00001a 	bl	3894 <SCSIHandleCmd>
    3828:	e59f302c 	ldr	r3, [pc, #44]	; 385c <.text+0x385c>
    382c:	e3500000 	cmp	r0, #0	; 0x0
    3830:	e5830000 	str	r0, [r3]
    3834:	1affffa0 	bne	36bc <.text+0x36bc>
    3838:	eaffffd7 	b	379c <.text+0x379c>
    383c:	e28dd008 	add	sp, sp, #8	; 0x8
    3840:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    3844:	e12fff1e 	bx	lr
    3848:	40000d1c 	andmi	r0, r0, ip, lsl sp
    384c:	40000cec 	andmi	r0, r0, ip, ror #25
    3850:	43425355 	movtmi	r5, #9045	; 0x2355
    3854:	40000ce4 	andmi	r0, r0, r4, ror #25
    3858:	40000ce8 	andmi	r0, r0, r8, ror #25
    385c:	40000d20 	andmi	r0, r0, r0, lsr #26

00003860 <MSCBotReset>:
    3860:	e59f3014 	ldr	r3, [pc, #20]	; 387c <.text+0x387c>
    3864:	e3a02000 	mov	r2, #0	; 0x0
    3868:	e52de004 	str	lr, [sp, #-4]!
    386c:	e5832000 	str	r2, [r3]
    3870:	eb000002 	bl	3880 <SCSIReset>
    3874:	e49de004 	ldr	lr, [sp], #4
    3878:	e12fff1e 	bx	lr
    387c:	40000d1c 	andmi	r0, r0, ip, lsl sp

00003880 <SCSIReset>:

**************************************************************************/
void SCSIReset(void)
{
    dwSense = 0;
    3880:	e59f3008 	ldr	r3, [pc, #8]	; 3890 <.text+0x3890>
    3884:	e3a02000 	mov	r2, #0	; 0x0
    3888:	e5832000 	str	r2, [r3]
}
    388c:	e12fff1e 	bx	lr
    3890:	40000d24 	andmi	r0, r0, r4, lsr #26

00003894 <SCSIHandleCmd>:


/*************************************************************************
    SCSIHandleCmd
    =============
        Verifies a SCSI CDB and indicates the direction and amount of data
        that the device wants to transfer.

    If this call fails, a sense code is set in dwSense.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    OUT     *piRspLen   Length of intended response data:
            *pfDevIn    TRUE if data is transferred from device-to-host

    Returns a pointer to the data exchange buffer if successful,
    return NULL otherwise.
**************************************************************************/
U8 * SCSIHandleCmd(U8 *pbCDB, int iCDBLen, int *piRspLen, BOOL *pfDevIn)
{
    3894:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3898:	e1a04000 	mov	r4, r0
    389c:	e24dd008 	sub	sp, sp, #8	; 0x8
    int     i;
    TCDB6   *pCDB;
    U32     dwLen, dwLBA;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
    38a0:	e3a08008 	mov	r8, #8	; 0x8
    38a4:	e1a06001 	mov	r6, r1
    38a8:	e1a05002 	mov	r5, r2
    38ac:	e1a0000d 	mov	r0, sp
    38b0:	e1a02008 	mov	r2, r8
    38b4:	e1a01004 	mov	r1, r4
    38b8:	e1a07003 	mov	r7, r3
    38bc:	eb0006f3 	bl	5490 <memcpy>
	
    // default direction is from device to host
    *pfDevIn = TRUE;

    switch (pCDB->bOperationCode)
    38c0:	e5dd2000 	ldrb	r2, [sp]
    38c4:	e3a03001 	mov	r3, #1	; 0x1
    38c8:	e3520012 	cmp	r2, #18	; 0x12
    38cc:	e5873000 	str	r3, [r7]
    38d0:	0a000013 	beq	3924 <SCSIHandleCmd+0x90>
    38d4:	8a000006 	bhi	38f4 <SCSIHandleCmd+0x60>
    38d8:	e3520000 	cmp	r2, #0	; 0x0
    {

        // test unit ready (6)
        case SCSI_CMD_TEST_UNIT_READY:
            DBG("TEST UNIT READY\n");
            *piRspLen = 0;
    38dc:	059f00dc 	ldreq	r0, [pc, #220]	; 39c0 <.text+0x39c0>
    38e0:	05852000 	streq	r2, [r5]
    38e4:	0a000032 	beq	39b4 <SCSIHandleCmd+0x120>
    38e8:	e3520003 	cmp	r2, #3	; 0x3
    38ec:	1a000028 	bne	3994 <SCSIHandleCmd+0x100>
    38f0:	ea000006 	b	3910 <SCSIHandleCmd+0x7c>
    38f4:	e3520028 	cmp	r2, #40	; 0x28
    38f8:	0a000012 	beq	3948 <SCSIHandleCmd+0xb4>
    38fc:	e352002a 	cmp	r2, #42	; 0x2a
    3900:	0a000018 	beq	3968 <SCSIHandleCmd+0xd4>
    3904:	e3520025 	cmp	r2, #37	; 0x25
    3908:	1a000021 	bne	3994 <SCSIHandleCmd+0x100>
    390c:	ea00000a 	b	393c <SCSIHandleCmd+0xa8>
            break;

        // request sense (6)
        case SCSI_CMD_REQUEST_SENSE:
            DBG("REQUEST SENSE (%06X)\n", dwSense);
            // check params
            *piRspLen = MIN(18, pCDB->bLength);
    3910:	e5dd3004 	ldrb	r3, [sp, #4]
    3914:	e59f00a4 	ldr	r0, [pc, #164]	; 39c0 <.text+0x39c0>
    3918:	e3530012 	cmp	r3, #18	; 0x12
    391c:	23a03012 	movcs	r3, #18	; 0x12
    3920:	ea000003 	b	3934 <SCSIHandleCmd+0xa0>
            break;

        // inquiry (6)
        case SCSI_CMD_INQUIRY:
            DBG("INQUIRY\n");
            // see SPC20r20, 4.3.4.6
            *piRspLen = MIN(36, pCDB->bLength);
    3924:	e5dd3004 	ldrb	r3, [sp, #4]
    3928:	e59f0090 	ldr	r0, [pc, #144]	; 39c0 <.text+0x39c0>
    392c:	e3530024 	cmp	r3, #36	; 0x24
    3930:	23a03024 	movcs	r3, #36	; 0x24
    3934:	e5853000 	str	r3, [r5]
    3938:	ea00001d 	b	39b4 <SCSIHandleCmd+0x120>
            break;

        // read capacity (10)
        case SCSI_CMD_READ_CAPACITY:
            DBG("READ CAPACITY\n");
            *piRspLen = 8;
    393c:	e59f007c 	ldr	r0, [pc, #124]	; 39c0 <.text+0x39c0>
    3940:	e5858000 	str	r8, [r5]
    3944:	ea00001a 	b	39b4 <SCSIHandleCmd+0x120>
            break;

        // read (10)
        case SCSI_CMD_READ_10:
            if (iCDBLen != 10)
    3948:	e356000a 	cmp	r6, #10	; 0xa
    394c:	1a000017 	bne	39b0 <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("READ10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
    3950:	e5d43008 	ldrb	r3, [r4, #8]
    3954:	e5d42007 	ldrb	r2, [r4, #7]
    3958:	e59f0060 	ldr	r0, [pc, #96]	; 39c0 <.text+0x39c0>
    395c:	e1833402 	orr	r3, r3, r2, lsl #8
    3960:	e1a03483 	mov	r3, r3, lsl #9
    3964:	eafffff2 	b	3934 <SCSIHandleCmd+0xa0>
            break;

        // write (10)
        case SCSI_CMD_WRITE_10:
            if (iCDBLen != 10)
    3968:	e356000a 	cmp	r6, #10	; 0xa
    396c:	1a00000f 	bne	39b0 <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("WRITE10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
    3970:	e5d43008 	ldrb	r3, [r4, #8]
    3974:	e5d42007 	ldrb	r2, [r4, #7]
    3978:	e1833402 	orr	r3, r3, r2, lsl #8
    397c:	e1a03483 	mov	r3, r3, lsl #9
            *pfDevIn = FALSE;
    3980:	e59f0038 	ldr	r0, [pc, #56]	; 39c0 <.text+0x39c0>
    3984:	e5853000 	str	r3, [r5]
    3988:	e3a03000 	mov	r3, #0	; 0x0
    398c:	e5873000 	str	r3, [r7]
    3990:	ea000007 	b	39b4 <SCSIHandleCmd+0x120>
            break;

        default:
            DBG("Unhandled SCSI: ");
            for (i = 0; i < iCDBLen; i++)
            {
                DBG(" %02X", pbCDB[i]);
            }
            DBG("\n");
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
            *piRspLen = 0;
    3994:	e3a01000 	mov	r1, #0	; 0x0
    3998:	e59f3024 	ldr	r3, [pc, #36]	; 39c4 <.text+0x39c4>
    399c:	e3a02a52 	mov	r2, #335872	; 0x52000
    39a0:	e1a00001 	mov	r0, r1
    39a4:	e5832000 	str	r2, [r3]
    39a8:	e5851000 	str	r1, [r5]
    39ac:	ea000000 	b	39b4 <SCSIHandleCmd+0x120>
            return NULL;
    39b0:	e3a00000 	mov	r0, #0	; 0x0
        }


    return abBlockBuf;
}
    39b4:	e28dd008 	add	sp, sp, #8	; 0x8
    39b8:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    39bc:	e12fff1e 	bx	lr
    39c0:	40000d28 	andmi	r0, r0, r8, lsr #26
    39c4:	40000d24 	andmi	r0, r0, r4, lsr #26

000039c8 <SCSIHandleData>:


/*************************************************************************
    SCSIHandleData
    ==============
        Handles a block of SCSI data.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    IN/OUT  pbData      Data buffer
    IN      dwOffset    Offset in data

    Returns a pointer to the next data to be exchanged if successful,
    returns NULL otherwise.
**************************************************************************/
U8 * SCSIHandleData(U8 *pbCDB, int iCDBLen, U8 *pbData, U32 dwOffset)
{
    39c8:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    39cc:	e1a04000 	mov	r4, r0
    39d0:	e24dd00c 	sub	sp, sp, #12	; 0xc
    39d4:	e1a05002 	mov	r5, r2
    TCDB6   *pCDB;
    U32     dwLBA;
    U32     dwBufPos, dwBlockNr;
    U32     dwNumBlocks, dwMaxBlock;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
    39d8:	e1a0000d 	mov	r0, sp
    39dc:	e1a01004 	mov	r1, r4
    39e0:	e3a02008 	mov	r2, #8	; 0x8
    39e4:	e1a06003 	mov	r6, r3
    39e8:	eb0006a8 	bl	5490 <memcpy>
	
    switch (pCDB->bOperationCode)
    39ec:	e5dd3000 	ldrb	r3, [sp]
    39f0:	e3530012 	cmp	r3, #18	; 0x12
    39f4:	0a000022 	beq	3a84 <SCSIHandleData+0xbc>
    39f8:	8a000004 	bhi	3a10 <SCSIHandleData+0x48>
    39fc:	e3530000 	cmp	r3, #0	; 0x0
    3a00:	0a000009 	beq	3a2c <SCSIHandleData+0x64>
    3a04:	e3530003 	cmp	r3, #3	; 0x3
    3a08:	1a000065 	bne	3ba4 <SCSIHandleData+0x1dc>
    3a0c:	ea00000d 	b	3a48 <SCSIHandleData+0x80>
    3a10:	e3530028 	cmp	r3, #40	; 0x28
    3a14:	0a000034 	beq	3aec <SCSIHandleData+0x124>
    3a18:	e353002a 	cmp	r3, #42	; 0x2a
    3a1c:	0a000046 	beq	3b3c <SCSIHandleData+0x174>
    3a20:	e3530025 	cmp	r3, #37	; 0x25
    3a24:	1a00005e 	bne	3ba4 <SCSIHandleData+0x1dc>
    3a28:	ea00001b 	b	3a9c <SCSIHandleData+0xd4>
    {

        // test unit ready
        case 0x00:
            if (dwSense != 0)
    3a2c:	e59f3190 	ldr	r3, [pc, #400]	; 3bc4 <.text+0x3bc4>
    3a30:	e5932000 	ldr	r2, [r3]
    3a34:	e59f318c 	ldr	r3, [pc, #396]	; 3bc8 <.text+0x3bc8>
    3a38:	e3520000 	cmp	r2, #0	; 0x0
    3a3c:	01a0e003 	moveq	lr, r3
    3a40:	13a0e000 	movne	lr, #0	; 0x0
    3a44:	ea00005a 	b	3bb4 <SCSIHandleData+0x1ec>
            {
                return NULL;
            }
            break;

        // request sense
        case SCSI_CMD_REQUEST_SENSE:
            memcpy(pbData, abSense, 18);
    3a48:	e59f117c 	ldr	r1, [pc, #380]	; 3bcc <.text+0x3bcc>
    3a4c:	e3a02012 	mov	r2, #18	; 0x12
    3a50:	e1a00005 	mov	r0, r5
    3a54:	eb00068d 	bl	5490 <memcpy>
            // fill in KEY/ASC/ASCQ
            pbData[2] = (dwSense >> 16) & 0xFF;
    3a58:	e59f0164 	ldr	r0, [pc, #356]	; 3bc4 <.text+0x3bc4>
    3a5c:	e5903000 	ldr	r3, [r0]
            pbData[12] = (dwSense >> 8) & 0xFF;
            pbData[13] = (dwSense >> 0) & 0xFF;
            // reset sense data
            dwSense = 0;
    3a60:	e59fe160 	ldr	lr, [pc, #352]	; 3bc8 <.text+0x3bc8>
    3a64:	e1a02823 	mov	r2, r3, lsr #16
    3a68:	e1a01423 	mov	r1, r3, lsr #8
    3a6c:	e5c5300d 	strb	r3, [r5, #13]
    3a70:	e3a03000 	mov	r3, #0	; 0x0
    3a74:	e5c52002 	strb	r2, [r5, #2]
    3a78:	e5c5100c 	strb	r1, [r5, #12]
    3a7c:	e5803000 	str	r3, [r0]
    3a80:	ea00004b 	b	3bb4 <SCSIHandleData+0x1ec>
            break;

        // inquiry
        case SCSI_CMD_INQUIRY:
            memcpy(pbData, abInquiry, sizeof(abInquiry));
    3a84:	e1a00005 	mov	r0, r5
    3a88:	e59f1140 	ldr	r1, [pc, #320]	; 3bd0 <.text+0x3bd0>
    3a8c:	e3a02024 	mov	r2, #36	; 0x24
    3a90:	eb00067e 	bl	5490 <memcpy>
    3a94:	e59fe12c 	ldr	lr, [pc, #300]	; 3bc8 <.text+0x3bc8>
    3a98:	ea000045 	b	3bb4 <SCSIHandleData+0x1ec>
            break;

        // read capacity
        case SCSI_CMD_READ_CAPACITY:
        // get size of drive (bytes)
            BlockDevGetSize(&dwNumBlocks);
    3a9c:	e28d0008 	add	r0, sp, #8	; 0x8
    3aa0:	eb000088 	bl	3cc8 <BlockDevGetSize>
            // calculate highest LBA
            dwMaxBlock = (dwNumBlocks - 1) / 512;
    3aa4:	e59d3008 	ldr	r3, [sp, #8]
    3aa8:	e2433001 	sub	r3, r3, #1	; 0x1
    3aac:	e1a004a3 	mov	r0, r3, lsr #9

            pbData[0] = (dwMaxBlock >> 24) & 0xFF;
            pbData[1] = (dwMaxBlock >> 16) & 0xFF;
            pbData[2] = (dwMaxBlock >> 8) & 0xFF;
    3ab0:	e1a0c8a3 	mov	ip, r3, lsr #17
            pbData[3] = (dwMaxBlock >> 0) & 0xFF;
            pbData[4] = (BLOCKSIZE >> 24) & 0xFF;
            pbData[5] = (BLOCKSIZE >> 16) & 0xFF;
            pbData[6] = (BLOCKSIZE >> 8) & 0xFF;
            pbData[7] = (BLOCKSIZE >> 0) & 0xFF;
    3ab4:	e59fe10c 	ldr	lr, [pc, #268]	; 3bc8 <.text+0x3bc8>
    3ab8:	e1a03ca3 	mov	r3, r3, lsr #25
    3abc:	e3a02000 	mov	r2, #0	; 0x0
    3ac0:	e1a01c20 	mov	r1, r0, lsr #24
    3ac4:	e5c53001 	strb	r3, [r5, #1]
    3ac8:	e3a03002 	mov	r3, #2	; 0x2
    3acc:	e5c52007 	strb	r2, [r5, #7]
    3ad0:	e5c51000 	strb	r1, [r5]
    3ad4:	e5c5c002 	strb	ip, [r5, #2]
    3ad8:	e5c50003 	strb	r0, [r5, #3]
    3adc:	e5c53006 	strb	r3, [r5, #6]
    3ae0:	e5c52004 	strb	r2, [r5, #4]
    3ae4:	e5c52005 	strb	r2, [r5, #5]
    3ae8:	ea000031 	b	3bb4 <SCSIHandleData+0x1ec>
            break;

        // read10
        case SCSI_CMD_READ_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data from block buffer
            dwBufPos = (dwOffset & (BLOCKSIZE - 1));
    3aec:	e1a05b86 	mov	r5, r6, lsl #23
    3af0:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
    3af4:	e3550000 	cmp	r5, #0	; 0x0
    3af8:	e5d42005 	ldrb	r2, [r4, #5]
    3afc:	e5d43002 	ldrb	r3, [r4, #2]
    3b00:	e5d40003 	ldrb	r0, [r4, #3]
    3b04:	e5d41004 	ldrb	r1, [r4, #4]
    3b08:	1a000022 	bne	3b98 <SCSIHandleData+0x1d0>
            {
                // read new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("R");
                if (BlockDevRead(dwBlockNr, abBlockBuf) < 0)
    3b0c:	e1a00800 	mov	r0, r0, lsl #16
    3b10:	e1800c03 	orr	r0, r0, r3, lsl #24
    3b14:	e1800002 	orr	r0, r0, r2
    3b18:	e1800401 	orr	r0, r0, r1, lsl #8
    3b1c:	e08004a6 	add	r0, r0, r6, lsr #9
    3b20:	e59f10a0 	ldr	r1, [pc, #160]	; 3bc8 <.text+0x3bc8>
    3b24:	eb0000d2 	bl	3e74 <BlockDevRead>
    3b28:	e3500000 	cmp	r0, #0	; 0x0
                {
                    dwSense = READ_ERROR;
    3b2c:	b1a0e005 	movlt	lr, r5
    3b30:	b59f209c 	ldrlt	r2, [pc, #156]	; 3bd4 <.text+0x3bd4>
    3b34:	ba000014 	blt	3b8c <SCSIHandleData+0x1c4>
    3b38:	ea000016 	b	3b98 <SCSIHandleData+0x1d0>
                    DBG("BlockDevRead failed\n");
                    return NULL;
                }
            }
            // return pointer to data
            return abBlockBuf + dwBufPos;

            // write10
            case SCSI_CMD_WRITE_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data to block buffer
            dwBufPos = ((dwOffset + 64) & (BLOCKSIZE - 1));
    3b3c:	e2863040 	add	r3, r6, #64	; 0x40
    3b40:	e1a05b83 	mov	r5, r3, lsl #23
    3b44:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
    3b48:	e3550000 	cmp	r5, #0	; 0x0
    3b4c:	e5d42005 	ldrb	r2, [r4, #5]
    3b50:	e5d43002 	ldrb	r3, [r4, #2]
    3b54:	e5d40003 	ldrb	r0, [r4, #3]
    3b58:	e5d41004 	ldrb	r1, [r4, #4]
    3b5c:	1a00000d 	bne	3b98 <SCSIHandleData+0x1d0>
            {
                // write new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("W");
                if (BlockDevWrite(dwBlockNr, abBlockBuf) < 0)
    3b60:	e1a00800 	mov	r0, r0, lsl #16
    3b64:	e1800c03 	orr	r0, r0, r3, lsl #24
    3b68:	e1800002 	orr	r0, r0, r2
    3b6c:	e1800401 	orr	r0, r0, r1, lsl #8
    3b70:	e08004a6 	add	r0, r0, r6, lsr #9
    3b74:	e59f104c 	ldr	r1, [pc, #76]	; 3bc8 <.text+0x3bc8>
    3b78:	eb000039 	bl	3c64 <BlockDevWrite>
    3b7c:	e3500000 	cmp	r0, #0	; 0x0
    3b80:	aa000004 	bge	3b98 <SCSIHandleData+0x1d0>
                {
                    dwSense = WRITE_ERROR;
    3b84:	e1a0e005 	mov	lr, r5
    3b88:	e3a02bc3 	mov	r2, #199680	; 0x30c00
    3b8c:	e59f3030 	ldr	r3, [pc, #48]	; 3bc4 <.text+0x3bc4>
    3b90:	e5832000 	str	r2, [r3]
    3b94:	ea000006 	b	3bb4 <SCSIHandleData+0x1ec>
                    DBG("BlockDevWrite failed\n");
                    return NULL;
                }
            }
            // return pointer to next data
            return abBlockBuf + dwBufPos;
    3b98:	e59f3028 	ldr	r3, [pc, #40]	; 3bc8 <.text+0x3bc8>
    3b9c:	e085e003 	add	lr, r5, r3
    3ba0:	ea000003 	b	3bb4 <SCSIHandleData+0x1ec>

            default:
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
    3ba4:	e59f3018 	ldr	r3, [pc, #24]	; 3bc4 <.text+0x3bc4>
    3ba8:	e3a02a52 	mov	r2, #335872	; 0x52000
    3bac:	e5832000 	str	r2, [r3]
    3bb0:	e3a0e000 	mov	lr, #0	; 0x0
            return NULL;
        }

    // default: return pointer to start of block buffer
    return abBlockBuf;
}
    3bb4:	e1a0000e 	mov	r0, lr
    3bb8:	e28dd00c 	add	sp, sp, #12	; 0xc
    3bbc:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    3bc0:	e12fff1e 	bx	lr
    3bc4:	40000d24 	andmi	r0, r0, r4, lsr #26
    3bc8:	40000d28 	andmi	r0, r0, r8, lsr #26
    3bcc:	00005cc4 	andeq	r5, r0, r4, asr #25
    3bd0:	00005cd6 	ldreqd	r5, [r0], -r6
    3bd4:	00031100 	andeq	r1, r3, r0, lsl #2

00003bd8 <Resp8b>:

/*****************************************************************************/

static U8 Resp8b(void)
{
    3bd8:	e92d4010 	stmdb	sp!, {r4, lr}
    3bdc:	e3a04000 	mov	r4, #0	; 0x0
    U8 i;
    U8 resp;

    /* Respone will come after 1 - 8 pings */
    for (i = 0; i < 8; i++)
    {
        resp = SPISend(0xff);
    3be0:	e3a000ff 	mov	r0, #255	; 0xff
    3be4:	eb000146 	bl	4104 <SPISend>
    3be8:	e2843001 	add	r3, r4, #1	; 0x1
        if (resp != 0xff)
    3bec:	e35000ff 	cmp	r0, #255	; 0xff
    3bf0:	e20340ff 	and	r4, r3, #255	; 0xff
    3bf4:	1a000001 	bne	3c00 <Resp8b+0x28>
    3bf8:	e3540008 	cmp	r4, #8	; 0x8
    3bfc:	1afffff7 	bne	3be0 <Resp8b+0x8>
        {
            return resp;
        }
    }

    return resp;
}
    3c00:	e8bd4010 	ldmia	sp!, {r4, lr}
    3c04:	e12fff1e 	bx	lr

00003c08 <Command>:
    3c08:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    3c0c:	e1a03001 	mov	r3, r1
    3c10:	e24dd008 	sub	sp, sp, #8	; 0x8
    3c14:	e3804040 	orr	r4, r0, #64	; 0x40
    3c18:	e3e05000 	mvn	r5, #0	; 0x0
    3c1c:	e1a02c21 	mov	r2, r1, lsr #24
    3c20:	e1a0c821 	mov	ip, r1, lsr #16
    3c24:	e1a0e421 	mov	lr, r1, lsr #8
    3c28:	e5cd3005 	strb	r3, [sp, #5]
    3c2c:	e1a0000d 	mov	r0, sp
    3c30:	e3e0306a 	mvn	r3, #106	; 0x6a
    3c34:	e3a01008 	mov	r1, #8	; 0x8
    3c38:	e5cd4001 	strb	r4, [sp, #1]
    3c3c:	e5cd2002 	strb	r2, [sp, #2]
    3c40:	e5cdc003 	strb	ip, [sp, #3]
    3c44:	e5cde004 	strb	lr, [sp, #4]
    3c48:	e5cd3006 	strb	r3, [sp, #6]
    3c4c:	e5cd5007 	strb	r5, [sp, #7]
    3c50:	e5cd5000 	strb	r5, [sp]
    3c54:	eb00013d 	bl	4150 <SPISendN>
    3c58:	e28dd008 	add	sp, sp, #8	; 0x8
    3c5c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    3c60:	e12fff1e 	bx	lr

00003c64 <BlockDevWrite>:

/*****************************************************************************/

static void Resp8bError(U8 value)
{
    switch (value)
    {
        case 0x40:  rprintf("Argument out of bounds.\n");               break;
        case 0x20:  rprintf("Address out of bounds.\n");                break;
        case 0x10:  rprintf("Error during erase sequence.\n");          break;
        case 0x08:  rprintf("CRC failed.\n");                           break;
        case 0x04:  rprintf("Illegal command.\n");                      break;
        case 0x02:  rprintf("Erase reset (see SanDisk docs p5-13).\n"); break;
//        case 0x01:  rprintf("Card is initialising.\n");                 break;
        case 0x01:  rprintf(".");                 break;
            default:
            rprintf("Unknown error 0x%x (see SanDisk docs p5-13).\n", value);
            break;
    }
}


/* ****************************************************************************
 calculates size of card from CSD
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
int BlockDevGetSize(U32 *pdwDriveSize)
{
    U8 cardresp, i, by;
    U8 iob[16];
    U16 c_size, c_size_mult, read_bl_len;

    Command(CMD_READCSD, 0);
    do
    {
        cardresp = Resp8b();
    }
    while (cardresp != 0xFE);

    rprintf("CSD:");
    for (i = 0; i < 16; i++)
    {
        iob[i] = SPISend(0xFF);
        rprintf(" %02x", iob[i]);
    }
    rprintf("\n");

    SPISend(0xff);
    SPISend(0xff);

    c_size = iob[6] & 0x03;     // bits 1..0
    c_size <<= 10;
    c_size += (U16) iob[7] << 2;
    c_size += iob[8] >> 6;

    by = iob[5] & 0x0F;
    read_bl_len = 1 << by;

    by = iob[9] & 0x03;
    by <<= 1;
    by += iob[10] >> 7;

    c_size_mult = 1 << (2 + by);

    *pdwDriveSize = (U32) (c_size + 1) * (U32) c_size_mult *(U32) read_bl_len;

    return 0;
}

/*****************************************************************************/

static U16 Resp16b(void)
{
    U16 resp;

    resp = (Resp8b() << 8) & 0xff00;
    resp |= SPISend(0xff);

    return resp;
}

/*****************************************************************************/

static int State(void)
{
    U16 value;

    Command(CMD_SENDSTATUS, 0);
    value = Resp16b();

    switch (value)
    {
        case 0x0000: return 1;
        case 0x0001: rprintf("Card is Locked.\n");                                                  break;
        case 0x0002: rprintf("WP Erase Skip, Lock/Unlock Cmd Failed.\n");                           break;
        case 0x0004: rprintf("General / Unknown error -- card broken?.\n");                         break;
        case 0x0008: rprintf("Internal card controller error.\n");                                  break;
        case 0x0010: rprintf("Card internal ECC was applied, but failed to correct the data.\n");   break;
        case 0x0020: rprintf("Write protect violation.\n");                                         break;
        case 0x0040: rprintf("An invalid selection, sectors for erase.\n");                         break;
        case 0x0080: rprintf("Out of Range, CSD_Overwrite.\n");                                     break;
            default:
            if (value > 0x00FF)
            {
                Resp8bError((U8) (value >> 8));
            }
            else
            {
                rprintf("Unknown error: 0x%x (see SanDisk docs p5-14).\n", value);
            }
            break;
    }
    return -1;
}

/*****************************************************************************/


int BlockDevInit(void)
{
    int i;
    U8 resp;

    SPIInit();              /* init at low speed */

    /* Try to send reset command up to 100 times */
    i = 100;
    do
    {
        Command(CMD_GOIDLESTATE, 0);
        resp = Resp8b();
    }
    while (resp != 1 && i--);

    if (resp != 1)
    {
        if (resp == 0xff)
        {
            rprintf("resp=0xff\n");
            return -1;
        }
        else
        {
            Resp8bError(resp);
            rprintf("resp!=0xff\n");
            return -2;
        }
    }

    /* Wait till card is ready initialising (returns 0 on CMD_1) */
    /* Try up to 32000 times. */
    i = 32000;
    do
    {
        Command(CMD_SENDOPCOND, 0);

        resp = Resp8b();
        if (resp != 0)
        {
            Resp8bError(resp);
        }
    }
    while (resp == 1 && i--);

    if (resp != 0)
    {
        Resp8bError(resp);
        return -3;
    }

    /* increase speed after init */
    SPISetSpeed(SPI_PRESCALE_MIN);

    if (State() < 0)
    {
        rprintf("Card didn't return the ready state, breaking up...\n");
        return -2;
    }

    rprintf("SD Init done...\n");

    return 0;
}

/*****************************************************************************/



/*****************************************************************************/


/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_WRITE
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK OUT
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 * BUSY...
 */

int BlockDevWrite(U32 dwAddress, U8 * pbBuf)
{
    U32 place;
    U16 t = 0;

    place = 512 * dwAddress;
    Command(CMD_WRITE, place);
    3c64:	e1a00480 	mov	r0, r0, lsl #9
    3c68:	e92d4010 	stmdb	sp!, {r4, lr}
    3c6c:	e1a04001 	mov	r4, r1
    3c70:	e1a01000 	mov	r1, r0
    3c74:	e3a00018 	mov	r0, #24	; 0x18
    3c78:	ebffffe2 	bl	3c08 <Command>

    Resp8b();               /* Card response */
    3c7c:	ebffffd5 	bl	3bd8 <Resp8b>

    SPISend(0xfe);          /* Start block */
    3c80:	e3a000fe 	mov	r0, #254	; 0xfe
    3c84:	eb00011e 	bl	4104 <SPISend>
    SPISendN(pbBuf, 512);
    3c88:	e3a01c02 	mov	r1, #512	; 0x200
    3c8c:	e1a00004 	mov	r0, r4
    3c90:	eb00012e 	bl	4150 <SPISendN>
    SPISend(0xff);          /* Checksum part 1 */
    3c94:	e3a000ff 	mov	r0, #255	; 0xff
    3c98:	eb000119 	bl	4104 <SPISend>
    SPISend(0xff);          /* Checksum part 2 */
    3c9c:	e3a000ff 	mov	r0, #255	; 0xff
    3ca0:	eb000117 	bl	4104 <SPISend>

    SPISend(0xff);
    3ca4:	e3a000ff 	mov	r0, #255	; 0xff
    3ca8:	eb000115 	bl	4104 <SPISend>

    while (SPISend(0xff) != 0xff)
    3cac:	e3a000ff 	mov	r0, #255	; 0xff
    3cb0:	eb000113 	bl	4104 <SPISend>
    3cb4:	e35000ff 	cmp	r0, #255	; 0xff
    3cb8:	1afffffb 	bne	3cac <BlockDevWrite+0x48>
    {
        t++;
    }

    return 0;
}
    3cbc:	e3a00000 	mov	r0, #0	; 0x0
    3cc0:	e8bd4010 	ldmia	sp!, {r4, lr}
    3cc4:	e12fff1e 	bx	lr

00003cc8 <BlockDevGetSize>:
    3cc8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    3ccc:	e3a01000 	mov	r1, #0	; 0x0
    3cd0:	e1a05000 	mov	r5, r0
    3cd4:	e24dd010 	sub	sp, sp, #16	; 0x10
    3cd8:	e3a00009 	mov	r0, #9	; 0x9
    3cdc:	ebffffc9 	bl	3c08 <Command>
    3ce0:	ebffffbc 	bl	3bd8 <Resp8b>
    3ce4:	e35000fe 	cmp	r0, #254	; 0xfe
    3ce8:	1afffffc 	bne	3ce0 <BlockDevGetSize+0x18>
    3cec:	e59f00bc 	ldr	r0, [pc, #188]	; 3db0 <.text+0x3db0>
    3cf0:	ebfff1b8 	bl	3d8 <rprintf>
    3cf4:	e3a04000 	mov	r4, #0	; 0x0
    3cf8:	e3a000ff 	mov	r0, #255	; 0xff
    3cfc:	eb000100 	bl	4104 <SPISend>
    3d00:	e1a0300d 	mov	r3, sp
    3d04:	e7c40003 	strb	r0, [r4, r3]
    3d08:	e1a01000 	mov	r1, r0
    3d0c:	e2844001 	add	r4, r4, #1	; 0x1
    3d10:	e59f009c 	ldr	r0, [pc, #156]	; 3db4 <.text+0x3db4>
    3d14:	ebfff1af 	bl	3d8 <rprintf>
    3d18:	e3540010 	cmp	r4, #16	; 0x10
    3d1c:	1afffff5 	bne	3cf8 <BlockDevGetSize+0x30>
    3d20:	e59f0090 	ldr	r0, [pc, #144]	; 3db8 <.text+0x3db8>
    3d24:	ebfff1ab 	bl	3d8 <rprintf>
    3d28:	e3a000ff 	mov	r0, #255	; 0xff
    3d2c:	eb0000f4 	bl	4104 <SPISend>
    3d30:	e3a000ff 	mov	r0, #255	; 0xff
    3d34:	eb0000f2 	bl	4104 <SPISend>
    3d38:	e5dd1005 	ldrb	r1, [sp, #5]
    3d3c:	e3a00001 	mov	r0, #1	; 0x1
    3d40:	e201100f 	and	r1, r1, #15	; 0xf
    3d44:	e1a01110 	mov	r1, r0, lsl r1
    3d48:	e5dd2009 	ldrb	r2, [sp, #9]
    3d4c:	e5dd300a 	ldrb	r3, [sp, #10]
    3d50:	e2022003 	and	r2, r2, #3	; 0x3
    3d54:	e1a033a3 	mov	r3, r3, lsr #7
    3d58:	e0833082 	add	r3, r3, r2, lsl #1
    3d5c:	e2833002 	add	r3, r3, #2	; 0x2
    3d60:	e1a00310 	mov	r0, r0, lsl r3
    3d64:	e5dd3007 	ldrb	r3, [sp, #7]
    3d68:	e5dd2006 	ldrb	r2, [sp, #6]
    3d6c:	e5ddc008 	ldrb	ip, [sp, #8]
    3d70:	e1a03103 	mov	r3, r3, lsl #2
    3d74:	e083332c 	add	r3, r3, ip, lsr #6
    3d78:	e2022003 	and	r2, r2, #3	; 0x3
    3d7c:	e0833502 	add	r3, r3, r2, lsl #10
    3d80:	e1a01801 	mov	r1, r1, lsl #16
    3d84:	e1a01821 	mov	r1, r1, lsr #16
    3d88:	e2833001 	add	r3, r3, #1	; 0x1
    3d8c:	e0030391 	mul	r3, r1, r3
    3d90:	e1a00800 	mov	r0, r0, lsl #16
    3d94:	e1a00820 	mov	r0, r0, lsr #16
    3d98:	e0030390 	mul	r3, r0, r3
    3d9c:	e3a00000 	mov	r0, #0	; 0x0
    3da0:	e5853000 	str	r3, [r5]
    3da4:	e28dd010 	add	sp, sp, #16	; 0x10
    3da8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    3dac:	e12fff1e 	bx	lr
    3db0:	00005fac 	andeq	r5, r0, ip, lsr #31
    3db4:	00005fb4 	streqh	r5, [r0], -r4
    3db8:	0000608c 	andeq	r6, r0, ip, lsl #1

00003dbc <Resp8bError>:
    3dbc:	e20010ff 	and	r1, r0, #255	; 0xff
    3dc0:	e3510008 	cmp	r1, #8	; 0x8
    3dc4:	e52de004 	str	lr, [sp, #-4]!
    3dc8:	0a000015 	beq	3e24 <Resp8bError+0x68>
    3dcc:	8a000006 	bhi	3dec <Resp8bError+0x30>
    3dd0:	e3510002 	cmp	r1, #2	; 0x2
    3dd4:	0a000016 	beq	3e34 <Resp8bError+0x78>
    3dd8:	e3510004 	cmp	r1, #4	; 0x4
    3ddc:	0a000012 	beq	3e2c <Resp8bError+0x70>
    3de0:	e3510001 	cmp	r1, #1	; 0x1
    3de4:	1a000016 	bne	3e44 <Resp8bError+0x88>
    3de8:	ea000013 	b	3e3c <Resp8bError+0x80>
    3dec:	e3510020 	cmp	r1, #32	; 0x20
    3df0:	0a000006 	beq	3e10 <Resp8bError+0x54>
    3df4:	e3510040 	cmp	r1, #64	; 0x40
    3df8:	0a000002 	beq	3e08 <Resp8bError+0x4c>
    3dfc:	e3510010 	cmp	r1, #16	; 0x10
    3e00:	1a00000f 	bne	3e44 <Resp8bError+0x88>
    3e04:	ea000004 	b	3e1c <Resp8bError+0x60>
    3e08:	e59f0044 	ldr	r0, [pc, #68]	; 3e54 <.text+0x3e54>
    3e0c:	ea000000 	b	3e14 <Resp8bError+0x58>
    3e10:	e59f0040 	ldr	r0, [pc, #64]	; 3e58 <.text+0x3e58>
    3e14:	ebfff16f 	bl	3d8 <rprintf>
    3e18:	ea00000b 	b	3e4c <Resp8bError+0x90>
    3e1c:	e59f0038 	ldr	r0, [pc, #56]	; 3e5c <.text+0x3e5c>
    3e20:	eafffffb 	b	3e14 <Resp8bError+0x58>
    3e24:	e59f0034 	ldr	r0, [pc, #52]	; 3e60 <.text+0x3e60>
    3e28:	eafffff9 	b	3e14 <Resp8bError+0x58>
    3e2c:	e59f0030 	ldr	r0, [pc, #48]	; 3e64 <.text+0x3e64>
    3e30:	eafffff7 	b	3e14 <Resp8bError+0x58>
    3e34:	e59f002c 	ldr	r0, [pc, #44]	; 3e68 <.text+0x3e68>
    3e38:	eafffff5 	b	3e14 <Resp8bError+0x58>
    3e3c:	e59f0028 	ldr	r0, [pc, #40]	; 3e6c <.text+0x3e6c>
    3e40:	eafffff3 	b	3e14 <Resp8bError+0x58>
    3e44:	e59f0024 	ldr	r0, [pc, #36]	; 3e70 <.text+0x3e70>
    3e48:	ebfff162 	bl	3d8 <rprintf>
    3e4c:	e49de004 	ldr	lr, [sp], #4
    3e50:	e12fff1e 	bx	lr
    3e54:	00005fbc 	streqh	r5, [r0], -ip
    3e58:	00005fd8 	ldreqd	r5, [r0], -r8
    3e5c:	00005ff0 	streqd	r5, [r0], -r0
    3e60:	00006010 	andeq	r6, r0, r0, lsl r0
    3e64:	00006020 	andeq	r6, r0, r0, lsr #32
    3e68:	00006034 	andeq	r6, r0, r4, lsr r0
    3e6c:	0000605c 	andeq	r6, r0, ip, asr r0
    3e70:	00006060 	andeq	r6, r0, r0, rrx

00003e74 <BlockDevRead>:

/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_CMD_
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK IN
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 */

int BlockDevRead(U32 dwAddress, U8 * pbBuf)
{
    U8 cardresp;
    U8 firstblock;
    U16 fb_timeout = 0xffff;
    U32 place;

    place = 512 * dwAddress;
    Command(CMD_READSINGLEBLOCK, place);
    3e74:	e1a00480 	mov	r0, r0, lsl #9
    3e78:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    3e7c:	e1a06001 	mov	r6, r1
    3e80:	e1a01000 	mov	r1, r0
    3e84:	e3a00011 	mov	r0, #17	; 0x11
    3e88:	ebffff5e 	bl	3c08 <Command>

    cardresp = Resp8b();        /* Card response */
    3e8c:	ebffff51 	bl	3bd8 <Resp8b>
    3e90:	e59f506c 	ldr	r5, [pc, #108]	; 3f04 <.text+0x3f04>
    3e94:	e1a04000 	mov	r4, r0

    /* Wait for startblock */
    do
    {
        firstblock = Resp8b();
    3e98:	ebffff4e 	bl	3bd8 <Resp8b>
    }
    while (firstblock == 0xff && fb_timeout--);
    3e9c:	e2453001 	sub	r3, r5, #1	; 0x1
    3ea0:	e35000ff 	cmp	r0, #255	; 0xff
    3ea4:	e1a03803 	mov	r3, r3, lsl #16
    3ea8:	1a000003 	bne	3ebc <BlockDevRead+0x48>
    3eac:	e3730801 	cmn	r3, #65536	; 0x10000
    3eb0:	e1a05823 	mov	r5, r3, lsr #16
    3eb4:	0a000005 	beq	3ed0 <BlockDevRead+0x5c>
    3eb8:	eafffff6 	b	3e98 <BlockDevRead+0x24>

    if (cardresp != 0x00 || firstblock != 0xfe)
    3ebc:	e35000fe 	cmp	r0, #254	; 0xfe
    3ec0:	03540000 	cmpeq	r4, #0	; 0x0
    3ec4:	03a04000 	moveq	r4, #0	; 0x0
    3ec8:	13a04001 	movne	r4, #1	; 0x1
    3ecc:	0a000002 	beq	3edc <BlockDevRead+0x68>
    {
        Resp8bError(firstblock);
    3ed0:	ebffffb9 	bl	3dbc <Resp8bError>
    3ed4:	e3e00000 	mvn	r0, #0	; 0x0
    3ed8:	ea000007 	b	3efc <BlockDevRead+0x88>
        return -1;
    }

    SPIRecvN(pbBuf, 512);
    3edc:	e3a01c02 	mov	r1, #512	; 0x200
    3ee0:	e1a00006 	mov	r0, r6
    3ee4:	eb0000b0 	bl	41ac <SPIRecvN>

    /* Checksum (2 byte) - ignore for now */
    SPISend(0xff);
    3ee8:	e3a000ff 	mov	r0, #255	; 0xff
    3eec:	eb000084 	bl	4104 <SPISend>
    SPISend(0xff);
    3ef0:	e3a000ff 	mov	r0, #255	; 0xff
    3ef4:	eb000082 	bl	4104 <SPISend>
    3ef8:	e1a00004 	mov	r0, r4

    return 0;
}
    3efc:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    3f00:	e12fff1e 	bx	lr
    3f04:	0000ffff 	streqd	pc, [r0], -pc

00003f08 <BlockDevInit>:
    3f08:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    3f0c:	eb0000bf 	bl	4210 <SPIInit>
    3f10:	e3a04064 	mov	r4, #100	; 0x64
    3f14:	e3a00000 	mov	r0, #0	; 0x0
    3f18:	e1a01000 	mov	r1, r0
    3f1c:	ebffff39 	bl	3c08 <Command>
    3f20:	ebffff2c 	bl	3bd8 <Resp8b>
    3f24:	e3500001 	cmp	r0, #1	; 0x1
    3f28:	e2444001 	sub	r4, r4, #1	; 0x1
    3f2c:	0a00000a 	beq	3f5c <BlockDevInit+0x54>
    3f30:	e3740001 	cmn	r4, #1	; 0x1
    3f34:	1afffff6 	bne	3f14 <BlockDevInit+0xc>
    3f38:	e35000ff 	cmp	r0, #255	; 0xff
    3f3c:	1a000003 	bne	3f50 <BlockDevInit+0x48>
    3f40:	e59f016c 	ldr	r0, [pc, #364]	; 40b4 <.text+0x40b4>
    3f44:	ebfff123 	bl	3d8 <rprintf>
    3f48:	e1a00004 	mov	r0, r4
    3f4c:	ea000056 	b	40ac <BlockDevInit+0x1a4>
    3f50:	ebffff99 	bl	3dbc <Resp8bError>
    3f54:	e59f015c 	ldr	r0, [pc, #348]	; 40b8 <.text+0x40b8>
    3f58:	ea000051 	b	40a4 <BlockDevInit+0x19c>
    3f5c:	e3a04c7d 	mov	r4, #32000	; 0x7d00
    3f60:	e3a01000 	mov	r1, #0	; 0x0
    3f64:	e3a00001 	mov	r0, #1	; 0x1
    3f68:	ebffff26 	bl	3c08 <Command>
    3f6c:	ebffff19 	bl	3bd8 <Resp8b>
    3f70:	e2505000 	subs	r5, r0, #0	; 0x0
    3f74:	e2444001 	sub	r4, r4, #1	; 0x1
    3f78:	0a000008 	beq	3fa0 <BlockDevInit+0x98>
    3f7c:	ebffff8e 	bl	3dbc <Resp8bError>
    3f80:	e3550001 	cmp	r5, #1	; 0x1
    3f84:	1a000001 	bne	3f90 <BlockDevInit+0x88>
    3f88:	e3740001 	cmn	r4, #1	; 0x1
    3f8c:	1afffff3 	bne	3f60 <BlockDevInit+0x58>
    3f90:	e1a00005 	mov	r0, r5
    3f94:	ebffff88 	bl	3dbc <Resp8bError>
    3f98:	e3e00002 	mvn	r0, #2	; 0x2
    3f9c:	ea000042 	b	40ac <BlockDevInit+0x1a4>
    3fa0:	e3a00008 	mov	r0, #8	; 0x8
    3fa4:	eb00004f 	bl	40e8 <SPISetSpeed>
    3fa8:	e1a01005 	mov	r1, r5
    3fac:	e3a0000d 	mov	r0, #13	; 0xd
    3fb0:	ebffff14 	bl	3c08 <Command>
    3fb4:	ebffff07 	bl	3bd8 <Resp8b>
    3fb8:	e1a04c00 	mov	r4, r0, lsl #24
    3fbc:	e3a000ff 	mov	r0, #255	; 0xff
    3fc0:	eb00004f 	bl	4104 <SPISend>
    3fc4:	e1a04824 	mov	r4, r4, lsr #16
    3fc8:	e1844000 	orr	r4, r4, r0
    3fcc:	e1a04804 	mov	r4, r4, lsl #16
    3fd0:	e1a01824 	mov	r1, r4, lsr #16
    3fd4:	e3510008 	cmp	r1, #8	; 0x8
    3fd8:	0a00001a 	beq	4048 <BlockDevInit+0x140>
    3fdc:	8a000007 	bhi	4000 <BlockDevInit+0xf8>
    3fe0:	e3510001 	cmp	r1, #1	; 0x1
    3fe4:	0a000010 	beq	402c <BlockDevInit+0x124>
    3fe8:	3a000028 	bcc	4090 <BlockDevInit+0x188>
    3fec:	e3510002 	cmp	r1, #2	; 0x2
    3ff0:	0a00000f 	beq	4034 <BlockDevInit+0x12c>
    3ff4:	e3510004 	cmp	r1, #4	; 0x4
    3ff8:	1a00001c 	bne	4070 <BlockDevInit+0x168>
    3ffc:	ea00000f 	b	4040 <BlockDevInit+0x138>
    4000:	e3510020 	cmp	r1, #32	; 0x20
    4004:	0a000013 	beq	4058 <BlockDevInit+0x150>
    4008:	8a000002 	bhi	4018 <BlockDevInit+0x110>
    400c:	e3510010 	cmp	r1, #16	; 0x10
    4010:	1a000016 	bne	4070 <BlockDevInit+0x168>
    4014:	ea00000d 	b	4050 <BlockDevInit+0x148>
    4018:	e3510040 	cmp	r1, #64	; 0x40
    401c:	0a00000f 	beq	4060 <BlockDevInit+0x158>
    4020:	e3510080 	cmp	r1, #128	; 0x80
    4024:	1a000011 	bne	4070 <BlockDevInit+0x168>
    4028:	ea00000e 	b	4068 <BlockDevInit+0x160>
    402c:	e59f0088 	ldr	r0, [pc, #136]	; 40bc <.text+0x40bc>
    4030:	ea000000 	b	4038 <BlockDevInit+0x130>
    4034:	e59f0084 	ldr	r0, [pc, #132]	; 40c0 <.text+0x40c0>
    4038:	ebfff0e6 	bl	3d8 <rprintf>
    403c:	ea000017 	b	40a0 <BlockDevInit+0x198>
    4040:	e59f007c 	ldr	r0, [pc, #124]	; 40c4 <.text+0x40c4>
    4044:	eafffffb 	b	4038 <BlockDevInit+0x130>
    4048:	e59f0078 	ldr	r0, [pc, #120]	; 40c8 <.text+0x40c8>
    404c:	eafffff9 	b	4038 <BlockDevInit+0x130>
    4050:	e59f0074 	ldr	r0, [pc, #116]	; 40cc <.text+0x40cc>
    4054:	eafffff7 	b	4038 <BlockDevInit+0x130>
    4058:	e59f0070 	ldr	r0, [pc, #112]	; 40d0 <.text+0x40d0>
    405c:	eafffff5 	b	4038 <BlockDevInit+0x130>
    4060:	e59f006c 	ldr	r0, [pc, #108]	; 40d4 <.text+0x40d4>
    4064:	eafffff3 	b	4038 <BlockDevInit+0x130>
    4068:	e59f0068 	ldr	r0, [pc, #104]	; 40d8 <.text+0x40d8>
    406c:	eafffff1 	b	4038 <BlockDevInit+0x130>
    4070:	e35100ff 	cmp	r1, #255	; 0xff
    4074:	9a000002 	bls	4084 <BlockDevInit+0x17c>
    4078:	e1a00421 	mov	r0, r1, lsr #8
    407c:	ebffff4e 	bl	3dbc <Resp8bError>
    4080:	ea000006 	b	40a0 <BlockDevInit+0x198>
    4084:	e59f0050 	ldr	r0, [pc, #80]	; 40dc <.text+0x40dc>
    4088:	ebfff0d2 	bl	3d8 <rprintf>
    408c:	ea000003 	b	40a0 <BlockDevInit+0x198>
    4090:	e59f0048 	ldr	r0, [pc, #72]	; 40e0 <.text+0x40e0>
    4094:	ebfff0cf 	bl	3d8 <rprintf>
    4098:	e1a00005 	mov	r0, r5
    409c:	ea000002 	b	40ac <BlockDevInit+0x1a4>
    40a0:	e59f003c 	ldr	r0, [pc, #60]	; 40e4 <.text+0x40e4>
    40a4:	ebfff0cb 	bl	3d8 <rprintf>
    40a8:	e3e00001 	mvn	r0, #1	; 0x1
    40ac:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    40b0:	e12fff1e 	bx	lr
    40b4:	00006090 	muleq	r0, r0, r0
    40b8:	0000609c 	muleq	r0, ip, r0
    40bc:	000060a8 	andeq	r6, r0, r8, lsr #1
    40c0:	000060bc 	streqh	r6, [r0], -ip
    40c4:	000060e4 	andeq	r6, r0, r4, ror #1
    40c8:	00006110 	andeq	r6, r0, r0, lsl r1
    40cc:	00006134 	andeq	r6, r0, r4, lsr r1
    40d0:	00006174 	andeq	r6, r0, r4, ror r1
    40d4:	00006190 	muleq	r0, r0, r1
    40d8:	000061bc 	streqh	r6, [r0], -ip
    40dc:	000061dc 	ldreqd	r6, [r0], -ip
    40e0:	0000620c 	andeq	r6, r0, ip, lsl #4
    40e4:	00006220 	andeq	r6, r0, r0, lsr #4

000040e8 <SPISetSpeed>:
/*****************************************************************************/

void SPISetSpeed(U8 speed)
{
    speed &= 0xFE;
    40e8:	e20000fe 	and	r0, r0, #254	; 0xfe
    if (speed < SPI_PRESCALE_MIN)
    40ec:	e3500007 	cmp	r0, #7	; 0x7
    {
        speed = SPI_PRESCALE_MIN;
    }
    SPI_PRESCALE_REG = speed;
    40f0:	e59f3008 	ldr	r3, [pc, #8]	; 4100 <.text+0x4100>
    40f4:	93a00008 	movls	r0, #8	; 0x8
    40f8:	e5c3000c 	strb	r0, [r3, #12]
}
    40fc:	e12fff1e 	bx	lr
    4100:	e0020000 	and	r0, r2, r0

00004104 <SPISend>:


void SPIInit(void)
{
    U8 i;
    //U32 j;

    rprintf("spiInit for SPI(0)\n");

    // setup GPIO
    PINSEL2 = 0;

	SPI_IODIR |= (1 << SPI_SCK_PIN) | (1 << SPI_MOSI_PIN);
    IODIR0 |= (1 << SPI_SS_PIN);			//Changed to Port0 for MP3 Player
    SPI_IODIR &= ~(1 << SPI_MISO_PIN);

    // reset Pin-Functions
    SPI_PINSEL &= ~((3 << SPI_SCK_FUNCBIT) | (3 << SPI_MISO_FUNCBIT) | (3 << SPI_MOSI_FUNCBIT));
    SPI_PINSEL |= ((1 << SPI_SCK_FUNCBIT) | (1 << SPI_MISO_FUNCBIT) | (1 << SPI_MOSI_FUNCBIT));

    /*        PINSEL0 &= ~(3 << (SPI_SS_FUNCBIT));*/
    /*        PINSEL0 |= (0 << (SPI_SS_FUNCBIT));*/

    // set Chip-Select high - unselect card
    UNSELECT_CARD();

    // enable SPI-Master
    S0SPCR = (1 << MSTR) | (0 << CPOL);   // TODO: check CPOL

    // low speed during init
    SPISetSpeed(254);

    /* Send 20 spi commands with card not selected */
    for (i = 0; i < 21; i++)
    {
        my_SPISend(0xff);
    }
}

/*****************************************************************************/

/*****************************************************************************/

U8 SPISend(U8 outgoing)
{
    U8 incoming;

    SELECT_CARD();
    4104:	e59f203c 	ldr	r2, [pc, #60]	; 4148 <.text+0x4148>
    4108:	e592300c 	ldr	r3, [r2, #12]
    410c:	e3833080 	orr	r3, r3, #128	; 0x80
    4110:	e582300c 	str	r3, [r2, #12]
    S0SPDR = outgoing;
    4114:	e59f3030 	ldr	r3, [pc, #48]	; 414c <.text+0x414c>
    4118:	e20000ff 	and	r0, r0, #255	; 0xff
    411c:	e5c30008 	strb	r0, [r3, #8]
    while (!(S0SPSR & (1 << SPIF)));
    4120:	e59f2024 	ldr	r2, [pc, #36]	; 414c <.text+0x414c>
    4124:	e5d23004 	ldrb	r3, [r2, #4]
    4128:	e3130080 	tst	r3, #128	; 0x80
    412c:	0afffffb 	beq	4120 <SPISend+0x1c>
    incoming = S0SPDR;
    UNSELECT_CARD();
    4130:	e59f3010 	ldr	r3, [pc, #16]	; 4148 <.text+0x4148>
    4134:	e5d20008 	ldrb	r0, [r2, #8]
    4138:	e5932004 	ldr	r2, [r3, #4]
    413c:	e3822080 	orr	r2, r2, #128	; 0x80
    4140:	e5832004 	str	r2, [r3, #4]

    return incoming;
}
    4144:	e12fff1e 	bx	lr
    4148:	e0028000 	and	r8, r2, r0
    414c:	e0020000 	and	r0, r2, r0

00004150 <SPISendN>:

void SPISendN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
    4150:	e59f204c 	ldr	r2, [pc, #76]	; 41a4 <.text+0x41a4>
    4154:	e592300c 	ldr	r3, [r2, #12]
    4158:	e3a0c000 	mov	ip, #0	; 0x0
    415c:	e3833080 	orr	r3, r3, #128	; 0x80
    4160:	e582300c 	str	r3, [r2, #12]
    4164:	ea000007 	b	4188 <SPISendN+0x38>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = pbBuf[i];
    4168:	e7d0200c 	ldrb	r2, [r0, ip]
    416c:	e59f3034 	ldr	r3, [pc, #52]	; 41a8 <.text+0x41a8>
    4170:	e5c32008 	strb	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
    4174:	e59f302c 	ldr	r3, [pc, #44]	; 41a8 <.text+0x41a8>
    4178:	e5d33004 	ldrb	r3, [r3, #4]
    417c:	e3130080 	tst	r3, #128	; 0x80
    4180:	0afffffb 	beq	4174 <SPISendN+0x24>
    4184:	e28cc001 	add	ip, ip, #1	; 0x1
    4188:	e15c0001 	cmp	ip, r1
    418c:	bafffff5 	blt	4168 <SPISendN+0x18>
    }
    UNSELECT_CARD();
    4190:	e59f200c 	ldr	r2, [pc, #12]	; 41a4 <.text+0x41a4>
    4194:	e5923004 	ldr	r3, [r2, #4]
    4198:	e3833080 	orr	r3, r3, #128	; 0x80
    419c:	e5823004 	str	r3, [r2, #4]
}
    41a0:	e12fff1e 	bx	lr
    41a4:	e0028000 	and	r8, r2, r0
    41a8:	e0020000 	and	r0, r2, r0

000041ac <SPIRecvN>:

void SPIRecvN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
    41ac:	e59f2054 	ldr	r2, [pc, #84]	; 4208 <.text+0x4208>
    41b0:	e592300c 	ldr	r3, [r2, #12]
    41b4:	e3a0c000 	mov	ip, #0	; 0x0
    41b8:	e3833080 	orr	r3, r3, #128	; 0x80
    41bc:	e582300c 	str	r3, [r2, #12]
    41c0:	ea000009 	b	41ec <SPIRecvN+0x40>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = 0xFF;
    41c4:	e59f3040 	ldr	r3, [pc, #64]	; 420c <.text+0x420c>
    41c8:	e3e02000 	mvn	r2, #0	; 0x0
    41cc:	e5c32008 	strb	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
    41d0:	e59f2034 	ldr	r2, [pc, #52]	; 420c <.text+0x420c>
    41d4:	e5d23004 	ldrb	r3, [r2, #4]
    41d8:	e3130080 	tst	r3, #128	; 0x80
    41dc:	0afffffb 	beq	41d0 <SPIRecvN+0x24>
        pbBuf[i] = S0SPDR;
    41e0:	e5d23008 	ldrb	r3, [r2, #8]
    41e4:	e7c0300c 	strb	r3, [r0, ip]
    41e8:	e28cc001 	add	ip, ip, #1	; 0x1
    41ec:	e15c0001 	cmp	ip, r1
    41f0:	bafffff3 	blt	41c4 <SPIRecvN+0x18>
    }
    UNSELECT_CARD();
    41f4:	e59f200c 	ldr	r2, [pc, #12]	; 4208 <.text+0x4208>
    41f8:	e5923004 	ldr	r3, [r2, #4]
    41fc:	e3833080 	orr	r3, r3, #128	; 0x80
    4200:	e5823004 	str	r3, [r2, #4]
}
    4204:	e12fff1e 	bx	lr
    4208:	e0028000 	and	r8, r2, r0
    420c:	e0020000 	and	r0, r2, r0

00004210 <SPIInit>:
    4210:	e59f00a8 	ldr	r0, [pc, #168]	; 42c0 <.text+0x42c0>
    4214:	e52de004 	str	lr, [sp, #-4]!
    4218:	ebfff06e 	bl	3d8 <rprintf>
    421c:	e59f10a0 	ldr	r1, [pc, #160]	; 42c4 <.text+0x42c4>
    4220:	e3a00000 	mov	r0, #0	; 0x0
    4224:	e5810014 	str	r0, [r1, #20]
    4228:	e59f2098 	ldr	r2, [pc, #152]	; 42c8 <.text+0x42c8>
    422c:	e5923008 	ldr	r3, [r2, #8]
    4230:	e3833050 	orr	r3, r3, #80	; 0x50
    4234:	e5823008 	str	r3, [r2, #8]
    4238:	e5923008 	ldr	r3, [r2, #8]
    423c:	e3833080 	orr	r3, r3, #128	; 0x80
    4240:	e5823008 	str	r3, [r2, #8]
    4244:	e5923008 	ldr	r3, [r2, #8]
    4248:	e3c33020 	bic	r3, r3, #32	; 0x20
    424c:	e5823008 	str	r3, [r2, #8]
    4250:	e5913000 	ldr	r3, [r1]
    4254:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
    4258:	e5813000 	str	r3, [r1]
    425c:	e5913000 	ldr	r3, [r1]
    4260:	e3833c15 	orr	r3, r3, #5376	; 0x1500
    4264:	e5813000 	str	r3, [r1]
    4268:	e5923004 	ldr	r3, [r2, #4]
    426c:	e3833080 	orr	r3, r3, #128	; 0x80
    4270:	e5823004 	str	r3, [r2, #4]
    4274:	e2411903 	sub	r1, r1, #49152	; 0xc000
    4278:	e3a03020 	mov	r3, #32	; 0x20
    427c:	e5c13000 	strb	r3, [r1]
    4280:	e3e03001 	mvn	r3, #1	; 0x1
    4284:	e5c1300c 	strb	r3, [r1, #12]
    4288:	e59f303c 	ldr	r3, [pc, #60]	; 42cc <.text+0x42cc>
    428c:	e3e02000 	mvn	r2, #0	; 0x0
    4290:	e5c32008 	strb	r2, [r3, #8]
    4294:	e59f2030 	ldr	r2, [pc, #48]	; 42cc <.text+0x42cc>
    4298:	e5d23004 	ldrb	r3, [r2, #4]
    429c:	e3130080 	tst	r3, #128	; 0x80
    42a0:	0afffffb 	beq	4294 <SPIInit+0x84>
    42a4:	e2803001 	add	r3, r0, #1	; 0x1
    42a8:	e20300ff 	and	r0, r3, #255	; 0xff
    42ac:	e3500015 	cmp	r0, #21	; 0x15
    42b0:	e5d23008 	ldrb	r3, [r2, #8]
    42b4:	1afffff3 	bne	4288 <SPIInit+0x78>
    42b8:	e49de004 	ldr	lr, [sp], #4
    42bc:	e12fff1e 	bx	lr
    42c0:	00006254 	andeq	r6, r0, r4, asr r2
    42c4:	e002c000 	and	ip, r2, r0
    42c8:	e0028000 	and	r8, r2, r0
    42cc:	e0020000 	and	r0, r2, r0

000042d0 <HandleUsbReset>:
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
    42d0:	e12fff1e 	bx	lr

000042d4 <USBInit>:


/**
	Initialises the USB hardware and sets up the USB stack by
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
    42d4:	e92d4010 	stmdb	sp!, {r4, lr}
	// init hardware
	USBHwInit();
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    42d8:	e59f4054 	ldr	r4, [pc, #84]	; 4334 <.text+0x4334>
    42dc:	eb00013d 	bl	47d8 <USBHwInit>
    42e0:	e59f0050 	ldr	r0, [pc, #80]	; 4338 <.text+0x4338>
    42e4:	eb000074 	bl	44bc <USBHwRegisterDevIntHandler>
    42e8:	e1a01004 	mov	r1, r4
    42ec:	e3a00000 	mov	r0, #0	; 0x0
    42f0:	eb00005e 	bl	4470 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
    42f4:	e1a01004 	mov	r1, r4
    42f8:	e3a00080 	mov	r0, #128	; 0x80
    42fc:	eb00005b 	bl	4470 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
    4300:	e3a00000 	mov	r0, #0	; 0x0
    4304:	e3a01040 	mov	r1, #64	; 0x40
    4308:	eb000041 	bl	4414 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
    430c:	e3a00080 	mov	r0, #128	; 0x80
    4310:	e3a01040 	mov	r1, #64	; 0x40
    4314:	eb00003e 	bl	4414 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
    4318:	e3a00000 	mov	r0, #0	; 0x0
    431c:	e59f1018 	ldr	r1, [pc, #24]	; 433c <.text+0x433c>
    4320:	e59f2018 	ldr	r2, [pc, #24]	; 4340 <.text+0x4340>
    4324:	eb00016c 	bl	48dc <USBRegisterRequestHandler>

	return TRUE;
}
    4328:	e3a00001 	mov	r0, #1	; 0x1
    432c:	e8bd4010 	ldmia	sp!, {r4, lr}
    4330:	e12fff1e 	bx	lr
    4334:	00004960 	andeq	r4, r0, r0, ror #18
    4338:	000042d0 	ldreqd	r4, [r0], -r0
    433c:	00004b50 	andeq	r4, r0, r0, asr fp
    4340:	40000f28 	andmi	r0, r0, r8, lsr #30

00004344 <USBHwCmd>:
		
	@param [in]	bCmd		Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    4344:	e1a00800 	mov	r0, r0, lsl #16
	// clear CDFULL/CCEMTY
	USBDevIntClr = CDFULL | CCEMTY;
    4348:	e59f202c 	ldr	r2, [pc, #44]	; 437c <.text+0x437c>
	// write command code
	USBCmdCode = 0x00000500 | (bCmd << 16);
    434c:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
    4350:	e3800c05 	orr	r0, r0, #1280	; 0x500
    4354:	e3a03030 	mov	r3, #48	; 0x30
    4358:	e5823008 	str	r3, [r2, #8]
    435c:	e5820010 	str	r0, [r2, #16]
    4360:	e59f2014 	ldr	r2, [pc, #20]	; 437c <.text+0x437c>
    4364:	e5923000 	ldr	r3, [r2]
    4368:	e2033010 	and	r3, r3, #16	; 0x10
    436c:	e3530010 	cmp	r3, #16	; 0x10
    4370:	1afffffa 	bne	4360 <USBHwCmd+0x1c>
    4374:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
    4378:	e12fff1e 	bx	lr
    437c:	e0090000 	and	r0, r9, r0

00004380 <USBHwCmdWrite>:


/**
	Local function to send a command + data to the USB protocol engine
		
	@param [in]	bCmd		Command to send
	@param [in]	bData		Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
    4380:	e92d4010 	stmdb	sp!, {r4, lr}
    4384:	e1a04801 	mov	r4, r1, lsl #16
    4388:	e20000ff 	and	r0, r0, #255	; 0xff
    438c:	e1a04824 	mov	r4, r4, lsr #16
	// write command code
	USBHwCmd(bCmd);
    4390:	ebffffeb 	bl	4344 <USBHwCmd>

	// write command data
	USBCmdCode = 0x00000100 | (bData << 16);
    4394:	e1a04804 	mov	r4, r4, lsl #16
    4398:	e59f3024 	ldr	r3, [pc, #36]	; 43c4 <.text+0x43c4>
    439c:	e3844c01 	orr	r4, r4, #256	; 0x100
    43a0:	e5834010 	str	r4, [r3, #16]
    43a4:	e59f2018 	ldr	r2, [pc, #24]	; 43c4 <.text+0x43c4>
    43a8:	e5923000 	ldr	r3, [r2]
    43ac:	e2033010 	and	r3, r3, #16	; 0x10
    43b0:	e3530010 	cmp	r3, #16	; 0x10
    43b4:	1afffffa 	bne	43a4 <USBHwCmdWrite+0x24>
    43b8:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
    43bc:	e8bd4010 	ldmia	sp!, {r4, lr}
    43c0:	e12fff1e 	bx	lr
    43c4:	e0090000 	and	r0, r9, r0

000043c8 <USBHwCmdRead>:


/**
	Local function to send a command to the USB protocol engine and read data
		
	@param [in]	bCmd		Command to send

	@return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    43c8:	e92d4010 	stmdb	sp!, {r4, lr}
    43cc:	e20040ff 	and	r4, r0, #255	; 0xff
	// write command code
	USBHwCmd(bCmd);
    43d0:	e1a00004 	mov	r0, r4
    43d4:	ebffffda 	bl	4344 <USBHwCmd>
	
	// get data
	USBCmdCode = 0x00000200 | (bCmd << 16);
    43d8:	e1a04804 	mov	r4, r4, lsl #16
    43dc:	e59f302c 	ldr	r3, [pc, #44]	; 4410 <.text+0x4410>
    43e0:	e3844c02 	orr	r4, r4, #512	; 0x200
    43e4:	e5834010 	str	r4, [r3, #16]
    43e8:	e59f2020 	ldr	r2, [pc, #32]	; 4410 <.text+0x4410>
    43ec:	e5923000 	ldr	r3, [r2]
    43f0:	e2033020 	and	r3, r3, #32	; 0x20
    43f4:	e3530020 	cmp	r3, #32	; 0x20
    43f8:	1afffffa 	bne	43e8 <USBHwCmdRead+0x20>
    43fc:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CDFULL);
	return USBCmdData;
    4400:	e5920014 	ldr	r0, [r2, #20]
    4404:	e20000ff 	and	r0, r0, #255	; 0xff
}
    4408:	e8bd4010 	ldmia	sp!, {r4, lr}
    440c:	e12fff1e 	bx	lr
    4410:	e0090000 	and	r0, r9, r0

00004414 <USBHwEPConfig>:


/**
	'Realizes' an endpoint, meaning that buffer space is reserved for
	it. An endpoint needs to be realised before it can be used.
		
	From experiments, it appears that a USB reset causes USBReEP to
	re-initialise to 3 (= just the control endpoints).
	However, a USB bus reset does not disturb the USBMaxPSize settings.
		
	@param [in]	idx			Endpoint index
	@param [in] wMaxPSize	Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
	USBReEP |= (1 << idx);
    4414:	e59fc050 	ldr	ip, [pc, #80]	; 446c <.text+0x446c>
	USBEpInd = idx;
	USBMaxPSize = wMaxPSize;
	Wait4DevInt(EP_RLZED);
}


/**
	Enables or disables an endpoint
		
	@param [in]	idx		Endpoint index
	@param [in]	fEnable	TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
}


/**
	Configures an endpoint and enables it
		
	@param [in]	bEP				Endpoint number
	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
	int idx;
	
	idx = EP2IDX(bEP);
    4418:	e2003080 	and	r3, r0, #128	; 0x80
    441c:	e59c2044 	ldr	r2, [ip, #68]
    4420:	e1a033c3 	mov	r3, r3, asr #7
    4424:	e200000f 	and	r0, r0, #15	; 0xf
    4428:	e1830080 	orr	r0, r3, r0, lsl #1
    442c:	e3a03001 	mov	r3, #1	; 0x1
    4430:	e1822013 	orr	r2, r2, r3, lsl r0
    4434:	e1a01801 	mov	r1, r1, lsl #16
    4438:	e1a01821 	mov	r1, r1, lsr #16
    443c:	e58c2044 	str	r2, [ip, #68]
    4440:	e58c0048 	str	r0, [ip, #72]
    4444:	e58c104c 	str	r1, [ip, #76]
    4448:	e59f201c 	ldr	r2, [pc, #28]	; 446c <.text+0x446c>
    444c:	e5923000 	ldr	r3, [r2]
    4450:	e2033c01 	and	r3, r3, #256	; 0x100
    4454:	e3530c01 	cmp	r3, #256	; 0x100
    4458:	1afffffa 	bne	4448 <USBHwEPConfig+0x34>
    445c:	e3800040 	orr	r0, r0, #64	; 0x40
    4460:	e3a01000 	mov	r1, #0	; 0x0
    4464:	e5823008 	str	r3, [r2, #8]
    4468:	eaffffc4 	b	4380 <USBHwCmdWrite>
    446c:	e0090000 	and	r0, r9, r0

00004470 <USBHwRegisterEPIntHandler>:
	
	// realise EP
	USBHwEPRealize(idx, wMaxPacketSize);

	// enable EP
	USBHwEPEnable(idx, TRUE);
}


/**
	Registers an endpoint event callback
		
	@param [in]	bEP				Endpoint number
	@param [in]	pfnHandler		Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
    4470:	e52de004 	str	lr, [sp, #-4]!
	int idx;
	
	idx = EP2IDX(bEP);

	ASSERT(idx<32);

	/* add handler to list of EP handlers */
	_apfnEPIntHandlers[idx / 2] = pfnHandler;
	
	/* enable EP interrupt */
	USBEpIntEn |= (1 << idx);
    4474:	e59fe038 	ldr	lr, [pc, #56]	; 44b4 <.text+0x44b4>
    4478:	e2003080 	and	r3, r0, #128	; 0x80
    447c:	e59ec034 	ldr	ip, [lr, #52]
    4480:	e200000f 	and	r0, r0, #15	; 0xf
    4484:	e1a033c3 	mov	r3, r3, asr #7
    4488:	e1833080 	orr	r3, r3, r0, lsl #1
    448c:	e3a02001 	mov	r2, #1	; 0x1
    4490:	e18cc312 	orr	ip, ip, r2, lsl r3
    4494:	e58ec034 	str	ip, [lr, #52]
	USBDevIntEn |= EP_SLOW;
    4498:	e59e3004 	ldr	r3, [lr, #4]
    449c:	e59f2014 	ldr	r2, [pc, #20]	; 44b8 <.text+0x44b8>
    44a0:	e3833004 	orr	r3, r3, #4	; 0x4
    44a4:	e7821100 	str	r1, [r2, r0, lsl #2]
    44a8:	e58e3004 	str	r3, [lr, #4]
	
	DBG("Registered handler for EP 0x%x\n", bEP);
}
    44ac:	e49de004 	ldr	lr, [sp], #4
    44b0:	e12fff1e 	bx	lr
    44b4:	e0090000 	and	r0, r9, r0
    44b8:	40000f38 	andmi	r0, r0, r8, lsr pc

000044bc <USBHwRegisterDevIntHandler>:


/**
	Registers an device status callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
	_pfnDevIntHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= DEV_STAT;
    44bc:	e59f3014 	ldr	r3, [pc, #20]	; 44d8 <.text+0x44d8>
    44c0:	e5932004 	ldr	r2, [r3, #4]
    44c4:	e59f1010 	ldr	r1, [pc, #16]	; 44dc <.text+0x44dc>
    44c8:	e3822008 	orr	r2, r2, #8	; 0x8
    44cc:	e5810000 	str	r0, [r1]
    44d0:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for device status\n");
}
    44d4:	e12fff1e 	bx	lr
    44d8:	e0090000 	and	r0, r9, r0
    44dc:	40000f34 	andmi	r0, r0, r4, lsr pc

000044e0 <USBHwRegisterFrameHandler>:


/**
	Registers the frame callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
	_pfnFrameHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= FRAME;
    44e0:	e59f3014 	ldr	r3, [pc, #20]	; 44fc <.text+0x44fc>
    44e4:	e5932004 	ldr	r2, [r3, #4]
    44e8:	e59f1010 	ldr	r1, [pc, #16]	; 4500 <.text+0x4500>
    44ec:	e3822001 	orr	r2, r2, #1	; 0x1
    44f0:	e5810000 	str	r0, [r1]
    44f4:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for frame\n");
}
    44f8:	e12fff1e 	bx	lr
    44fc:	e0090000 	and	r0, r9, r0
    4500:	40000f30 	andmi	r0, r0, r0, lsr pc

00004504 <USBHwSetAddress>:


/**
	Sets the USB address.
		
	@param [in]	bAddr		Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    4504:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
    4508:	e3811080 	orr	r1, r1, #128	; 0x80
    450c:	e3a000d0 	mov	r0, #208	; 0xd0
    4510:	eaffff9a 	b	4380 <USBHwCmdWrite>

00004514 <USBHwConnect>:
}


/**
	Connects or disconnects from the USB bus
		
	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
    4514:	e2501000 	subs	r1, r0, #0	; 0x0
    4518:	13a01001 	movne	r1, #1	; 0x1
    451c:	e3a000fe 	mov	r0, #254	; 0xfe
    4520:	eaffff96 	b	4380 <USBHwCmdWrite>

00004524 <USBHwNakIntEnable>:

}


/**
	Enables interrupt on NAK condition
		
	For IN endpoints a NAK is generated when the host wants to read data
	from the device, but none is available in the endpoint buffer.
	For OUT endpoints a NAK is generated when the host wants to write data
	to the device, but the endpoint buffer is still full.
	
	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
	from NAK interrupt by checking the bits in their bEPStatus argument.
	
	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
    4524:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
    4528:	e3a000f3 	mov	r0, #243	; 0xf3
    452c:	eaffff93 	b	4380 <USBHwCmdWrite>

00004530 <USBHwEPGetStatus>:
}


/**
	Gets the status from a specific endpoint.
		
	@param [in]	bEP		Endpoint number
	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8	USBHwEPGetStatus(U8 bEP)
{
    4530:	e1a03000 	mov	r3, r0
	int idx = EP2IDX(bEP);

	return USBHwCmdRead(CMD_EP_SELECT | idx);
    4534:	e2000080 	and	r0, r0, #128	; 0x80
    4538:	e203300f 	and	r3, r3, #15	; 0xf
    453c:	e1a003c0 	mov	r0, r0, asr #7
    4540:	e52de004 	str	lr, [sp, #-4]!
    4544:	e1800083 	orr	r0, r0, r3, lsl #1
    4548:	ebffff9e 	bl	43c8 <USBHwCmdRead>
}
    454c:	e49de004 	ldr	lr, [sp], #4
    4550:	e12fff1e 	bx	lr

00004554 <USBHwEPStall>:


/**
	Sets the stalled property of an endpoint
		
	@param [in]	bEP		Endpoint number
	@param [in]	fStall	TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
	int idx = EP2IDX(bEP);

	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
    4554:	e2003080 	and	r3, r0, #128	; 0x80
    4558:	e1a033c3 	mov	r3, r3, asr #7
    455c:	e200000f 	and	r0, r0, #15	; 0xf
    4560:	e1833080 	orr	r3, r3, r0, lsl #1
    4564:	e2511000 	subs	r1, r1, #0	; 0x0
    4568:	13a01001 	movne	r1, #1	; 0x1
    456c:	e3830040 	orr	r0, r3, #64	; 0x40
    4570:	eaffff82 	b	4380 <USBHwCmdWrite>

00004574 <USBHwEPWrite>:
}


/**
	Writes data to an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iLen	Number of bytes to write
			
	@return TRUE if the data was successfully written or <0 in case of error.
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
{
    4574:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	int idx;
	
	idx = EP2IDX(bEP);
    4578:	e200400f 	and	r4, r0, #15	; 0xf
	
	// set write enable for specific endpoint
	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
    457c:	e59fc074 	ldr	ip, [pc, #116]	; 45f8 <.text+0x45f8>
    4580:	e1a03104 	mov	r3, r4, lsl #2
    4584:	e3833002 	orr	r3, r3, #2	; 0x2
    4588:	e1a05002 	mov	r5, r2
	
	// set packet length
	USBTxPLen = iLen;
    458c:	e1a0e001 	mov	lr, r1
    4590:	e20000ff 	and	r0, r0, #255	; 0xff
    4594:	e58c3028 	str	r3, [ip, #40]
    4598:	e58c2024 	str	r2, [ip, #36]
    459c:	ea000008 	b	45c4 <USBHwEPWrite+0x50>
	
	// write data
	while (USBCtrl & WR_EN) {
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    45a0:	e55e3002 	ldrb	r3, [lr, #-2]
    45a4:	e55e2001 	ldrb	r2, [lr, #-1]
    45a8:	e55e1004 	ldrb	r1, [lr, #-4]
    45ac:	e1a03803 	mov	r3, r3, lsl #16
    45b0:	e1833c02 	orr	r3, r3, r2, lsl #24
    45b4:	e55e2003 	ldrb	r2, [lr, #-3]
    45b8:	e1833001 	orr	r3, r3, r1
    45bc:	e1833402 	orr	r3, r3, r2, lsl #8
    45c0:	e58c301c 	str	r3, [ip, #28]
    45c4:	e59fc02c 	ldr	ip, [pc, #44]	; 45f8 <.text+0x45f8>
    45c8:	e59c3028 	ldr	r3, [ip, #40]
    45cc:	e3130002 	tst	r3, #2	; 0x2
    45d0:	e28ee004 	add	lr, lr, #4	; 0x4
    45d4:	1afffff1 	bne	45a0 <USBHwEPWrite+0x2c>
		pbBuf += 4;
	}

	// select endpoint and validate buffer
	USBHwCmd(CMD_EP_SELECT | idx);
    45d8:	e1a003a0 	mov	r0, r0, lsr #7
    45dc:	e1800084 	orr	r0, r0, r4, lsl #1
    45e0:	ebffff57 	bl	4344 <USBHwCmd>
	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
    45e4:	e3a000fa 	mov	r0, #250	; 0xfa
    45e8:	ebffff55 	bl	4344 <USBHwCmd>
	
	return iLen;
}
    45ec:	e1a00005 	mov	r0, r5
    45f0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    45f4:	e12fff1e 	bx	lr
    45f8:	e0090000 	and	r0, r9, r0

000045fc <USBHwEPRead>:


/**
	Reads data from an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iMaxLen	Maximum number of bytes to read
			
	@return the number of bytes available in the EP (possibly more than iMaxLen),
	or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
{
    45fc:	e92d4010 	stmdb	sp!, {r4, lr}
	int i, idx;
	U32	dwData, dwLen;
	
	idx = EP2IDX(bEP);
    4600:	e200e00f 	and	lr, r0, #15	; 0xf
	
	// set read enable bit for specific endpoint
	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    4604:	e1a0310e 	mov	r3, lr, lsl #2
    4608:	e59fc08c 	ldr	ip, [pc, #140]	; 469c <.text+0x469c>
    460c:	e3833001 	orr	r3, r3, #1	; 0x1
    4610:	e58c3028 	str	r3, [ip, #40]
    4614:	e20000ff 	and	r0, r0, #255	; 0xff
	
	// wait for PKT_RDY
	do {
		dwLen = USBRxPLen;
    4618:	e59f307c 	ldr	r3, [pc, #124]	; 469c <.text+0x469c>
    461c:	e5933020 	ldr	r3, [r3, #32]
	} while ((dwLen & PKT_RDY) == 0);
    4620:	e3130b02 	tst	r3, #2048	; 0x800
    4624:	0afffffb 	beq	4618 <USBHwEPRead+0x1c>
	
	// packet valid?
	if ((dwLen & DV) == 0) {
    4628:	e3130b01 	tst	r3, #1024	; 0x400
    462c:	03e04000 	mvneq	r4, #0	; 0x0
    4630:	0a000016 	beq	4690 <USBHwEPRead+0x94>
		return -1;
	}
	
	// get length
	dwLen &= PKT_LNGTH_MASK;
    4634:	e1a0cb03 	mov	ip, r3, lsl #22
    4638:	e3a04000 	mov	r4, #0	; 0x0
    463c:	e1a0cb2c 	mov	ip, ip, lsr #22
    4640:	e1a03004 	mov	r3, r4
    4644:	ea000007 	b	4668 <USBHwEPRead+0x6c>
	
	// get data
	dwData = 0;
	for (i = 0; i < dwLen; i++) {
		if ((i % 4) == 0) {
    4648:	e3140003 	tst	r4, #3	; 0x3
			dwData = USBRxData;
    464c:	059f3048 	ldreq	r3, [pc, #72]	; 469c <.text+0x469c>
    4650:	05933018 	ldreq	r3, [r3, #24]
		}
		if ((pbBuf != NULL) && (i < iMaxLen)) {
    4654:	e3510000 	cmp	r1, #0	; 0x0
    4658:	11540002 	cmpne	r4, r2
			pbBuf[i] = dwData & 0xFF;
    465c:	b7c43001 	strltb	r3, [r4, r1]
		}
		dwData >>= 8;
    4660:	e1a03423 	mov	r3, r3, lsr #8
    4664:	e2844001 	add	r4, r4, #1	; 0x1
    4668:	e154000c 	cmp	r4, ip
    466c:	1afffff5 	bne	4648 <USBHwEPRead+0x4c>
	}

	// make sure RD_EN is clear
	USBCtrl = 0;
    4670:	e59f3024 	ldr	r3, [pc, #36]	; 469c <.text+0x469c>
    4674:	e3a02000 	mov	r2, #0	; 0x0

	// select endpoint and clear buffer
	USBHwCmd(CMD_EP_SELECT | idx);
    4678:	e1a003a0 	mov	r0, r0, lsr #7
    467c:	e180008e 	orr	r0, r0, lr, lsl #1
    4680:	e5832028 	str	r2, [r3, #40]
    4684:	ebffff2e 	bl	4344 <USBHwCmd>
	USBHwCmd(CMD_EP_CLEAR_BUFFER);
    4688:	e3a000f2 	mov	r0, #242	; 0xf2
    468c:	ebffff2c 	bl	4344 <USBHwCmd>
	
	return dwLen;
}
    4690:	e1a00004 	mov	r0, r4
    4694:	e8bd4010 	ldmia	sp!, {r4, lr}
    4698:	e12fff1e 	bx	lr
    469c:	e0090000 	and	r0, r9, r0

000046a0 <USBHwConfigDevice>:


/**
	Sets the 'configured' state.
		
	All registered endpoints are 'realised' and enabled, and the
	'configured' bit is set in the device status register.
		
	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
	// set configured bit
	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
    46a0:	e2501000 	subs	r1, r0, #0	; 0x0
    46a4:	13a01001 	movne	r1, #1	; 0x1
    46a8:	e3a000d8 	mov	r0, #216	; 0xd8
    46ac:	eaffff33 	b	4380 <USBHwCmdWrite>

000046b0 <USBHwISR>:
}


/**
	USB interrupt handler
		
	@todo Get all 11 bits of frame number instead of just 8

	Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
	U32	dwStatus;
	U32 dwIntBit;
	U8	bEPStat, bDevStat, bStat;
	int i;
	U16	wFrame;

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

	// handle device interrupts
	dwStatus = USBDevIntSt;
    46b0:	e59f2110 	ldr	r2, [pc, #272]	; 47c8 <.text+0x47c8>
    46b4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    46b8:	e5925000 	ldr	r5, [r2]
	
	// frame interrupt
	if (dwStatus & FRAME) {
    46bc:	e3150001 	tst	r5, #1	; 0x1
    46c0:	0a00000b 	beq	46f4 <USBHwISR+0x44>
		// clear int
		USBDevIntClr = FRAME;
		// call handler
		if (_pfnFrameHandler != NULL) {
    46c4:	e59f3100 	ldr	r3, [pc, #256]	; 47cc <.text+0x47cc>
    46c8:	e5934000 	ldr	r4, [r3]
    46cc:	e3a03001 	mov	r3, #1	; 0x1
    46d0:	e3540000 	cmp	r4, #0	; 0x0
    46d4:	e5823008 	str	r3, [r2, #8]
    46d8:	0a000005 	beq	46f4 <USBHwISR+0x44>
			wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
    46dc:	e3a000f5 	mov	r0, #245	; 0xf5
    46e0:	ebffff38 	bl	43c8 <USBHwCmdRead>
			_pfnFrameHandler(wFrame);
    46e4:	e1a00800 	mov	r0, r0, lsl #16
    46e8:	e1a00820 	mov	r0, r0, lsr #16
    46ec:	e1a0e00f 	mov	lr, pc
    46f0:	e12fff14 	bx	r4
		}
	}
	
	// device status interrupt
	if (dwStatus & DEV_STAT) {
    46f4:	e3150008 	tst	r5, #8	; 0x8
    46f8:	0a00000c 	beq	4730 <USBHwISR+0x80>
		/*	Clear DEV_STAT interrupt before reading DEV_STAT register.
			This prevents corrupted device status reads, see
			LPC2148 User manual revision 2, 25 july 2006.
		*/
		USBDevIntClr = DEV_STAT;
    46fc:	e59f30c4 	ldr	r3, [pc, #196]	; 47c8 <.text+0x47c8>
    4700:	e3a02008 	mov	r2, #8	; 0x8
		bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
    4704:	e3a000fe 	mov	r0, #254	; 0xfe
    4708:	e5832008 	str	r2, [r3, #8]
    470c:	ebffff2d 	bl	43c8 <USBHwCmdRead>
		if (bDevStat & (CON_CH | SUS_CH | RST)) {
    4710:	e310001a 	tst	r0, #26	; 0x1a
    4714:	0a000005 	beq	4730 <USBHwISR+0x80>
			// convert device status into something HW independent
			bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
					((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
					((bDevStat & RST) ? DEV_STATUS_RESET : 0);
			// call handler
			if (_pfnDevIntHandler != NULL) {
    4718:	e59f30b0 	ldr	r3, [pc, #176]	; 47d0 <.text+0x47d0>
    471c:	e5933000 	ldr	r3, [r3]
    4720:	e3530000 	cmp	r3, #0	; 0x0
DEBUG_LED_ON(8);		
				_pfnDevIntHandler(bStat);
    4724:	12000015 	andne	r0, r0, #21	; 0x15
    4728:	11a0e00f 	movne	lr, pc
    472c:	112fff13 	bxne	r3
DEBUG_LED_OFF(8);		
			}
		}
	}
	
	// endpoint interrupt
	if (dwStatus & EP_SLOW) {
    4730:	e3150004 	tst	r5, #4	; 0x4
    4734:	0a000021 	beq	47c0 <USBHwISR+0x110>
		// clear EP_SLOW
		USBDevIntClr = EP_SLOW;
    4738:	e59f3088 	ldr	r3, [pc, #136]	; 47c8 <.text+0x47c8>
    473c:	e3a02004 	mov	r2, #4	; 0x4
    4740:	e5832008 	str	r2, [r3, #8]
    4744:	e3a04000 	mov	r4, #0	; 0x0
		// check all endpoints
		for (i = 0; i < 32; i++) {
			dwIntBit = (1 << i);
    4748:	e3a03001 	mov	r3, #1	; 0x1
    474c:	e1a02413 	mov	r2, r3, lsl r4
			if (USBEpIntSt & dwIntBit) {
    4750:	e59f1070 	ldr	r1, [pc, #112]	; 47c8 <.text+0x47c8>
    4754:	e5913030 	ldr	r3, [r1, #48]
    4758:	e1130002 	tst	r3, r2
    475c:	0a000014 	beq	47b4 <USBHwISR+0x104>
				// clear int (and retrieve status)
				USBEpIntClr = dwIntBit;
    4760:	e5812038 	str	r2, [r1, #56]
    4764:	e59f105c 	ldr	r1, [pc, #92]	; 47c8 <.text+0x47c8>
    4768:	e5913000 	ldr	r3, [r1]
    476c:	e2030020 	and	r0, r3, #32	; 0x20
    4770:	e3500020 	cmp	r0, #32	; 0x20
    4774:	1afffffa 	bne	4764 <USBHwISR+0xb4>
				Wait4DevInt(CDFULL);
				bEPStat = USBCmdData;
				// convert EP pipe stat into something HW independent
				bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
						((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
						((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
						((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
						((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
				// call handler
				if (_apfnEPIntHandlers[i / 2] != NULL) {
    4778:	e0843fa4 	add	r3, r4, r4, lsr #31
    477c:	e59f2050 	ldr	r2, [pc, #80]	; 47d4 <.text+0x47d4>
    4780:	e1a030c3 	mov	r3, r3, asr #1
    4784:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    4788:	e5810008 	str	r0, [r1, #8]
    478c:	e3530000 	cmp	r3, #0	; 0x0
    4790:	e5911014 	ldr	r1, [r1, #20]
    4794:	0a000006 	beq	47b4 <USBHwISR+0x104>
DEBUG_LED_ON(10);		
					_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
    4798:	e1a000c4 	mov	r0, r4, asr #1
    479c:	e200000f 	and	r0, r0, #15	; 0xf
    47a0:	e1800384 	orr	r0, r0, r4, lsl #7
    47a4:	e200008f 	and	r0, r0, #143	; 0x8f
    47a8:	e201101f 	and	r1, r1, #31	; 0x1f
    47ac:	e1a0e00f 	mov	lr, pc
    47b0:	e12fff13 	bx	r3
    47b4:	e2844001 	add	r4, r4, #1	; 0x1
    47b8:	e3540020 	cmp	r4, #32	; 0x20
    47bc:	1affffe1 	bne	4748 <USBHwISR+0x98>
DEBUG_LED_OFF(10);
				}
			}
		}
	}
	
DEBUG_LED_OFF(9);		
}
    47c0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    47c4:	e12fff1e 	bx	lr
    47c8:	e0090000 	and	r0, r9, r0
    47cc:	40000f30 	andmi	r0, r0, r0, lsr pc
    47d0:	40000f34 	andmi	r0, r0, r4, lsr pc
    47d4:	40000f38 	andmi	r0, r0, r8, lsr pc

000047d8 <USBHwInit>:



/**
	Initialises the USB hardware
		
	This function assumes that the hardware is connected as shown in
	section 10.1 of the LPC2148 data sheet:
	* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
	* P0.23 is connected to USB VCC.
	
	Embedded artists board: make sure to disconnect P0.23 LED as it
	acts as a pull-up and so prevents detection of USB disconnect.
		
	@return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
	// configure P0.23 for Vbus sense
	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
    47d8:	e59f20b0 	ldr	r2, [pc, #176]	; 4890 <.text+0x4890>
    47dc:	e5923004 	ldr	r3, [r2, #4]
    47e0:	e3c33903 	bic	r3, r3, #49152	; 0xc000
    47e4:	e3833901 	orr	r3, r3, #16384	; 0x4000
    47e8:	e5823004 	str	r3, [r2, #4]
	// configure P0.31 for CONNECT
	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
    47ec:	e5923004 	ldr	r3, [r2, #4]
    47f0:	e3c33103 	bic	r3, r3, #-1073741824	; 0xc0000000
    47f4:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    47f8:	e5823004 	str	r3, [r2, #4]

	// enable PUSB
	PCONP |= (1 << 31);		
    47fc:	e282281d 	add	r2, r2, #1900544	; 0x1d0000
    4800:	e59230c4 	ldr	r3, [r2, #196]
    4804:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
    4808:	e58230c4 	str	r3, [r2, #196]
	
	// initialise PLL
	PLL1CON = 1;			// enable PLL
    480c:	e3a03001 	mov	r3, #1	; 0x1
    4810:	e58230a0 	str	r3, [r2, #160]
    4814:	e52de004 	str	lr, [sp, #-4]!
	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
    4818:	e2833022 	add	r3, r3, #34	; 0x22
    481c:	e58230a4 	str	r3, [r2, #164]
	PLL1FEED = 0xAA;
    4820:	e2833087 	add	r3, r3, #135	; 0x87
    4824:	e58230ac 	str	r3, [r2, #172]
	PLL1FEED = 0x55;
    4828:	e3a03055 	mov	r3, #85	; 0x55
    482c:	e58230ac 	str	r3, [r2, #172]
	while ((PLL1STAT & (1 << 10)) == 0);
    4830:	e59fe05c 	ldr	lr, [pc, #92]	; 4894 <.text+0x4894>
    4834:	e59e30a8 	ldr	r3, [lr, #168]
    4838:	e3130b01 	tst	r3, #1024	; 0x400
    483c:	0afffffb 	beq	4830 <USBHwInit+0x58>

	PLL1CON = 3;			// enable and connect
    4840:	e3a03003 	mov	r3, #3	; 0x3
    4844:	e58e30a0 	str	r3, [lr, #160]
	PLL1FEED = 0xAA;
	PLL1FEED = 0x55;
	
	// disable/clear all interrupts for now
	USBDevIntEn = 0;
    4848:	e59f2048 	ldr	r2, [pc, #72]	; 4898 <.text+0x4898>
    484c:	e28330a7 	add	r3, r3, #167	; 0xa7
    4850:	e58e30ac 	str	r3, [lr, #172]
    4854:	e3a01000 	mov	r1, #0	; 0x0
	USBDevIntClr = 0xFFFFFFFF;
    4858:	e3e0c000 	mvn	ip, #0	; 0x0
    485c:	e3a03055 	mov	r3, #85	; 0x55
    4860:	e58e30ac 	str	r3, [lr, #172]
	USBDevIntPri = 0;

	USBEpIntEn = 0;
	USBEpIntClr = 0xFFFFFFFF;
	USBEpIntPri = 0;

	// by default, only ACKs generate interrupts
	USBHwNakIntEnable(0);
    4864:	e1a00001 	mov	r0, r1
    4868:	e5821004 	str	r1, [r2, #4]
    486c:	e582c008 	str	ip, [r2, #8]
    4870:	e582102c 	str	r1, [r2, #44]
    4874:	e5821034 	str	r1, [r2, #52]
    4878:	e582c038 	str	ip, [r2, #56]
    487c:	e5821040 	str	r1, [r2, #64]
    4880:	ebffff27 	bl	4524 <USBHwNakIntEnable>
	
	// init debug leds
	DEBUG_LED_INIT(8);
	DEBUG_LED_INIT(9);
	DEBUG_LED_INIT(10);

	return TRUE;
}
    4884:	e3a00001 	mov	r0, #1	; 0x1
    4888:	e49de004 	ldr	lr, [sp], #4
    488c:	e12fff1e 	bx	lr
    4890:	e002c000 	and	ip, r2, r0
    4894:	e01fc000 	ands	ip, pc, r0
    4898:	e0090000 	and	r0, r9, r0

0000489c <_HandleRequest>:

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    489c:	e52de004 	str	lr, [sp, #-4]!
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
	pfnHandler = apfnReqHandlers[iType];
    48a0:	e5d03000 	ldrb	r3, [r0]
    48a4:	e59fc02c 	ldr	ip, [pc, #44]	; 48d8 <.text+0x48d8>
    48a8:	e1a032a3 	mov	r3, r3, lsr #5
    48ac:	e2033003 	and	r3, r3, #3	; 0x3
    48b0:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
	if (pfnHandler == NULL) {
    48b4:	e3530000 	cmp	r3, #0	; 0x0
    48b8:	e1a0c003 	mov	ip, r3
    48bc:	0a000002 	beq	48cc <_HandleRequest+0x30>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
	}

	return pfnHandler(pSetup, piLen, ppbData);
    48c0:	e1a0e00f 	mov	lr, pc
    48c4:	e12fff13 	bx	r3
    48c8:	e1a0c000 	mov	ip, r0
}
    48cc:	e1a0000c 	mov	r0, ip
    48d0:	e49de004 	ldr	lr, [sp], #4
    48d4:	e12fff1e 	bx	lr
    48d8:	40000f78 	andmi	r0, r0, r8, ror pc

000048dc <USBRegisterRequestHandler>:


/**
	Local function to stall the control endpoint
	
	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);

// dump setup packet
	DBG("STALL on [");
	pb = (U8 *)&Setup;
	for (i = 0; i < 8; i++) {
		DBG(" %02x", *pb++);
	}
	DBG("] stat=%x\n", bEPStat);
}


/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
	USBHwEPWrite(0x80, pbData, iChunk);
	pbData += iChunk;
	iResidue -= iChunk;
}


/**
 *	Handles IN/OUT transfers on EP0
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
	int iChunk, iType;

	if (bEP == 0x00) {
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
			pbData = apbDataStore[iType];
			iResidue = Setup.wLength;
			iLen = Setup.wLength;

			if ((Setup.wLength == 0) ||
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
					return;
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
				// send first part (possibly a zero-length status message)
				DataIn();
			}
		}
		else {		
			if (iResidue > 0) {
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
				if (iChunk < 0) {
					StallControlPipe(bEPStat);
					return;
				}
				pbData += iChunk;
				iResidue -= iChunk;
				if (iResidue == 0) {
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
					pbData = apbDataStore[iType];
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
						return;
					}
					// send status to host
					DataIn();
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}


/**
	Registers a callback for handling requests
		
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
	apbDataStore[iType] = pbDataStore;
    48dc:	e59f300c 	ldr	r3, [pc, #12]	; 48f0 <.text+0x48f0>
    48e0:	e7832100 	str	r2, [r3, r0, lsl #2]
    48e4:	e59f3008 	ldr	r3, [pc, #8]	; 48f4 <.text+0x48f4>
    48e8:	e7831100 	str	r1, [r3, r0, lsl #2]
}
    48ec:	e12fff1e 	bx	lr
    48f0:	40000f88 	andmi	r0, r0, r8, lsl #31
    48f4:	40000f78 	andmi	r0, r0, r8, ror pc

000048f8 <StallControlPipe>:
    48f8:	e52de004 	str	lr, [sp, #-4]!
    48fc:	e3a00080 	mov	r0, #128	; 0x80
    4900:	e3a01001 	mov	r1, #1	; 0x1
    4904:	ebffff12 	bl	4554 <USBHwEPStall>
    4908:	e49de004 	ldr	lr, [sp], #4
    490c:	e12fff1e 	bx	lr

00004910 <DataIn>:
    4910:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    4914:	e59f603c 	ldr	r6, [pc, #60]	; 4958 <.text+0x4958>
    4918:	e5964000 	ldr	r4, [r6]
    491c:	e59f5038 	ldr	r5, [pc, #56]	; 495c <.text+0x495c>
    4920:	e3540040 	cmp	r4, #64	; 0x40
    4924:	a3a04040 	movge	r4, #64	; 0x40
    4928:	e1a02004 	mov	r2, r4
    492c:	e3a00080 	mov	r0, #128	; 0x80
    4930:	e5951000 	ldr	r1, [r5]
    4934:	ebffff0e 	bl	4574 <USBHwEPWrite>
    4938:	e5953000 	ldr	r3, [r5]
    493c:	e5962000 	ldr	r2, [r6]
    4940:	e0833004 	add	r3, r3, r4
    4944:	e0642002 	rsb	r2, r4, r2
    4948:	e5853000 	str	r3, [r5]
    494c:	e5862000 	str	r2, [r6]
    4950:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
    4954:	e12fff1e 	bx	lr
    4958:	40000fa4 	andmi	r0, r0, r4, lsr #31
    495c:	40000fa0 	andmi	r0, r0, r0, lsr #31

00004960 <USBHandleControlTransfer>:
    4960:	e21000ff 	ands	r0, r0, #255	; 0xff
    4964:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    4968:	e20170ff 	and	r7, r1, #255	; 0xff
    496c:	1a000043 	bne	4a80 <USBHandleControlTransfer+0x120>
    4970:	e3110004 	tst	r1, #4	; 0x4
    4974:	e59f611c 	ldr	r6, [pc, #284]	; 4a98 <.text+0x4a98>
    4978:	0a00001d 	beq	49f4 <USBHandleControlTransfer+0x94>
    497c:	e59f5118 	ldr	r5, [pc, #280]	; 4a9c <.text+0x4a9c>
    4980:	e3a02008 	mov	r2, #8	; 0x8
    4984:	e1a01005 	mov	r1, r5
    4988:	ebffff1b 	bl	45fc <USBHwEPRead>
    498c:	e5d50000 	ldrb	r0, [r5]
    4990:	e59f2108 	ldr	r2, [pc, #264]	; 4aa0 <.text+0x4aa0>
    4994:	e1a032a0 	mov	r3, r0, lsr #5
    4998:	e1d510b6 	ldrh	r1, [r5, #6]
    499c:	e2033003 	and	r3, r3, #3	; 0x3
    49a0:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    49a4:	e59f40f8 	ldr	r4, [pc, #248]	; 4aa4 <.text+0x4aa4>
    49a8:	e59f20f8 	ldr	r2, [pc, #248]	; 4aa8 <.text+0x4aa8>
    49ac:	e3510000 	cmp	r1, #0	; 0x0
    49b0:	e5823000 	str	r3, [r2]
    49b4:	e5861000 	str	r1, [r6]
    49b8:	e5841000 	str	r1, [r4]
    49bc:	0a000001 	beq	49c8 <USBHandleControlTransfer+0x68>
    49c0:	e1b003a0 	movs	r0, r0, lsr #7
    49c4:	0a000031 	beq	4a90 <USBHandleControlTransfer+0x130>
    49c8:	e1a00005 	mov	r0, r5
    49cc:	e1a01004 	mov	r1, r4
    49d0:	ebffffb1 	bl	489c <_HandleRequest>
    49d4:	e3500000 	cmp	r0, #0	; 0x0
    49d8:	0a000021 	beq	4a64 <USBHandleControlTransfer+0x104>
    49dc:	e1d520b6 	ldrh	r2, [r5, #6]
    49e0:	e5943000 	ldr	r3, [r4]
    49e4:	e1520003 	cmp	r2, r3
    49e8:	d5862000 	strle	r2, [r6]
    49ec:	c5863000 	strgt	r3, [r6]
    49f0:	ea000024 	b	4a88 <USBHandleControlTransfer+0x128>
    49f4:	e5962000 	ldr	r2, [r6]
    49f8:	e3520000 	cmp	r2, #0	; 0x0
    49fc:	da00001b 	ble	4a70 <USBHandleControlTransfer+0x110>
    4a00:	e59f40a0 	ldr	r4, [pc, #160]	; 4aa8 <.text+0x4aa8>
    4a04:	e5941000 	ldr	r1, [r4]
    4a08:	ebfffefb 	bl	45fc <USBHwEPRead>
    4a0c:	e3500000 	cmp	r0, #0	; 0x0
    4a10:	ba000013 	blt	4a64 <USBHandleControlTransfer+0x104>
    4a14:	e5962000 	ldr	r2, [r6]
    4a18:	e5943000 	ldr	r3, [r4]
    4a1c:	e0602002 	rsb	r2, r0, r2
    4a20:	e0833000 	add	r3, r3, r0
    4a24:	e3520000 	cmp	r2, #0	; 0x0
    4a28:	e5843000 	str	r3, [r4]
    4a2c:	e5862000 	str	r2, [r6]
    4a30:	1a000016 	bne	4a90 <USBHandleControlTransfer+0x130>
    4a34:	e59f0060 	ldr	r0, [pc, #96]	; 4a9c <.text+0x4a9c>
    4a38:	e5d03000 	ldrb	r3, [r0]
    4a3c:	e59f205c 	ldr	r2, [pc, #92]	; 4aa0 <.text+0x4aa0>
    4a40:	e1a032a3 	mov	r3, r3, lsr #5
    4a44:	e2033003 	and	r3, r3, #3	; 0x3
    4a48:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    4a4c:	e59f1050 	ldr	r1, [pc, #80]	; 4aa4 <.text+0x4aa4>
    4a50:	e1a02004 	mov	r2, r4
    4a54:	e5843000 	str	r3, [r4]
    4a58:	ebffff8f 	bl	489c <_HandleRequest>
    4a5c:	e3500000 	cmp	r0, #0	; 0x0
    4a60:	1a000008 	bne	4a88 <USBHandleControlTransfer+0x128>
    4a64:	e1a00007 	mov	r0, r7
    4a68:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    4a6c:	eaffffa1 	b	48f8 <StallControlPipe>
    4a70:	e1a01000 	mov	r1, r0
    4a74:	e1a02000 	mov	r2, r0
    4a78:	ebfffedf 	bl	45fc <USBHwEPRead>
    4a7c:	ea000003 	b	4a90 <USBHandleControlTransfer+0x130>
    4a80:	e3500080 	cmp	r0, #128	; 0x80
    4a84:	1a000001 	bne	4a90 <USBHandleControlTransfer+0x130>
    4a88:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    4a8c:	eaffff9f 	b	4910 <DataIn>
    4a90:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    4a94:	e12fff1e 	bx	lr
    4a98:	40000fa4 	andmi	r0, r0, r4, lsr #31
    4a9c:	40000f98 	mulmi	r0, r8, pc
    4aa0:	40000f88 	andmi	r0, r0, r8, lsl #31
    4aa4:	40000fa8 	andmi	r0, r0, r8, lsr #31
    4aa8:	40000fa0 	andmi	r0, r0, r0, lsr #31

00004aac <USBRegisterDescriptors>:
 */
//void USBRegisterDescriptors(const U8 *pabDescriptors)
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
    4aac:	e59f3004 	ldr	r3, [pc, #4]	; 4ab8 <.text+0x4ab8>
    4ab0:	e5830000 	str	r0, [r3]
}
    4ab4:	e12fff1e 	bx	lr
    4ab8:	40000fb4 	strmih	r0, [r0], -r4

00004abc <USBGetDescriptor>:


/**
	Parses the list of installed USB descriptors and attempts to find
	the specified USB descriptor.
		
	@param [in]		wTypeIndex	Type and index of the descriptor
	@param [in]		wLangID		Language ID of the descriptor (currently unused)
	@param [out]	*piLen		Descriptor length
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    4abc:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	U8	bType, bIndex;
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
	pab = (U8 *)pabDescrip;
    4ac0:	e59f1074 	ldr	r1, [pc, #116]	; 4b3c <.text+0x4b3c>
    4ac4:	e1a00800 	mov	r0, r0, lsl #16
    4ac8:	e591c000 	ldr	ip, [r1]
    4acc:	e1a01820 	mov	r1, r0, lsr #16
    4ad0:	e1a05002 	mov	r5, r2
    4ad4:	e1a04003 	mov	r4, r3
    4ad8:	e1a0ec20 	mov	lr, r0, lsr #24
    4adc:	e20110ff 	and	r1, r1, #255	; 0xff
    4ae0:	e3a02000 	mov	r2, #0	; 0x0
    4ae4:	ea00000f 	b	4b28 <USBGetDescriptor+0x6c>
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
		if (pab[DESC_bDescriptorType] == bType) {
    4ae8:	e5dc3001 	ldrb	r3, [ip, #1]
    4aec:	e153000e 	cmp	r3, lr
    4af0:	1a00000b 	bne	4b24 <USBGetDescriptor+0x68>
			if (iCurIndex == bIndex) {
    4af4:	e1520001 	cmp	r2, r1
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
			}
			iCurIndex++;
    4af8:	e2822001 	add	r2, r2, #1	; 0x1
    4afc:	1a000008 	bne	4b24 <USBGetDescriptor+0x68>
    4b00:	e584c000 	str	ip, [r4]
    4b04:	e35e0002 	cmp	lr, #2	; 0x2
    4b08:	05dc2003 	ldreqb	r2, [ip, #3]
    4b0c:	05dc3002 	ldreqb	r3, [ip, #2]
    4b10:	15dc3000 	ldrneb	r3, [ip]
    4b14:	01833402 	orreq	r3, r3, r2, lsl #8
    4b18:	e3a00001 	mov	r0, #1	; 0x1
    4b1c:	e5853000 	str	r3, [r5]
    4b20:	ea000003 	b	4b34 <USBGetDescriptor+0x78>
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
    4b24:	e08cc000 	add	ip, ip, r0
    4b28:	e5dc0000 	ldrb	r0, [ip]
    4b2c:	e3500000 	cmp	r0, #0	; 0x0
    4b30:	1affffec 	bne	4ae8 <USBGetDescriptor+0x2c>
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
    4b34:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    4b38:	e12fff1e 	bx	lr
    4b3c:	40000fb4 	strmih	r0, [r0], -r4

00004b40 <USBRegisterCustomReqHandler>:


/**
	Configures the device according to the specified configuration index and
	alternate setting by parsing the installed USB descriptor list.
	A configuration index of 0 unconfigures the device.
		
	@param [in]		bConfigIndex	Configuration index
	@param [in]		bAltSetting		Alternate setting number
	
	@todo function always returns TRUE, add stricter checking?
	
	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
	U8	*pab;
	U8	bCurConfig, bCurAltSetting;
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
		// unconfigure device
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {

			switch (pab[DESC_bDescriptorType]) {

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
				break;

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
				break;

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
	}

	return TRUE;
}


/**
	Local function to handle a standard device request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
		*piLen = 1;
		break;

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_REMOTE_WAKEUP) {
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;

	case REQ_SET_DESCRIPTOR:
		DBG("Device req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Local function to handle a standard interface request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
		*piLen = 1;
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
			return FALSE;
		}
		*piLen = 0;
		break;

	default:
		DBG("Illegal interface req %d\n", pSetup->bRequest);
		return FALSE;
	}

	return TRUE;
}


/**
	Local function to handle a standard endpoint request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;

	case REQ_SYNCH_FRAME:
		DBG("EP req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal EP req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Default handler for standard ('chapter 9') requests
	
	If a custom request handler was installed, this handler is called first.
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}


/**
	Registers a callback for custom device requests
	
	In USBHandleStandardRequest, the custom request handler gets a first
	chance at handling the request before it is handed over to the 'chapter 9'
	request handler.
	
	This can be used for example in HID devices, where a REQ_GET_DESCRIPTOR
	request is sent to an interface, which is not covered by the 'chapter 9'
	specification.
		
	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
	pfnHandleCustomReq = pfnHandler;
    4b40:	e59f3004 	ldr	r3, [pc, #4]	; 4b4c <.text+0x4b4c>
    4b44:	e5830000 	str	r0, [r3]
}
    4b48:	e12fff1e 	bx	lr
    4b4c:	40000fac 	andmi	r0, r0, ip, lsr #31

00004b50 <USBHandleStandardRequest>:
    4b50:	e59f3264 	ldr	r3, [pc, #612]	; 4dbc <.text+0x4dbc>
    4b54:	e5933000 	ldr	r3, [r3]
    4b58:	e3530000 	cmp	r3, #0	; 0x0
    4b5c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4b60:	e1a05000 	mov	r5, r0
    4b64:	e1a08001 	mov	r8, r1
    4b68:	e1a07002 	mov	r7, r2
    4b6c:	0a000003 	beq	4b80 <USBHandleStandardRequest+0x30>
    4b70:	e1a0e00f 	mov	lr, pc
    4b74:	e12fff13 	bx	r3
    4b78:	e3500000 	cmp	r0, #0	; 0x0
    4b7c:	1a00001e 	bne	4bfc <.text+0x4bfc>
    4b80:	e5d53000 	ldrb	r3, [r5]
    4b84:	e203401f 	and	r4, r3, #31	; 0x1f
    4b88:	e3540001 	cmp	r4, #1	; 0x1
    4b8c:	0a00004e 	beq	4ccc <.text+0x4ccc>
    4b90:	e3540002 	cmp	r4, #2	; 0x2
    4b94:	0a000064 	beq	4d2c <.text+0x4d2c>
    4b98:	e3540000 	cmp	r4, #0	; 0x0
    4b9c:	1a000082 	bne	4dac <.text+0x4dac>
    4ba0:	e5d53001 	ldrb	r3, [r5, #1]
    4ba4:	e5971000 	ldr	r1, [r7]
    4ba8:	e3530009 	cmp	r3, #9	; 0x9
    4bac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    4bb0:	ea00007d 	b	4dac <.text+0x4dac>
    4bb4:	00004bdc 	ldreqd	r4, [r0], -ip
    4bb8:	00004dac 	andeq	r4, r0, ip, lsr #27
    4bbc:	00004dac 	andeq	r4, r0, ip, lsr #27
    4bc0:	00004dac 	andeq	r4, r0, ip, lsr #27
    4bc4:	00004dac 	andeq	r4, r0, ip, lsr #27
    4bc8:	00004bf4 	streqd	r4, [r0], -r4
    4bcc:	00004c04 	andeq	r4, r0, r4, lsl #24
    4bd0:	00004dac 	andeq	r4, r0, ip, lsr #27
    4bd4:	00004c1c 	andeq	r4, r0, ip, lsl ip
    4bd8:	00004c38 	andeq	r4, r0, r8, lsr ip
    4bdc:	e3a03000 	mov	r3, #0	; 0x0
    4be0:	e5c13001 	strb	r3, [r1, #1]
    4be4:	e5c13000 	strb	r3, [r1]
    4be8:	e3a0c001 	mov	ip, #1	; 0x1
    4bec:	e2833002 	add	r3, r3, #2	; 0x2
    4bf0:	ea00000e 	b	4c30 <.text+0x4c30>
    4bf4:	e5d50002 	ldrb	r0, [r5, #2]
    4bf8:	ebfffe41 	bl	4504 <USBHwSetAddress>
    4bfc:	e3a0c001 	mov	ip, #1	; 0x1
    4c00:	ea00006a 	b	4db0 <.text+0x4db0>
    4c04:	e1d510b4 	ldrh	r1, [r5, #4]
    4c08:	e1d500b2 	ldrh	r0, [r5, #2]
    4c0c:	e1a02008 	mov	r2, r8
    4c10:	e1a03007 	mov	r3, r7
    4c14:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    4c18:	eaffffa7 	b	4abc <USBGetDescriptor>
    4c1c:	e59f319c 	ldr	r3, [pc, #412]	; 4dc0 <.text+0x4dc0>
    4c20:	e5d32000 	ldrb	r2, [r3]
    4c24:	e3a03001 	mov	r3, #1	; 0x1
    4c28:	e5c12000 	strb	r2, [r1]
    4c2c:	e1a0c003 	mov	ip, r3
    4c30:	e5883000 	str	r3, [r8]
    4c34:	ea00005d 	b	4db0 <.text+0x4db0>
    4c38:	e5d56002 	ldrb	r6, [r5, #2]
    4c3c:	e3560000 	cmp	r6, #0	; 0x0
    4c40:	01a00006 	moveq	r0, r6
    4c44:	0a00001a 	beq	4cb4 <.text+0x4cb4>
    4c48:	e59f3174 	ldr	r3, [pc, #372]	; 4dc4 <.text+0x4dc4>
    4c4c:	e3a070ff 	mov	r7, #255	; 0xff
    4c50:	e5934000 	ldr	r4, [r3]
    4c54:	e1a08007 	mov	r8, r7
    4c58:	ea000011 	b	4ca4 <.text+0x4ca4>
    4c5c:	e5d43001 	ldrb	r3, [r4, #1]
    4c60:	e3530004 	cmp	r3, #4	; 0x4
    4c64:	05d47003 	ldreqb	r7, [r4, #3]
    4c68:	0a00000b 	beq	4c9c <.text+0x4c9c>
    4c6c:	e3530005 	cmp	r3, #5	; 0x5
    4c70:	0a000002 	beq	4c80 <.text+0x4c80>
    4c74:	e3530002 	cmp	r3, #2	; 0x2
    4c78:	05d48005 	ldreqb	r8, [r4, #5]
    4c7c:	ea000006 	b	4c9c <.text+0x4c9c>
    4c80:	e1580006 	cmp	r8, r6
    4c84:	03570000 	cmpeq	r7, #0	; 0x0
    4c88:	05d43004 	ldreqb	r3, [r4, #4]
    4c8c:	05d41005 	ldreqb	r1, [r4, #5]
    4c90:	05d40002 	ldreqb	r0, [r4, #2]
    4c94:	01831401 	orreq	r1, r3, r1, lsl #8
    4c98:	0bfffddd 	bleq	4414 <USBHwEPConfig>
    4c9c:	e5d43000 	ldrb	r3, [r4]
    4ca0:	e0844003 	add	r4, r4, r3
    4ca4:	e5d43000 	ldrb	r3, [r4]
    4ca8:	e3530000 	cmp	r3, #0	; 0x0
    4cac:	1affffea 	bne	4c5c <.text+0x4c5c>
    4cb0:	e3a00001 	mov	r0, #1	; 0x1
    4cb4:	ebfffe79 	bl	46a0 <USBHwConfigDevice>
    4cb8:	e1d520b2 	ldrh	r2, [r5, #2]
    4cbc:	e59f30fc 	ldr	r3, [pc, #252]	; 4dc0 <.text+0x4dc0>
    4cc0:	e3a0c001 	mov	ip, #1	; 0x1
    4cc4:	e5c32000 	strb	r2, [r3]
    4cc8:	ea000038 	b	4db0 <.text+0x4db0>
    4ccc:	e5d53001 	ldrb	r3, [r5, #1]
    4cd0:	e3530000 	cmp	r3, #0	; 0x0
    4cd4:	e5972000 	ldr	r2, [r7]
    4cd8:	0a000004 	beq	4cf0 <.text+0x4cf0>
    4cdc:	e353000a 	cmp	r3, #10	; 0xa
    4ce0:	0a000007 	beq	4d04 <.text+0x4d04>
    4ce4:	e353000b 	cmp	r3, #11	; 0xb
    4ce8:	1a00002f 	bne	4dac <.text+0x4dac>
    4cec:	ea000008 	b	4d14 <.text+0x4d14>
    4cf0:	e5c23001 	strb	r3, [r2, #1]
    4cf4:	e5c23000 	strb	r3, [r2]
    4cf8:	e1a0c004 	mov	ip, r4
    4cfc:	e3a03002 	mov	r3, #2	; 0x2
    4d00:	eaffffca 	b	4c30 <.text+0x4c30>
    4d04:	e3a03000 	mov	r3, #0	; 0x0
    4d08:	e1a0c004 	mov	ip, r4
    4d0c:	e5c23000 	strb	r3, [r2]
    4d10:	ea000015 	b	4d6c <.text+0x4d6c>
    4d14:	e1d500b2 	ldrh	r0, [r5, #2]
    4d18:	e3500000 	cmp	r0, #0	; 0x0
    4d1c:	03a0c001 	moveq	ip, #1	; 0x1
    4d20:	05880000 	streq	r0, [r8]
    4d24:	0a000021 	beq	4db0 <.text+0x4db0>
    4d28:	ea00001f 	b	4dac <.text+0x4dac>
    4d2c:	e5d56001 	ldrb	r6, [r5, #1]
    4d30:	e3560001 	cmp	r6, #1	; 0x1
    4d34:	e5977000 	ldr	r7, [r7]
    4d38:	0a00000d 	beq	4d74 <.text+0x4d74>
    4d3c:	3a000002 	bcc	4d4c <.text+0x4d4c>
    4d40:	e3560003 	cmp	r6, #3	; 0x3
    4d44:	1a000018 	bne	4dac <.text+0x4dac>
    4d48:	ea000010 	b	4d90 <.text+0x4d90>
    4d4c:	e5d50004 	ldrb	r0, [r5, #4]
    4d50:	ebfffdf6 	bl	4530 <USBHwEPGetStatus>
    4d54:	e1a000a0 	mov	r0, r0, lsr #1
    4d58:	e2000001 	and	r0, r0, #1	; 0x1
    4d5c:	e3a03000 	mov	r3, #0	; 0x0
    4d60:	e5c73001 	strb	r3, [r7, #1]
    4d64:	e5c70000 	strb	r0, [r7]
    4d68:	e3a0c001 	mov	ip, #1	; 0x1
    4d6c:	e5884000 	str	r4, [r8]
    4d70:	ea00000e 	b	4db0 <.text+0x4db0>
    4d74:	e1d510b2 	ldrh	r1, [r5, #2]
    4d78:	e3510000 	cmp	r1, #0	; 0x0
    4d7c:	1a00000a 	bne	4dac <.text+0x4dac>
    4d80:	e5d50004 	ldrb	r0, [r5, #4]
    4d84:	ebfffdf2 	bl	4554 <USBHwEPStall>
    4d88:	e1a0c006 	mov	ip, r6
    4d8c:	ea000007 	b	4db0 <.text+0x4db0>
    4d90:	e1d530b2 	ldrh	r3, [r5, #2]
    4d94:	e3530000 	cmp	r3, #0	; 0x0
    4d98:	1a000003 	bne	4dac <.text+0x4dac>
    4d9c:	e5d50004 	ldrb	r0, [r5, #4]
    4da0:	e3a01001 	mov	r1, #1	; 0x1
    4da4:	ebfffdea 	bl	4554 <USBHwEPStall>
    4da8:	eaffff93 	b	4bfc <.text+0x4bfc>
    4dac:	e3a0c000 	mov	ip, #0	; 0x0
    4db0:	e1a0000c 	mov	r0, ip
    4db4:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    4db8:	e12fff1e 	bx	lr
    4dbc:	40000fac 	andmi	r0, r0, ip, lsr #31
    4dc0:	40000fb0 	strmih	r0, [r0], -r0
    4dc4:	40000fb4 	strmih	r0, [r0], -r4

00004dc8 <free>:
    4dc8:	e59f3014 	ldr	r3, [pc, #20]	; 4de4 <.text+0x4de4>
    4dcc:	e1a01000 	mov	r1, r0
    4dd0:	e52de004 	str	lr, [sp, #-4]!
    4dd4:	e5930000 	ldr	r0, [r3]
    4dd8:	eb000256 	bl	5738 <_free_r>
    4ddc:	e49de004 	ldr	lr, [sp], #4
    4de0:	e12fff1e 	bx	lr
    4de4:	400006c8 	andmi	r0, r0, r8, asr #13

00004de8 <malloc>:
    4de8:	e59f3014 	ldr	r3, [pc, #20]	; 4e04 <.text+0x4e04>
    4dec:	e1a01000 	mov	r1, r0
    4df0:	e52de004 	str	lr, [sp, #-4]!
    4df4:	e5930000 	ldr	r0, [r3]
    4df8:	eb000002 	bl	4e08 <_malloc_r>
    4dfc:	e49de004 	ldr	lr, [sp], #4
    4e00:	e12fff1e 	bx	lr
    4e04:	400006c8 	andmi	r0, r0, r8, asr #13

00004e08 <_malloc_r>:
    4e08:	e281300b 	add	r3, r1, #11	; 0xb
    4e0c:	e3530016 	cmp	r3, #22	; 0x16
    4e10:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4e14:	93a08010 	movls	r8, #16	; 0x10
    4e18:	83c38007 	bichi	r8, r3, #7	; 0x7
    4e1c:	e1580001 	cmp	r8, r1
    4e20:	23a03000 	movcs	r3, #0	; 0x0
    4e24:	33a03001 	movcc	r3, #1	; 0x1
    4e28:	e1933fa8 	orrs	r3, r3, r8, lsr #31
    4e2c:	e1a0a000 	mov	sl, r0
    4e30:	13a0300c 	movne	r3, #12	; 0xc
    4e34:	13a00000 	movne	r0, #0	; 0x0
    4e38:	158a3000 	strne	r3, [sl]
    4e3c:	1a00018a 	bne	546c <_malloc_r+0x664>
    4e40:	e1a0000a 	mov	r0, sl
    4e44:	eb0001a0 	bl	54cc <__malloc_lock>
    4e48:	e3580f7e 	cmp	r8, #504	; 0x1f8
    4e4c:	2a000011 	bcs	4e98 <_malloc_r+0x90>
    4e50:	e59f361c 	ldr	r3, [pc, #1564]	; 5474 <.text+0x5474>
    4e54:	e1a021a8 	mov	r2, r8, lsr #3
    4e58:	e0833182 	add	r3, r3, r2, lsl #3
    4e5c:	e593400c 	ldr	r4, [r3, #12]
    4e60:	e1540003 	cmp	r4, r3
    4e64:	1a000003 	bne	4e78 <_malloc_r+0x70>
    4e68:	e2843008 	add	r3, r4, #8	; 0x8
    4e6c:	e593400c 	ldr	r4, [r3, #12]
    4e70:	e1540003 	cmp	r4, r3
    4e74:	0a000005 	beq	4e90 <_malloc_r+0x88>
    4e78:	e5943004 	ldr	r3, [r4, #4]
    4e7c:	e3c33003 	bic	r3, r3, #3	; 0x3
    4e80:	e0843003 	add	r3, r4, r3
    4e84:	e5932004 	ldr	r2, [r3, #4]
    4e88:	e594000c 	ldr	r0, [r4, #12]
    4e8c:	ea00016e 	b	544c <_malloc_r+0x644>
    4e90:	e2825002 	add	r5, r2, #2	; 0x2
    4e94:	ea00002a 	b	4f44 <_malloc_r+0x13c>
    4e98:	e1b024a8 	movs	r2, r8, lsr #9
    4e9c:	01a021a8 	moveq	r2, r8, lsr #3
    4ea0:	0a000017 	beq	4f04 <_malloc_r+0xfc>
    4ea4:	e3520004 	cmp	r2, #4	; 0x4
    4ea8:	91a03328 	movls	r3, r8, lsr #6
    4eac:	92832038 	addls	r2, r3, #56	; 0x38
    4eb0:	9a000013 	bls	4f04 <_malloc_r+0xfc>
    4eb4:	e3520014 	cmp	r2, #20	; 0x14
    4eb8:	9282205b 	addls	r2, r2, #91	; 0x5b
    4ebc:	9a000010 	bls	4f04 <_malloc_r+0xfc>
    4ec0:	e3520054 	cmp	r2, #84	; 0x54
    4ec4:	91a03628 	movls	r3, r8, lsr #12
    4ec8:	9283206e 	addls	r2, r3, #110	; 0x6e
    4ecc:	9a00000c 	bls	4f04 <_malloc_r+0xfc>
    4ed0:	e3520f55 	cmp	r2, #340	; 0x154
    4ed4:	91a037a8 	movls	r3, r8, lsr #15
    4ed8:	92832077 	addls	r2, r3, #119	; 0x77
    4edc:	9a000008 	bls	4f04 <_malloc_r+0xfc>
    4ee0:	e59f3590 	ldr	r3, [pc, #1424]	; 5478 <.text+0x5478>
    4ee4:	e1520003 	cmp	r2, r3
    4ee8:	83a0207e 	movhi	r2, #126	; 0x7e
    4eec:	8a000004 	bhi	4f04 <_malloc_r+0xfc>
    4ef0:	ea000001 	b	4efc <_malloc_r+0xf4>
    4ef4:	e2422001 	sub	r2, r2, #1	; 0x1
    4ef8:	ea000010 	b	4f40 <_malloc_r+0x138>
    4efc:	e1a03928 	mov	r3, r8, lsr #18
    4f00:	e283207c 	add	r2, r3, #124	; 0x7c
    4f04:	e59f3568 	ldr	r3, [pc, #1384]	; 5474 <.text+0x5474>
    4f08:	e083c182 	add	ip, r3, r2, lsl #3
    4f0c:	e59c400c 	ldr	r4, [ip, #12]
    4f10:	ea000008 	b	4f38 <_malloc_r+0x130>
    4f14:	e5943004 	ldr	r3, [r4, #4]
    4f18:	e3c33003 	bic	r3, r3, #3	; 0x3
    4f1c:	e0681003 	rsb	r1, r8, r3
    4f20:	e351000f 	cmp	r1, #15	; 0xf
    4f24:	cafffff2 	bgt	4ef4 <_malloc_r+0xec>
    4f28:	e3510000 	cmp	r1, #0	; 0x0
    4f2c:	e594000c 	ldr	r0, [r4, #12]
    4f30:	aa000143 	bge	5444 <_malloc_r+0x63c>
    4f34:	e1a04000 	mov	r4, r0
    4f38:	e154000c 	cmp	r4, ip
    4f3c:	1afffff4 	bne	4f14 <_malloc_r+0x10c>
    4f40:	e2825001 	add	r5, r2, #1	; 0x1
    4f44:	e59fb528 	ldr	fp, [pc, #1320]	; 5474 <.text+0x5474>
    4f48:	e28b7008 	add	r7, fp, #8	; 0x8
    4f4c:	e5974008 	ldr	r4, [r7, #8]
    4f50:	e1540007 	cmp	r4, r7
    4f54:	0a000054 	beq	50ac <_malloc_r+0x2a4>
    4f58:	e5943004 	ldr	r3, [r4, #4]
    4f5c:	e3c32003 	bic	r2, r3, #3	; 0x3
    4f60:	e0680002 	rsb	r0, r8, r2
    4f64:	e350000f 	cmp	r0, #15	; 0xf
    4f68:	da000009 	ble	4f94 <_malloc_r+0x18c>
    4f6c:	e0842008 	add	r2, r4, r8
    4f70:	e3883001 	orr	r3, r8, #1	; 0x1
    4f74:	e3801001 	orr	r1, r0, #1	; 0x1
    4f78:	e5843004 	str	r3, [r4, #4]
    4f7c:	e587200c 	str	r2, [r7, #12]
    4f80:	e5872008 	str	r2, [r7, #8]
    4f84:	e7820000 	str	r0, [r2, r0]
    4f88:	e9820082 	stmib	r2, {r1, r7}
    4f8c:	e582700c 	str	r7, [r2, #12]
    4f90:	ea000132 	b	5460 <_malloc_r+0x658>
    4f94:	e3500000 	cmp	r0, #0	; 0x0
    4f98:	e587700c 	str	r7, [r7, #12]
    4f9c:	e5877008 	str	r7, [r7, #8]
    4fa0:	a0842002 	addge	r2, r4, r2
    4fa4:	a5923004 	ldrge	r3, [r2, #4]
    4fa8:	a3833001 	orrge	r3, r3, #1	; 0x1
    4fac:	a5823004 	strge	r3, [r2, #4]
    4fb0:	aa00012a 	bge	5460 <_malloc_r+0x658>
    4fb4:	e3520c02 	cmp	r2, #512	; 0x200
    4fb8:	2a00000c 	bcs	4ff0 <_malloc_r+0x1e8>
    4fbc:	e1a011a2 	mov	r1, r2, lsr #3
    4fc0:	e59b2004 	ldr	r2, [fp, #4]
    4fc4:	e1a00121 	mov	r0, r1, lsr #2
    4fc8:	e3a03001 	mov	r3, #1	; 0x1
    4fcc:	e1822013 	orr	r2, r2, r3, lsl r0
    4fd0:	e08b1181 	add	r1, fp, r1, lsl #3
    4fd4:	e5913008 	ldr	r3, [r1, #8]
    4fd8:	e584100c 	str	r1, [r4, #12]
    4fdc:	e5843008 	str	r3, [r4, #8]
    4fe0:	e58b2004 	str	r2, [fp, #4]
    4fe4:	e583400c 	str	r4, [r3, #12]
    4fe8:	e5814008 	str	r4, [r1, #8]
    4fec:	ea00002e 	b	50ac <_malloc_r+0x2a4>
    4ff0:	e1b014a2 	movs	r1, r2, lsr #9
    4ff4:	01a011a2 	moveq	r1, r2, lsr #3
    4ff8:	0a000013 	beq	504c <_malloc_r+0x244>
    4ffc:	e3510004 	cmp	r1, #4	; 0x4
    5000:	91a03322 	movls	r3, r2, lsr #6
    5004:	92831038 	addls	r1, r3, #56	; 0x38
    5008:	9a00000f 	bls	504c <_malloc_r+0x244>
    500c:	e3510014 	cmp	r1, #20	; 0x14
    5010:	9281105b 	addls	r1, r1, #91	; 0x5b
    5014:	9a00000c 	bls	504c <_malloc_r+0x244>
    5018:	e3510054 	cmp	r1, #84	; 0x54
    501c:	91a03622 	movls	r3, r2, lsr #12
    5020:	9283106e 	addls	r1, r3, #110	; 0x6e
    5024:	9a000008 	bls	504c <_malloc_r+0x244>
    5028:	e3510f55 	cmp	r1, #340	; 0x154
    502c:	91a037a2 	movls	r3, r2, lsr #15
    5030:	92831077 	addls	r1, r3, #119	; 0x77
    5034:	9a000004 	bls	504c <_malloc_r+0x244>
    5038:	e59f3438 	ldr	r3, [pc, #1080]	; 5478 <.text+0x5478>
    503c:	e1510003 	cmp	r1, r3
    5040:	91a03922 	movls	r3, r2, lsr #18
    5044:	83a0107e 	movhi	r1, #126	; 0x7e
    5048:	9283107c 	addls	r1, r3, #124	; 0x7c
    504c:	e08b0181 	add	r0, fp, r1, lsl #3
    5050:	e590c008 	ldr	ip, [r0, #8]
    5054:	e15c0000 	cmp	ip, r0
    5058:	1a00000a 	bne	5088 <_malloc_r+0x280>
    505c:	e59f0410 	ldr	r0, [pc, #1040]	; 5474 <.text+0x5474>
    5060:	e5902004 	ldr	r2, [r0, #4]
    5064:	e1a01121 	mov	r1, r1, lsr #2
    5068:	e3a03001 	mov	r3, #1	; 0x1
    506c:	e1822113 	orr	r2, r2, r3, lsl r1
    5070:	e1a0e00c 	mov	lr, ip
    5074:	e5802004 	str	r2, [r0, #4]
    5078:	ea000007 	b	509c <_malloc_r+0x294>
    507c:	e59cc008 	ldr	ip, [ip, #8]
    5080:	e15c0000 	cmp	ip, r0
    5084:	0a000003 	beq	5098 <_malloc_r+0x290>
    5088:	e59c3004 	ldr	r3, [ip, #4]
    508c:	e3c33003 	bic	r3, r3, #3	; 0x3
    5090:	e1520003 	cmp	r2, r3
    5094:	3afffff8 	bcc	507c <_malloc_r+0x274>
    5098:	e59ce00c 	ldr	lr, [ip, #12]
    509c:	e584e00c 	str	lr, [r4, #12]
    50a0:	e584c008 	str	ip, [r4, #8]
    50a4:	e58c400c 	str	r4, [ip, #12]
    50a8:	e58e4008 	str	r4, [lr, #8]
    50ac:	e3550000 	cmp	r5, #0	; 0x0
    50b0:	e2853003 	add	r3, r5, #3	; 0x3
    50b4:	a1a03005 	movge	r3, r5
    50b8:	e1a03143 	mov	r3, r3, asr #2
    50bc:	e3a02001 	mov	r2, #1	; 0x1
    50c0:	e1a02312 	mov	r2, r2, lsl r3
    50c4:	e59f93a8 	ldr	r9, [pc, #936]	; 5474 <.text+0x5474>
    50c8:	e5991004 	ldr	r1, [r9, #4]
    50cc:	e1520001 	cmp	r2, r1
    50d0:	8a000037 	bhi	51b4 <_malloc_r+0x3ac>
    50d4:	e1120001 	tst	r2, r1
    50d8:	01a02082 	moveq	r2, r2, lsl #1
    50dc:	03c53003 	biceq	r3, r5, #3	; 0x3
    50e0:	0a000001 	beq	50ec <_malloc_r+0x2e4>
    50e4:	ea000004 	b	50fc <_malloc_r+0x2f4>
    50e8:	e1a02082 	mov	r2, r2, lsl #1
    50ec:	e1120001 	tst	r2, r1
    50f0:	e2833004 	add	r3, r3, #4	; 0x4
    50f4:	0afffffb 	beq	50e8 <_malloc_r+0x2e0>
    50f8:	e1a05003 	mov	r5, r3
    50fc:	e08b6185 	add	r6, fp, r5, lsl #3
    5100:	e1a0e005 	mov	lr, r5
    5104:	e1a01006 	mov	r1, r6
    5108:	e591400c 	ldr	r4, [r1, #12]
    510c:	ea000008 	b	5134 <_malloc_r+0x32c>
    5110:	e5943004 	ldr	r3, [r4, #4]
    5114:	e3c33003 	bic	r3, r3, #3	; 0x3
    5118:	e068c003 	rsb	ip, r8, r3
    511c:	e35c000f 	cmp	ip, #15	; 0xf
    5120:	ca0000ad 	bgt	53dc <_malloc_r+0x5d4>
    5124:	e35c0000 	cmp	ip, #0	; 0x0
    5128:	e594000c 	ldr	r0, [r4, #12]
    512c:	aa0000b9 	bge	5418 <_malloc_r+0x610>
    5130:	e1a04000 	mov	r4, r0
    5134:	e1540001 	cmp	r4, r1
    5138:	1afffff4 	bne	5110 <_malloc_r+0x308>
    513c:	e28ee001 	add	lr, lr, #1	; 0x1
    5140:	e31e0003 	tst	lr, #3	; 0x3
    5144:	12841008 	addne	r1, r4, #8	; 0x8
    5148:	1affffee 	bne	5108 <_malloc_r+0x300>
    514c:	e1a00005 	mov	r0, r5
    5150:	e1a01006 	mov	r1, r6
    5154:	e3100003 	tst	r0, #3	; 0x3
    5158:	e2411008 	sub	r1, r1, #8	; 0x8
    515c:	e2400001 	sub	r0, r0, #1	; 0x1
    5160:	0a00000f 	beq	51a4 <_malloc_r+0x39c>
    5164:	e5913008 	ldr	r3, [r1, #8]
    5168:	e1530001 	cmp	r3, r1
    516c:	0afffff8 	beq	5154 <_malloc_r+0x34c>
    5170:	e5993004 	ldr	r3, [r9, #4]
    5174:	e1a02082 	mov	r2, r2, lsl #1
    5178:	e1520003 	cmp	r2, r3
    517c:	8a00000c 	bhi	51b4 <_malloc_r+0x3ac>
    5180:	e3520000 	cmp	r2, #0	; 0x0
    5184:	0a00000a 	beq	51b4 <_malloc_r+0x3ac>
    5188:	e1a0500e 	mov	r5, lr
    518c:	ea000001 	b	5198 <_malloc_r+0x390>
    5190:	e2855004 	add	r5, r5, #4	; 0x4
    5194:	e1a02082 	mov	r2, r2, lsl #1
    5198:	e1120003 	tst	r2, r3
    519c:	0afffffb 	beq	5190 <_malloc_r+0x388>
    51a0:	eaffffd5 	b	50fc <_malloc_r+0x2f4>
    51a4:	e5993004 	ldr	r3, [r9, #4]
    51a8:	e1c33002 	bic	r3, r3, r2
    51ac:	e5893004 	str	r3, [r9, #4]
    51b0:	eaffffee 	b	5170 <_malloc_r+0x368>
    51b4:	e5996008 	ldr	r6, [r9, #8]
    51b8:	e5963004 	ldr	r3, [r6, #4]
    51bc:	e3c37003 	bic	r7, r3, #3	; 0x3
    51c0:	e0681007 	rsb	r1, r8, r7
    51c4:	e351000f 	cmp	r1, #15	; 0xf
    51c8:	c3a03000 	movgt	r3, #0	; 0x0
    51cc:	d3a03001 	movle	r3, #1	; 0x1
    51d0:	e1570008 	cmp	r7, r8
    51d4:	33833001 	orrcc	r3, r3, #1	; 0x1
    51d8:	e3530000 	cmp	r3, #0	; 0x0
    51dc:	0a000070 	beq	53a4 <_malloc_r+0x59c>
    51e0:	e59f3294 	ldr	r3, [pc, #660]	; 547c <.text+0x547c>
    51e4:	e5932000 	ldr	r2, [r3]
    51e8:	e59f3290 	ldr	r3, [pc, #656]	; 5480 <.text+0x5480>
    51ec:	e5933000 	ldr	r3, [r3]
    51f0:	e2822010 	add	r2, r2, #16	; 0x10
    51f4:	e3730001 	cmn	r3, #1	; 0x1
    51f8:	e0884002 	add	r4, r8, r2
    51fc:	12843eff 	addne	r3, r4, #4080	; 0xff0
    5200:	1283300f 	addne	r3, r3, #15	; 0xf
    5204:	13c34eff 	bicne	r4, r3, #4080	; 0xff0
    5208:	13c4400f 	bicne	r4, r4, #15	; 0xf
    520c:	e1a0000a 	mov	r0, sl
    5210:	e1a01004 	mov	r1, r4
    5214:	ebffec50 	bl	35c <_sbrk_r>
    5218:	e3700001 	cmn	r0, #1	; 0x1
    521c:	0a000051 	beq	5368 <_malloc_r+0x560>
    5220:	e086c007 	add	ip, r6, r7
    5224:	e150000c 	cmp	r0, ip
    5228:	e1a05000 	mov	r5, r0
    522c:	2a000002 	bcs	523c <_malloc_r+0x434>
    5230:	e1560009 	cmp	r6, r9
    5234:	1a00004b 	bne	5368 <_malloc_r+0x560>
    5238:	ea000062 	b	53c8 <_malloc_r+0x5c0>
    523c:	e59f2240 	ldr	r2, [pc, #576]	; 5484 <.text+0x5484>
    5240:	e5923000 	ldr	r3, [r2]
    5244:	e0841003 	add	r1, r4, r3
    5248:	e5821000 	str	r1, [r2]
    524c:	1a000007 	bne	5270 <_malloc_r+0x468>
    5250:	e1a03a00 	mov	r3, r0, lsl #20
    5254:	e1a03a23 	mov	r3, r3, lsr #20
    5258:	e3530000 	cmp	r3, #0	; 0x0
    525c:	00843007 	addeq	r3, r4, r7
    5260:	05992008 	ldreq	r2, [r9, #8]
    5264:	03833001 	orreq	r3, r3, #1	; 0x1
    5268:	05823004 	streq	r3, [r2, #4]
    526c:	0a000033 	beq	5340 <_malloc_r+0x538>
    5270:	e59f2208 	ldr	r2, [pc, #520]	; 5480 <.text+0x5480>
    5274:	e5923000 	ldr	r3, [r2]
    5278:	e3730001 	cmn	r3, #1	; 0x1
    527c:	106c3000 	rsbne	r3, ip, r0
    5280:	159f21fc 	ldrne	r2, [pc, #508]	; 5484 <.text+0x5484>
    5284:	10813003 	addne	r3, r1, r3
    5288:	05820000 	streq	r0, [r2]
    528c:	15823000 	strne	r3, [r2]
    5290:	e2103007 	ands	r3, r0, #7	; 0x7
    5294:	12631008 	rsbne	r1, r3, #8	; 0x8
    5298:	10805001 	addne	r5, r0, r1
    529c:	01a01003 	moveq	r1, r3
    52a0:	e0853004 	add	r3, r5, r4
    52a4:	e1a03a03 	mov	r3, r3, lsl #20
    52a8:	e1a03a23 	mov	r3, r3, lsr #20
    52ac:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
    52b0:	e0814003 	add	r4, r1, r3
    52b4:	e1a01004 	mov	r1, r4
    52b8:	e1a0000a 	mov	r0, sl
    52bc:	ebffec26 	bl	35c <_sbrk_r>
    52c0:	e59f31bc 	ldr	r3, [pc, #444]	; 5484 <.text+0x5484>
    52c4:	e3700001 	cmn	r0, #1	; 0x1
    52c8:	01a00005 	moveq	r0, r5
    52cc:	03a04000 	moveq	r4, #0	; 0x0
    52d0:	e5931000 	ldr	r1, [r3]
    52d4:	e0652000 	rsb	r2, r5, r0
    52d8:	e0822004 	add	r2, r2, r4
    52dc:	e0811004 	add	r1, r1, r4
    52e0:	e3822001 	orr	r2, r2, #1	; 0x1
    52e4:	e1560009 	cmp	r6, r9
    52e8:	e5831000 	str	r1, [r3]
    52ec:	e5852004 	str	r2, [r5, #4]
    52f0:	e5895008 	str	r5, [r9, #8]
    52f4:	0a000011 	beq	5340 <_malloc_r+0x538>
    52f8:	e357000f 	cmp	r7, #15	; 0xf
    52fc:	93a03001 	movls	r3, #1	; 0x1
    5300:	95853004 	strls	r3, [r5, #4]
    5304:	9a000017 	bls	5368 <_malloc_r+0x560>
    5308:	e5963004 	ldr	r3, [r6, #4]
    530c:	e247200c 	sub	r2, r7, #12	; 0xc
    5310:	e3c22007 	bic	r2, r2, #7	; 0x7
    5314:	e2033001 	and	r3, r3, #1	; 0x1
    5318:	e1833002 	orr	r3, r3, r2
    531c:	e3a01005 	mov	r1, #5	; 0x5
    5320:	e352000f 	cmp	r2, #15	; 0xf
    5324:	e0862002 	add	r2, r6, r2
    5328:	e5863004 	str	r3, [r6, #4]
    532c:	e5821008 	str	r1, [r2, #8]
    5330:	e5821004 	str	r1, [r2, #4]
    5334:	82861008 	addhi	r1, r6, #8	; 0x8
    5338:	81a0000a 	movhi	r0, sl
    533c:	8b0000fd 	blhi	5738 <_free_r>
    5340:	e59f1140 	ldr	r1, [pc, #320]	; 5488 <.text+0x5488>
    5344:	e59f3138 	ldr	r3, [pc, #312]	; 5484 <.text+0x5484>
    5348:	e5932000 	ldr	r2, [r3]
    534c:	e5913000 	ldr	r3, [r1]
    5350:	e1520003 	cmp	r2, r3
    5354:	85812000 	strhi	r2, [r1]
    5358:	e59f112c 	ldr	r1, [pc, #300]	; 548c <.text+0x548c>
    535c:	e5913000 	ldr	r3, [r1]
    5360:	e1520003 	cmp	r2, r3
    5364:	85812000 	strhi	r2, [r1]
    5368:	e5993008 	ldr	r3, [r9, #8]
    536c:	e5932004 	ldr	r2, [r3, #4]
    5370:	e3c22003 	bic	r2, r2, #3	; 0x3
    5374:	e0681002 	rsb	r1, r8, r2
    5378:	e351000f 	cmp	r1, #15	; 0xf
    537c:	c3a03000 	movgt	r3, #0	; 0x0
    5380:	d3a03001 	movle	r3, #1	; 0x1
    5384:	e1520008 	cmp	r2, r8
    5388:	33833001 	orrcc	r3, r3, #1	; 0x1
    538c:	e3530000 	cmp	r3, #0	; 0x0
    5390:	0a000003 	beq	53a4 <_malloc_r+0x59c>
    5394:	e1a0000a 	mov	r0, sl
    5398:	eb00004c 	bl	54d0 <__malloc_unlock>
    539c:	e3a00000 	mov	r0, #0	; 0x0
    53a0:	ea000031 	b	546c <_malloc_r+0x664>
    53a4:	e5994008 	ldr	r4, [r9, #8]
    53a8:	e3811001 	orr	r1, r1, #1	; 0x1
    53ac:	e0842008 	add	r2, r4, r8
    53b0:	e3883001 	orr	r3, r8, #1	; 0x1
    53b4:	e1a0000a 	mov	r0, sl
    53b8:	e5843004 	str	r3, [r4, #4]
    53bc:	e5892008 	str	r2, [r9, #8]
    53c0:	e5821004 	str	r1, [r2, #4]
    53c4:	ea000026 	b	5464 <_malloc_r+0x65c>
    53c8:	e59f20b4 	ldr	r2, [pc, #180]	; 5484 <.text+0x5484>
    53cc:	e5923000 	ldr	r3, [r2]
    53d0:	e0841003 	add	r1, r4, r3
    53d4:	e5821000 	str	r1, [r2]
    53d8:	eaffffa4 	b	5270 <_malloc_r+0x468>
    53dc:	e3883001 	orr	r3, r8, #1	; 0x1
    53e0:	e594000c 	ldr	r0, [r4, #12]
    53e4:	e5843004 	str	r3, [r4, #4]
    53e8:	e0843008 	add	r3, r4, r8
    53ec:	e5b41008 	ldr	r1, [r4, #8]!
    53f0:	e38c2001 	orr	r2, ip, #1	; 0x1
    53f4:	e5801008 	str	r1, [r0, #8]
    53f8:	e581000c 	str	r0, [r1, #12]
    53fc:	e1a0000a 	mov	r0, sl
    5400:	e5873008 	str	r3, [r7, #8]
    5404:	e587300c 	str	r3, [r7, #12]
    5408:	e783c00c 	str	ip, [r3, ip]
    540c:	e9830084 	stmib	r3, {r2, r7}
    5410:	e583700c 	str	r7, [r3, #12]
    5414:	ea000007 	b	5438 <_malloc_r+0x630>
    5418:	e0843003 	add	r3, r4, r3
    541c:	e5932004 	ldr	r2, [r3, #4]
    5420:	e5b41008 	ldr	r1, [r4, #8]!
    5424:	e3822001 	orr	r2, r2, #1	; 0x1
    5428:	e5832004 	str	r2, [r3, #4]
    542c:	e5801008 	str	r1, [r0, #8]
    5430:	e581000c 	str	r0, [r1, #12]
    5434:	e1a0000a 	mov	r0, sl
    5438:	eb000024 	bl	54d0 <__malloc_unlock>
    543c:	e1a00004 	mov	r0, r4
    5440:	ea000009 	b	546c <_malloc_r+0x664>
    5444:	e0843003 	add	r3, r4, r3
    5448:	e5932004 	ldr	r2, [r3, #4]
    544c:	e5941008 	ldr	r1, [r4, #8]
    5450:	e3822001 	orr	r2, r2, #1	; 0x1
    5454:	e5801008 	str	r1, [r0, #8]
    5458:	e5832004 	str	r2, [r3, #4]
    545c:	e581000c 	str	r0, [r1, #12]
    5460:	e1a0000a 	mov	r0, sl
    5464:	eb000019 	bl	54d0 <__malloc_unlock>
    5468:	e2840008 	add	r0, r4, #8	; 0x8
    546c:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5470:	e12fff1e 	bx	lr
    5474:	400002b8 	strmih	r0, [r0], -r8
    5478:	00000554 	andeq	r0, r0, r4, asr r5
    547c:	40000fb8 	strmih	r0, [r0], -r8
    5480:	400006c4 	andmi	r0, r0, r4, asr #13
    5484:	40000fc4 	andmi	r0, r0, r4, asr #31
    5488:	40000fbc 	strmih	r0, [r0], -ip
    548c:	40000fc0 	andmi	r0, r0, r0, asr #31

00005490 <memcpy>:
    5490:	e3a0c000 	mov	ip, #0	; 0x0
    5494:	ea000002 	b	54a4 <memcpy+0x14>
    5498:	e7dc3001 	ldrb	r3, [ip, r1]
    549c:	e7cc3000 	strb	r3, [ip, r0]
    54a0:	e28cc001 	add	ip, ip, #1	; 0x1
    54a4:	e2522001 	subs	r2, r2, #1	; 0x1
    54a8:	2afffffa 	bcs	5498 <memcpy+0x8>
    54ac:	e12fff1e 	bx	lr

000054b0 <memset>:
    54b0:	e3a03000 	mov	r3, #0	; 0x0
    54b4:	ea000001 	b	54c0 <memset+0x10>
    54b8:	e7c31000 	strb	r1, [r3, r0]
    54bc:	e2833001 	add	r3, r3, #1	; 0x1
    54c0:	e2522001 	subs	r2, r2, #1	; 0x1
    54c4:	2afffffb 	bcs	54b8 <memset+0x8>
    54c8:	e12fff1e 	bx	lr

000054cc <__malloc_lock>:
    54cc:	e12fff1e 	bx	lr

000054d0 <__malloc_unlock>:
    54d0:	e12fff1e 	bx	lr

000054d4 <strchr>:
    54d4:	e20110ff 	and	r1, r1, #255	; 0xff
    54d8:	ea000000 	b	54e0 <strchr+0xc>
    54dc:	e2800001 	add	r0, r0, #1	; 0x1
    54e0:	e5d03000 	ldrb	r3, [r0]
    54e4:	e3530000 	cmp	r3, #0	; 0x0
    54e8:	0a000002 	beq	54f8 <strchr+0x24>
    54ec:	e1530001 	cmp	r3, r1
    54f0:	1afffff9 	bne	54dc <strchr+0x8>
    54f4:	e12fff1e 	bx	lr
    54f8:	e3510000 	cmp	r1, #0	; 0x0
    54fc:	13a00000 	movne	r0, #0	; 0x0
    5500:	e12fff1e 	bx	lr

00005504 <strcmp>:
    5504:	ea000000 	b	550c <strcmp+0x8>
    5508:	e2811001 	add	r1, r1, #1	; 0x1
    550c:	e5d02000 	ldrb	r2, [r0]
    5510:	e3520000 	cmp	r2, #0	; 0x0
    5514:	e2800001 	add	r0, r0, #1	; 0x1
    5518:	0a000002 	beq	5528 <strcmp+0x24>
    551c:	e5d13000 	ldrb	r3, [r1]
    5520:	e1530002 	cmp	r3, r2
    5524:	0afffff7 	beq	5508 <strcmp+0x4>
    5528:	e5d10000 	ldrb	r0, [r1]
    552c:	e0600002 	rsb	r0, r0, r2
    5530:	e12fff1e 	bx	lr

00005534 <strlen>:
    5534:	e1a02000 	mov	r2, r0
    5538:	ea000000 	b	5540 <strlen+0xc>
    553c:	e2800001 	add	r0, r0, #1	; 0x1
    5540:	e5d03000 	ldrb	r3, [r0]
    5544:	e3530000 	cmp	r3, #0	; 0x0
    5548:	1afffffb 	bne	553c <strlen+0x8>
    554c:	e0620000 	rsb	r0, r2, r0
    5550:	e12fff1e 	bx	lr

00005554 <strncmp>:
    5554:	e3520000 	cmp	r2, #0	; 0x0
    5558:	01a00002 	moveq	r0, r2
    555c:	012fff1e 	bxeq	lr
    5560:	ea000005 	b	557c <strncmp+0x28>
    5564:	e3520000 	cmp	r2, #0	; 0x0
    5568:	0a000009 	beq	5594 <strncmp+0x40>
    556c:	e35c0000 	cmp	ip, #0	; 0x0
    5570:	0a000007 	beq	5594 <strncmp+0x40>
    5574:	e2800001 	add	r0, r0, #1	; 0x1
    5578:	e2811001 	add	r1, r1, #1	; 0x1
    557c:	e2522001 	subs	r2, r2, #1	; 0x1
    5580:	3a000003 	bcc	5594 <strncmp+0x40>
    5584:	e5d1c000 	ldrb	ip, [r1]
    5588:	e5d03000 	ldrb	r3, [r0]
    558c:	e15c0003 	cmp	ip, r3
    5590:	0afffff3 	beq	5564 <strncmp+0x10>
    5594:	e5d02000 	ldrb	r2, [r0]
    5598:	e5d13000 	ldrb	r3, [r1]
    559c:	e0630002 	rsb	r0, r3, r2
    55a0:	e12fff1e 	bx	lr

000055a4 <strncpy>:
    55a4:	e1a0c000 	mov	ip, r0
    55a8:	ea000005 	b	55c4 <strncpy+0x20>
    55ac:	e5d13000 	ldrb	r3, [r1]
    55b0:	e3530000 	cmp	r3, #0	; 0x0
    55b4:	e2422001 	sub	r2, r2, #1	; 0x1
    55b8:	e4cc3001 	strb	r3, [ip], #1
    55bc:	0a000002 	beq	55cc <strncpy+0x28>
    55c0:	e2811001 	add	r1, r1, #1	; 0x1
    55c4:	e3520000 	cmp	r2, #0	; 0x0
    55c8:	1afffff7 	bne	55ac <strncpy+0x8>
    55cc:	e1a0100c 	mov	r1, ip
    55d0:	ea000001 	b	55dc <strncpy+0x38>
    55d4:	e3a03000 	mov	r3, #0	; 0x0
    55d8:	e5413001 	strb	r3, [r1, #-1]
    55dc:	e2422001 	sub	r2, r2, #1	; 0x1
    55e0:	e3720001 	cmn	r2, #1	; 0x1
    55e4:	e2811001 	add	r1, r1, #1	; 0x1
    55e8:	1afffff9 	bne	55d4 <strncpy+0x30>
    55ec:	e12fff1e 	bx	lr

000055f0 <strrchr>:
    55f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    55f4:	e2515000 	subs	r5, r1, #0	; 0x0
    55f8:	e1a03000 	mov	r3, r0
    55fc:	13a04000 	movne	r4, #0	; 0x0
    5600:	1a000002 	bne	5610 <strrchr+0x20>
    5604:	ea000007 	b	5628 <strrchr+0x38>
    5608:	e1a04000 	mov	r4, r0
    560c:	e2803001 	add	r3, r0, #1	; 0x1
    5610:	e1a00003 	mov	r0, r3
    5614:	e1a01005 	mov	r1, r5
    5618:	ebffffad 	bl	54d4 <strchr>
    561c:	e3500000 	cmp	r0, #0	; 0x0
    5620:	1afffff8 	bne	5608 <strrchr+0x18>
    5624:	ea000001 	b	5630 <strrchr+0x40>
    5628:	ebffffa9 	bl	54d4 <strchr>
    562c:	e1a04000 	mov	r4, r0
    5630:	e1a00004 	mov	r0, r4
    5634:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
    5638:	e12fff1e 	bx	lr

0000563c <_malloc_trim_r>:
    563c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    5640:	e59f70e4 	ldr	r7, [pc, #228]	; 572c <.text+0x572c>
    5644:	e1a04001 	mov	r4, r1
    5648:	e1a05000 	mov	r5, r0
    564c:	ebffff9e 	bl	54cc <__malloc_lock>
    5650:	e5973008 	ldr	r3, [r7, #8]
    5654:	e5933004 	ldr	r3, [r3, #4]
    5658:	e3c36003 	bic	r6, r3, #3	; 0x3
    565c:	e0644006 	rsb	r4, r4, r6
    5660:	e2844efe 	add	r4, r4, #4064	; 0xfe0
    5664:	e284400f 	add	r4, r4, #15	; 0xf
    5668:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
    566c:	e3c4400f 	bic	r4, r4, #15	; 0xf
    5670:	e2444a01 	sub	r4, r4, #4096	; 0x1000
    5674:	e3540a01 	cmp	r4, #4096	; 0x1000
    5678:	e3a01000 	mov	r1, #0	; 0x0
    567c:	e1a00005 	mov	r0, r5
    5680:	ba00001c 	blt	56f8 <_malloc_trim_r+0xbc>
    5684:	ebffeb34 	bl	35c <_sbrk_r>
    5688:	e5973008 	ldr	r3, [r7, #8]
    568c:	e0863003 	add	r3, r6, r3
    5690:	e1500003 	cmp	r0, r3
    5694:	e2641000 	rsb	r1, r4, #0	; 0x0
    5698:	e1a00005 	mov	r0, r5
    569c:	1a000015 	bne	56f8 <_malloc_trim_r+0xbc>
    56a0:	ebffeb2d 	bl	35c <_sbrk_r>
    56a4:	e0643006 	rsb	r3, r4, r6
    56a8:	e3700001 	cmn	r0, #1	; 0x1
    56ac:	e3a01000 	mov	r1, #0	; 0x0
    56b0:	e59fe078 	ldr	lr, [pc, #120]	; 5730 <.text+0x5730>
    56b4:	e383c001 	orr	ip, r3, #1	; 0x1
    56b8:	e1a00005 	mov	r0, r5
    56bc:	1a000010 	bne	5704 <_malloc_trim_r+0xc8>
    56c0:	ebffeb25 	bl	35c <_sbrk_r>
    56c4:	e597c008 	ldr	ip, [r7, #8]
    56c8:	e1a02000 	mov	r2, r0
    56cc:	e06c3002 	rsb	r3, ip, r2
    56d0:	e353000f 	cmp	r3, #15	; 0xf
    56d4:	e1a00005 	mov	r0, r5
    56d8:	e3831001 	orr	r1, r3, #1	; 0x1
    56dc:	da000005 	ble	56f8 <_malloc_trim_r+0xbc>
    56e0:	e59f304c 	ldr	r3, [pc, #76]	; 5734 <.text+0x5734>
    56e4:	e5933000 	ldr	r3, [r3]
    56e8:	e0633002 	rsb	r3, r3, r2
    56ec:	e59f203c 	ldr	r2, [pc, #60]	; 5730 <.text+0x5730>
    56f0:	e58c1004 	str	r1, [ip, #4]
    56f4:	e5823000 	str	r3, [r2]
    56f8:	ebffff74 	bl	54d0 <__malloc_unlock>
    56fc:	e3a00000 	mov	r0, #0	; 0x0
    5700:	ea000007 	b	5724 <_malloc_trim_r+0xe8>
    5704:	e59e3000 	ldr	r3, [lr]
    5708:	e5972008 	ldr	r2, [r7, #8]
    570c:	e0643003 	rsb	r3, r4, r3
    5710:	e1a00005 	mov	r0, r5
    5714:	e582c004 	str	ip, [r2, #4]
    5718:	e58e3000 	str	r3, [lr]
    571c:	ebffff6b 	bl	54d0 <__malloc_unlock>
    5720:	e3a00001 	mov	r0, #1	; 0x1
    5724:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
    5728:	e12fff1e 	bx	lr
    572c:	400002b8 	strmih	r0, [r0], -r8
    5730:	40000fc4 	andmi	r0, r0, r4, asr #31
    5734:	400006c4 	andmi	r0, r0, r4, asr #13

00005738 <_free_r>:
    5738:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    573c:	e2515000 	subs	r5, r1, #0	; 0x0
    5740:	e1a08000 	mov	r8, r0
    5744:	0a00008c 	beq	597c <_free_r+0x244>
    5748:	ebffff5f 	bl	54cc <__malloc_lock>
    574c:	e5153004 	ldr	r3, [r5, #-4]
    5750:	e59f722c 	ldr	r7, [pc, #556]	; 5984 <.text+0x5984>
    5754:	e245e008 	sub	lr, r5, #8	; 0x8
    5758:	e3c30001 	bic	r0, r3, #1	; 0x1
    575c:	e08e4000 	add	r4, lr, r0
    5760:	e5972008 	ldr	r2, [r7, #8]
    5764:	e5941004 	ldr	r1, [r4, #4]
    5768:	e1540002 	cmp	r4, r2
    576c:	e3c16003 	bic	r6, r1, #3	; 0x3
    5770:	e2031001 	and	r1, r3, #1	; 0x1
    5774:	1a000015 	bne	57d0 <_free_r+0x98>
    5778:	e3510000 	cmp	r1, #0	; 0x0
    577c:	e0800006 	add	r0, r0, r6
    5780:	1a000006 	bne	57a0 <_free_r+0x68>
    5784:	e5151008 	ldr	r1, [r5, #-8]
    5788:	e061e00e 	rsb	lr, r1, lr
    578c:	e59e200c 	ldr	r2, [lr, #12]
    5790:	e59e3008 	ldr	r3, [lr, #8]
    5794:	e5823008 	str	r3, [r2, #8]
    5798:	e583200c 	str	r2, [r3, #12]
    579c:	e0800001 	add	r0, r0, r1
    57a0:	e59f31e0 	ldr	r3, [pc, #480]	; 5988 <.text+0x5988>
    57a4:	e5933000 	ldr	r3, [r3]
    57a8:	e1500003 	cmp	r0, r3
    57ac:	e3803001 	orr	r3, r0, #1	; 0x1
    57b0:	e587e008 	str	lr, [r7, #8]
    57b4:	e58e3004 	str	r3, [lr, #4]
    57b8:	3a00006d 	bcc	5974 <_free_r+0x23c>
    57bc:	e59f31c8 	ldr	r3, [pc, #456]	; 598c <.text+0x598c>
    57c0:	e1a00008 	mov	r0, r8
    57c4:	e5931000 	ldr	r1, [r3]
    57c8:	ebffff9b 	bl	563c <_malloc_trim_r>
    57cc:	ea000068 	b	5974 <_free_r+0x23c>
    57d0:	e3510000 	cmp	r1, #0	; 0x0
    57d4:	e5846004 	str	r6, [r4, #4]
    57d8:	13a01000 	movne	r1, #0	; 0x0
    57dc:	1a000009 	bne	5808 <_free_r+0xd0>
    57e0:	e5152008 	ldr	r2, [r5, #-8]
    57e4:	e062e00e 	rsb	lr, r2, lr
    57e8:	e59ec008 	ldr	ip, [lr, #8]
    57ec:	e2873008 	add	r3, r7, #8	; 0x8
    57f0:	e15c0003 	cmp	ip, r3
    57f4:	159e300c 	ldrne	r3, [lr, #12]
    57f8:	1583c008 	strne	ip, [r3, #8]
    57fc:	158c300c 	strne	r3, [ip, #12]
    5800:	e0800002 	add	r0, r0, r2
    5804:	03a01001 	moveq	r1, #1	; 0x1
    5808:	e0843006 	add	r3, r4, r6
    580c:	e5933004 	ldr	r3, [r3, #4]
    5810:	e3130001 	tst	r3, #1	; 0x1
    5814:	1a000012 	bne	5864 <_free_r+0x12c>
    5818:	e3510000 	cmp	r1, #0	; 0x0
    581c:	e0800006 	add	r0, r0, r6
    5820:	1a00000b 	bne	5854 <_free_r+0x11c>
    5824:	e5942008 	ldr	r2, [r4, #8]
    5828:	e59f3160 	ldr	r3, [pc, #352]	; 5990 <.text+0x5990>
    582c:	e1520003 	cmp	r2, r3
    5830:	1a000007 	bne	5854 <_free_r+0x11c>
    5834:	e3803001 	orr	r3, r0, #1	; 0x1
    5838:	e582e00c 	str	lr, [r2, #12]
    583c:	e582e008 	str	lr, [r2, #8]
    5840:	e78e0000 	str	r0, [lr, r0]
    5844:	e58e3004 	str	r3, [lr, #4]
    5848:	e58e2008 	str	r2, [lr, #8]
    584c:	e58e200c 	str	r2, [lr, #12]
    5850:	ea000047 	b	5974 <_free_r+0x23c>
    5854:	e2842008 	add	r2, r4, #8	; 0x8
    5858:	e892000c 	ldmia	r2, {r2, r3}
    585c:	e5832008 	str	r2, [r3, #8]
    5860:	e582300c 	str	r3, [r2, #12]
    5864:	e3803001 	orr	r3, r0, #1	; 0x1
    5868:	e3510000 	cmp	r1, #0	; 0x0
    586c:	e58e3004 	str	r3, [lr, #4]
    5870:	e78e0000 	str	r0, [lr, r0]
    5874:	1a00003e 	bne	5974 <_free_r+0x23c>
    5878:	e3500c02 	cmp	r0, #512	; 0x200
    587c:	2a00000d 	bcs	58b8 <_free_r+0x180>
    5880:	e1a001a0 	mov	r0, r0, lsr #3
    5884:	e5972004 	ldr	r2, [r7, #4]
    5888:	e1a01120 	mov	r1, r0, lsr #2
    588c:	e3a03001 	mov	r3, #1	; 0x1
    5890:	e1822113 	orr	r2, r2, r3, lsl r1
    5894:	e59f30e8 	ldr	r3, [pc, #232]	; 5984 <.text+0x5984>
    5898:	e0833180 	add	r3, r3, r0, lsl #3
    589c:	e5931008 	ldr	r1, [r3, #8]
    58a0:	e58e300c 	str	r3, [lr, #12]
    58a4:	e58e1008 	str	r1, [lr, #8]
    58a8:	e5872004 	str	r2, [r7, #4]
    58ac:	e581e00c 	str	lr, [r1, #12]
    58b0:	e583e008 	str	lr, [r3, #8]
    58b4:	ea00002e 	b	5974 <_free_r+0x23c>
    58b8:	e1b014a0 	movs	r1, r0, lsr #9
    58bc:	01a011a0 	moveq	r1, r0, lsr #3
    58c0:	0a000013 	beq	5914 <_free_r+0x1dc>
    58c4:	e3510004 	cmp	r1, #4	; 0x4
    58c8:	91a03320 	movls	r3, r0, lsr #6
    58cc:	92831038 	addls	r1, r3, #56	; 0x38
    58d0:	9a00000f 	bls	5914 <_free_r+0x1dc>
    58d4:	e3510014 	cmp	r1, #20	; 0x14
    58d8:	9281105b 	addls	r1, r1, #91	; 0x5b
    58dc:	9a00000c 	bls	5914 <_free_r+0x1dc>
    58e0:	e3510054 	cmp	r1, #84	; 0x54
    58e4:	91a03620 	movls	r3, r0, lsr #12
    58e8:	9283106e 	addls	r1, r3, #110	; 0x6e
    58ec:	9a000008 	bls	5914 <_free_r+0x1dc>
    58f0:	e3510f55 	cmp	r1, #340	; 0x154
    58f4:	91a037a0 	movls	r3, r0, lsr #15
    58f8:	92831077 	addls	r1, r3, #119	; 0x77
    58fc:	9a000004 	bls	5914 <_free_r+0x1dc>
    5900:	e59f308c 	ldr	r3, [pc, #140]	; 5994 <.text+0x5994>
    5904:	e1510003 	cmp	r1, r3
    5908:	91a03920 	movls	r3, r0, lsr #18
    590c:	83a0107e 	movhi	r1, #126	; 0x7e
    5910:	9283107c 	addls	r1, r3, #124	; 0x7c
    5914:	e59f3068 	ldr	r3, [pc, #104]	; 5984 <.text+0x5984>
    5918:	e0832181 	add	r2, r3, r1, lsl #3
    591c:	e592c008 	ldr	ip, [r2, #8]
    5920:	e15c0002 	cmp	ip, r2
    5924:	1a000009 	bne	5950 <_free_r+0x218>
    5928:	e5973004 	ldr	r3, [r7, #4]
    592c:	e3a02001 	mov	r2, #1	; 0x1
    5930:	e1a01121 	mov	r1, r1, lsr #2
    5934:	e1833112 	orr	r3, r3, r2, lsl r1
    5938:	e1a0200c 	mov	r2, ip
    593c:	e5873004 	str	r3, [r7, #4]
    5940:	ea000007 	b	5964 <_free_r+0x22c>
    5944:	e59cc008 	ldr	ip, [ip, #8]
    5948:	e15c0002 	cmp	ip, r2
    594c:	0a000003 	beq	5960 <_free_r+0x228>
    5950:	e59c3004 	ldr	r3, [ip, #4]
    5954:	e3c33003 	bic	r3, r3, #3	; 0x3
    5958:	e1500003 	cmp	r0, r3
    595c:	3afffff8 	bcc	5944 <_free_r+0x20c>
    5960:	e59c200c 	ldr	r2, [ip, #12]
    5964:	e58e200c 	str	r2, [lr, #12]
    5968:	e58ec008 	str	ip, [lr, #8]
    596c:	e58ce00c 	str	lr, [ip, #12]
    5970:	e582e008 	str	lr, [r2, #8]
    5974:	e1a00008 	mov	r0, r8
    5978:	ebfffed4 	bl	54d0 <__malloc_unlock>
    597c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
    5980:	e12fff1e 	bx	lr
    5984:	400002b8 	strmih	r0, [r0], -r8
    5988:	400006c0 	andmi	r0, r0, r0, asr #13
    598c:	40000fb8 	strmih	r0, [r0], -r8
    5990:	400002c0 	andmi	r0, r0, r0, asr #5
    5994:	00000554 	andeq	r0, r0, r4, asr r5

00005998 <__aeabi_uidiv>:
    5998:	e2512001 	subs	r2, r1, #1	; 0x1
    599c:	012fff1e 	bxeq	lr
    59a0:	3a000036 	bcc	5a80 <__aeabi_uidiv+0xe8>
    59a4:	e1500001 	cmp	r0, r1
    59a8:	9a000022 	bls	5a38 <__aeabi_uidiv+0xa0>
    59ac:	e1110002 	tst	r1, r2
    59b0:	0a000023 	beq	5a44 <__aeabi_uidiv+0xac>
    59b4:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    59b8:	01a01181 	moveq	r1, r1, lsl #3
    59bc:	03a03008 	moveq	r3, #8	; 0x8
    59c0:	13a03001 	movne	r3, #1	; 0x1
    59c4:	e3510201 	cmp	r1, #268435456	; 0x10000000
    59c8:	31510000 	cmpcc	r1, r0
    59cc:	31a01201 	movcc	r1, r1, lsl #4
    59d0:	31a03203 	movcc	r3, r3, lsl #4
    59d4:	3afffffa 	bcc	59c4 <__aeabi_uidiv+0x2c>
    59d8:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    59dc:	31510000 	cmpcc	r1, r0
    59e0:	31a01081 	movcc	r1, r1, lsl #1
    59e4:	31a03083 	movcc	r3, r3, lsl #1
    59e8:	3afffffa 	bcc	59d8 <__aeabi_uidiv+0x40>
    59ec:	e3a02000 	mov	r2, #0	; 0x0
    59f0:	e1500001 	cmp	r0, r1
    59f4:	20400001 	subcs	r0, r0, r1
    59f8:	21822003 	orrcs	r2, r2, r3
    59fc:	e15000a1 	cmp	r0, r1, lsr #1
    5a00:	204000a1 	subcs	r0, r0, r1, lsr #1
    5a04:	218220a3 	orrcs	r2, r2, r3, lsr #1
    5a08:	e1500121 	cmp	r0, r1, lsr #2
    5a0c:	20400121 	subcs	r0, r0, r1, lsr #2
    5a10:	21822123 	orrcs	r2, r2, r3, lsr #2
    5a14:	e15001a1 	cmp	r0, r1, lsr #3
    5a18:	204001a1 	subcs	r0, r0, r1, lsr #3
    5a1c:	218221a3 	orrcs	r2, r2, r3, lsr #3
    5a20:	e3500000 	cmp	r0, #0	; 0x0
    5a24:	11b03223 	movnes	r3, r3, lsr #4
    5a28:	11a01221 	movne	r1, r1, lsr #4
    5a2c:	1affffef 	bne	59f0 <__aeabi_uidiv+0x58>
    5a30:	e1a00002 	mov	r0, r2
    5a34:	e12fff1e 	bx	lr
    5a38:	03a00001 	moveq	r0, #1	; 0x1
    5a3c:	13a00000 	movne	r0, #0	; 0x0
    5a40:	e12fff1e 	bx	lr
    5a44:	e3510801 	cmp	r1, #65536	; 0x10000
    5a48:	21a01821 	movcs	r1, r1, lsr #16
    5a4c:	23a02010 	movcs	r2, #16	; 0x10
    5a50:	33a02000 	movcc	r2, #0	; 0x0
    5a54:	e3510c01 	cmp	r1, #256	; 0x100
    5a58:	21a01421 	movcs	r1, r1, lsr #8
    5a5c:	22822008 	addcs	r2, r2, #8	; 0x8
    5a60:	e3510010 	cmp	r1, #16	; 0x10
    5a64:	21a01221 	movcs	r1, r1, lsr #4
    5a68:	22822004 	addcs	r2, r2, #4	; 0x4
    5a6c:	e3510004 	cmp	r1, #4	; 0x4
    5a70:	82822003 	addhi	r2, r2, #3	; 0x3
    5a74:	908220a1 	addls	r2, r2, r1, lsr #1
    5a78:	e1a00230 	mov	r0, r0, lsr r2
    5a7c:	e12fff1e 	bx	lr
    5a80:	e52de008 	str	lr, [sp, #-8]!
    5a84:	eb00008d 	bl	5cc0 <__aeabi_idiv0>
    5a88:	e3a00000 	mov	r0, #0	; 0x0
    5a8c:	e49de008 	ldr	lr, [sp], #8
    5a90:	e12fff1e 	bx	lr

00005a94 <__aeabi_uidivmod>:
    5a94:	e92d4003 	stmdb	sp!, {r0, r1, lr}
    5a98:	ebffffbe 	bl	5998 <__aeabi_uidiv>
    5a9c:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
    5aa0:	e0030092 	mul	r3, r2, r0
    5aa4:	e0411003 	sub	r1, r1, r3
    5aa8:	e12fff1e 	bx	lr

00005aac <__aeabi_idiv>:
    5aac:	e3510000 	cmp	r1, #0	; 0x0
    5ab0:	e020c001 	eor	ip, r0, r1
    5ab4:	0a000042 	beq	5bc4 <__aeabi_idiv+0x118>
    5ab8:	42611000 	rsbmi	r1, r1, #0	; 0x0
    5abc:	e2512001 	subs	r2, r1, #1	; 0x1
    5ac0:	0a000027 	beq	5b64 <__aeabi_idiv+0xb8>
    5ac4:	e1b03000 	movs	r3, r0
    5ac8:	42603000 	rsbmi	r3, r0, #0	; 0x0
    5acc:	e1530001 	cmp	r3, r1
    5ad0:	9a000026 	bls	5b70 <__aeabi_idiv+0xc4>
    5ad4:	e1110002 	tst	r1, r2
    5ad8:	0a000028 	beq	5b80 <__aeabi_idiv+0xd4>
    5adc:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    5ae0:	01a01181 	moveq	r1, r1, lsl #3
    5ae4:	03a02008 	moveq	r2, #8	; 0x8
    5ae8:	13a02001 	movne	r2, #1	; 0x1
    5aec:	e3510201 	cmp	r1, #268435456	; 0x10000000
    5af0:	31510003 	cmpcc	r1, r3
    5af4:	31a01201 	movcc	r1, r1, lsl #4
    5af8:	31a02202 	movcc	r2, r2, lsl #4
    5afc:	3afffffa 	bcc	5aec <__aeabi_idiv+0x40>
    5b00:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    5b04:	31510003 	cmpcc	r1, r3
    5b08:	31a01081 	movcc	r1, r1, lsl #1
    5b0c:	31a02082 	movcc	r2, r2, lsl #1
    5b10:	3afffffa 	bcc	5b00 <__aeabi_idiv+0x54>
    5b14:	e3a00000 	mov	r0, #0	; 0x0
    5b18:	e1530001 	cmp	r3, r1
    5b1c:	20433001 	subcs	r3, r3, r1
    5b20:	21800002 	orrcs	r0, r0, r2
    5b24:	e15300a1 	cmp	r3, r1, lsr #1
    5b28:	204330a1 	subcs	r3, r3, r1, lsr #1
    5b2c:	218000a2 	orrcs	r0, r0, r2, lsr #1
    5b30:	e1530121 	cmp	r3, r1, lsr #2
    5b34:	20433121 	subcs	r3, r3, r1, lsr #2
    5b38:	21800122 	orrcs	r0, r0, r2, lsr #2
    5b3c:	e15301a1 	cmp	r3, r1, lsr #3
    5b40:	204331a1 	subcs	r3, r3, r1, lsr #3
    5b44:	218001a2 	orrcs	r0, r0, r2, lsr #3
    5b48:	e3530000 	cmp	r3, #0	; 0x0
    5b4c:	11b02222 	movnes	r2, r2, lsr #4
    5b50:	11a01221 	movne	r1, r1, lsr #4
    5b54:	1affffef 	bne	5b18 <__aeabi_idiv+0x6c>
    5b58:	e35c0000 	cmp	ip, #0	; 0x0
    5b5c:	42600000 	rsbmi	r0, r0, #0	; 0x0
    5b60:	e12fff1e 	bx	lr
    5b64:	e13c0000 	teq	ip, r0
    5b68:	42600000 	rsbmi	r0, r0, #0	; 0x0
    5b6c:	e12fff1e 	bx	lr
    5b70:	33a00000 	movcc	r0, #0	; 0x0
    5b74:	01a00fcc 	moveq	r0, ip, asr #31
    5b78:	03800001 	orreq	r0, r0, #1	; 0x1
    5b7c:	e12fff1e 	bx	lr
    5b80:	e3510801 	cmp	r1, #65536	; 0x10000
    5b84:	21a01821 	movcs	r1, r1, lsr #16
    5b88:	23a02010 	movcs	r2, #16	; 0x10
    5b8c:	33a02000 	movcc	r2, #0	; 0x0
    5b90:	e3510c01 	cmp	r1, #256	; 0x100
    5b94:	21a01421 	movcs	r1, r1, lsr #8
    5b98:	22822008 	addcs	r2, r2, #8	; 0x8
    5b9c:	e3510010 	cmp	r1, #16	; 0x10
    5ba0:	21a01221 	movcs	r1, r1, lsr #4
    5ba4:	22822004 	addcs	r2, r2, #4	; 0x4
    5ba8:	e3510004 	cmp	r1, #4	; 0x4
    5bac:	82822003 	addhi	r2, r2, #3	; 0x3
    5bb0:	908220a1 	addls	r2, r2, r1, lsr #1
    5bb4:	e35c0000 	cmp	ip, #0	; 0x0
    5bb8:	e1a00233 	mov	r0, r3, lsr r2
    5bbc:	42600000 	rsbmi	r0, r0, #0	; 0x0
    5bc0:	e12fff1e 	bx	lr
    5bc4:	e52de008 	str	lr, [sp, #-8]!
    5bc8:	eb00003c 	bl	5cc0 <__aeabi_idiv0>
    5bcc:	e3a00000 	mov	r0, #0	; 0x0
    5bd0:	e49de008 	ldr	lr, [sp], #8
    5bd4:	e12fff1e 	bx	lr

00005bd8 <__aeabi_idivmod>:
    5bd8:	e92d4003 	stmdb	sp!, {r0, r1, lr}
    5bdc:	ebffffb2 	bl	5aac <__aeabi_idiv>
    5be0:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
    5be4:	e0030092 	mul	r3, r2, r0
    5be8:	e0411003 	sub	r1, r1, r3
    5bec:	e12fff1e 	bx	lr

00005bf0 <__umodsi3>:
    5bf0:	e2512001 	subs	r2, r1, #1	; 0x1
    5bf4:	3a00002c 	bcc	5cac <__umodsi3+0xbc>
    5bf8:	11500001 	cmpne	r0, r1
    5bfc:	03a00000 	moveq	r0, #0	; 0x0
    5c00:	81110002 	tsthi	r1, r2
    5c04:	00000002 	andeq	r0, r0, r2
    5c08:	912fff1e 	bxls	lr
    5c0c:	e3a02000 	mov	r2, #0	; 0x0
    5c10:	e3510201 	cmp	r1, #268435456	; 0x10000000
    5c14:	31510000 	cmpcc	r1, r0
    5c18:	31a01201 	movcc	r1, r1, lsl #4
    5c1c:	32822004 	addcc	r2, r2, #4	; 0x4
    5c20:	3afffffa 	bcc	5c10 <__umodsi3+0x20>
    5c24:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    5c28:	31510000 	cmpcc	r1, r0
    5c2c:	31a01081 	movcc	r1, r1, lsl #1
    5c30:	32822001 	addcc	r2, r2, #1	; 0x1
    5c34:	3afffffa 	bcc	5c24 <__umodsi3+0x34>
    5c38:	e2522003 	subs	r2, r2, #3	; 0x3
    5c3c:	ba00000e 	blt	5c7c <__umodsi3+0x8c>
    5c40:	e1500001 	cmp	r0, r1
    5c44:	20400001 	subcs	r0, r0, r1
    5c48:	e15000a1 	cmp	r0, r1, lsr #1
    5c4c:	204000a1 	subcs	r0, r0, r1, lsr #1
    5c50:	e1500121 	cmp	r0, r1, lsr #2
    5c54:	20400121 	subcs	r0, r0, r1, lsr #2
    5c58:	e15001a1 	cmp	r0, r1, lsr #3
    5c5c:	204001a1 	subcs	r0, r0, r1, lsr #3
    5c60:	e3500001 	cmp	r0, #1	; 0x1
    5c64:	e1a01221 	mov	r1, r1, lsr #4
    5c68:	a2522004 	subges	r2, r2, #4	; 0x4
    5c6c:	aafffff3 	bge	5c40 <__umodsi3+0x50>
    5c70:	e3120003 	tst	r2, #3	; 0x3
    5c74:	13300000 	teqne	r0, #0	; 0x0
    5c78:	0a00000a 	beq	5ca8 <__umodsi3+0xb8>
    5c7c:	e3720002 	cmn	r2, #2	; 0x2
    5c80:	ba000006 	blt	5ca0 <__umodsi3+0xb0>
    5c84:	0a000002 	beq	5c94 <__umodsi3+0xa4>
    5c88:	e1500001 	cmp	r0, r1
    5c8c:	20400001 	subcs	r0, r0, r1
    5c90:	e1a010a1 	mov	r1, r1, lsr #1
    5c94:	e1500001 	cmp	r0, r1
    5c98:	20400001 	subcs	r0, r0, r1
    5c9c:	e1a010a1 	mov	r1, r1, lsr #1
    5ca0:	e1500001 	cmp	r0, r1
    5ca4:	20400001 	subcs	r0, r0, r1
    5ca8:	e12fff1e 	bx	lr
    5cac:	e52de008 	str	lr, [sp, #-8]!
    5cb0:	eb000002 	bl	5cc0 <__aeabi_idiv0>
    5cb4:	e3a00000 	mov	r0, #0	; 0x0
    5cb8:	e49de008 	ldr	lr, [sp], #8
    5cbc:	e12fff1e 	bx	lr

00005cc0 <__aeabi_idiv0>:
    5cc0:	e12fff1e 	bx	lr

00005cc4 <abSense>:
    5cc4:	00ff0070 0a000000 00000000 0000ffff     p...............
	...

00005cd6 <abInquiry>:
    5cd6:	02048000 0000001f 5543504c 20204253     ........LPCUSB  
    5ce6:	7373614d 6f747320 65676172 20202020     Mass storage    
    5cf6:	20312e30 06cc0000                                0.1 ..

00005cfc <_global_impure_ptr>:
    5cfc:	400006cc 746f6f42 20707520 706d6f63     ...@Boot up comp
    5d0c:	6574656c 0000000a 55206f4e 44204253     lete....No USB D
    5d1c:	63657465 0a646574 00000000 746f6f52     etected.....Root
    5d2c:	65706f20 00000a6e 532e5746 00004546      open...FW.SFE..
    5d3c:	2077654e 6d726966 65726177 756f6620     New firmware fou
    5d4c:	000a646e 2077654e 6d726966 65726177     nd..New firmware
    5d5c:	616f6c20 0a646564 00000000 53206f4e      loaded.....No S
    5d6c:	61432044 44206472 63657465 0a646574     D Card Detected.
    5d7c:	00000000 746f6f42 6e6f4420 43202e65     ....Boot Done. C
    5d8c:	696c6c61 6620676e 776d7269 2e657261     alling firmware.
    5d9c:	000a2e2e 550a0a0a 42204253 6c746f6f     .......USB Bootl
    5dac:	6564616f 31762072 000a312e 756e616d     oader v1.1..manu
    5dbc:	20203a66 30257830 0d0a7832 00000000     f:  0x%02x......
    5dcc:	3a6d656f 20202020 0d0a7325 00000000     oem:    %s......
    5ddc:	646f7270 2020203a 0d0a7325 00000000     prod:   %s......
    5dec:	3a766572 20202020 78323025 00000d0a     rev:    %02x....
    5dfc:	69726573 203a6c61 30257830 0a786c38     serial: 0x%08lx.
    5e0c:	0000000d 65746164 2020203a 64323025     ....date:   %02d
    5e1c:	3230252f 000d0a64 657a6973 2020203a     /%02d...size:   
    5e2c:	0a646c25 0000000d 79706f63 2020203a     %ld.....copy:   
    5e3c:	0d0a6425 00000000 702e7277 203a2e72     %d......wr.pr.: 
    5e4c:	252f6425 000d0a64 6d726f66 203a7461     %d/%d...format: 
    5e5c:	0d0a6425 00000000 65657266 2020203a     %d......free:   
    5e6c:	2f646c25 0a646c25 0000000d 6e65706f     %ld/%ld.....open
    5e7c:	20676e69 74726170 6f697469 6166206e     ing partition fa
    5e8c:	64656c69 00000d0a 6e65706f 20676e69     iled....opening 
    5e9c:	656c6966 74737973 66206d65 656c6961     filesystem faile
    5eac:	000d0a64 0000002f 6e65706f 20676e69     d.../...opening 
    5ebc:	746f6f72 72696420 6f746365 66207972     root directory f
    5ecc:	656c6961 000d0a64 52204453 4e205741     ailed...SD RAW N
    5edc:	4120544f 4c494156 454c4241 00000d0a     OT AVAILABLE....
    5eec:	64253d69 6572202c 6e6f7073 253d6573     i=%d, response=%
    5efc:	000d0a64 65720d0a 6e6f7073 203a6573     d.....response: 
    5f0c:	0d0a6425 00000000 203d2069 66377830     %d......i = 0x7f
    5f1c:	0d0a6666 00000000 434f4c42 4953204b     ff......BLOCK SI
    5f2c:	5320455a 45205445 0a205252 0000000d     ZE SET ERR .....
    5f3c:	725f6473 725f7761 20646165 6b726f62     sd_raw_read bork
    5f4c:	000d0a73 4c4c414d 4620434f 534c4941     s...MALLOC FAILS
    5f5c:	00000d0a 6c696146 52206465 69646165     ....Failed Readi
    5f6c:	4820676e 65646165 000d0a72 74696e49     ng Header...Init
    5f7c:	696c6169 676e6973 42535520 61747320     ialising USB sta
    5f8c:	000a6b63 72617453 676e6974 42535520     ck..Starting USB
    5f9c:	6d6f6320 696e756d 69746163 000a6e6f      communication..
    5fac:	3a445343 00000000 32302520 00000078     CSD:.... %02x...
    5fbc:	75677241 746e656d 74756f20 20666f20     Argument out of 
    5fcc:	6e756f62 0a2e7364 00000000 72646441     bounds......Addr
    5fdc:	20737365 2074756f 6220666f 646e756f     ess out of bound
    5fec:	000a2e73 6f727245 75642072 676e6972     s...Error during
    5ffc:	61726520 73206573 65757165 2e65636e      erase sequence.
    600c:	0000000a 20435243 6c696166 0a2e6465     ....CRC failed..
    601c:	00000000 656c6c49 206c6167 6d6d6f63     ....Illegal comm
    602c:	2e646e61 0000000a 73617245 65722065     and.....Erase re
    603c:	20746573 65657328 6e615320 6b736944     set (see SanDisk
    604c:	636f6420 35702073 2933312d 00000a2e      docs p5-13)....
    605c:	0000002e 6e6b6e55 206e776f 6f727265     ....Unknown erro
    606c:	78302072 28207825 20656573 446e6153     r 0x%x (see SanD
    607c:	206b7369 73636f64 2d357020 2e293331     isk docs p5-13).
    608c:	0000000a 70736572 6678303d 00000a66     ....resp=0xff...
    609c:	70736572 78303d21 000a6666 64726143     resp!=0xff..Card
    60ac:	20736920 6b636f4c 0a2e6465 00000000      is Locked......
    60bc:	45205057 65736172 696b5320 4c202c70     WP Erase Skip, L
    60cc:	2f6b636f 6f6c6e55 43206b63 4620646d     ock/Unlock Cmd F
    60dc:	656c6961 000a2e64 656e6547 206c6172     ailed...General 
    60ec:	6e55202f 776f6e6b 7265206e 20726f72     / Unknown error 
    60fc:	63202d2d 20647261 6b6f7262 2e3f6e65     -- card broken?.
    610c:	0000000a 65746e49 6c616e72 72616320     ....Internal car
    611c:	6f632064 6f72746e 72656c6c 72726520     d controller err
    612c:	0a2e726f 00000000 64726143 746e6920     or......Card int
    613c:	616e7265 4345206c 61772043 70612073     ernal ECC was ap
    614c:	65696c70 62202c64 66207475 656c6961     plied, but faile
    615c:	6f742064 726f6320 74636572 65687420     d to correct the
    616c:	74616420 000a2e61 74697257 72702065      data...Write pr
    617c:	6365746f 69762074 74616c6f 2e6e6f69     otect violation.
    618c:	0000000a 69206e41 6c61766e 73206469     ....An invalid s
    619c:	63656c65 6e6f6974 6573202c 726f7463     election, sector
    61ac:	6f662073 72652072 2e657361 0000000a     s for erase.....
    61bc:	2074754f 5220666f 65676e61 5343202c     Out of Range, CS
    61cc:	764f5f44 72777265 2e657469 0000000a     D_Overwrite.....
    61dc:	6e6b6e55 206e776f 6f727265 30203a72     Unknown error: 0
    61ec:	20782578 65657328 6e615320 6b736944     x%x (see SanDisk
    61fc:	636f6420 35702073 2934312d 00000a2e      docs p5-14)....
    620c:	49204453 2074696e 656e6f64 0a2e2e2e     SD Init done....
    621c:	00000000 64726143 64696420 2074276e     ....Card didn't 
    622c:	75746572 74206e72 72206568 79646165     return the ready
    623c:	61747320 202c6574 61657262 676e696b      state, breaking
    624c:	2e707520 000a2e2e 49697073 2074696e      up.....spiInit 
    625c:	20726f66 28495053 000a2930 00000043     for SPI(0)..C...
